import {
  __toESM,
  require_core,
  require_exec
} from "./main-tjp1a9xb.js";

// shared/metrics.ts
var import_core = __toESM(require_core(), 1), import_exec = __toESM(require_exec(), 1);
import * as fs from "node:fs";
import * as path from "node:path";
async function parseMetricsYaml(yamlContent) {
  if (!yamlContent || yamlContent.trim() === "")
    return null;
  try {
    let chunks = [];
    await import_exec.exec("yq", ["-o=json", "."], {
      input: Buffer.from(yamlContent, "utf-8"),
      silent: !0,
      listeners: {
        stdout: (data) => chunks.push(data.toString())
      }
    });
    let json = chunks.join("");
    return JSON.parse(json);
  } catch (error) {
    return import_core.warning(`Failed to parse metrics YAML: ${String(error)}`), null;
  }
}
function mergeMetricConfigs(defaultConfig, customConfig) {
  return {
    default: {
      step: customConfig.default?.step ?? defaultConfig.default.step,
      timeout: customConfig.default?.timeout ?? defaultConfig.default.timeout
    },
    metrics: [...customConfig.metrics || [], ...defaultConfig.metrics || []]
  };
}
async function loadDefaultMetricConfig() {
  import_core.debug("Loading default metrics from GITHUB_ACTION_PATH/deploy/metrics.yaml");
  let actionRoot = path.resolve(process.env.GITHUB_ACTION_PATH), defaultPath = path.join(actionRoot, "deploy", "metrics.yaml");
  if (fs.existsSync(defaultPath)) {
    let content = fs.readFileSync(defaultPath, { encoding: "utf-8" }), config = await parseMetricsYaml(content);
    if (config)
      return config;
  }
  return import_core.warning("Could not load default metrics, using hardcoded defaults"), {
    default: {
      step: "500ms",
      timeout: "30s"
    },
    metrics: []
  };
}
async function loadMetricConfig(customYaml, customPath) {
  let config = await loadDefaultMetricConfig();
  if (customYaml) {
    import_core.debug("Merging custom metrics from inline YAML");
    let customConfig = await parseMetricsYaml(customYaml);
    if (customConfig)
      config = mergeMetricConfigs(config, customConfig);
  }
  if (customPath && fs.existsSync(customPath)) {
    import_core.debug(`Merging custom metrics from file: ${customPath}`);
    let content = fs.readFileSync(customPath, { encoding: "utf-8" }), customConfig = await parseMetricsYaml(content);
    if (customConfig)
      config = mergeMetricConfigs(config, customConfig);
  }
  return config;
}
function percentile(values, p) {
  let sorted = [...values].sort((a, b) => a - b), index = Math.ceil(sorted.length * p) - 1;
  return sorted[Math.max(0, index)];
}
function aggregateValues(values, fn) {
  if (values.length === 0)
    return NaN;
  let nums = values.map(([_, v]) => parseFloat(v)).filter((n) => !isNaN(n));
  if (nums.length === 0)
    return NaN;
  switch (fn) {
    case "last":
      return nums[nums.length - 1];
    case "first":
      return nums[0];
    case "avg":
      return nums.reduce((a, b) => a + b, 0) / nums.length;
    case "min":
      return Math.min(...nums);
    case "max":
      return Math.max(...nums);
    case "p50":
      return percentile(nums, 0.5);
    case "p90":
      return percentile(nums, 0.9);
    case "p95":
      return percentile(nums, 0.95);
    case "p99":
      return percentile(nums, 0.99);
    case "sum":
      return nums.reduce((a, b) => a + b, 0);
    case "count":
      return nums.length;
    default:
      return NaN;
  }
}
function getMetricValue(metric, ref, aggregate = "avg") {
  let series = metric.data.find((s) => s.metric.ref === ref) || null;
  if (!series)
    return NaN;
  if (metric.type === "instant")
    return parseFloat(series.value[1]);
  return aggregateValues(series.values, aggregate);
}

// shared/analysis.ts
function inferMetricDirection(name) {
  let lowerName = name.toLowerCase();
  if (lowerName.includes("latency") || lowerName.includes("duration") || lowerName.includes("time") || lowerName.includes("delay") || lowerName.includes("error") || lowerName.includes("failure"))
    return "lower_is_better";
  if (lowerName.includes("availability") || lowerName.includes("throughput") || lowerName.includes("success") || lowerName.includes("qps") || lowerName.includes("rps") || lowerName.includes("ops"))
    return "higher_is_better";
  return "neutral";
}
function determineChangeDirection(currentValue, baselineValue, metricDirection, neutralThreshold = 5) {
  if (isNaN(currentValue) || isNaN(baselineValue))
    return "unknown";
  if (Math.abs((currentValue - baselineValue) / baselineValue * 100) < neutralThreshold)
    return "neutral";
  if (metricDirection === "lower_is_better")
    return currentValue < baselineValue ? "better" : "worse";
  if (metricDirection === "higher_is_better")
    return currentValue > baselineValue ? "better" : "worse";
  return "neutral";
}
function compareMetric(metric, currentRef, baselineRef, aggregate = "avg", neutralThreshold) {
  let currentValue = getMetricValue(metric, currentRef, aggregate), baselineValue = getMetricValue(metric, baselineRef, aggregate), absolute = currentValue - baselineValue, percent = isNaN(baselineValue) || baselineValue === 0 ? NaN : absolute / baselineValue * 100, metricDirection = inferMetricDirection(metric.name), direction = determineChangeDirection(currentValue, baselineValue, metricDirection, neutralThreshold), currentAggregates, baselineAggregates;
  if (metric.type === "range")
    currentAggregates = {
      avg: getMetricValue(metric, currentRef, "avg"),
      p50: getMetricValue(metric, currentRef, "p50"),
      p90: getMetricValue(metric, currentRef, "p90"),
      p95: getMetricValue(metric, currentRef, "p95")
    }, baselineAggregates = {
      avg: getMetricValue(metric, baselineRef, "avg"),
      p50: getMetricValue(metric, baselineRef, "p50"),
      p90: getMetricValue(metric, baselineRef, "p90"),
      p95: getMetricValue(metric, baselineRef, "p95")
    };
  return {
    name: metric.name,
    type: metric.type,
    current: {
      value: currentValue,
      available: !isNaN(currentValue),
      aggregates: currentAggregates
    },
    baseline: {
      value: baselineValue,
      available: !isNaN(baselineValue),
      aggregates: baselineAggregates
    },
    change: {
      absolute,
      percent,
      direction
    }
  };
}
function compareWorkloadMetrics(workload, metrics, currentRef, baselineRef, aggregate = "avg", neutralThreshold) {
  let comparisons = [];
  for (let metric of metrics) {
    let comparison = compareMetric(metric, currentRef, baselineRef, aggregate, neutralThreshold);
    comparisons.push(comparison);
  }
  let stable = comparisons.filter((c) => c.change.direction === "neutral").length, regressions = comparisons.filter((c) => c.change.direction === "worse").length, improvements = comparisons.filter((c) => c.change.direction === "better").length;
  return {
    workload,
    metrics: comparisons,
    summary: {
      total: comparisons.length,
      stable,
      regressions,
      improvements
    }
  };
}
function formatValue(value, metricName) {
  if (isNaN(value))
    return "N/A";
  let lowerName = metricName.toLowerCase();
  if (lowerName.includes("latency") || lowerName.includes("duration") || lowerName.endsWith("_ms"))
    return `${value.toFixed(2)}ms`;
  if (lowerName.includes("time") && lowerName.endsWith("_s"))
    return `${value.toFixed(2)}s`;
  if (lowerName.includes("availability") || lowerName.includes("percent") || lowerName.includes("rate"))
    return `${value.toFixed(2)}%`;
  if (lowerName.includes("throughput") || lowerName.includes("qps") || lowerName.includes("rps") || lowerName.includes("ops")) {
    if (value >= 1000)
      return `${(value / 1000).toFixed(2)}k/s`;
    return `${value.toFixed(0)}/s`;
  }
  return value.toFixed(2);
}
function formatChange(percent, direction) {
  if (isNaN(percent))
    return "N/A";
  let sign = percent >= 0 ? "+" : "", emoji = direction === "better" ? "\uD83D\uDFE2" : direction === "worse" ? "\uD83D\uDD34" : direction === "neutral" ? "⚪" : "❓";
  return `${sign}${percent.toFixed(1)}% ${emoji}`;
}

export { loadMetricConfig, compareWorkloadMetrics, formatValue, formatChange };

//# debugId=0AAEF2EF71BA2EAB64756E2164756E21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc2hhcmVkL21ldHJpY3MudHMiLCAiLi4vc2hhcmVkL2FuYWx5c2lzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWwogICAgImltcG9ydCAqIGFzIGZzIGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgZGVidWcsIHdhcm5pbmcgfSBmcm9tICdAYWN0aW9ucy9jb3JlJ1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ0BhY3Rpb25zL2V4ZWMnXG5cbmV4cG9ydCB0eXBlIE1ldHJpY1R5cGUgPSAncmFuZ2UnIHwgJ2luc3RhbnQnXG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0cmljRGVmaW5pdGlvbiB7XG5cdG5hbWU6IHN0cmluZ1xuXHRxdWVyeTogc3RyaW5nXG5cdHR5cGU/OiBNZXRyaWNUeXBlXG5cdHN0ZXA/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXRyaWNDb25maWcge1xuXHRkZWZhdWx0OiB7XG5cdFx0c3RlcD86IHN0cmluZ1xuXHRcdHRpbWVvdXQ/OiBzdHJpbmdcblx0fVxuXHRtZXRyaWNzOiBNZXRyaWNEZWZpbml0aW9uW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSYW5nZVNlcmllcyB7XG5cdG1ldHJpYzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXHR2YWx1ZXM6IFtudW1iZXIsIHN0cmluZ11bXSAvLyBbdGltZXN0YW1wIChzZWMpLCB2YWx1ZSAoZmxvYXQpXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluc3RhbnRTZXJpZXMge1xuXHRtZXRyaWM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblx0dmFsdWU6IFtudW1iZXIsIHN0cmluZ10gLy8gW3RpbWVzdGFtcCAoc2VjKSwgdmFsdWUgKGZsb2F0KV1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXBhcmF0ZWRTZXJpZXMge1xuXHRjdXJyZW50OiBSYW5nZVNlcmllcyB8IEluc3RhbnRTZXJpZXMgfCBudWxsXG5cdGJhc2VsaW5lOiBSYW5nZVNlcmllcyB8IEluc3RhbnRTZXJpZXMgfCBudWxsXG59XG5cbi8qKlxuICogQ29sbGVjdGVkIG1ldHJpYyBmcm9tIGluaXQgYWN0aW9uIChKU09OTCBmb3JtYXQpXG4gKi9cbmV4cG9ydCB0eXBlIENvbGxlY3RlZE1ldHJpYyA9IHtcblx0bmFtZTogc3RyaW5nXG5cdHF1ZXJ5OiBzdHJpbmdcbn0gJiAoXG5cdHwge1xuXHRcdFx0dHlwZTogJ3JhbmdlJ1xuXHRcdFx0ZGF0YTogUmFuZ2VTZXJpZXNbXVxuXHQgIH1cblx0fCB7XG5cdFx0XHR0eXBlOiAnaW5zdGFudCdcblx0XHRcdGRhdGE6IEluc3RhbnRTZXJpZXNbXVxuXHQgIH1cbilcblxuLyoqXG4gKiBQYXJzZSBZQU1MIG1ldHJpY3MgY29uZmlnIHVzaW5nIGB5cWBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlTWV0cmljc1lhbWwoeWFtbENvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8TWV0cmljQ29uZmlnIHwgbnVsbD4ge1xuXHRpZiAoIXlhbWxDb250ZW50IHx8IHlhbWxDb250ZW50LnRyaW0oKSA9PT0gJycpIHtcblx0XHRyZXR1cm4gbnVsbFxuXHR9XG5cblx0dHJ5IHtcblx0XHRsZXQgY2h1bmtzOiBzdHJpbmdbXSA9IFtdXG5cblx0XHRhd2FpdCBleGVjKCd5cScsIFsnLW89anNvbicsICcuJ10sIHtcblx0XHRcdGlucHV0OiBCdWZmZXIuZnJvbSh5YW1sQ29udGVudCwgJ3V0Zi04JyksXG5cdFx0XHRzaWxlbnQ6IHRydWUsXG5cdFx0XHRsaXN0ZW5lcnM6IHtcblx0XHRcdFx0c3Rkb3V0OiAoZGF0YSkgPT4gY2h1bmtzLnB1c2goZGF0YS50b1N0cmluZygpKSxcblx0XHRcdH0sXG5cdFx0fSlcblxuXHRcdGxldCBqc29uID0gY2h1bmtzLmpvaW4oJycpXG5cdFx0bGV0IHBhcnNlZCA9IEpTT04ucGFyc2UoanNvbikgYXMgTWV0cmljQ29uZmlnXG5cblx0XHRyZXR1cm4gcGFyc2VkXG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0d2FybmluZyhgRmFpbGVkIHRvIHBhcnNlIG1ldHJpY3MgWUFNTDogJHtTdHJpbmcoZXJyb3IpfWApXG5cdFx0cmV0dXJuIG51bGxcblx0fVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBtZXRyaWMgY29uZmlncyAoY3VzdG9tIGV4dGVuZHMvb3ZlcnJpZGVzIGRlZmF1bHQpXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWV0cmljQ29uZmlncyhkZWZhdWx0Q29uZmlnOiBNZXRyaWNDb25maWcsIGN1c3RvbUNvbmZpZzogTWV0cmljQ29uZmlnKTogTWV0cmljQ29uZmlnIHtcblx0Ly8gcHJldHRpZXItaWdub3JlXG5cdHJldHVybiB7XG5cdFx0ZGVmYXVsdDoge1xuXHRcdFx0c3RlcDogY3VzdG9tQ29uZmlnLmRlZmF1bHQ/LnN0ZXAgPz8gZGVmYXVsdENvbmZpZy5kZWZhdWx0LnN0ZXAsXG5cdFx0XHR0aW1lb3V0OiBjdXN0b21Db25maWcuZGVmYXVsdD8udGltZW91dCA/PyBkZWZhdWx0Q29uZmlnLmRlZmF1bHQudGltZW91dCxcblx0XHR9LFxuXHRcdG1ldHJpY3M6IFsuLi4oY3VzdG9tQ29uZmlnLm1ldHJpY3MgfHwgW10pLCAuLi4oZGVmYXVsdENvbmZpZy5tZXRyaWNzIHx8IFtdKV0sXG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGRlZmF1bHQgbWV0cmljcyBmcm9tIGRlcGxveS9tZXRyaWNzLnlhbWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWREZWZhdWx0TWV0cmljQ29uZmlnKCk6IFByb21pc2U8TWV0cmljQ29uZmlnPiB7XG5cdGRlYnVnKCdMb2FkaW5nIGRlZmF1bHQgbWV0cmljcyBmcm9tIEdJVEhVQl9BQ1RJT05fUEFUSC9kZXBsb3kvbWV0cmljcy55YW1sJylcblx0bGV0IGFjdGlvblJvb3QgPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5lbnZbJ0dJVEhVQl9BQ1RJT05fUEFUSCddISlcblx0bGV0IGRlZmF1bHRQYXRoID0gcGF0aC5qb2luKGFjdGlvblJvb3QsICdkZXBsb3knLCAnbWV0cmljcy55YW1sJylcblxuXHRpZiAoZnMuZXhpc3RzU3luYyhkZWZhdWx0UGF0aCkpIHtcblx0XHRsZXQgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhkZWZhdWx0UGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KVxuXHRcdGxldCBjb25maWcgPSBhd2FpdCBwYXJzZU1ldHJpY3NZYW1sKGNvbnRlbnQpXG5cdFx0aWYgKGNvbmZpZykgcmV0dXJuIGNvbmZpZ1xuXHR9XG5cblx0Ly8gRmFsbGJhY2sgdG8gaGFyZGNvZGVkIGRlZmF1bHRzXG5cdHdhcm5pbmcoJ0NvdWxkIG5vdCBsb2FkIGRlZmF1bHQgbWV0cmljcywgdXNpbmcgaGFyZGNvZGVkIGRlZmF1bHRzJylcblx0cmV0dXJuIHtcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHRzdGVwOiAnNTAwbXMnLFxuXHRcdFx0dGltZW91dDogJzMwcycsXG5cdFx0fSxcblx0XHRtZXRyaWNzOiBbXSxcblx0fVxufVxuXG4vKipcbiAqIExvYWQgbWV0cmljcyBjb25maWd1cmF0aW9uIHdpdGggbWVyZ2luZzpcbiAqIDEuIExvYWQgZGVmYXVsdCBmcm9tIGRlcGxveS9tZXRyaWNzLnlhbWxcbiAqIDIuIE1lcmdlIHdpdGggY3VzdG9tIFlBTUwgKGlubGluZSkgaWYgcHJvdmlkZWRcbiAqIDMuIE1lcmdlIHdpdGggY3VzdG9tIGZpbGUgaWYgcHJvdmlkZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRyaWNDb25maWcoY3VzdG9tWWFtbD86IHN0cmluZywgY3VzdG9tUGF0aD86IHN0cmluZyk6IFByb21pc2U8TWV0cmljQ29uZmlnPiB7XG5cdGxldCBjb25maWcgPSBhd2FpdCBsb2FkRGVmYXVsdE1ldHJpY0NvbmZpZygpXG5cblx0Ly8gTWVyZ2Ugd2l0aCBjdXN0b20gWUFNTCAoaW5saW5lKVxuXHRpZiAoY3VzdG9tWWFtbCkge1xuXHRcdGRlYnVnKCdNZXJnaW5nIGN1c3RvbSBtZXRyaWNzIGZyb20gaW5saW5lIFlBTUwnKVxuXHRcdGxldCBjdXN0b21Db25maWcgPSBhd2FpdCBwYXJzZU1ldHJpY3NZYW1sKGN1c3RvbVlhbWwpXG5cdFx0aWYgKGN1c3RvbUNvbmZpZykge1xuXHRcdFx0Y29uZmlnID0gbWVyZ2VNZXRyaWNDb25maWdzKGNvbmZpZywgY3VzdG9tQ29uZmlnKVxuXHRcdH1cblx0fVxuXG5cdC8vIE1lcmdlIHdpdGggY3VzdG9tIGZpbGVcblx0aWYgKGN1c3RvbVBhdGggJiYgZnMuZXhpc3RzU3luYyhjdXN0b21QYXRoKSkge1xuXHRcdGRlYnVnKGBNZXJnaW5nIGN1c3RvbSBtZXRyaWNzIGZyb20gZmlsZTogJHtjdXN0b21QYXRofWApXG5cdFx0bGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoY3VzdG9tUGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KVxuXHRcdGxldCBjdXN0b21Db25maWcgPSBhd2FpdCBwYXJzZU1ldHJpY3NZYW1sKGNvbnRlbnQpXG5cdFx0aWYgKGN1c3RvbUNvbmZpZykge1xuXHRcdFx0Y29uZmlnID0gbWVyZ2VNZXRyaWNDb25maWdzKGNvbmZpZywgY3VzdG9tQ29uZmlnKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb25maWdcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgcGVyY2VudGlsZVxuICovXG5mdW5jdGlvbiBwZXJjZW50aWxlKHZhbHVlczogbnVtYmVyW10sIHA6IG51bWJlcik6IG51bWJlciB7XG5cdGxldCBzb3J0ZWQgPSBbLi4udmFsdWVzXS5zb3J0KChhLCBiKSA9PiBhIC0gYilcblx0bGV0IGluZGV4ID0gTWF0aC5jZWlsKHNvcnRlZC5sZW5ndGggKiBwKSAtIDFcblx0cmV0dXJuIHNvcnRlZFtNYXRoLm1heCgwLCBpbmRleCldXG59XG5cbi8qKlxuICogQWdncmVnYXRlIGZ1bmN0aW9uIHR5cGUgZm9yIHJhbmdlIG1ldHJpY3NcbiAqL1xuZXhwb3J0IHR5cGUgQWdncmVnYXRlRnVuY3Rpb24gPVxuXHR8ICdsYXN0J1xuXHR8ICdmaXJzdCdcblx0fCAnYXZnJ1xuXHR8ICdtaW4nXG5cdHwgJ21heCdcblx0fCAncDUwJ1xuXHR8ICdwOTAnXG5cdHwgJ3A5NSdcblx0fCAncDk5J1xuXHR8ICdzdW0nXG5cdHwgJ2NvdW50J1xuXG4vKipcbiAqIEFnZ3JlZ2F0ZSByYW5nZSBtZXRyaWMgdmFsdWVzIHVzaW5nIHNwZWNpZmllZCBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYWdncmVnYXRlVmFsdWVzKHZhbHVlczogW251bWJlciwgc3RyaW5nXVtdLCBmbjogQWdncmVnYXRlRnVuY3Rpb24pOiBudW1iZXIge1xuXHRpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIE5hTlxuXG5cdGxldCBudW1zID0gdmFsdWVzLm1hcCgoW18sIHZdKSA9PiBwYXJzZUZsb2F0KHYpKS5maWx0ZXIoKG4pID0+ICFpc05hTihuKSlcblxuXHRpZiAobnVtcy5sZW5ndGggPT09IDApIHJldHVybiBOYU5cblxuXHRzd2l0Y2ggKGZuKSB7XG5cdFx0Y2FzZSAnbGFzdCc6XG5cdFx0XHRyZXR1cm4gbnVtc1tudW1zLmxlbmd0aCAtIDFdXG5cdFx0Y2FzZSAnZmlyc3QnOlxuXHRcdFx0cmV0dXJuIG51bXNbMF1cblx0XHRjYXNlICdhdmcnOlxuXHRcdFx0cmV0dXJuIG51bXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCkgLyBudW1zLmxlbmd0aFxuXHRcdGNhc2UgJ21pbic6XG5cdFx0XHRyZXR1cm4gTWF0aC5taW4oLi4ubnVtcylcblx0XHRjYXNlICdtYXgnOlxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KC4uLm51bXMpXG5cdFx0Y2FzZSAncDUwJzpcblx0XHRcdHJldHVybiBwZXJjZW50aWxlKG51bXMsIDAuNSlcblx0XHRjYXNlICdwOTAnOlxuXHRcdFx0cmV0dXJuIHBlcmNlbnRpbGUobnVtcywgMC45KVxuXHRcdGNhc2UgJ3A5NSc6XG5cdFx0XHRyZXR1cm4gcGVyY2VudGlsZShudW1zLCAwLjk1KVxuXHRcdGNhc2UgJ3A5OSc6XG5cdFx0XHRyZXR1cm4gcGVyY2VudGlsZShudW1zLCAwLjk5KVxuXHRcdGNhc2UgJ3N1bSc6XG5cdFx0XHRyZXR1cm4gbnVtcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKVxuXHRcdGNhc2UgJ2NvdW50Jzpcblx0XHRcdHJldHVybiBudW1zLmxlbmd0aFxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gTmFOXG5cdH1cbn1cblxuLyoqXG4gKiBHZXQgc2luZ2xlIHZhbHVlIGZyb20gbWV0cmljIChpbnN0YW50IG9yIGFnZ3JlZ2F0ZWQgcmFuZ2UpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNZXRyaWNWYWx1ZShtZXRyaWM6IENvbGxlY3RlZE1ldHJpYywgcmVmOiBzdHJpbmcsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlRnVuY3Rpb24gPSAnYXZnJyk6IG51bWJlciB7XG5cdGxldCBzZXJpZXMgPSBtZXRyaWMuZGF0YS5maW5kKChzKSA9PiBzLm1ldHJpYy5yZWYgPT09IHJlZikgfHwgbnVsbFxuXG5cdGlmICghc2VyaWVzKSByZXR1cm4gTmFOXG5cblx0aWYgKG1ldHJpYy50eXBlID09PSAnaW5zdGFudCcpIHtcblx0XHRyZXR1cm4gcGFyc2VGbG9hdCgoc2VyaWVzIGFzIEluc3RhbnRTZXJpZXMpLnZhbHVlWzFdKVxuXHR9XG5cblx0cmV0dXJuIGFnZ3JlZ2F0ZVZhbHVlcygoc2VyaWVzIGFzIFJhbmdlU2VyaWVzKS52YWx1ZXMsIGFnZ3JlZ2F0ZSlcbn1cblxuLyoqXG4gKiBTZXBhcmF0ZSBzZXJpZXMgYnkgcmVmIGxhYmVsIChjdXJyZW50IHZzIGJhc2VsaW5lKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGVCeVJlZihtZXRyaWM6IENvbGxlY3RlZE1ldHJpYywgY3VycmVudFJlZjogc3RyaW5nLCBiYXNlbGluZVJlZjogc3RyaW5nKTogU2VwYXJhdGVkU2VyaWVzIHtcblx0bGV0IGN1cnJlbnQ6IFJhbmdlU2VyaWVzIHwgSW5zdGFudFNlcmllcyB8IG51bGwgPSBudWxsXG5cdGxldCBiYXNlbGluZTogUmFuZ2VTZXJpZXMgfCBJbnN0YW50U2VyaWVzIHwgbnVsbCA9IG51bGxcblxuXHRjdXJyZW50ID0gbWV0cmljLmRhdGEuZmluZCgocykgPT4gcy5tZXRyaWMucmVmID09PSBjdXJyZW50UmVmKSB8fCBudWxsXG5cdGJhc2VsaW5lID0gbWV0cmljLmRhdGEuZmluZCgocykgPT4gcy5tZXRyaWMucmVmID09PSBiYXNlbGluZVJlZikgfHwgbnVsbFxuXG5cdHJldHVybiB7IGN1cnJlbnQsIGJhc2VsaW5lIH1cbn1cbiIsCiAgICAiLyoqXG4gKiBTaGFyZWQgbWV0cmljcyBhbmFseXNpcyBhbmQgY29tcGFyaXNvblxuICpcbiAqIENvcGllZCBmcm9tIHJlcG9ydC9saWIvYW5hbHlzaXMudHMgYW5kIGFkanVzdGVkIHRvIGltcG9ydCBmcm9tIHNoYXJlZC9tZXRyaWNzLnRzXG4gKi9cblxuaW1wb3J0IHsgZ2V0TWV0cmljVmFsdWUsIHR5cGUgQWdncmVnYXRlRnVuY3Rpb24sIHR5cGUgQ29sbGVjdGVkTWV0cmljIH0gZnJvbSAnLi9tZXRyaWNzLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY0NvbXBhcmlzb24ge1xuXHRuYW1lOiBzdHJpbmdcblx0dHlwZTogJ3JhbmdlJyB8ICdpbnN0YW50J1xuXHRjdXJyZW50OiB7XG5cdFx0dmFsdWU6IG51bWJlclxuXHRcdGF2YWlsYWJsZTogYm9vbGVhblxuXHRcdGFnZ3JlZ2F0ZXM/OiB7XG5cdFx0XHRhdmc6IG51bWJlclxuXHRcdFx0cDUwOiBudW1iZXJcblx0XHRcdHA5MDogbnVtYmVyXG5cdFx0XHRwOTU6IG51bWJlclxuXHRcdH1cblx0fVxuXHRiYXNlbGluZToge1xuXHRcdHZhbHVlOiBudW1iZXJcblx0XHRhdmFpbGFibGU6IGJvb2xlYW5cblx0XHRhZ2dyZWdhdGVzPzoge1xuXHRcdFx0YXZnOiBudW1iZXJcblx0XHRcdHA1MDogbnVtYmVyXG5cdFx0XHRwOTA6IG51bWJlclxuXHRcdFx0cDk1OiBudW1iZXJcblx0XHR9XG5cdH1cblx0Y2hhbmdlOiB7XG5cdFx0YWJzb2x1dGU6IG51bWJlclxuXHRcdHBlcmNlbnQ6IG51bWJlclxuXHRcdGRpcmVjdGlvbjogJ2JldHRlcicgfCAnd29yc2UnIHwgJ25ldXRyYWwnIHwgJ3Vua25vd24nXG5cdH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXb3JrbG9hZENvbXBhcmlzb24ge1xuXHR3b3JrbG9hZDogc3RyaW5nXG5cdG1ldHJpY3M6IE1ldHJpY0NvbXBhcmlzb25bXVxuXHRzdW1tYXJ5OiB7XG5cdFx0dG90YWw6IG51bWJlclxuXHRcdHN0YWJsZTogbnVtYmVyXG5cdFx0cmVncmVzc2lvbnM6IG51bWJlclxuXHRcdGltcHJvdmVtZW50czogbnVtYmVyXG5cdH1cbn1cblxuLyoqXG4gKiBJbmZlciBtZXRyaWMgZGlyZWN0aW9uIGJhc2VkIG9uIG5hbWVcbiAqL1xuZnVuY3Rpb24gaW5mZXJNZXRyaWNEaXJlY3Rpb24obmFtZTogc3RyaW5nKTogJ2xvd2VyX2lzX2JldHRlcicgfCAnaGlnaGVyX2lzX2JldHRlcicgfCAnbmV1dHJhbCcge1xuXHRsZXQgbG93ZXJOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cblx0Ly8gTG93ZXIgaXMgYmV0dGVyXG5cdGlmIChcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ2xhdGVuY3knKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygnZHVyYXRpb24nKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygndGltZScpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdkZWxheScpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdlcnJvcicpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdmYWlsdXJlJylcblx0KSB7XG5cdFx0cmV0dXJuICdsb3dlcl9pc19iZXR0ZXInXG5cdH1cblxuXHQvLyBIaWdoZXIgaXMgYmV0dGVyXG5cdGlmIChcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ2F2YWlsYWJpbGl0eScpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCd0aHJvdWdocHV0JykgfHxcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ3N1Y2Nlc3MnKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygncXBzJykgfHxcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ3JwcycpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdvcHMnKVxuXHQpIHtcblx0XHRyZXR1cm4gJ2hpZ2hlcl9pc19iZXR0ZXInXG5cdH1cblxuXHRyZXR1cm4gJ25ldXRyYWwnXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGNoYW5nZSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hhbmdlRGlyZWN0aW9uKFxuXHRjdXJyZW50VmFsdWU6IG51bWJlcixcblx0YmFzZWxpbmVWYWx1ZTogbnVtYmVyLFxuXHRtZXRyaWNEaXJlY3Rpb246ICdsb3dlcl9pc19iZXR0ZXInIHwgJ2hpZ2hlcl9pc19iZXR0ZXInIHwgJ25ldXRyYWwnLFxuXHRuZXV0cmFsVGhyZXNob2xkOiBudW1iZXIgPSA1LjBcbik6ICdiZXR0ZXInIHwgJ3dvcnNlJyB8ICduZXV0cmFsJyB8ICd1bmtub3duJyB7XG5cdGlmIChpc05hTihjdXJyZW50VmFsdWUpIHx8IGlzTmFOKGJhc2VsaW5lVmFsdWUpKSB7XG5cdFx0cmV0dXJuICd1bmtub3duJ1xuXHR9XG5cblx0bGV0IGNoYW5nZVBlcmNlbnQgPSBNYXRoLmFicygoKGN1cnJlbnRWYWx1ZSAtIGJhc2VsaW5lVmFsdWUpIC8gYmFzZWxpbmVWYWx1ZSkgKiAxMDApXG5cblx0Ly8gQ29uc2lkZXIgY2hhbmdlIGJlbG93IHRocmVzaG9sZCBhcyBzdGFibGUvbmV1dHJhbFxuXHRpZiAoY2hhbmdlUGVyY2VudCA8IG5ldXRyYWxUaHJlc2hvbGQpIHtcblx0XHRyZXR1cm4gJ25ldXRyYWwnXG5cdH1cblxuXHRpZiAobWV0cmljRGlyZWN0aW9uID09PSAnbG93ZXJfaXNfYmV0dGVyJykge1xuXHRcdHJldHVybiBjdXJyZW50VmFsdWUgPCBiYXNlbGluZVZhbHVlID8gJ2JldHRlcicgOiAnd29yc2UnXG5cdH1cblxuXHRpZiAobWV0cmljRGlyZWN0aW9uID09PSAnaGlnaGVyX2lzX2JldHRlcicpIHtcblx0XHRyZXR1cm4gY3VycmVudFZhbHVlID4gYmFzZWxpbmVWYWx1ZSA/ICdiZXR0ZXInIDogJ3dvcnNlJ1xuXHR9XG5cblx0cmV0dXJuICduZXV0cmFsJ1xufVxuXG4vKipcbiAqIENvbXBhcmUgc2luZ2xlIG1ldHJpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZU1ldHJpYyhcblx0bWV0cmljOiBDb2xsZWN0ZWRNZXRyaWMsXG5cdGN1cnJlbnRSZWY6IHN0cmluZyxcblx0YmFzZWxpbmVSZWY6IHN0cmluZyxcblx0YWdncmVnYXRlOiBBZ2dyZWdhdGVGdW5jdGlvbiA9ICdhdmcnLFxuXHRuZXV0cmFsVGhyZXNob2xkPzogbnVtYmVyXG4pOiBNZXRyaWNDb21wYXJpc29uIHtcblx0bGV0IGN1cnJlbnRWYWx1ZSA9IGdldE1ldHJpY1ZhbHVlKG1ldHJpYywgY3VycmVudFJlZiwgYWdncmVnYXRlKVxuXHRsZXQgYmFzZWxpbmVWYWx1ZSA9IGdldE1ldHJpY1ZhbHVlKG1ldHJpYywgYmFzZWxpbmVSZWYsIGFnZ3JlZ2F0ZSlcblxuXHRsZXQgYWJzb2x1dGUgPSBjdXJyZW50VmFsdWUgLSBiYXNlbGluZVZhbHVlXG5cdGxldCBwZXJjZW50ID0gaXNOYU4oYmFzZWxpbmVWYWx1ZSkgfHwgYmFzZWxpbmVWYWx1ZSA9PT0gMCA/IE5hTiA6IChhYnNvbHV0ZSAvIGJhc2VsaW5lVmFsdWUpICogMTAwXG5cblx0bGV0IG1ldHJpY0RpcmVjdGlvbiA9IGluZmVyTWV0cmljRGlyZWN0aW9uKG1ldHJpYy5uYW1lKVxuXHRsZXQgZGlyZWN0aW9uID0gZGV0ZXJtaW5lQ2hhbmdlRGlyZWN0aW9uKGN1cnJlbnRWYWx1ZSwgYmFzZWxpbmVWYWx1ZSwgbWV0cmljRGlyZWN0aW9uLCBuZXV0cmFsVGhyZXNob2xkKVxuXG5cdC8vIENhbGN1bGF0ZSBtdWx0aXBsZSBhZ2dyZWdhdGVzIGZvciByYW5nZSBtZXRyaWNzXG5cdGxldCBjdXJyZW50QWdncmVnYXRlczogeyBhdmc6IG51bWJlcjsgcDUwOiBudW1iZXI7IHA5MDogbnVtYmVyOyBwOTU6IG51bWJlciB9IHwgdW5kZWZpbmVkXG5cdGxldCBiYXNlbGluZUFnZ3JlZ2F0ZXM6IHsgYXZnOiBudW1iZXI7IHA1MDogbnVtYmVyOyBwOTA6IG51bWJlcjsgcDk1OiBudW1iZXIgfSB8IHVuZGVmaW5lZFxuXG5cdGlmIChtZXRyaWMudHlwZSA9PT0gJ3JhbmdlJykge1xuXHRcdGN1cnJlbnRBZ2dyZWdhdGVzID0ge1xuXHRcdFx0YXZnOiBnZXRNZXRyaWNWYWx1ZShtZXRyaWMsIGN1cnJlbnRSZWYsICdhdmcnKSxcblx0XHRcdHA1MDogZ2V0TWV0cmljVmFsdWUobWV0cmljLCBjdXJyZW50UmVmLCAncDUwJyksXG5cdFx0XHRwOTA6IGdldE1ldHJpY1ZhbHVlKG1ldHJpYywgY3VycmVudFJlZiwgJ3A5MCcpLFxuXHRcdFx0cDk1OiBnZXRNZXRyaWNWYWx1ZShtZXRyaWMsIGN1cnJlbnRSZWYsICdwOTUnKSxcblx0XHR9XG5cdFx0YmFzZWxpbmVBZ2dyZWdhdGVzID0ge1xuXHRcdFx0YXZnOiBnZXRNZXRyaWNWYWx1ZShtZXRyaWMsIGJhc2VsaW5lUmVmLCAnYXZnJyksXG5cdFx0XHRwNTA6IGdldE1ldHJpY1ZhbHVlKG1ldHJpYywgYmFzZWxpbmVSZWYsICdwNTAnKSxcblx0XHRcdHA5MDogZ2V0TWV0cmljVmFsdWUobWV0cmljLCBiYXNlbGluZVJlZiwgJ3A5MCcpLFxuXHRcdFx0cDk1OiBnZXRNZXRyaWNWYWx1ZShtZXRyaWMsIGJhc2VsaW5lUmVmLCAncDk1JyksXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRuYW1lOiBtZXRyaWMubmFtZSxcblx0XHR0eXBlOiBtZXRyaWMudHlwZSxcblx0XHRjdXJyZW50OiB7XG5cdFx0XHR2YWx1ZTogY3VycmVudFZhbHVlLFxuXHRcdFx0YXZhaWxhYmxlOiAhaXNOYU4oY3VycmVudFZhbHVlKSxcblx0XHRcdGFnZ3JlZ2F0ZXM6IGN1cnJlbnRBZ2dyZWdhdGVzLFxuXHRcdH0sXG5cdFx0YmFzZWxpbmU6IHtcblx0XHRcdHZhbHVlOiBiYXNlbGluZVZhbHVlLFxuXHRcdFx0YXZhaWxhYmxlOiAhaXNOYU4oYmFzZWxpbmVWYWx1ZSksXG5cdFx0XHRhZ2dyZWdhdGVzOiBiYXNlbGluZUFnZ3JlZ2F0ZXMsXG5cdFx0fSxcblx0XHRjaGFuZ2U6IHtcblx0XHRcdGFic29sdXRlLFxuXHRcdFx0cGVyY2VudCxcblx0XHRcdGRpcmVjdGlvbixcblx0XHR9LFxuXHR9XG59XG5cbi8qKlxuICogQ29tcGFyZSBhbGwgbWV0cmljcyBpbiBhIHdvcmtsb2FkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlV29ya2xvYWRNZXRyaWNzKFxuXHR3b3JrbG9hZDogc3RyaW5nLFxuXHRtZXRyaWNzOiBDb2xsZWN0ZWRNZXRyaWNbXSxcblx0Y3VycmVudFJlZjogc3RyaW5nLFxuXHRiYXNlbGluZVJlZjogc3RyaW5nLFxuXHRhZ2dyZWdhdGU6IEFnZ3JlZ2F0ZUZ1bmN0aW9uID0gJ2F2ZycsXG5cdG5ldXRyYWxUaHJlc2hvbGQ/OiBudW1iZXJcbik6IFdvcmtsb2FkQ29tcGFyaXNvbiB7XG5cdGxldCBjb21wYXJpc29uczogTWV0cmljQ29tcGFyaXNvbltdID0gW11cblxuXHRmb3IgKGxldCBtZXRyaWMgb2YgbWV0cmljcykge1xuXHRcdGxldCBjb21wYXJpc29uID0gY29tcGFyZU1ldHJpYyhtZXRyaWMsIGN1cnJlbnRSZWYsIGJhc2VsaW5lUmVmLCBhZ2dyZWdhdGUsIG5ldXRyYWxUaHJlc2hvbGQpXG5cdFx0Y29tcGFyaXNvbnMucHVzaChjb21wYXJpc29uKVxuXHR9XG5cblx0Ly8gQ2FsY3VsYXRlIHN1bW1hcnlcblx0bGV0IHN0YWJsZSA9IGNvbXBhcmlzb25zLmZpbHRlcigoYykgPT4gYy5jaGFuZ2UuZGlyZWN0aW9uID09PSAnbmV1dHJhbCcpLmxlbmd0aFxuXHRsZXQgcmVncmVzc2lvbnMgPSBjb21wYXJpc29ucy5maWx0ZXIoKGMpID0+IGMuY2hhbmdlLmRpcmVjdGlvbiA9PT0gJ3dvcnNlJykubGVuZ3RoXG5cdGxldCBpbXByb3ZlbWVudHMgPSBjb21wYXJpc29ucy5maWx0ZXIoKGMpID0+IGMuY2hhbmdlLmRpcmVjdGlvbiA9PT0gJ2JldHRlcicpLmxlbmd0aFxuXG5cdHJldHVybiB7XG5cdFx0d29ya2xvYWQsXG5cdFx0bWV0cmljczogY29tcGFyaXNvbnMsXG5cdFx0c3VtbWFyeToge1xuXHRcdFx0dG90YWw6IGNvbXBhcmlzb25zLmxlbmd0aCxcblx0XHRcdHN0YWJsZSxcblx0XHRcdHJlZ3Jlc3Npb25zLFxuXHRcdFx0aW1wcm92ZW1lbnRzLFxuXHRcdH0sXG5cdH1cbn1cblxuLyoqXG4gKiBGb3JtYXQgdmFsdWUgd2l0aCB1bml0IGluZmVyZW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWU6IG51bWJlciwgbWV0cmljTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcblx0aWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuICdOL0EnXG5cblx0bGV0IGxvd2VyTmFtZSA9IG1ldHJpY05hbWUudG9Mb3dlckNhc2UoKVxuXG5cdC8vIExhdGVuY3kvZHVyYXRpb24gKG1zKVxuXHRpZiAobG93ZXJOYW1lLmluY2x1ZGVzKCdsYXRlbmN5JykgfHwgbG93ZXJOYW1lLmluY2x1ZGVzKCdkdXJhdGlvbicpIHx8IGxvd2VyTmFtZS5lbmRzV2l0aCgnX21zJykpIHtcblx0XHRyZXR1cm4gYCR7dmFsdWUudG9GaXhlZCgyKX1tc2Bcblx0fVxuXG5cdC8vIFRpbWUgKHNlY29uZHMpXG5cdGlmIChsb3dlck5hbWUuaW5jbHVkZXMoJ3RpbWUnKSAmJiBsb3dlck5hbWUuZW5kc1dpdGgoJ19zJykpIHtcblx0XHRyZXR1cm4gYCR7dmFsdWUudG9GaXhlZCgyKX1zYFxuXHR9XG5cblx0Ly8gUGVyY2VudGFnZVxuXHRpZiAobG93ZXJOYW1lLmluY2x1ZGVzKCdhdmFpbGFiaWxpdHknKSB8fCBsb3dlck5hbWUuaW5jbHVkZXMoJ3BlcmNlbnQnKSB8fCBsb3dlck5hbWUuaW5jbHVkZXMoJ3JhdGUnKSkge1xuXHRcdHJldHVybiBgJHt2YWx1ZS50b0ZpeGVkKDIpfSVgXG5cdH1cblxuXHQvLyBUaHJvdWdocHV0XG5cdGlmIChcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ3Rocm91Z2hwdXQnKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygncXBzJykgfHxcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ3JwcycpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdvcHMnKVxuXHQpIHtcblx0XHRpZiAodmFsdWUgPj0gMTAwMCkge1xuXHRcdFx0cmV0dXJuIGAkeyh2YWx1ZSAvIDEwMDApLnRvRml4ZWQoMil9ay9zYFxuXHRcdH1cblx0XHRyZXR1cm4gYCR7dmFsdWUudG9GaXhlZCgwKX0vc2Bcblx0fVxuXG5cdC8vIERlZmF1bHQ6IDIgZGVjaW1hbCBwbGFjZXNcblx0cmV0dXJuIHZhbHVlLnRvRml4ZWQoMilcbn1cblxuLyoqXG4gKiBGb3JtYXQgY2hhbmdlIHBlcmNlbnRhZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdENoYW5nZShwZXJjZW50OiBudW1iZXIsIGRpcmVjdGlvbjogJ2JldHRlcicgfCAnd29yc2UnIHwgJ25ldXRyYWwnIHwgJ3Vua25vd24nKTogc3RyaW5nIHtcblx0aWYgKGlzTmFOKHBlcmNlbnQpKSByZXR1cm4gJ04vQSdcblxuXHRsZXQgc2lnbiA9IHBlcmNlbnQgPj0gMCA/ICcrJyA6ICcnXG5cdGxldCBlbW9qaSA9IGRpcmVjdGlvbiA9PT0gJ2JldHRlcicgPyAn8J+foicgOiBkaXJlY3Rpb24gPT09ICd3b3JzZScgPyAn8J+UtCcgOiBkaXJlY3Rpb24gPT09ICduZXV0cmFsJyA/ICfimqonIDogJ+KdkydcblxuXHRyZXR1cm4gYCR7c2lnbn0ke3BlcmNlbnQudG9GaXhlZCgxKX0lICR7ZW1vaml9YFxufVxuIgogIF0sCiAgIm1hcHBp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S0FDeEIsVUFBVSxTQUFTLEtBQUssR0FDdkI7QUFBQSxJQUNELElBQUksU0FBUztBQUFBLE1BQ1osT0FBTyxJQUFJLFFBQVEsTUFBTSxRQUFRLENBQUM7QUFBQSxJQUVuQyxPQUFPLEdBQUcsTUFBTSxRQUFRLENBQUM7QUFBQTtBQUFBLEVBSTFCLE9BQU8sTUFBTSxRQUFRLENBQUM7QUFBQTtBQU1oQixTQUFTLFlBQVksQ0FBQyxTQUFpQixXQUErRDtBQUFBLEVBQzVHLElBQUksTUFBTSxPQUFPO0FBQUEsSUFBRyxPQUFPO0FBQUEsRUFFM0IsSUFBSSxPQUFPLFdBQVcsSUFBSSxNQUFNLElBQzVCLFFBQVEsY0FBYyxXQUFXLGlCQUFNLGNBQWMsVUFBVSxpQkFBTyxjQUFjLFlBQVksTUFBTTtBQUFBLEVBRTFHLE9BQU8sR0FBRyxPQUFPLFFBQVEsUUFBUSxDQUFDLE1BQU07QUFBQTsiLAogICJkZWJ1Z0lkIjogIjBBQUVGMkVGNzFCQTJFQUI2NDc1NkUyMTY0NzU2RTIxIiwKICAibmFtZXMiOiBbXQp9
