import {
  require_artifact
} from "../main-bjt997wk.js";
import {
  require_core,
  require_exec
} from "../main-777rh5c8.js";
import {
  __toESM
} from "../main-eyq3236q.js";

// init/post.ts
var import_core3 = __toESM(require_core(), 1);
import * as fs2 from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

// init/lib/artifacts.ts
var import_artifact = __toESM(require_artifact(), 1), import_core = __toESM(require_core(), 1);
import * as fs from "node:fs";
async function uploadArtifacts(name, artifacts, cwd) {
  let artifactClient = new import_artifact.DefaultArtifactClient, rootDirectory = cwd || process.cwd(), files = [];
  for (let artifact of artifacts) {
    if (!fs.existsSync(artifact.path)) {
      import_core.warning(`Artifact source missing: ${artifact.path}`);
      continue;
    }
    files.push(artifact.path);
  }
  if (files.length === 0) {
    import_core.warning("No artifacts to upload");
    return;
  }
  try {
    let { id } = await artifactClient.uploadArtifact(name, files, rootDirectory, {
      retentionDays: 1
    });
    import_core.info(`Uploaded ${files.length} file(s) as artifact ${name} (id: ${id})`);
  } catch (error) {
    import_core.warning(`Failed to upload artifacts: ${String(error)}`);
  }
}

// init/lib/docker.ts
var import_core2 = __toESM(require_core(), 1), import_exec = __toESM(require_exec(), 1);
async function getContainerIp(containerName, cwd) {
  try {
    let chunks = [];
    return await import_exec.exec("docker", ["inspect", "-f", "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}", containerName], {
      cwd,
      silent: !0,
      listeners: {
        stdout: (data) => chunks.push(data.toString())
      }
    }), chunks.join("").trim() || null;
  } catch (error) {
    return import_core2.warning(`Failed to get container IP for ${containerName}: ${String(error)}`), null;
  }
}
async function collectComposeLogs(cwd) {
  try {
    let chunks = [];
    return await import_exec.exec("docker", ["compose", "-f", "compose.yml", "logs", "--no-color"], {
      cwd,
      silent: !0,
      listeners: {
        stdout: (data) => chunks.push(data.toString()),
        stderr: (data) => chunks.push(data.toString())
      }
    }), chunks.join("");
  } catch (error) {
    return import_core2.warning(`Failed to collect docker compose logs: ${String(error)}`), "";
  }
}
async function collectDockerEvents(options) {
  let events = [];
  try {
    let chunks = [];
    await import_exec.exec("docker", [
      "events",
      "--filter",
      "label=ydb.node.type=database",
      "--filter",
      "event=stop",
      "--filter",
      "event=start",
      "--filter",
      "event=kill",
      "--filter",
      "event=restart",
      "--since",
      options.since.toISOString(),
      "--until",
      options.until.toISOString(),
      "--format",
      "{{json .}}"
    ], {
      cwd: options.cwd,
      silent: !0,
      listeners: {
        stdout: (data) => chunks.push(data.toString())
      }
    });
    let lines = chunks.join("").split(`
`).filter(Boolean);
    for (let line of lines)
      events.push(JSON.parse(line));
  } catch (error) {
    import_core2.warning(`Failed to collect Docker events: ${String(error)}`);
  }
  return events;
}
async function stopCompose(cwd) {
  await import_exec.exec("docker", ["compose", "-f", "compose.yml", "down"], { cwd });
}

// init/lib/metrics.ts
var import_exec2 = __toESM(require_exec(), 1);

// init/lib/prometheus.ts
async function queryInstant(params) {
  let baseUrl = params.url || "http://localhost:9090", timeout = params.timeout || 30000, url = new URL("/api/v1/query", baseUrl);
  if (url.searchParams.set("query", params.query), params.time !== void 0)
    url.searchParams.set("time", params.time.toString());
  if (params.queryTimeout)
    url.searchParams.set("timeout", params.queryTimeout);
  let response = await fetch(url.toString(), {
    signal: AbortSignal.timeout(timeout)
  }), data = await response.json();
  if (!response.ok)
    throw Error(`Prometheus query failed: ${data.error || response.statusText}`);
  return data;
}
async function queryRange(params) {
  let baseUrl = params.url || "http://localhost:9090", timeout = params.timeout || 30000, url = new URL("/api/v1/query_range", baseUrl);
  if (url.searchParams.set("query", params.query), url.searchParams.set("start", params.start.toString()), url.searchParams.set("end", params.end.toString()), url.searchParams.set("step", params.step), params.queryTimeout)
    url.searchParams.set("timeout", params.queryTimeout);
  let response = await fetch(url.toString(), {
    signal: AbortSignal.timeout(timeout)
  }), data = await response.json();
  if (!response.ok)
    throw Error(`Prometheus range query failed: ${data.error || response.statusText}`);
  return data;
}

// init/lib/metrics.ts
async function parseMetricsYaml(yamlContent) {
  if (!yamlContent || yamlContent.trim() === "")
    return [];
  try {
    let chunks = [];
    await import_exec2.exec("yq", ["-o=json", "."], {
      input: Buffer.from(yamlContent, "utf-8"),
      silent: !0,
      listeners: {
        stdout: (data) => chunks.push(data.toString())
      }
    });
    let json = chunks.join(""), parsed = JSON.parse(json);
    if (Array.isArray(parsed))
      return parsed;
    return [];
  } catch (error) {
    throw Error(`Failed to parse metrics YAML: ${String(error)}`);
  }
}
function calculateOptimalStep(durationSeconds) {
  let stepSeconds = Math.ceil(durationSeconds / 200);
  stepSeconds = Math.max(5, Math.min(60, stepSeconds));
  let niceSteps = [5, 10, 15, 30, 60];
  for (let niceStep of niceSteps)
    if (stepSeconds <= niceStep)
      return `${niceStep}s`;
  return "60s";
}
async function collectMetrics(options) {
  let results = [], durationSeconds = options.end - options.start, defaultStep = calculateOptimalStep(durationSeconds);
  for (let metric of options.metrics)
    try {
      if ((metric.type || "range") === "instant") {
        let response = await queryInstant({
          url: options.url,
          query: metric.query,
          time: metric.time || options.end,
          timeout: options.timeout
        });
        if (response.status === "success" && response.data)
          results.push({
            name: metric.name,
            query: metric.query,
            type: "instant",
            data: response.data.result
          });
      } else {
        let response = await queryRange({
          url: options.url,
          query: metric.query,
          start: options.start,
          end: options.end,
          step: metric.step || defaultStep,
          timeout: options.timeout
        });
        if (response.status === "success" && response.data)
          results.push({
            name: metric.name,
            query: metric.query,
            type: "range",
            data: response.data.result
          });
      }
    } catch {
      continue;
    }
  return results;
}

// init/post.ts
async function post() {
  let cwd = import_core3.getState("cwd"), workload = import_core3.getState("workload"), start = new Date(import_core3.getState("start")), finish = /* @__PURE__ */ new Date, duration = finish.getTime() - start.getTime(), pullPath = import_core3.getState("pull_info_path"), logsPath = path.join(cwd, `${workload}-logs.txt`), eventsPath = path.join(cwd, `${workload}-events.jsonl`), metricsPath = path.join(cwd, `${workload}-metrics.jsonl`), prometheusIp = await getContainerIp("prometheus", cwd), prometheusUrl = prometheusIp ? `http://${prometheusIp}:9090` : "http://localhost:9090";
  import_core3.debug(`Prometheus URL: ${prometheusUrl}`);
  let actionRoot = path.resolve(path.dirname(fileURLToPath(import.meta.url)), "../../"), defaultMetricsPath = path.join(actionRoot, "deploy", "metrics.yaml"), metricsYaml = fs2.readFileSync(defaultMetricsPath, { encoding: "utf-8" }), customMetricsYaml = import_core3.getInput("metrics_yaml");
  if (import_core3.getInput("metrics_yaml_path")) {
    let customMetricsPath = import_core3.getInput("metrics_yaml_path");
    if (!fs2.existsSync(customMetricsPath))
      import_core3.warning(`Custom metrics file not found: ${customMetricsPath}`);
    else
      customMetricsYaml = fs2.readFileSync(customMetricsPath, { encoding: "utf-8" });
  }
  {
    import_core3.info("Collecting logs...");
    let logs = await collectComposeLogs(cwd);
    fs2.writeFileSync(logsPath, logs, { encoding: "utf-8" });
  }
  {
    import_core3.info("Collecting events...");
    let content = (await collectDockerEvents({
      cwd,
      since: start,
      until: finish
    })).map((e) => JSON.stringify(e)).join(`
`);
    fs2.writeFileSync(eventsPath, content, { encoding: "utf-8" });
  }
  {
    import_core3.info("Collecting metrics...");
    let metricsDef = [];
    if (metricsYaml) {
      let defaultMetrics = await parseMetricsYaml(metricsYaml);
      metricsDef.push(...defaultMetrics);
    }
    if (customMetricsYaml) {
      let customMetrics = await parseMetricsYaml(customMetricsYaml);
      metricsDef.push(...customMetrics);
    }
    let content = (await collectMetrics({
      url: prometheusUrl,
      start: start.getTime() / 1000,
      end: finish.getTime() / 1000,
      metrics: metricsDef,
      timeout: 30000
    })).map((m) => JSON.stringify(m)).join(`
`);
    fs2.writeFileSync(metricsPath, content, { encoding: "utf-8" });
  }
  import_core3.info("Stopping YDB services..."), await stopCompose(cwd);
  {
    import_core3.info("Uploading artifacts...");
    let artifacts = [
      { name: `${workload}-pull.txt`, path: pullPath },
      { name: `${workload}-logs.txt`, path: logsPath },
      { name: `${workload}-events.jsonl`, path: eventsPath },
      { name: `${workload}-metrics.jsonl`, path: metricsPath }
    ];
    await uploadArtifacts(workload, artifacts, cwd);
  }
  import_core3.info(`YDB SLO Test duration: ${(duration / 1000).toFixed(1)}s`);
}
post();

//# debugId=DBEB6D7B17D346DD64756E2164756E21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vaW5pdC9wb3N0LnRzIiwgIi4uL2luaXQvbGliL2FydGlmYWN0cy50cyIsICIuLi9pbml0L2xpYi9kb2NrZXIudHMiLCAiLi4vaW5pdC9saWIvbWV0cmljcy50cyIsICIuLi9pbml0L2xpYi9wcm9tZXRoZXVzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWwogICAgImltcG9ydCAqIGFzIGZzIGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICdub2RlOnVybCdcblxuaW1wb3J0IHsgZGVidWcsIGdldElucHV0LCBnZXRTdGF0ZSwgaW5mbywgd2FybmluZyB9IGZyb20gJ0BhY3Rpb25zL2NvcmUnXG5cbmltcG9ydCB7IHVwbG9hZEFydGlmYWN0cywgdHlwZSBBcnRpZmFjdEZpbGUgfSBmcm9tICcuL2xpYi9hcnRpZmFjdHMuanMnXG5pbXBvcnQgeyBjb2xsZWN0Q29tcG9zZUxvZ3MsIGNvbGxlY3REb2NrZXJFdmVudHMsIGdldENvbnRhaW5lcklwLCBzdG9wQ29tcG9zZSB9IGZyb20gJy4vbGliL2RvY2tlci5qcydcbmltcG9ydCB7IGNvbGxlY3RNZXRyaWNzLCBwYXJzZU1ldHJpY3NZYW1sLCB0eXBlIE1ldHJpY0RlZmluaXRpb24gfSBmcm9tICcuL2xpYi9tZXRyaWNzLmpzJ1xuXG5hc3luYyBmdW5jdGlvbiBwb3N0KCkge1xuXHRsZXQgY3dkID0gZ2V0U3RhdGUoJ2N3ZCcpXG5cdGxldCB3b3JrbG9hZCA9IGdldFN0YXRlKCd3b3JrbG9hZCcpXG5cblx0bGV0IHN0YXJ0ID0gbmV3IERhdGUoZ2V0U3RhdGUoJ3N0YXJ0JykpXG5cdGxldCBmaW5pc2ggPSBuZXcgRGF0ZSgpXG5cdGxldCBkdXJhdGlvbiA9IGZpbmlzaC5nZXRUaW1lKCkgLSBzdGFydC5nZXRUaW1lKClcblxuXHRsZXQgcHVsbFBhdGggPSBnZXRTdGF0ZSgncHVsbF9pbmZvX3BhdGgnKVxuXHRsZXQgbG9nc1BhdGggPSBwYXRoLmpvaW4oY3dkLCBgJHt3b3JrbG9hZH0tbG9ncy50eHRgKVxuXHRsZXQgZXZlbnRzUGF0aCA9IHBhdGguam9pbihjd2QsIGAke3dvcmtsb2FkfS1ldmVudHMuanNvbmxgKVxuXHRsZXQgbWV0cmljc1BhdGggPSBwYXRoLmpvaW4oY3dkLCBgJHt3b3JrbG9hZH0tbWV0cmljcy5qc29ubGApXG5cblx0bGV0IHByb21ldGhldXNJcCA9IGF3YWl0IGdldENvbnRhaW5lcklwKCdwcm9tZXRoZXVzJywgY3dkKVxuXHRsZXQgcHJvbWV0aGV1c1VybCA9IHByb21ldGhldXNJcCA/IGBodHRwOi8vJHtwcm9tZXRoZXVzSXB9OjkwOTBgIDogJ2h0dHA6Ly9sb2NhbGhvc3Q6OTA5MCdcblx0ZGVidWcoYFByb21ldGhldXMgVVJMOiAke3Byb21ldGhldXNVcmx9YClcblxuXHRsZXQgYWN0aW9uUm9vdCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpKSwgJy4uLy4uLycpXG5cdGxldCBkZWZhdWx0TWV0cmljc1BhdGggPSBwYXRoLmpvaW4oYWN0aW9uUm9vdCwgJ2RlcGxveScsICdtZXRyaWNzLnlhbWwnKVxuXG5cdGxldCBtZXRyaWNzWWFtbCA9IGZzLnJlYWRGaWxlU3luYyhkZWZhdWx0TWV0cmljc1BhdGgsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSlcblx0bGV0IGN1c3RvbU1ldHJpY3NZYW1sID0gZ2V0SW5wdXQoJ21ldHJpY3NfeWFtbCcpXG5cblx0aWYgKGdldElucHV0KCdtZXRyaWNzX3lhbWxfcGF0aCcpKSB7XG5cdFx0bGV0IGN1c3RvbU1ldHJpY3NQYXRoID0gZ2V0SW5wdXQoJ21ldHJpY3NfeWFtbF9wYXRoJylcblx0XHRpZiAoIWZzLmV4aXN0c1N5bmMoY3VzdG9tTWV0cmljc1BhdGgpKSB7XG5cdFx0XHR3YXJuaW5nKGBDdXN0b20gbWV0cmljcyBmaWxlIG5vdCBmb3VuZDogJHtjdXN0b21NZXRyaWNzUGF0aH1gKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXN0b21NZXRyaWNzWWFtbCA9IGZzLnJlYWRGaWxlU3luYyhjdXN0b21NZXRyaWNzUGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KVxuXHRcdH1cblx0fVxuXG5cdHtcblx0XHRpbmZvKCdDb2xsZWN0aW5nIGxvZ3MuLi4nKVxuXHRcdGxldCBsb2dzID0gYXdhaXQgY29sbGVjdENvbXBvc2VMb2dzKGN3ZClcblxuXHRcdGZzLndyaXRlRmlsZVN5bmMobG9nc1BhdGgsIGxvZ3MsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSlcblx0fVxuXG5cdHtcblx0XHRpbmZvKCdDb2xsZWN0aW5nIGV2ZW50cy4uLicpXG5cdFx0bGV0IGV2ZW50cyA9IGF3YWl0IGNvbGxlY3REb2NrZXJFdmVudHMoe1xuXHRcdFx0Y3dkLFxuXHRcdFx0c2luY2U6IHN0YXJ0LFxuXHRcdFx0dW50aWw6IGZpbmlzaCxcblx0XHR9KVxuXG5cdFx0bGV0IGNvbnRlbnQgPSBldmVudHMubWFwKChlKSA9PiBKU09OLnN0cmluZ2lmeShlKSkuam9pbignXFxuJylcblx0XHRmcy53cml0ZUZpbGVTeW5jKGV2ZW50c1BhdGgsIGNvbnRlbnQsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSlcblx0fVxuXG5cdHtcblx0XHRpbmZvKCdDb2xsZWN0aW5nIG1ldHJpY3MuLi4nKVxuXG5cdFx0bGV0IG1ldHJpY3NEZWY6IE1ldHJpY0RlZmluaXRpb25bXSA9IFtdXG5cblx0XHRpZiAobWV0cmljc1lhbWwpIHtcblx0XHRcdGxldCBkZWZhdWx0TWV0cmljcyA9IGF3YWl0IHBhcnNlTWV0cmljc1lhbWwobWV0cmljc1lhbWwpXG5cdFx0XHRtZXRyaWNzRGVmLnB1c2goLi4uZGVmYXVsdE1ldHJpY3MpXG5cdFx0fVxuXG5cdFx0aWYgKGN1c3RvbU1ldHJpY3NZYW1sKSB7XG5cdFx0XHRsZXQgY3VzdG9tTWV0cmljcyA9IGF3YWl0IHBhcnNlTWV0cmljc1lhbWwoY3VzdG9tTWV0cmljc1lhbWwpXG5cdFx0XHRtZXRyaWNzRGVmLnB1c2goLi4uY3VzdG9tTWV0cmljcylcblx0XHR9XG5cblx0XHRsZXQgbWV0cmljcyA9IGF3YWl0IGNvbGxlY3RNZXRyaWNzKHtcblx0XHRcdHVybDogcHJvbWV0aGV1c1VybCxcblx0XHRcdHN0YXJ0OiBzdGFydC5nZXRUaW1lKCkgLyAxMDAwLFxuXHRcdFx0ZW5kOiBmaW5pc2guZ2V0VGltZSgpIC8gMTAwMCxcblx0XHRcdG1ldHJpY3M6IG1ldHJpY3NEZWYsXG5cdFx0XHR0aW1lb3V0OiAzMDAwMCxcblx0XHR9KVxuXG5cdFx0bGV0IGNvbnRlbnQgPSBtZXRyaWNzLm1hcCgobSkgPT4gSlNPTi5zdHJpbmdpZnkobSkpLmpvaW4oJ1xcbicpXG5cdFx0ZnMud3JpdGVGaWxlU3luYyhtZXRyaWNzUGF0aCwgY29udGVudCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KVxuXHR9XG5cblx0e1xuXHRcdGluZm8oJ1N0b3BwaW5nIFlEQiBzZXJ2aWNlcy4uLicpXG5cdFx0YXdhaXQgc3RvcENvbXBvc2UoY3dkKVxuXHR9XG5cblx0e1xuXHRcdGluZm8oJ1VwbG9hZGluZyBhcnRpZmFjdHMuLi4nKVxuXG5cdFx0bGV0IGFydGlmYWN0czogQXJ0aWZhY3RGaWxlW10gPSBbXG5cdFx0XHR7IG5hbWU6IGAke3dvcmtsb2FkfS1wdWxsLnR4dGAsIHBhdGg6IHB1bGxQYXRoIH0sXG5cdFx0XHR7IG5hbWU6IGAke3dvcmtsb2FkfS1sb2dzLnR4dGAsIHBhdGg6IGxvZ3NQYXRoIH0sXG5cdFx0XHR7IG5hbWU6IGAke3dvcmtsb2FkfS1ldmVudHMuanNvbmxgLCBwYXRoOiBldmVudHNQYXRoIH0sXG5cdFx0XHR7IG5hbWU6IGAke3dvcmtsb2FkfS1tZXRyaWNzLmpzb25sYCwgcGF0aDogbWV0cmljc1BhdGggfSxcblx0XHRdXG5cblx0XHRhd2FpdCB1cGxvYWRBcnRpZmFjdHMod29ya2xvYWQsIGFydGlmYWN0cywgY3dkKVxuXHR9XG5cblx0aW5mbyhgWURCIFNMTyBUZXN0IGR1cmF0aW9uOiAkeyhkdXJhdGlvbiAvIDEwMDApLnRvRml4ZWQoMSl9c2ApXG59XG5cbnBvc3QoKVxuIiwKICAgICJpbXBvcnQgKiBhcyBmcyBmcm9tICdub2RlOmZzJ1xuXG5pbXBvcnQgeyBEZWZhdWx0QXJ0aWZhY3RDbGllbnQgfSBmcm9tICdAYWN0aW9ucy9hcnRpZmFjdCdcbmltcG9ydCB7IGluZm8sIHdhcm5pbmcgfSBmcm9tICdAYWN0aW9ucy9jb3JlJ1xuXG5leHBvcnQgaW50ZXJmYWNlIEFydGlmYWN0RmlsZSB7XG5cdG5hbWU6IHN0cmluZ1xuXHRwYXRoOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBVcGxvYWRzIGFydGlmYWN0cyB0byBHaXRIdWIgQWN0aW9ucyBhcyBhIHNpbmdsZSBidW5kbGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZEFydGlmYWN0cyhuYW1lOiBzdHJpbmcsIGFydGlmYWN0czogQXJ0aWZhY3RGaWxlW10sIGN3ZD86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuXHRsZXQgYXJ0aWZhY3RDbGllbnQgPSBuZXcgRGVmYXVsdEFydGlmYWN0Q2xpZW50KClcblx0bGV0IHJvb3REaXJlY3RvcnkgPSBjd2QgfHwgcHJvY2Vzcy5jd2QoKVxuXG5cdGxldCBmaWxlczogc3RyaW5nW10gPSBbXVxuXG5cdGZvciAobGV0IGFydGlmYWN0IG9mIGFydGlmYWN0cykge1xuXHRcdGlmICghZnMuZXhpc3RzU3luYyhhcnRpZmFjdC5wYXRoKSkge1xuXHRcdFx0d2FybmluZyhgQXJ0aWZhY3Qgc291cmNlIG1pc3Npbmc6ICR7YXJ0aWZhY3QucGF0aH1gKVxuXHRcdFx0Y29udGludWVcblx0XHR9XG5cdFx0ZmlsZXMucHVzaChhcnRpZmFjdC5wYXRoKVxuXHR9XG5cblx0aWYgKGZpbGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdHdhcm5pbmcoJ05vIGFydGlmYWN0cyB0byB1cGxvYWQnKVxuXHRcdHJldHVyblxuXHR9XG5cblx0dHJ5IHtcblx0XHQvLyBLZWVwIGFydGlmYWN0cyBmb3IgMSBkYXkgb25seSB0byBzYXZlIHN0b3JhZ2Ugc3BhY2Vcblx0XHRsZXQgeyBpZCB9ID0gYXdhaXQgYXJ0aWZhY3RDbGllbnQudXBsb2FkQXJ0aWZhY3QobmFtZSwgZmlsZXMsIHJvb3REaXJlY3RvcnksIHtcblx0XHRcdHJldGVudGlvbkRheXM6IDEsXG5cdFx0fSlcblxuXHRcdGluZm8oYFVwbG9hZGVkICR7ZmlsZXMubGVuZ3RofSBmaWxlKHMpIGFzIGFydGlmYWN0ICR7bmFtZX0gKGlkOiAke2lkfSlgKVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHdhcm5pbmcoYEZhaWxlZCB0byB1cGxvYWQgYXJ0aWZhY3RzOiAke1N0cmluZyhlcnJvcil9YClcblx0fVxufVxuIiwKICAgICJpbXBvcnQgeyB3YXJuaW5nIH0gZnJvbSAnQGFjdGlvbnMvY29yZSdcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICdAYWN0aW9ucy9leGVjJ1xuXG5leHBvcnQgaW50ZXJmYWNlIERvY2tlckV2ZW50IHtcblx0c3RhdHVzOiBzdHJpbmdcblx0aWQ6IHN0cmluZ1xuXHRmcm9tOiBzdHJpbmdcblx0VHlwZTogc3RyaW5nXG5cdEFjdGlvbjogc3RyaW5nXG5cdEFjdG9yOiB7XG5cdFx0SUQ6IHN0cmluZ1xuXHRcdEF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblx0fVxuXHRzY29wZTogc3RyaW5nXG5cdHRpbWU6IG51bWJlclxuXHR0aW1lTmFubzogbnVtYmVyXG59XG5cbi8qKlxuICogR2V0cyBJUCBhZGRyZXNzIG9mIGEgRG9ja2VyIGNvbnRhaW5lclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29udGFpbmVySXAoY29udGFpbmVyTmFtZTogc3RyaW5nLCBjd2Q6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuXHR0cnkge1xuXHRcdGxldCBjaHVua3M6IHN0cmluZ1tdID0gW11cblxuXHRcdGF3YWl0IGV4ZWMoXG5cdFx0XHQnZG9ja2VyJyxcblx0XHRcdFsnaW5zcGVjdCcsICctZicsICd7e3JhbmdlIC5OZXR3b3JrU2V0dGluZ3MuTmV0d29ya3N9fXt7LklQQWRkcmVzc319e3tlbmR9fScsIGNvbnRhaW5lck5hbWVdLFxuXHRcdFx0e1xuXHRcdFx0XHRjd2QsXG5cdFx0XHRcdHNpbGVudDogdHJ1ZSxcblx0XHRcdFx0bGlzdGVuZXJzOiB7XG5cdFx0XHRcdFx0c3Rkb3V0OiAoZGF0YSkgPT4gY2h1bmtzLnB1c2goZGF0YS50b1N0cmluZygpKSxcblx0XHRcdFx0fSxcblx0XHRcdH1cblx0XHQpXG5cblx0XHRsZXQgaXAgPSBjaHVua3Muam9pbignJykudHJpbSgpXG5cdFx0cmV0dXJuIGlwIHx8IG51bGxcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHR3YXJuaW5nKGBGYWlsZWQgdG8gZ2V0IGNvbnRhaW5lciBJUCBmb3IgJHtjb250YWluZXJOYW1lfTogJHtTdHJpbmcoZXJyb3IpfWApXG5cdFx0cmV0dXJuIG51bGxcblx0fVxufVxuXG4vKipcbiAqIENvbGxlY3RzIGxvZ3MgZnJvbSBEb2NrZXIgQ29tcG9zZSBzZXJ2aWNlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29sbGVjdENvbXBvc2VMb2dzKGN3ZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcblx0dHJ5IHtcblx0XHRsZXQgY2h1bmtzOiBzdHJpbmdbXSA9IFtdXG5cblx0XHRhd2FpdCBleGVjKGBkb2NrZXJgLCBbYGNvbXBvc2VgLCBgLWZgLCBgY29tcG9zZS55bWxgLCBgbG9nc2AsIGAtLW5vLWNvbG9yYF0sIHtcblx0XHRcdGN3ZCxcblx0XHRcdHNpbGVudDogdHJ1ZSxcblx0XHRcdGxpc3RlbmVyczoge1xuXHRcdFx0XHRzdGRvdXQ6IChkYXRhKSA9PiBjaHVua3MucHVzaChkYXRhLnRvU3RyaW5nKCkpLFxuXHRcdFx0XHRzdGRlcnI6IChkYXRhKSA9PiBjaHVua3MucHVzaChkYXRhLnRvU3RyaW5nKCkpLFxuXHRcdFx0fSxcblx0XHR9KVxuXG5cdFx0cmV0dXJuIGNodW5rcy5qb2luKCcnKVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHdhcm5pbmcoYEZhaWxlZCB0byBjb2xsZWN0IGRvY2tlciBjb21wb3NlIGxvZ3M6ICR7U3RyaW5nKGVycm9yKX1gKVxuXHRcdHJldHVybiAnJ1xuXHR9XG59XG5cbi8qKlxuICogQ29sbGVjdHMgRG9ja2VyIGV2ZW50cyBmb3IgWURCIGRhdGFiYXNlIG5vZGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb2xsZWN0RG9ja2VyRXZlbnRzKG9wdGlvbnM6IHsgY3dkOiBzdHJpbmc7IHNpbmNlOiBEYXRlOyB1bnRpbDogRGF0ZSB9KTogUHJvbWlzZTxEb2NrZXJFdmVudFtdPiB7XG5cdGxldCBldmVudHM6IERvY2tlckV2ZW50W10gPSBbXVxuXG5cdHRyeSB7XG5cdFx0bGV0IGNodW5rczogc3RyaW5nW10gPSBbXVxuXG5cdFx0YXdhaXQgZXhlYyhcblx0XHRcdGBkb2NrZXJgLFxuXHRcdFx0W1xuXHRcdFx0XHRgZXZlbnRzYCxcblx0XHRcdFx0YC0tZmlsdGVyYCxcblx0XHRcdFx0YGxhYmVsPXlkYi5ub2RlLnR5cGU9ZGF0YWJhc2VgLFxuXHRcdFx0XHRgLS1maWx0ZXJgLFxuXHRcdFx0XHRgZXZlbnQ9c3RvcGAsXG5cdFx0XHRcdGAtLWZpbHRlcmAsXG5cdFx0XHRcdGBldmVudD1zdGFydGAsXG5cdFx0XHRcdGAtLWZpbHRlcmAsXG5cdFx0XHRcdGBldmVudD1raWxsYCxcblx0XHRcdFx0YC0tZmlsdGVyYCxcblx0XHRcdFx0YGV2ZW50PXJlc3RhcnRgLFxuXHRcdFx0XHRgLS1zaW5jZWAsXG5cdFx0XHRcdG9wdGlvbnMuc2luY2UudG9JU09TdHJpbmcoKSxcblx0XHRcdFx0YC0tdW50aWxgLFxuXHRcdFx0XHRvcHRpb25zLnVudGlsLnRvSVNPU3RyaW5nKCksXG5cdFx0XHRcdGAtLWZvcm1hdGAsXG5cdFx0XHRcdGB7e2pzb24gLn19YCxcblx0XHRcdF0sXG5cdFx0XHR7XG5cdFx0XHRcdGN3ZDogb3B0aW9ucy5jd2QsXG5cdFx0XHRcdHNpbGVudDogdHJ1ZSxcblx0XHRcdFx0bGlzdGVuZXJzOiB7XG5cdFx0XHRcdFx0c3Rkb3V0OiAoZGF0YSkgPT4gY2h1bmtzLnB1c2goZGF0YS50b1N0cmluZygpKSxcblx0XHRcdFx0fSxcblx0XHRcdH1cblx0XHQpXG5cblx0XHRsZXQgbGluZXMgPSBjaHVua3Muam9pbignJykuc3BsaXQoJ1xcbicpLmZpbHRlcihCb29sZWFuKVxuXHRcdGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRcdGV2ZW50cy5wdXNoKEpTT04ucGFyc2UobGluZSkgYXMgRG9ja2VyRXZlbnQpXG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHdhcm5pbmcoYEZhaWxlZCB0byBjb2xsZWN0IERvY2tlciBldmVudHM6ICR7U3RyaW5nKGVycm9yKX1gKVxuXHR9XG5cblx0cmV0dXJuIGV2ZW50c1xufVxuXG4vKipcbiAqIFN0b3BzIERvY2tlciBDb21wb3NlIHByb2plY3RcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0b3BDb21wb3NlKGN3ZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdGF3YWl0IGV4ZWMoYGRvY2tlcmAsIFtgY29tcG9zZWAsIGAtZmAsIGBjb21wb3NlLnltbGAsIGBkb3duYF0sIHsgY3dkIH0pXG59XG4iLAogICAgImltcG9ydCB7IGV4ZWMgfSBmcm9tICdAYWN0aW9ucy9leGVjJ1xuXG5pbXBvcnQgeyBxdWVyeUluc3RhbnQsIHF1ZXJ5UmFuZ2UsIHR5cGUgUHJvbWV0aGV1c0luc3RhbnRWYWx1ZSwgdHlwZSBQcm9tZXRoZXVzUmFuZ2VWYWx1ZSB9IGZyb20gJy4vcHJvbWV0aGV1cy5qcydcblxuZXhwb3J0IGludGVyZmFjZSBNZXRyaWNEZWZpbml0aW9uIHtcblx0bmFtZTogc3RyaW5nXG5cdHF1ZXJ5OiBzdHJpbmdcblx0dHlwZT86ICdyYW5nZScgfCAnaW5zdGFudCdcblx0c3RlcD86IHN0cmluZ1xuXHR0aW1lPzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGVjdGVkTWV0cmljIHtcblx0bmFtZTogc3RyaW5nXG5cdHF1ZXJ5OiBzdHJpbmdcblx0dHlwZTogJ3JhbmdlJyB8ICdpbnN0YW50J1xuXHRkYXRhOiBQcm9tZXRoZXVzUmFuZ2VWYWx1ZVtdIHwgUHJvbWV0aGV1c0luc3RhbnRWYWx1ZVtdXG59XG5cbi8qKlxuICogU3VwcG9ydHMgdHdvIFlBTUwgZm9ybWF0cyBmb3IgZmxleGliaWxpdHk6XG4gKiAtIEFycmF5IGF0IHJvb3Q6IFt7IG5hbWU6IC4uLiwgcXVlcnk6IC4uLiB9XVxuICogLSBPYmplY3Qgd2l0aCBtZXRyaWNzIGZpZWxkOiB7IG1ldHJpY3M6IFt7IG5hbWU6IC4uLiwgcXVlcnk6IC4uLiB9XSB9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZU1ldHJpY3NZYW1sKHlhbWxDb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPE1ldHJpY0RlZmluaXRpb25bXT4ge1xuXHRpZiAoIXlhbWxDb250ZW50IHx8IHlhbWxDb250ZW50LnRyaW0oKSA9PT0gJycpIHtcblx0XHRyZXR1cm4gW11cblx0fVxuXG5cdHRyeSB7XG5cdFx0bGV0IGNodW5rczogc3RyaW5nW10gPSBbXVxuXG5cdFx0YXdhaXQgZXhlYygneXEnLCBbJy1vPWpzb24nLCAnLiddLCB7XG5cdFx0XHRpbnB1dDogQnVmZmVyLmZyb20oeWFtbENvbnRlbnQsICd1dGYtOCcpLFxuXHRcdFx0c2lsZW50OiB0cnVlLFxuXHRcdFx0bGlzdGVuZXJzOiB7XG5cdFx0XHRcdHN0ZG91dDogKGRhdGEpID0+IGNodW5rcy5wdXNoKGRhdGEudG9TdHJpbmcoKSksXG5cdFx0XHR9LFxuXHRcdH0pXG5cblx0XHRsZXQganNvbiA9IGNodW5rcy5qb2luKCcnKVxuXHRcdGxldCBwYXJzZWQgPSBKU09OLnBhcnNlKGpzb24pXG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShwYXJzZWQpKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VkXG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtdXG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgbWV0cmljcyBZQU1MOiAke1N0cmluZyhlcnJvcil9YClcblx0fVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgb3B0aW1hbCBzdGVwIHRvIGdldCB+MjAwIGRhdGEgcG9pbnRzIHJlZ2FyZGxlc3Mgb2YgdGVzdCBkdXJhdGlvbi5cbiAqIFRoaXMgcHJvdmlkZXMgZ29vZCBjaGFydCByZXNvbHV0aW9uIHdpdGhvdXQgb3ZlcmxvYWRpbmcgUHJvbWV0aGV1cy5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlT3B0aW1hbFN0ZXAoZHVyYXRpb25TZWNvbmRzOiBudW1iZXIpOiBzdHJpbmcge1xuXHRsZXQgdGFyZ2V0UG9pbnRzID0gMjAwXG5cdGxldCBzdGVwU2Vjb25kcyA9IE1hdGguY2VpbChkdXJhdGlvblNlY29uZHMgLyB0YXJnZXRQb2ludHMpXG5cblx0c3RlcFNlY29uZHMgPSBNYXRoLm1heCg1LCBNYXRoLm1pbig2MCwgc3RlcFNlY29uZHMpKVxuXG5cdC8vIFJvdW5kIHRvIGNvbW1vbiBpbnRlcnZhbHMgZm9yIGJldHRlciBhbGlnbm1lbnQgd2l0aCBzY3JhcGUgaW50ZXJ2YWxzXG5cdGxldCBuaWNlU3RlcHMgPSBbNSwgMTAsIDE1LCAzMCwgNjBdXG5cdGZvciAobGV0IG5pY2VTdGVwIG9mIG5pY2VTdGVwcykge1xuXHRcdGlmIChzdGVwU2Vjb25kcyA8PSBuaWNlU3RlcCkge1xuXHRcdFx0cmV0dXJuIGAke25pY2VTdGVwfXNgXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuICc2MHMnXG59XG5cbi8qKlxuICogQ29sbGVjdHMgbWV0cmljcyBmcm9tIFByb21ldGhldXMgdXNpbmcgcHJvdmlkZWQgbWV0cmljIGRlZmluaXRpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb2xsZWN0TWV0cmljcyhvcHRpb25zOiB7XG5cdHVybDogc3RyaW5nXG5cdHN0YXJ0OiBudW1iZXJcblx0ZW5kOiBudW1iZXJcblx0bWV0cmljczogTWV0cmljRGVmaW5pdGlvbltdXG5cdHRpbWVvdXQ6IG51bWJlclxufSk6IFByb21pc2U8Q29sbGVjdGVkTWV0cmljW10+IHtcblx0bGV0IHJlc3VsdHM6IENvbGxlY3RlZE1ldHJpY1tdID0gW11cblxuXHRsZXQgZHVyYXRpb25TZWNvbmRzID0gb3B0aW9ucy5lbmQgLSBvcHRpb25zLnN0YXJ0XG5cdGxldCBkZWZhdWx0U3RlcCA9IGNhbGN1bGF0ZU9wdGltYWxTdGVwKGR1cmF0aW9uU2Vjb25kcylcblxuXHRmb3IgKGxldCBtZXRyaWMgb2Ygb3B0aW9ucy5tZXRyaWNzKSB7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCB0eXBlID0gbWV0cmljLnR5cGUgfHwgJ3JhbmdlJ1xuXG5cdFx0XHRpZiAodHlwZSA9PT0gJ2luc3RhbnQnKSB7XG5cdFx0XHRcdGxldCByZXNwb25zZSA9IGF3YWl0IHF1ZXJ5SW5zdGFudCh7XG5cdFx0XHRcdFx0dXJsOiBvcHRpb25zLnVybCxcblx0XHRcdFx0XHRxdWVyeTogbWV0cmljLnF1ZXJ5LFxuXHRcdFx0XHRcdHRpbWU6IG1ldHJpYy50aW1lIHx8IG9wdGlvbnMuZW5kLFxuXHRcdFx0XHRcdHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCxcblx0XHRcdFx0fSlcblxuXHRcdFx0XHRpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAnc3VjY2VzcycgJiYgcmVzcG9uc2UuZGF0YSkge1xuXHRcdFx0XHRcdHJlc3VsdHMucHVzaCh7XG5cdFx0XHRcdFx0XHRuYW1lOiBtZXRyaWMubmFtZSxcblx0XHRcdFx0XHRcdHF1ZXJ5OiBtZXRyaWMucXVlcnksXG5cdFx0XHRcdFx0XHR0eXBlOiAnaW5zdGFudCcsXG5cdFx0XHRcdFx0XHRkYXRhOiByZXNwb25zZS5kYXRhLnJlc3VsdCxcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgcmVzcG9uc2UgPSBhd2FpdCBxdWVyeVJhbmdlKHtcblx0XHRcdFx0XHR1cmw6IG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdHF1ZXJ5OiBtZXRyaWMucXVlcnksXG5cdFx0XHRcdFx0c3RhcnQ6IG9wdGlvbnMuc3RhcnQsXG5cdFx0XHRcdFx0ZW5kOiBvcHRpb25zLmVuZCxcblx0XHRcdFx0XHRzdGVwOiBtZXRyaWMuc3RlcCB8fCBkZWZhdWx0U3RlcCxcblx0XHRcdFx0XHR0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsXG5cdFx0XHRcdH0pXG5cblx0XHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnICYmIHJlc3BvbnNlLmRhdGEpIHtcblx0XHRcdFx0XHRyZXN1bHRzLnB1c2goe1xuXHRcdFx0XHRcdFx0bmFtZTogbWV0cmljLm5hbWUsXG5cdFx0XHRcdFx0XHRxdWVyeTogbWV0cmljLnF1ZXJ5LFxuXHRcdFx0XHRcdFx0dHlwZTogJ3JhbmdlJyxcblx0XHRcdFx0XHRcdGRhdGE6IHJlc3BvbnNlLmRhdGEucmVzdWx0LFxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGNhdGNoIHtcblx0XHRcdGNvbnRpbnVlXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHNcbn1cbiIsCiAgICAiZXhwb3J0IHR5cGUgUHJvbWV0aGV1c1ZhbHVlVHlwZSA9ICdtYXRyaXgnIHwgJ3ZlY3RvcicgfCAnc2NhbGFyJyB8ICdzdHJpbmcnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbWV0aGV1c01ldHJpYyB7XG5cdFtsYWJlbDogc3RyaW5nXTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbWV0aGV1c0luc3RhbnRWYWx1ZSB7XG5cdG1ldHJpYzogUHJvbWV0aGV1c01ldHJpY1xuXHR2YWx1ZTogW251bWJlciwgc3RyaW5nXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21ldGhldXNSYW5nZVZhbHVlIHtcblx0bWV0cmljOiBQcm9tZXRoZXVzTWV0cmljXG5cdHZhbHVlczogQXJyYXk8W251bWJlciwgc3RyaW5nXT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9tZXRoZXVzU2NhbGFyVmFsdWUge1xuXHR2YWx1ZTogW251bWJlciwgc3RyaW5nXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb21ldGhldXNSZXNwb25zZTxUID0gUHJvbWV0aGV1c0luc3RhbnRWYWx1ZSB8IFByb21ldGhldXNSYW5nZVZhbHVlPiB7XG5cdHN0YXR1czogJ3N1Y2Nlc3MnIHwgJ2Vycm9yJ1xuXHRkYXRhPzoge1xuXHRcdHJlc3VsdFR5cGU6IFByb21ldGhldXNWYWx1ZVR5cGVcblx0XHRyZXN1bHQ6IFRbXVxuXHR9XG5cdGVycm9yVHlwZT86IHN0cmluZ1xuXHRlcnJvcj86IHN0cmluZ1xuXHR3YXJuaW5ncz86IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbWV0aGV1c1F1ZXJ5T3B0aW9ucyB7XG5cdHVybD86IHN0cmluZ1xuXHR0aW1lb3V0PzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbWV0aGV1c0luc3RhbnRRdWVyeVBhcmFtcyBleHRlbmRzIFByb21ldGhldXNRdWVyeU9wdGlvbnMge1xuXHRxdWVyeTogc3RyaW5nXG5cdHRpbWU/OiBzdHJpbmcgfCBudW1iZXJcblx0cXVlcnlUaW1lb3V0Pzogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbWV0aGV1c1JhbmdlUXVlcnlQYXJhbXMgZXh0ZW5kcyBQcm9tZXRoZXVzUXVlcnlPcHRpb25zIHtcblx0cXVlcnk6IHN0cmluZ1xuXHRzdGFydDogc3RyaW5nIHwgbnVtYmVyXG5cdGVuZDogc3RyaW5nIHwgbnVtYmVyXG5cdHN0ZXA6IHN0cmluZ1xuXHRxdWVyeVRpbWVvdXQ/OiBzdHJpbmdcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBpbnN0YW50IFByb21RTCBxdWVyeSBhdCBhIHNwZWNpZmljIHBvaW50IGluIHRpbWVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW5zdGFudChcblx0cGFyYW1zOiBQcm9tZXRoZXVzSW5zdGFudFF1ZXJ5UGFyYW1zXG4pOiBQcm9taXNlPFByb21ldGhldXNSZXNwb25zZTxQcm9tZXRoZXVzSW5zdGFudFZhbHVlPj4ge1xuXHRsZXQgYmFzZVVybCA9IHBhcmFtcy51cmwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6OTA5MCdcblx0bGV0IHRpbWVvdXQgPSBwYXJhbXMudGltZW91dCB8fCAzMDAwMFxuXG5cdGxldCB1cmwgPSBuZXcgVVJMKCcvYXBpL3YxL3F1ZXJ5JywgYmFzZVVybClcblx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3F1ZXJ5JywgcGFyYW1zLnF1ZXJ5KVxuXG5cdGlmIChwYXJhbXMudGltZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3RpbWUnLCBwYXJhbXMudGltZS50b1N0cmluZygpKVxuXHR9XG5cblx0aWYgKHBhcmFtcy5xdWVyeVRpbWVvdXQpIHtcblx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldCgndGltZW91dCcsIHBhcmFtcy5xdWVyeVRpbWVvdXQpXG5cdH1cblxuXHRsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuXHRcdHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aW1lb3V0KSxcblx0fSlcblxuXHRsZXQgZGF0YSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIFByb21ldGhldXNSZXNwb25zZTxQcm9tZXRoZXVzSW5zdGFudFZhbHVlPlxuXG5cdGlmICghcmVzcG9uc2Uub2spIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFByb21ldGhldXMgcXVlcnkgZmFpbGVkOiAke2RhdGEuZXJyb3IgfHwgcmVzcG9uc2Uuc3RhdHVzVGV4dH1gKVxuXHR9XG5cblx0cmV0dXJuIGRhdGFcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBQcm9tUUwgcmFuZ2UgcXVlcnkgb3ZlciBhIHRpbWUgcGVyaW9kXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBxdWVyeVJhbmdlKFxuXHRwYXJhbXM6IFByb21ldGhldXNSYW5nZVF1ZXJ5UGFyYW1zXG4pOiBQcm9taXNlPFByb21ldGhldXNSZXNwb25zZTxQcm9tZXRoZXVzUmFuZ2VWYWx1ZT4+IHtcblx0bGV0IGJhc2VVcmwgPSBwYXJhbXMudXJsIHx8ICdodHRwOi8vbG9jYWxob3N0OjkwOTAnXG5cdGxldCB0aW1lb3V0ID0gcGFyYW1zLnRpbWVvdXQgfHwgMzAwMDBcblxuXHRsZXQgdXJsID0gbmV3IFVSTCgnL2FwaS92MS9xdWVyeV9yYW5nZScsIGJhc2VVcmwpXG5cdHVybC5zZWFyY2hQYXJhbXMuc2V0KCdxdWVyeScsIHBhcmFtcy5xdWVyeSlcblx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3N0YXJ0JywgcGFyYW1zLnN0YXJ0LnRvU3RyaW5nKCkpXG5cdHVybC5zZWFyY2hQYXJhbXMuc2V0KCdlbmQnLCBwYXJhbXMuZW5kLnRvU3RyaW5nKCkpXG5cdHVybC5zZWFyY2hQYXJhbXMuc2V0KCdzdGVwJywgcGFyYW1zLnN0ZXApXG5cblx0aWYgKHBhcmFtcy5xdWVyeVRpbWVvdXQpIHtcblx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldCgndGltZW91dCcsIHBhcmFtcy5xdWVyeVRpbWVvdXQpXG5cdH1cblxuXHRsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuXHRcdHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aW1lb3V0KSxcblx0fSlcblxuXHRsZXQgZGF0YSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIFByb21ldGhldXNSZXNwb25zZTxQcm9tZXRoZXVzUmFuZ2VWYWx1ZT5cblxuXHRpZiAoIXJlc3BvbnNlLm9rKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBQcm9tZXRoZXVzIHJhbmdlIHF1ZXJ5IGZhaWxlZDogJHtkYXRhLmVycm9yIHx8IHJlc3BvbnNlLnN0YXR1c1RleHR9YClcblx0fVxuXG5cdHJldHVybiBkYXRhXG59XG4iCiAgXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7QUFJQTtBQUpBO0FBQ0E7QUFDQTs7O0FDQUEsc0RBQ0E7QUFI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LE1BQ3pCLEtBQUssT0FBTyxRQUFRLElBQUk7QUFBQSxNQUN4QixTQUFTO0FBQUEsTUFDVCxTQUFTO0FBQUEsSUFDVixDQUFDLEdBRXFCLElBQUksQ0FBQyxNQUFNLEtBQUssVUFBVSxDQUFDLENBQUMsRUFBRSxLQUFLO0FBQUEsQ0FBSTtBQUFBLElBQzFELGtCQUFjLGFBQWEsU0FBUyxFQUFFLFVBQVUsUUFBUSxDQUFDO0FBQUEsRUFDN0Q7QUFBQSxFQUdDLGtCQUFLLDBCQUEwQixHQUMvQixNQUFNLFlBQVksR0FBRztBQUFBLEVBR3RCO0FBQUEsSUFDQyxrQkFBSyx3QkFBd0I7QUFBQSxJQUU3QixJQUFJLFlBQTRCO0FBQUEsTUFDL0IsRUFBRSxNQUFNLEdBQUcscUJBQXFCLE1BQU0sU0FBUztBQUFBLE1BQy9DLEVBQUUsTUFBTSxHQUFHLHFCQUFxQixNQUFNLFNBQVM7QUFBQSxNQUMvQyxFQUFFLE1BQU0sR0FBRyx5QkFBeUIsTUFBTSxXQUFXO0FBQUEsTUFDckQsRUFBRSxNQUFNLEdBQUcsMEJBQTBCLE1BQU0sWUFBWTtBQUFBLElBQ3hEO0FBQUEsSUFFQSxNQUFNLGdCQUFnQixVQUFVLFdBQVcsR0FBRztBQUFBLEVBQy9DO0FBQUEsRUFFQSxrQkFBSywyQkFBMkIsV0FBVyxNQUFNLFFBQVEsQ0FBQyxJQUFJO0FBQUE7QUFHL0QsS0FBSzsiLAogICJkZWJ1Z0lkIjogIkRCRUI2RDdCMTdEMzQ2REQ2NDc1NkUyMTY0NzU2RTIxIiwKICAibmFtZXMiOiBbXQp9
