import {
  queryRange
} from "./prometheus.js";
import {
  require_exec
} from "../../main-c7r720rd.js";
import {
  __toESM
} from "../../main-ynsbc1hx.js";

// init/lib/metrics.ts
var import_exec = __toESM(require_exec(), 1);
async function parseMetricsYaml(yamlContent) {
  if (!yamlContent || yamlContent.trim() === "")
    return [];
  try {
    let chunks = [];
    await import_exec.exec("yq", ["-o=json", "."], {
      input: Buffer.from(yamlContent, "utf-8"),
      silent: !0,
      listeners: {
        stdout: (data) => chunks.push(data.toString())
      }
    });
    let json = chunks.join(""), parsed = JSON.parse(json);
    if (Array.isArray(parsed))
      return parsed;
    return [];
  } catch (error) {
    throw Error(`Failed to parse metrics YAML: ${String(error)}`);
  }
}
function calculateOptimalStep(durationSeconds) {
  let stepSeconds = Math.ceil(durationSeconds / 200);
  stepSeconds = Math.max(5, Math.min(60, stepSeconds));
  let niceSteps = [5, 10, 15, 30, 60];
  for (let niceStep of niceSteps)
    if (stepSeconds <= niceStep)
      return `${niceStep}s`;
  return "60s";
}
async function collectMetrics(options) {
  let results = [], durationSeconds = options.end - options.start, defaultStep = calculateOptimalStep(durationSeconds);
  for (let metric of options.metrics)
    try {
      let response = await queryRange({
        url: options.url,
        query: metric.query,
        start: options.start,
        end: options.end,
        step: metric.step || defaultStep,
        timeout: options.timeout
      });
      if (response.status === "success" && response.data)
        results.push({
          name: metric.name,
          query: metric.query,
          data: response.data.result
        });
    } catch {
      continue;
    }
  return results;
}
export {
  parseMetricsYaml,
  collectMetrics
};

export { parseMetricsYaml, collectMetrics };

//# debugId=8DC7C87EF64B472964756E2164756E21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vaW5pdC9saWIvbWV0cmljcy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsKICAgICJpbXBvcnQgeyBleGVjIH0gZnJvbSAnQGFjdGlvbnMvZXhlYydcblxuaW1wb3J0IHsgcXVlcnlSYW5nZSwgdHlwZSBQcm9tZXRoZXVzUmFuZ2VWYWx1ZSB9IGZyb20gJy4vcHJvbWV0aGV1cy5qcydcblxuZXhwb3J0IGludGVyZmFjZSBNZXRyaWNEZWZpbml0aW9uIHtcblx0bmFtZTogc3RyaW5nXG5cdHF1ZXJ5OiBzdHJpbmdcblx0c3RlcD86IHN0cmluZ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbGxlY3RlZE1ldHJpYyB7XG5cdG5hbWU6IHN0cmluZ1xuXHRxdWVyeTogc3RyaW5nXG5cdGRhdGE6IFByb21ldGhldXNSYW5nZVZhbHVlW11cbn1cblxuLyoqXG4gKiBTdXBwb3J0cyB0d28gWUFNTCBmb3JtYXRzIGZvciBmbGV4aWJpbGl0eTpcbiAqIC0gQXJyYXkgYXQgcm9vdDogW3sgbmFtZTogLi4uLCBxdWVyeTogLi4uIH1dXG4gKiAtIE9iamVjdCB3aXRoIG1ldHJpY3MgZmllbGQ6IHsgbWV0cmljczogW3sgbmFtZTogLi4uLCBxdWVyeTogLi4uIH1dIH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlTWV0cmljc1lhbWwoeWFtbENvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8TWV0cmljRGVmaW5pdGlvbltdPiB7XG5cdGlmICgheWFtbENvbnRlbnQgfHwgeWFtbENvbnRlbnQudHJpbSgpID09PSAnJykge1xuXHRcdHJldHVybiBbXVxuXHR9XG5cblx0dHJ5IHtcblx0XHRsZXQgY2h1bmtzOiBzdHJpbmdbXSA9IFtdXG5cblx0XHRhd2FpdCBleGVjKCd5cScsIFsnLW89anNvbicsICcuJ10sIHtcblx0XHRcdGlucHV0OiBCdWZmZXIuZnJvbSh5YW1sQ29udGVudCwgJ3V0Zi04JyksXG5cdFx0XHRzaWxlbnQ6IHRydWUsXG5cdFx0XHRsaXN0ZW5lcnM6IHtcblx0XHRcdFx0c3Rkb3V0OiAoZGF0YSkgPT4gY2h1bmtzLnB1c2goZGF0YS50b1N0cmluZygpKSxcblx0XHRcdH0sXG5cdFx0fSlcblxuXHRcdGxldCBqc29uID0gY2h1bmtzLmpvaW4oJycpXG5cdFx0bGV0IHBhcnNlZCA9IEpTT04ucGFyc2UoanNvbilcblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcblx0XHRcdHJldHVybiBwYXJzZWRcblx0XHR9XG5cblx0XHRyZXR1cm4gW11cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBtZXRyaWNzIFlBTUw6ICR7U3RyaW5nKGVycm9yKX1gKVxuXHR9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyBvcHRpbWFsIHN0ZXAgdG8gZ2V0IH4yMDAgZGF0YSBwb2ludHMgcmVnYXJkbGVzcyBvZiB0ZXN0IGR1cmF0aW9uLlxuICogVGhpcyBwcm92aWRlcyBnb29kIGNoYXJ0IHJlc29sdXRpb24gd2l0aG91dCBvdmVybG9hZGluZyBQcm9tZXRoZXVzLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVPcHRpbWFsU3RlcChkdXJhdGlvblNlY29uZHM6IG51bWJlcik6IHN0cmluZyB7XG5cdGxldCB0YXJnZXRQb2ludHMgPSAyMDBcblx0bGV0IHN0ZXBTZWNvbmRzID0gTWF0aC5jZWlsKGR1cmF0aW9uU2Vjb25kcyAvIHRhcmdldFBvaW50cylcblxuXHRzdGVwU2Vjb25kcyA9IE1hdGgubWF4KDUsIE1hdGgubWluKDYwLCBzdGVwU2Vjb25kcykpXG5cblx0Ly8gUm91bmQgdG8gY29tbW9uIGludGVydmFscyBmb3IgYmV0dGVyIGFsaWdubWVudCB3aXRoIHNjcmFwZSBpbnRlcnZhbHNcblx0bGV0IG5pY2VTdGVwcyA9IFs1LCAxMCwgMTUsIDMwLCA2MF1cblx0Zm9yIChsZXQgbmljZVN0ZXAgb2YgbmljZVN0ZXBzKSB7XG5cdFx0aWYgKHN0ZXBTZWNvbmRzIDw9IG5pY2VTdGVwKSB7XG5cdFx0XHRyZXR1cm4gYCR7bmljZVN0ZXB9c2Bcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gJzYwcydcbn1cblxuLyoqXG4gKiBDb2xsZWN0cyBtZXRyaWNzIGZyb20gUHJvbWV0aGV1cyB1c2luZyBwcm92aWRlZCBtZXRyaWMgZGVmaW5pdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbGxlY3RNZXRyaWNzKG9wdGlvbnM6IHtcblx0dXJsOiBzdHJpbmdcblx0c3RhcnQ6IG51bWJlclxuXHRlbmQ6IG51bWJlclxuXHRtZXRyaWNzOiBNZXRyaWNEZWZpbml0aW9uW11cblx0dGltZW91dDogbnVtYmVyXG59KTogUHJvbWlzZTxDb2xsZWN0ZWRNZXRyaWNbXT4ge1xuXHRsZXQgcmVzdWx0czogQ29sbGVjdGVkTWV0cmljW10gPSBbXVxuXG5cdGxldCBkdXJhdGlvblNlY29uZHMgPSBvcHRpb25zLmVuZCAtIG9wdGlvbnMuc3RhcnRcblx0bGV0IGRlZmF1bHRTdGVwID0gY2FsY3VsYXRlT3B0aW1hbFN0ZXAoZHVyYXRpb25TZWNvbmRzKVxuXG5cdGZvciAobGV0IG1ldHJpYyBvZiBvcHRpb25zLm1ldHJpY3MpIHtcblx0XHR0cnkge1xuXHRcdFx0bGV0IHJlc3BvbnNlID0gYXdhaXQgcXVlcnlSYW5nZSh7XG5cdFx0XHRcdHVybDogb3B0aW9ucy51cmwsXG5cdFx0XHRcdHF1ZXJ5OiBtZXRyaWMucXVlcnksXG5cdFx0XHRcdHN0YXJ0OiBvcHRpb25zLnN0YXJ0LFxuXHRcdFx0XHRlbmQ6IG9wdGlvbnMuZW5kLFxuXHRcdFx0XHRzdGVwOiBtZXRyaWMuc3RlcCB8fCBkZWZhdWx0U3RlcCxcblx0XHRcdFx0dGltZW91dDogb3B0aW9ucy50aW1lb3V0LFxuXHRcdFx0fSlcblxuXHRcdFx0aWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnICYmIHJlc3BvbnNlLmRhdGEpIHtcblx0XHRcdFx0cmVzdWx0cy5wdXNoKHtcblx0XHRcdFx0XHRuYW1lOiBtZXRyaWMubmFtZSxcblx0XHRcdFx0XHRxdWVyeTogbWV0cmljLnF1ZXJ5LFxuXHRcdFx0XHRcdGRhdGE6IHJlc3BvbnNlLmRhdGEucmVzdWx0LFxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH0gY2F0Y2gge1xuXHRcdFx0Y29udGludWVcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0c1xufVxuIgogIF0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7QUFBQTtBQXFCQSxlQUFzQixnQkFBZ0IsQ0FBQyxhQUFrRDtBQUFBLEVBQ3hGLElBQUksQ0FBQyxlQUFlLFlBQVksS0FBSyxNQUFNO0FBQUEsSUFDMUMsT0FBTyxDQUFDO0FBQUEsRUFHVCxJQUFJO0FBQUEsSUFDSCxJQUFJLFNBQW1CLENBQUM7QUFBQSxJQUV4QixNQUFNLGlCQUFLLE1BQU0sQ0FBQyxXQUFXLEdBQUcsR0FBRztBQUFBLE1BQ2xDLE9BQU8sT0FBTyxLQUFLLGFBQWEsT0FBTztBQUFBLE1BQ3ZDLFFBQVE7QUFBQSxNQUNSLFdBQVc7QUFBQSxRQUNWLFFBQVEsQ0FBQyxTQUFTLE9BQU8sS0FBSyxLQUFLLFNBQVMsQ0FBQztBQUFBLE1BQzlDO0FBQUEsSUFDRCxDQUFDO0FBQUEsSUFFRCxJQUFJLE9BQU8sT0FBTyxLQUFLLEVBQUUsR0FDckIsU0FBUyxLQUFLLE1BQU0sSUFBSTtBQUFBLElBRTVCLElBQUksTUFBTSxRQUFRLE1BQU07QUFBQSxNQUN2QixPQUFPO0FBQUEsSUFHUixPQUFPLENBQUM7QUFBQSxJQUNQLE9BQU8sT0FBTztBQUFBLElBQ2YsTUFBVSxNQUFNLGlDQUFpQyxPQUFPLEtBQUssR0FBRztBQUFBO0FBQUE7QUFRbEUsU0FBUyxvQkFBb0IsQ0FBQyxpQkFBaUM7QUFBQSxFQUU5RCxJQUFJLGNBQWMsS0FBSyxLQUFLLGtCQURULEdBQ3VDO0FBQUEsRUFFMUQsY0FBYyxLQUFLLElBQUksR0FBRyxLQUFLLElBQUksSUFBSSxXQUFXLENBQUM7QUFBQSxFQUduRCxJQUFJLFlBQVksQ0FBQyxHQUFHLElBQUksSUFBSSxJQUFJLEVBQUU7QUFBQSxFQUNsQyxTQUFTLFlBQVk7QUFBQSxJQUNwQixJQUFJLGVBQWU7QUFBQSxNQUNsQixPQUFPLEdBQUc7QUFBQSxFQUlaLE9BQU87QUFBQTtBQU1SLGVBQXNCLGNBQWMsQ0FBQyxTQU1OO0FBQUEsRUFDOUIsSUFBSSxVQUE2QixDQUFDLEdBRTlCLGtCQUFrQixRQUFRLE1BQU0sUUFBUSxPQUN4QyxjQUFjLHFCQUFxQixlQUFlO0FBQUEsRUFFdEQsU0FBUyxVQUFVLFFBQVE7QUFBQSxJQUMxQixJQUFJO0FBQUEsTUFDSCxJQUFJLFdBQVcsTUFBTSxXQUFXO0FBQUEsUUFDL0IsS0FBSyxRQUFRO0FBQUEsUUFDYixPQUFPLE9BQU87QUFBQSxRQUNkLE9BQU8sUUFBUTtBQUFBLFFBQ2YsS0FBSyxRQUFRO0FBQUEsUUFDYixNQUFNLE9BQU8sUUFBUTtBQUFBLFFBQ3JCLFNBQVMsUUFBUTtBQUFBLE1BQ2xCLENBQUM7QUFBQSxNQUVELElBQUksU0FBUyxXQUFXLGFBQWEsU0FBUztBQUFBLFFBQzdDLFFBQVEsS0FBSztBQUFBLFVBQ1osTUFBTSxPQUFPO0FBQUEsVUFDYixPQUFPLE9BQU87QUFBQSxVQUNkLE1BQU0sU0FBUyxLQUFLO0FBQUEsUUFDckIsQ0FBQztBQUFBLE1BRUQsTUFBTTtBQUFBLE1BQ1A7QUFBQTtBQUFBLEVBSUYsT0FBTztBQUFBOyIsCiAgImRlYnVnSWQiOiAiOERDN0M4N0VGNjRCNDcyOTY0NzU2RTIxNjQ3NTZFMjEiLAogICJuYW1lcyI6IFtdCn0=
