import {
  getMetricValue
} from "./metrics.js";
import"../../main-ynsbc1hx.js";

// report/lib/analysis.ts
function inferMetricDirection(name) {
  let lowerName = name.toLowerCase();
  if (lowerName.includes("latency") || lowerName.includes("duration") || lowerName.includes("time") || lowerName.includes("delay") || lowerName.includes("error") || lowerName.includes("failure"))
    return "lower_is_better";
  if (lowerName.includes("availability") || lowerName.includes("throughput") || lowerName.includes("success") || lowerName.includes("qps") || lowerName.includes("rps") || lowerName.includes("ops"))
    return "higher_is_better";
  return "neutral";
}
function determineChangeDirection(currentValue, baseValue, metricDirection) {
  if (isNaN(currentValue) || isNaN(baseValue))
    return "unknown";
  if (Math.abs((currentValue - baseValue) / baseValue * 100) < 5)
    return "neutral";
  if (metricDirection === "lower_is_better")
    return currentValue < baseValue ? "better" : "worse";
  if (metricDirection === "higher_is_better")
    return currentValue > baseValue ? "better" : "worse";
  return "neutral";
}
function compareMetric(metric, aggregate = "avg") {
  let currentValue = getMetricValue(metric, "current", aggregate), baseValue = getMetricValue(metric, "base", aggregate), absolute = currentValue - baseValue, percent = isNaN(baseValue) || baseValue === 0 ? NaN : absolute / baseValue * 100, metricDirection = inferMetricDirection(metric.name), direction = determineChangeDirection(currentValue, baseValue, metricDirection);
  return {
    name: metric.name,
    type: metric.type,
    current: {
      value: currentValue,
      available: !isNaN(currentValue)
    },
    base: {
      value: baseValue,
      available: !isNaN(baseValue)
    },
    change: {
      absolute,
      percent,
      direction
    }
  };
}
function compareWorkloadMetrics(workload, metrics, aggregate = "avg") {
  let comparisons = [];
  for (let [name, metric] of metrics) {
    let comparison = compareMetric(metric, aggregate);
    comparisons.push(comparison);
  }
  let regressions = comparisons.filter((c) => c.change.direction === "worse").length, improvements = comparisons.filter((c) => c.change.direction === "better").length, stable = comparisons.filter((c) => c.change.direction === "neutral").length;
  return {
    workload,
    metrics: comparisons,
    summary: {
      total: comparisons.length,
      regressions,
      improvements,
      stable
    }
  };
}
function formatValue(value, metricName) {
  if (isNaN(value))
    return "N/A";
  let lowerName = metricName.toLowerCase();
  if (lowerName.includes("latency") || lowerName.includes("duration") || lowerName.endsWith("_ms"))
    return `${value.toFixed(2)}ms`;
  if (lowerName.includes("time") && lowerName.endsWith("_s"))
    return `${value.toFixed(2)}s`;
  if (lowerName.includes("availability") || lowerName.includes("percent") || lowerName.includes("rate"))
    return `${value.toFixed(2)}%`;
  if (lowerName.includes("throughput") || lowerName.includes("qps") || lowerName.includes("rps") || lowerName.includes("ops")) {
    if (value >= 1000)
      return `${(value / 1000).toFixed(2)}k/s`;
    return `${value.toFixed(0)}/s`;
  }
  return value.toFixed(2);
}
function formatChange(percent, direction) {
  if (isNaN(percent))
    return "N/A";
  let sign = percent >= 0 ? "+" : "", emoji = direction === "better" ? "\uD83D\uDFE2" : direction === "worse" ? "\uD83D\uDD34" : direction === "neutral" ? "⚪" : "❓";
  return `${sign}${percent.toFixed(1)}% ${emoji}`;
}
export {
  formatValue,
  formatChange,
  compareWorkloadMetrics,
  compareMetric
};

export { compareWorkloadMetrics, formatValue, formatChange };

//# debugId=2DF674FD84C0D4ED64756E2164756E21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vcmVwb3J0L2xpYi9hbmFseXNpcy50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsKICAgICIvKipcbiAqIE1ldHJpY3MgYW5hbHlzaXMgYW5kIGNvbXBhcmlzb25cbiAqL1xuXG5pbXBvcnQgeyBhZ2dyZWdhdGVWYWx1ZXMsIGdldE1ldHJpY1ZhbHVlLCBzZXBhcmF0ZUJ5UmVmLCB0eXBlIEFnZ3JlZ2F0ZUZ1bmN0aW9uLCB0eXBlIENvbGxlY3RlZE1ldHJpYywgdHlwZSBNZXRyaWNzTWFwIH0gZnJvbSAnLi9tZXRyaWNzLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY0NvbXBhcmlzb24ge1xuXHRuYW1lOiBzdHJpbmdcblx0dHlwZTogJ3JhbmdlJyB8ICdpbnN0YW50J1xuXHRjdXJyZW50OiB7XG5cdFx0dmFsdWU6IG51bWJlclxuXHRcdGF2YWlsYWJsZTogYm9vbGVhblxuXHR9XG5cdGJhc2U6IHtcblx0XHR2YWx1ZTogbnVtYmVyXG5cdFx0YXZhaWxhYmxlOiBib29sZWFuXG5cdH1cblx0Y2hhbmdlOiB7XG5cdFx0YWJzb2x1dGU6IG51bWJlclxuXHRcdHBlcmNlbnQ6IG51bWJlclxuXHRcdGRpcmVjdGlvbjogJ2JldHRlcicgfCAnd29yc2UnIHwgJ25ldXRyYWwnIHwgJ3Vua25vd24nXG5cdH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXb3JrbG9hZENvbXBhcmlzb24ge1xuXHR3b3JrbG9hZDogc3RyaW5nXG5cdG1ldHJpY3M6IE1ldHJpY0NvbXBhcmlzb25bXVxuXHRzdW1tYXJ5OiB7XG5cdFx0dG90YWw6IG51bWJlclxuXHRcdHJlZ3Jlc3Npb25zOiBudW1iZXJcblx0XHRpbXByb3ZlbWVudHM6IG51bWJlclxuXHRcdHN0YWJsZTogbnVtYmVyXG5cdH1cbn1cblxuLyoqXG4gKiBJbmZlciBtZXRyaWMgZGlyZWN0aW9uIGJhc2VkIG9uIG5hbWVcbiAqL1xuZnVuY3Rpb24gaW5mZXJNZXRyaWNEaXJlY3Rpb24obmFtZTogc3RyaW5nKTogJ2xvd2VyX2lzX2JldHRlcicgfCAnaGlnaGVyX2lzX2JldHRlcicgfCAnbmV1dHJhbCcge1xuXHRsZXQgbG93ZXJOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cblx0Ly8gTG93ZXIgaXMgYmV0dGVyXG5cdGlmIChcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ2xhdGVuY3knKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygnZHVyYXRpb24nKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygndGltZScpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdkZWxheScpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdlcnJvcicpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdmYWlsdXJlJylcblx0KSB7XG5cdFx0cmV0dXJuICdsb3dlcl9pc19iZXR0ZXInXG5cdH1cblxuXHQvLyBIaWdoZXIgaXMgYmV0dGVyXG5cdGlmIChcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ2F2YWlsYWJpbGl0eScpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCd0aHJvdWdocHV0JykgfHxcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ3N1Y2Nlc3MnKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygncXBzJykgfHxcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ3JwcycpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdvcHMnKVxuXHQpIHtcblx0XHRyZXR1cm4gJ2hpZ2hlcl9pc19iZXR0ZXInXG5cdH1cblxuXHRyZXR1cm4gJ25ldXRyYWwnXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGNoYW5nZSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hhbmdlRGlyZWN0aW9uKFxuXHRjdXJyZW50VmFsdWU6IG51bWJlcixcblx0YmFzZVZhbHVlOiBudW1iZXIsXG5cdG1ldHJpY0RpcmVjdGlvbjogJ2xvd2VyX2lzX2JldHRlcicgfCAnaGlnaGVyX2lzX2JldHRlcicgfCAnbmV1dHJhbCdcbik6ICdiZXR0ZXInIHwgJ3dvcnNlJyB8ICduZXV0cmFsJyB8ICd1bmtub3duJyB7XG5cdGlmIChpc05hTihjdXJyZW50VmFsdWUpIHx8IGlzTmFOKGJhc2VWYWx1ZSkpIHtcblx0XHRyZXR1cm4gJ3Vua25vd24nXG5cdH1cblxuXHRsZXQgY2hhbmdlUGVyY2VudCA9IE1hdGguYWJzKCgoY3VycmVudFZhbHVlIC0gYmFzZVZhbHVlKSAvIGJhc2VWYWx1ZSkgKiAxMDApXG5cblx0Ly8gQ29uc2lkZXIgPCA1JSBhcyBzdGFibGUvbmV1dHJhbFxuXHRpZiAoY2hhbmdlUGVyY2VudCA8IDUpIHtcblx0XHRyZXR1cm4gJ25ldXRyYWwnXG5cdH1cblxuXHRpZiAobWV0cmljRGlyZWN0aW9uID09PSAnbG93ZXJfaXNfYmV0dGVyJykge1xuXHRcdHJldHVybiBjdXJyZW50VmFsdWUgPCBiYXNlVmFsdWUgPyAnYmV0dGVyJyA6ICd3b3JzZSdcblx0fVxuXG5cdGlmIChtZXRyaWNEaXJlY3Rpb24gPT09ICdoaWdoZXJfaXNfYmV0dGVyJykge1xuXHRcdHJldHVybiBjdXJyZW50VmFsdWUgPiBiYXNlVmFsdWUgPyAnYmV0dGVyJyA6ICd3b3JzZSdcblx0fVxuXG5cdHJldHVybiAnbmV1dHJhbCdcbn1cblxuLyoqXG4gKiBDb21wYXJlIHNpbmdsZSBtZXRyaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVNZXRyaWMobWV0cmljOiBDb2xsZWN0ZWRNZXRyaWMsIGFnZ3JlZ2F0ZTogQWdncmVnYXRlRnVuY3Rpb24gPSAnYXZnJyk6IE1ldHJpY0NvbXBhcmlzb24ge1xuXHRsZXQgY3VycmVudFZhbHVlID0gZ2V0TWV0cmljVmFsdWUobWV0cmljLCAnY3VycmVudCcsIGFnZ3JlZ2F0ZSlcblx0bGV0IGJhc2VWYWx1ZSA9IGdldE1ldHJpY1ZhbHVlKG1ldHJpYywgJ2Jhc2UnLCBhZ2dyZWdhdGUpXG5cblx0bGV0IGFic29sdXRlID0gY3VycmVudFZhbHVlIC0gYmFzZVZhbHVlXG5cdGxldCBwZXJjZW50ID0gaXNOYU4oYmFzZVZhbHVlKSB8fCBiYXNlVmFsdWUgPT09IDAgPyBOYU4gOiAoYWJzb2x1dGUgLyBiYXNlVmFsdWUpICogMTAwXG5cblx0bGV0IG1ldHJpY0RpcmVjdGlvbiA9IGluZmVyTWV0cmljRGlyZWN0aW9uKG1ldHJpYy5uYW1lKVxuXHRsZXQgZGlyZWN0aW9uID0gZGV0ZXJtaW5lQ2hhbmdlRGlyZWN0aW9uKGN1cnJlbnRWYWx1ZSwgYmFzZVZhbHVlLCBtZXRyaWNEaXJlY3Rpb24pXG5cblx0cmV0dXJuIHtcblx0XHRuYW1lOiBtZXRyaWMubmFtZSxcblx0XHR0eXBlOiBtZXRyaWMudHlwZSxcblx0XHRjdXJyZW50OiB7XG5cdFx0XHR2YWx1ZTogY3VycmVudFZhbHVlLFxuXHRcdFx0YXZhaWxhYmxlOiAhaXNOYU4oY3VycmVudFZhbHVlKSxcblx0XHR9LFxuXHRcdGJhc2U6IHtcblx0XHRcdHZhbHVlOiBiYXNlVmFsdWUsXG5cdFx0XHRhdmFpbGFibGU6ICFpc05hTihiYXNlVmFsdWUpLFxuXHRcdH0sXG5cdFx0Y2hhbmdlOiB7XG5cdFx0XHRhYnNvbHV0ZSxcblx0XHRcdHBlcmNlbnQsXG5cdFx0XHRkaXJlY3Rpb24sXG5cdFx0fSxcblx0fVxufVxuXG4vKipcbiAqIENvbXBhcmUgYWxsIG1ldHJpY3MgaW4gYSB3b3JrbG9hZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVdvcmtsb2FkTWV0cmljcyh3b3JrbG9hZDogc3RyaW5nLCBtZXRyaWNzOiBNZXRyaWNzTWFwLCBhZ2dyZWdhdGU6IEFnZ3JlZ2F0ZUZ1bmN0aW9uID0gJ2F2ZycpOiBXb3JrbG9hZENvbXBhcmlzb24ge1xuXHRsZXQgY29tcGFyaXNvbnM6IE1ldHJpY0NvbXBhcmlzb25bXSA9IFtdXG5cblx0Zm9yIChsZXQgW25hbWUsIG1ldHJpY10gb2YgbWV0cmljcykge1xuXHRcdGxldCBjb21wYXJpc29uID0gY29tcGFyZU1ldHJpYyhtZXRyaWMsIGFnZ3JlZ2F0ZSlcblx0XHRjb21wYXJpc29ucy5wdXNoKGNvbXBhcmlzb24pXG5cdH1cblxuXHQvLyBDYWxjdWxhdGUgc3VtbWFyeVxuXHRsZXQgcmVncmVzc2lvbnMgPSBjb21wYXJpc29ucy5maWx0ZXIoKGMpID0+IGMuY2hhbmdlLmRpcmVjdGlvbiA9PT0gJ3dvcnNlJykubGVuZ3RoXG5cdGxldCBpbXByb3ZlbWVudHMgPSBjb21wYXJpc29ucy5maWx0ZXIoKGMpID0+IGMuY2hhbmdlLmRpcmVjdGlvbiA9PT0gJ2JldHRlcicpLmxlbmd0aFxuXHRsZXQgc3RhYmxlID0gY29tcGFyaXNvbnMuZmlsdGVyKChjKSA9PiBjLmNoYW5nZS5kaXJlY3Rpb24gPT09ICduZXV0cmFsJykubGVuZ3RoXG5cblx0cmV0dXJuIHtcblx0XHR3b3JrbG9hZCxcblx0XHRtZXRyaWNzOiBjb21wYXJpc29ucyxcblx0XHRzdW1tYXJ5OiB7XG5cdFx0XHR0b3RhbDogY29tcGFyaXNvbnMubGVuZ3RoLFxuXHRcdFx0cmVncmVzc2lvbnMsXG5cdFx0XHRpbXByb3ZlbWVudHMsXG5cdFx0XHRzdGFibGUsXG5cdFx0fSxcblx0fVxufVxuXG4vKipcbiAqIEZvcm1hdCB2YWx1ZSB3aXRoIHVuaXQgaW5mZXJlbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBtZXRyaWNOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gJ04vQSdcblxuXHRsZXQgbG93ZXJOYW1lID0gbWV0cmljTmFtZS50b0xvd2VyQ2FzZSgpXG5cblx0Ly8gTGF0ZW5jeS9kdXJhdGlvbiAobXMpXG5cdGlmIChsb3dlck5hbWUuaW5jbHVkZXMoJ2xhdGVuY3knKSB8fCBsb3dlck5hbWUuaW5jbHVkZXMoJ2R1cmF0aW9uJykgfHwgbG93ZXJOYW1lLmVuZHNXaXRoKCdfbXMnKSkge1xuXHRcdHJldHVybiBgJHt2YWx1ZS50b0ZpeGVkKDIpfW1zYFxuXHR9XG5cblx0Ly8gVGltZSAoc2Vjb25kcylcblx0aWYgKGxvd2VyTmFtZS5pbmNsdWRlcygndGltZScpICYmIGxvd2VyTmFtZS5lbmRzV2l0aCgnX3MnKSkge1xuXHRcdHJldHVybiBgJHt2YWx1ZS50b0ZpeGVkKDIpfXNgXG5cdH1cblxuXHQvLyBQZXJjZW50YWdlXG5cdGlmIChsb3dlck5hbWUuaW5jbHVkZXMoJ2F2YWlsYWJpbGl0eScpIHx8IGxvd2VyTmFtZS5pbmNsdWRlcygncGVyY2VudCcpIHx8IGxvd2VyTmFtZS5pbmNsdWRlcygncmF0ZScpKSB7XG5cdFx0cmV0dXJuIGAke3ZhbHVlLnRvRml4ZWQoMil9JWBcblx0fVxuXG5cdC8vIFRocm91Z2hwdXRcblx0aWYgKGxvd2VyTmFtZS5pbmNsdWRlcygndGhyb3VnaHB1dCcpIHx8IGxvd2VyTmFtZS5pbmNsdWRlcygncXBzJykgfHwgbG93ZXJOYW1lLmluY2x1ZGVzKCdycHMnKSB8fCBsb3dlck5hbWUuaW5jbHVkZXMoJ29wcycpKSB7XG5cdFx0aWYgKHZhbHVlID49IDEwMDApIHtcblx0XHRcdHJldHVybiBgJHsodmFsdWUgLyAxMDAwKS50b0ZpeGVkKDIpfWsvc2Bcblx0XHR9XG5cdFx0cmV0dXJuIGAke3ZhbHVlLnRvRml4ZWQoMCl9L3NgXG5cdH1cblxuXHQvLyBEZWZhdWx0OiAyIGRlY2ltYWwgcGxhY2VzXG5cdHJldHVybiB2YWx1ZS50b0ZpeGVkKDIpXG59XG5cbi8qKlxuICogRm9ybWF0IGNoYW5nZSBwZXJjZW50YWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRDaGFuZ2UocGVyY2VudDogbnVtYmVyLCBkaXJlY3Rpb246ICdiZXR0ZXInIHwgJ3dvcnNlJyB8ICduZXV0cmFsJyB8ICd1bmtub3duJyk6IHN0cmluZyB7XG5cdGlmIChpc05hTihwZXJjZW50KSkgcmV0dXJuICdOL0EnXG5cblx0bGV0IHNpZ24gPSBwZXJjZW50ID49IDAgPyAnKycgOiAnJ1xuXHRsZXQgZW1vamkgPSBkaXJlY3Rpb24gPT09ICdiZXR0ZXInID8gJ/Cfn6InIDogZGlyZWN0aW9uID09PSAnd29yc2UnID8gJ/CflLQnIDogZGlyZWN0aW9uID09PSAnbmV1dHJhbCcgPyAn4pqqJyA6ICfinZMnXG5cblx0cmV0dXJuIGAke3NpZ259JHtwZXJjZW50LnRvRml4ZWQoMSl9JSAke2Vtb2ppfWBcbn1cbiIKICBdLAogICJtYXBwaW5ncyI6ICI7Ozs7OztBQXNDQSxTQUFTLG9CQUFvQixDQUFDLE1BQWtFO0FBQUEsRUFDL0YsSUFBSSxZQUFZLEtBQUssWUFBWTtBQUFBLEVBR2pDLElBQ0MsVUFBVSxTQUFTLFNBQVMsS0FDNUIsVUFBVSxTQUFTLFVBQVUsS0FDN0IsVUFBVSxTQUFTLE1BQU0sS0FDekIsVUFBVSxTQUFTLE9BQU8sS0FDMUIsVUFBVSxTQUFTLE9BQU8sS0FDMUIsVUFBVSxTQUFTLFNBQVM7QUFBQSxJQUU1QixPQUFPO0FBQUEsRUFJUixJQUNDLFVBQVUsU0FBUyxjQUFjLEtBQ2pDLFVBQVUsU0FBUyxZQUFZLEtBQy9CLFVBQVUsU0FBUyxTQUFTLEtBQzVCLFVBQVUsU0FBUyxLQUFLLEtBQ3hCLFVBQVUsU0FBUyxLQUFLLEtBQ3hCLFVBQVUsU0FBUyxLQUFLO0FBQUEsSUFFeEIsT0FBTztBQUFBLEVBR1IsT0FBTztBQUFBO0FBTVIsU0FBUyx3QkFBd0IsQ0FDaEMsY0FDQSxXQUNBLGlCQUM2QztBQUFBLEVBQzdDLElBQUksTUFBTSxZQUFZLEtBQUssTUFBTSxTQUFTO0FBQUEsSUFDekMsT0FBTztBQUFBLEVBTVIsSUFIb0IsS0FBSyxLQUFNLGVBQWUsYUFBYSxZQUFhLEdBQUcsSUFHdkQ7QUFBQSxJQUNuQixPQUFPO0FBQUEsRUFHUixJQUFJLG9CQUFvQjtBQUFBLElBQ3ZCLE9BQU8sZUFBZSxZQUFZLFdBQVc7QUFBQSxFQUc5QyxJQUFJLG9CQUFvQjtBQUFBLElBQ3ZCLE9BQU8sZUFBZSxZQUFZLFdBQVc7QUFBQSxFQUc5QyxPQUFPO0FBQUE7QUFNRCxTQUFTLGFBQWEsQ0FBQyxRQUF5QixZQUErQixPQUF5QjtBQUFBLEVBQzlHLElBQUksZUFBZSxlQUFlLFFBQVEsV0FBVyxTQUFTLEdBQzFELFlBQVksZUFBZSxRQUFRLFFB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
