import"../../main-ynsbc1hx.js";

// report/lib/metrics.ts
function parseMetricsJsonl(content) {
  let metrics = /* @__PURE__ */ new Map, lines = content.trim().split(`
`);
  for (let line of lines) {
    if (!line.trim())
      continue;
    try {
      let metric = JSON.parse(line);
      metrics.set(metric.name, metric);
    } catch {
      continue;
    }
  }
  return metrics;
}
function separateByRef(metric) {
  let current = null, base = null;
  if (metric.type === "instant") {
    let data = metric.data;
    current = data.find((s) => s.metric.ref === "current") || null, base = data.find((s) => s.metric.ref === "base") || null;
  } else {
    let data = metric.data;
    current = data.find((s) => s.metric.ref === "current") || null, base = data.find((s) => s.metric.ref === "base") || null;
  }
  return { current, base };
}
function percentile(values, p) {
  let sorted = [...values].sort((a, b) => a - b), index = Math.ceil(sorted.length * p) - 1;
  return sorted[Math.max(0, index)];
}
function aggregateValues(values, fn) {
  if (values.length === 0)
    return NaN;
  let nums = values.map(([_, v]) => parseFloat(v)).filter((n) => !isNaN(n));
  if (nums.length === 0)
    return NaN;
  switch (fn) {
    case "last":
      return nums[nums.length - 1];
    case "first":
      return nums[0];
    case "avg":
      return nums.reduce((a, b) => a + b, 0) / nums.length;
    case "min":
      return Math.min(...nums);
    case "max":
      return Math.max(...nums);
    case "p50":
      return percentile(nums, 0.5);
    case "p95":
      return percentile(nums, 0.95);
    case "p99":
      return percentile(nums, 0.99);
    case "sum":
      return nums.reduce((a, b) => a + b, 0);
    case "count":
      return nums.length;
    default:
      return NaN;
  }
}
function getMetricValue(metric, ref, aggregate = "avg") {
  let separated = separateByRef(metric), series = ref === "current" ? separated.current : separated.base;
  if (!series)
    return NaN;
  if (metric.type === "instant")
    return parseFloat(series.value[1]);
  else
    return aggregateValues(series.values, aggregate);
}

// report/lib/analysis.ts
function inferMetricDirection(name) {
  let lowerName = name.toLowerCase();
  if (lowerName.includes("latency") || lowerName.includes("duration") || lowerName.includes("time") || lowerName.includes("delay") || lowerName.includes("error") || lowerName.includes("failure"))
    return "lower_is_better";
  if (lowerName.includes("availability") || lowerName.includes("throughput") || lowerName.includes("success") || lowerName.includes("qps") || lowerName.includes("rps") || lowerName.includes("ops"))
    return "higher_is_better";
  return "neutral";
}
function determineChangeDirection(currentValue, baseValue, metricDirection, neutralThreshold = 5) {
  if (isNaN(currentValue) || isNaN(baseValue))
    return "unknown";
  if (Math.abs((currentValue - baseValue) / baseValue * 100) < neutralThreshold)
    return "neutral";
  if (metricDirection === "lower_is_better")
    return currentValue < baseValue ? "better" : "worse";
  if (metricDirection === "higher_is_better")
    return currentValue > baseValue ? "better" : "worse";
  return "neutral";
}
function compareMetric(metric, aggregate = "avg", neutralThreshold) {
  let currentValue = getMetricValue(metric, "current", aggregate), baseValue = getMetricValue(metric, "base", aggregate), absolute = currentValue - baseValue, percent = isNaN(baseValue) || baseValue === 0 ? NaN : absolute / baseValue * 100, metricDirection = inferMetricDirection(metric.name), direction = determineChangeDirection(currentValue, baseValue, metricDirection, neutralThreshold);
  return {
    name: metric.name,
    type: metric.type,
    current: {
      value: currentValue,
      available: !isNaN(currentValue)
    },
    base: {
      value: baseValue,
      available: !isNaN(baseValue)
    },
    change: {
      absolute,
      percent,
      direction
    }
  };
}
function compareWorkloadMetrics(workload, metrics, aggregate = "avg", neutralThreshold) {
  let comparisons = [];
  for (let [_name, metric] of metrics) {
    let comparison = compareMetric(metric, aggregate, neutralThreshold);
    comparisons.push(comparison);
  }
  let regressions = comparisons.filter((c) => c.change.direction === "worse").length, improvements = comparisons.filter((c) => c.change.direction === "better").length, stable = comparisons.filter((c) => c.change.direction === "neutral").length;
  return {
    workload,
    metrics: comparisons,
    summary: {
      total: comparisons.length,
      regressions,
      improvements,
      stable
    }
  };
}
function formatValue(value, metricName) {
  if (isNaN(value))
    return "N/A";
  let lowerName = metricName.toLowerCase();
  if (lowerName.includes("latency") || lowerName.includes("duration") || lowerName.endsWith("_ms"))
    return `${value.toFixed(2)}ms`;
  if (lowerName.includes("time") && lowerName.endsWith("_s"))
    return `${value.toFixed(2)}s`;
  if (lowerName.includes("availability") || lowerName.includes("percent") || lowerName.includes("rate"))
    return `${value.toFixed(2)}%`;
  if (lowerName.includes("throughput") || lowerName.includes("qps") || lowerName.includes("rps") || lowerName.includes("ops")) {
    if (value >= 1000)
      return `${(value / 1000).toFixed(2)}k/s`;
    return `${value.toFixed(0)}/s`;
  }
  return value.toFixed(2);
}
function formatChange(percent, direction) {
  if (isNaN(percent))
    return "N/A";
  let sign = percent >= 0 ? "+" : "", emoji = direction === "better" ? "\uD83D\uDFE2" : direction === "worse" ? "\uD83D\uDD34" : direction === "neutral" ? "⚪" : "❓";
  return `${sign}${percent.toFixed(1)}% ${emoji}`;
}
export {
  formatValue,
  formatChange,
  compareWorkloadMetrics,
  compareMetric
};

export { parseMetricsJsonl, compareWorkloadMetrics, formatValue, formatChange };

//# debugId=D0CC649698299E8664756E2164756E21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vcmVwb3J0L2xpYi9tZXRyaWNzLnRzIiwgIi4uL3JlcG9ydC9saWIvYW5hbHlzaXMudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbCiAgICAiLyoqXG4gKiBNZXRyaWNzIHBhcnNpbmcgYW5kIHR5cGVzIGZvciByZXBvcnQgYWN0aW9uXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBTZXJpZXMge1xuXHRtZXRyaWM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblx0dmFsdWVzOiBbbnVtYmVyLCBzdHJpbmddW10gLy8gW3RpbWVzdGFtcCAoc2VjKSwgdmFsdWUgKGZsb2F0KV1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbnN0YW50U2VyaWVzIHtcblx0bWV0cmljOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG5cdHZhbHVlOiBbbnVtYmVyLCBzdHJpbmddIC8vIFt0aW1lc3RhbXAgKHNlYyksIHZhbHVlIChmbG9hdCldXG59XG5cbi8qKlxuICogQ29sbGVjdGVkIG1ldHJpYyBmcm9tIGluaXQgYWN0aW9uIChKU09OTCBmb3JtYXQpXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGVjdGVkTWV0cmljIHtcblx0bmFtZTogc3RyaW5nXG5cdHF1ZXJ5OiBzdHJpbmdcblx0dHlwZTogJ3JhbmdlJyB8ICdpbnN0YW50J1xuXHRkYXRhOiBTZXJpZXNbXSB8IEluc3RhbnRTZXJpZXNbXVxufVxuXG4vKipcbiAqIFBhcnNlZCBtZXRyaWNzIGJ5IG5hbWVcbiAqL1xuZXhwb3J0IHR5cGUgTWV0cmljc01hcCA9IE1hcDxzdHJpbmcsIENvbGxlY3RlZE1ldHJpYz5cblxuLyoqXG4gKiBQYXJzZSBKU09OTCBtZXRyaWNzIGZpbGUgaW50byBNZXRyaWNzTWFwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1ldHJpY3NKc29ubChjb250ZW50OiBzdHJpbmcpOiBNZXRyaWNzTWFwIHtcblx0bGV0IG1ldHJpY3MgPSBuZXcgTWFwPHN0cmluZywgQ29sbGVjdGVkTWV0cmljPigpXG5cdGxldCBsaW5lcyA9IGNvbnRlbnQudHJpbSgpLnNwbGl0KCdcXG4nKVxuXG5cdGZvciAobGV0IGxpbmUgb2YgbGluZXMpIHtcblx0XHRpZiAoIWxpbmUudHJpbSgpKSBjb250aW51ZVxuXG5cdFx0dHJ5IHtcblx0XHRcdGxldCBtZXRyaWMgPSBKU09OLnBhcnNlKGxpbmUpIGFzIENvbGxlY3RlZE1ldHJpY1xuXHRcdFx0bWV0cmljcy5zZXQobWV0cmljLm5hbWUsIG1ldHJpYylcblx0XHR9IGNhdGNoIHtcblx0XHRcdC8vIFNraXAgaW52YWxpZCBsaW5lc1xuXHRcdFx0Y29udGludWVcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWV0cmljc1xufVxuXG4vKipcbiAqIFNlcGFyYXRlIHNlcmllcyBieSByZWYgbGFiZWwgKGN1cnJlbnQgdnMgYmFzZSlcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXBhcmF0ZWRTZXJpZXMge1xuXHRjdXJyZW50OiBTZXJpZXMgfCBJbnN0YW50U2VyaWVzIHwgbnVsbFxuXHRiYXNlOiBTZXJpZXMgfCBJbnN0YW50U2VyaWVzIHwgbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VwYXJhdGVCeVJlZihtZXRyaWM6IENvbGxlY3RlZE1ldHJpYyk6IFNlcGFyYXRlZFNlcmllcyB7XG5cdGxldCBjdXJyZW50OiBTZXJpZXMgfCBJbnN0YW50U2VyaWVzIHwgbnVsbCA9IG51bGxcblx0bGV0IGJhc2U6IFNlcmllcyB8IEluc3RhbnRTZXJpZXMgfCBudWxsID0gbnVsbFxuXG5cdGlmIChtZXRyaWMudHlwZSA9PT0gJ2luc3RhbnQnKSB7XG5cdFx0bGV0IGRhdGEgPSBtZXRyaWMuZGF0YSBhcyBJbnN0YW50U2VyaWVzW11cblx0XHRjdXJyZW50ID0gZGF0YS5maW5kKChzKSA9PiBzLm1ldHJpYy5yZWYgPT09ICdjdXJyZW50JykgfHwgbnVsbFxuXHRcdGJhc2UgPSBkYXRhLmZpbmQoKHMpID0+IHMubWV0cmljLnJlZiA9PT0gJ2Jhc2UnKSB8fCBudWxsXG5cdH0gZWxzZSB7XG5cdFx0bGV0IGRhdGEgPSBtZXRyaWMuZGF0YSBhcyBTZXJpZXNbXVxuXHRcdGN1cnJlbnQgPSBkYXRhLmZpbmQoKHMpID0+IHMubWV0cmljLnJlZiA9PT0gJ2N1cnJlbnQnKSB8fCBudWxsXG5cdFx0YmFzZSA9IGRhdGEuZmluZCgocykgPT4gcy5tZXRyaWMucmVmID09PSAnYmFzZScpIHx8IG51bGxcblx0fVxuXG5cdHJldHVybiB7IGN1cnJlbnQsIGJhc2UgfVxufVxuXG4vKipcbiAqIEFnZ3JlZ2F0ZSBmdW5jdGlvbiB0eXBlIGZvciByYW5nZSBtZXRyaWNzXG4gKi9cbmV4cG9ydCB0eXBlIEFnZ3JlZ2F0ZUZ1bmN0aW9uID0gJ2xhc3QnIHwgJ2ZpcnN0JyB8ICdhdmcnIHwgJ21pbicgfCAnbWF4JyB8ICdwNTAnIHwgJ3A5NScgfCAncDk5JyB8ICdzdW0nIHwgJ2NvdW50J1xuXG4vKipcbiAqIENhbGN1bGF0ZSBwZXJjZW50aWxlXG4gKi9cbmZ1bmN0aW9uIHBlcmNlbnRpbGUodmFsdWVzOiBudW1iZXJbXSwgcDogbnVtYmVyKTogbnVtYmVyIHtcblx0bGV0IHNvcnRlZCA9IFsuLi52YWx1ZXNdLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuXHRsZXQgaW5kZXggPSBNYXRoLmNlaWwoc29ydGVkLmxlbmd0aCAqIHApIC0gMVxuXHRyZXR1cm4gc29ydGVkW01hdGgubWF4KDAsIGluZGV4KV1cbn1cblxuLyoqXG4gKiBBZ2dyZWdhdGUgcmFuZ2UgbWV0cmljIHZhbHVlcyB1c2luZyBzcGVjaWZpZWQgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFnZ3JlZ2F0ZVZhbHVlcyh2YWx1ZXM6IFtudW1iZXIsIHN0cmluZ11bXSwgZm46IEFnZ3JlZ2F0ZUZ1bmN0aW9uKTogbnVtYmVyIHtcblx0aWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHJldHVybiBOYU5cblxuXHRsZXQgbnVtcyA9IHZhbHVlcy5tYXAoKFtfLCB2XSkgPT4gcGFyc2VGbG9hdCh2KSkuZmlsdGVyKChuKSA9PiAhaXNOYU4obikpXG5cblx0aWYgKG51bXMubGVuZ3RoID09PSAwKSByZXR1cm4gTmFOXG5cblx0c3dpdGNoIChmbikge1xuXHRcdGNhc2UgJ2xhc3QnOlxuXHRcdFx0cmV0dXJuIG51bXNbbnVtcy5sZW5ndGggLSAxXVxuXHRcdGNhc2UgJ2ZpcnN0Jzpcblx0XHRcdHJldHVybiBudW1zWzBdXG5cdFx0Y2FzZSAnYXZnJzpcblx0XHRcdHJldHVybiBudW1zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gbnVtcy5sZW5ndGhcblx0XHRjYXNlICdtaW4nOlxuXHRcdFx0cmV0dXJuIE1hdGgubWluKC4uLm51bXMpXG5cdFx0Y2FzZSAnbWF4Jzpcblx0XHRcdHJldHVybiBNYXRoLm1heCguLi5udW1zKVxuXHRcdGNhc2UgJ3A1MCc6XG5cdFx0XHRyZXR1cm4gcGVyY2VudGlsZShudW1zLCAwLjUpXG5cdFx0Y2FzZSAncDk1Jzpcblx0XHRcdHJldHVybiBwZXJjZW50aWxlKG51bXMsIDAuOTUpXG5cdFx0Y2FzZSAncDk5Jzpcblx0XHRcdHJldHVybiBwZXJjZW50aWxlKG51bXMsIDAuOTkpXG5cdFx0Y2FzZSAnc3VtJzpcblx0XHRcdHJldHVybiBudW1zLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApXG5cdFx0Y2FzZSAnY291bnQnOlxuXHRcdFx0cmV0dXJuIG51bXMubGVuZ3RoXG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiBOYU5cblx0fVxufVxuXG4vKipcbiAqIEdldCBzaW5nbGUgdmFsdWUgZnJvbSBtZXRyaWMgKGluc3RhbnQgb3IgYWdncmVnYXRlZCByYW5nZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldHJpY1ZhbHVlKFxuXHRtZXRyaWM6IENvbGxlY3RlZE1ldHJpYyxcblx0cmVmOiAnY3VycmVudCcgfCAnYmFzZScsXG5cdGFnZ3JlZ2F0ZTogQWdncmVnYXRlRnVuY3Rpb24gPSAnYXZnJ1xuKTogbnVtYmVyIHtcblx0bGV0IHNlcGFyYXRlZCA9IHNlcGFyYXRlQnlSZWYobWV0cmljKVxuXHRsZXQgc2VyaWVzID0gcmVmID09PSAnY3VycmVudCcgPyBzZXBhcmF0ZWQuY3VycmVudCA6IHNlcGFyYXRlZC5iYXNlXG5cblx0aWYgKCFzZXJpZXMpIHJldHVybiBOYU5cblxuXHRpZiAobWV0cmljLnR5cGUgPT09ICdpbnN0YW50Jykge1xuXHRcdGxldCBpbnN0YW50U2VyaWVzID0gc2VyaWVzIGFzIEluc3RhbnRTZXJpZXNcblx0XHRyZXR1cm4gcGFyc2VGbG9hdChpbnN0YW50U2VyaWVzLnZhbHVlWzFdKVxuXHR9IGVsc2Uge1xuXHRcdGxldCByYW5nZVNlcmllcyA9IHNlcmllcyBhcyBTZXJpZXNcblx0XHRyZXR1cm4gYWdncmVnYXRlVmFsdWVzKHJhbmdlU2VyaWVzLnZhbHVlcywgYWdncmVnYXRlKVxuXHR9XG59XG4iLAogICAgIi8qKlxuICogTWV0cmljcyBhbmFseXNpcyBhbmQgY29tcGFyaXNvblxuICovXG5cbmltcG9ydCB7IGdldE1ldHJpY1ZhbHVlLCB0eXBlIEFnZ3JlZ2F0ZUZ1bmN0aW9uLCB0eXBlIENvbGxlY3RlZE1ldHJpYywgdHlwZSBNZXRyaWNzTWFwIH0gZnJvbSAnLi9tZXRyaWNzLmpzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIE1ldHJpY0NvbXBhcmlzb24ge1xuXHRuYW1lOiBzdHJpbmdcblx0dHlwZTogJ3JhbmdlJyB8ICdpbnN0YW50J1xuXHRjdXJyZW50OiB7XG5cdFx0dmFsdWU6IG51bWJlclxuXHRcdGF2YWlsYWJsZTogYm9vbGVhblxuXHR9XG5cdGJhc2U6IHtcblx0XHR2YWx1ZTogbnVtYmVyXG5cdFx0YXZhaWxhYmxlOiBib29sZWFuXG5cdH1cblx0Y2hhbmdlOiB7XG5cdFx0YWJzb2x1dGU6IG51bWJlclxuXHRcdHBlcmNlbnQ6IG51bWJlclxuXHRcdGRpcmVjdGlvbjogJ2JldHRlcicgfCAnd29yc2UnIHwgJ25ldXRyYWwnIHwgJ3Vua25vd24nXG5cdH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXb3JrbG9hZENvbXBhcmlzb24ge1xuXHR3b3JrbG9hZDogc3RyaW5nXG5cdG1ldHJpY3M6IE1ldHJpY0NvbXBhcmlzb25bXVxuXHRzdW1tYXJ5OiB7XG5cdFx0dG90YWw6IG51bWJlclxuXHRcdHJlZ3Jlc3Npb25zOiBudW1iZXJcblx0XHRpbXByb3ZlbWVudHM6IG51bWJlclxuXHRcdHN0YWJsZTogbnVtYmVyXG5cdH1cbn1cblxuLyoqXG4gKiBJbmZlciBtZXRyaWMgZGlyZWN0aW9uIGJhc2VkIG9uIG5hbWVcbiAqL1xuZnVuY3Rpb24gaW5mZXJNZXRyaWNEaXJlY3Rpb24obmFtZTogc3RyaW5nKTogJ2xvd2VyX2lzX2JldHRlcicgfCAnaGlnaGVyX2lzX2JldHRlcicgfCAnbmV1dHJhbCcge1xuXHRsZXQgbG93ZXJOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cblx0Ly8gTG93ZXIgaXMgYmV0dGVyXG5cdGlmIChcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ2xhdGVuY3knKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygnZHVyYXRpb24nKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygndGltZScpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdkZWxheScpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdlcnJvcicpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdmYWlsdXJlJylcblx0KSB7XG5cdFx0cmV0dXJuICdsb3dlcl9pc19iZXR0ZXInXG5cdH1cblxuXHQvLyBIaWdoZXIgaXMgYmV0dGVyXG5cdGlmIChcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ2F2YWlsYWJpbGl0eScpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCd0aHJvdWdocHV0JykgfHxcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ3N1Y2Nlc3MnKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygncXBzJykgfHxcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ3JwcycpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdvcHMnKVxuXHQpIHtcblx0XHRyZXR1cm4gJ2hpZ2hlcl9pc19iZXR0ZXInXG5cdH1cblxuXHRyZXR1cm4gJ25ldXRyYWwnXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGNoYW5nZSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQ2hhbmdlRGlyZWN0aW9uKFxuXHRjdXJyZW50VmFsdWU6IG51bWJlcixcblx0YmFzZVZhbHVlOiBudW1iZXIsXG5cdG1ldHJpY0RpcmVjdGlvbjogJ2xvd2VyX2lzX2JldHRlcicgfCAnaGlnaGVyX2lzX2JldHRlcicgfCAnbmV1dHJhbCcsXG5cdG5ldXRyYWxUaHJlc2hvbGQ6IG51bWJlciA9IDUuMFxuKTogJ2JldHRlcicgfCAnd29yc2UnIHwgJ25ldXRyYWwnIHwgJ3Vua25vd24nIHtcblx0aWYgKGlzTmFOKGN1cnJlbnRWYWx1ZSkgfHwgaXNOYU4oYmFzZVZhbHVlKSkge1xuXHRcdHJldHVybiAndW5rbm93bidcblx0fVxuXG5cdGxldCBjaGFuZ2VQZXJjZW50ID0gTWF0aC5hYnMoKChjdXJyZW50VmFsdWUgLSBiYXNlVmFsdWUpIC8gYmFzZVZhbHVlKSAqIDEwMClcblxuXHQvLyBDb25zaWRlciBjaGFuZ2UgYmVsb3cgdGhyZXNob2xkIGFzIHN0YWJsZS9uZXV0cmFsXG5cdGlmIChjaGFuZ2VQZXJjZW50IDwgbmV1dHJhbFRocmVzaG9sZCkge1xuXHRcdHJldHVybiAnbmV1dHJhbCdcblx0fVxuXG5cdGlmIChtZXRyaWNEaXJlY3Rpb24gPT09ICdsb3dlcl9pc19iZXR0ZXInKSB7XG5cdFx0cmV0dXJuIGN1cnJlbnRWYWx1ZSA8IGJhc2VWYWx1ZSA/ICdiZXR0ZXInIDogJ3dvcnNlJ1xuXHR9XG5cblx0aWYgKG1ldHJpY0RpcmVjdGlvbiA9PT0gJ2hpZ2hlcl9pc19iZXR0ZXInKSB7XG5cdFx0cmV0dXJuIGN1cnJlbnRWYWx1ZSA+IGJhc2VWYWx1ZSA/ICdiZXR0ZXInIDogJ3dvcnNlJ1xuXHR9XG5cblx0cmV0dXJuICduZXV0cmFsJ1xufVxuXG4vKipcbiAqIENvbXBhcmUgc2luZ2xlIG1ldHJpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZU1ldHJpYyhcblx0bWV0cmljOiBDb2xsZWN0ZWRNZXRyaWMsXG5cdGFnZ3JlZ2F0ZTogQWdncmVnYXRlRnVuY3Rpb24gPSAnYXZnJyxcblx0bmV1dHJhbFRocmVzaG9sZD86IG51bWJlclxuKTogTWV0cmljQ29tcGFyaXNvbiB7XG5cdGxldCBjdXJyZW50VmFsdWUgPSBnZXRNZXRyaWNWYWx1ZShtZXRyaWMsICdjdXJyZW50JywgYWdncmVnYXRlKVxuXHRsZXQgYmFzZVZhbHVlID0gZ2V0TWV0cmljVmFsdWUobWV0cmljLCAnYmFzZScsIGFnZ3JlZ2F0ZSlcblxuXHRsZXQgYWJzb2x1dGUgPSBjdXJyZW50VmFsdWUgLSBiYXNlVmFsdWVcblx0bGV0IHBlcmNlbnQgPSBpc05hTihiYXNlVmFsdWUpIHx8IGJhc2VWYWx1ZSA9PT0gMCA/IE5hTiA6IChhYnNvbHV0ZSAvIGJhc2VWYWx1ZSkgKiAxMDBcblxuXHRsZXQgbWV0cmljRGlyZWN0aW9uID0gaW5mZXJNZXRyaWNEaXJlY3Rpb24obWV0cmljLm5hbWUpXG5cdGxldCBkaXJlY3Rpb24gPSBkZXRlcm1pbmVDaGFuZ2VEaXJlY3Rpb24oY3VycmVudFZhbHVlLCBiYXNlVmFsdWUsIG1ldHJpY0RpcmVjdGlvbiwgbmV1dHJhbFRocmVzaG9sZClcblxuXHRyZXR1cm4ge1xuXHRcdG5hbWU6IG1ldHJpYy5uYW1lLFxuXHRcdHR5cGU6IG1ldHJpYy50eXBlLFxuXHRcdGN1cnJlbnQ6IHtcblx0XHRcdHZhbHVlOiBjdXJyZW50VmFsdWUsXG5cdFx0XHRhdmFpbGFibGU6ICFpc05hTihjdXJyZW50VmFsdWUpLFxuXHRcdH0sXG5cdFx0YmFzZToge1xuXHRcdFx0dmFsdWU6IGJhc2VWYWx1ZSxcblx0XHRcdGF2YWlsYWJsZTogIWlzTmFOKGJhc2VWYWx1ZSksXG5cdFx0fSxcblx0XHRjaGFuZ2U6IHtcblx0XHRcdGFic29sdXRlLFxuXHRcdFx0cGVyY2VudCxcblx0XHRcdGRpcmVjdGlvbixcblx0XHR9LFxuXHR9XG59XG5cbi8qKlxuICogQ29tcGFyZSBhbGwgbWV0cmljcyBpbiBhIHdvcmtsb2FkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlV29ya2xvYWRNZXRyaWNzKFxuXHR3b3JrbG9hZDogc3RyaW5nLFxuXHRtZXRyaWNzOiBNZXRyaWNzTWFwLFxuXHRhZ2dyZWdhdGU6IEFnZ3JlZ2F0ZUZ1bmN0aW9uID0gJ2F2ZycsXG5cdG5ldXRyYWxUaHJlc2hvbGQ/OiBudW1iZXJcbik6IFdvcmtsb2FkQ29tcGFyaXNvbiB7XG5cdGxldCBjb21wYXJpc29uczogTWV0cmljQ29tcGFyaXNvbltdID0gW11cblxuXHRmb3IgKGxldCBbX25hbWUsIG1ldHJpY10gb2YgbWV0cmljcykge1xuXHRcdGxldCBjb21wYXJpc29uID0gY29tcGFyZU1ldHJpYyhtZXRyaWMsIGFnZ3JlZ2F0ZSwgbmV1dHJhbFRocmVzaG9sZClcblx0XHRjb21wYXJpc29ucy5wdXNoKGNvbXBhcmlzb24pXG5cdH1cblxuXHQvLyBDYWxjdWxhdGUgc3VtbWFyeVxuXHRsZXQgcmVncmVzc2lvbnMgPSBjb21wYXJpc29ucy5maWx0ZXIoKGMpID0+IGMuY2hhbmdlLmRpcmVjdGlvbiA9PT0gJ3dvcnNlJykubGVuZ3RoXG5cdGxldCBpbXByb3ZlbWVudHMgPSBjb21wYXJpc29ucy5maWx0ZXIoKGMpID0+IGMuY2hhbmdlLmRpcmVjdGlvbiA9PT0gJ2JldHRlcicpLmxlbmd0aFxuXHRsZXQgc3RhYmxlID0gY29tcGFyaXNvbnMuZmlsdGVyKChjKSA9PiBjLmNoYW5nZS5kaXJlY3Rpb24gPT09ICduZXV0cmFsJykubGVuZ3RoXG5cblx0cmV0dXJuIHtcblx0XHR3b3JrbG9hZCxcblx0XHRtZXRyaWNzOiBjb21wYXJpc29ucyxcblx0XHRzdW1tYXJ5OiB7XG5cdFx0XHR0b3RhbDogY29tcGFyaXNvbnMubGVuZ3RoLFxuXHRcdFx0cmVncmVzc2lvbnMsXG5cdFx0XHRpbXByb3ZlbWVudHMsXG5cdFx0XHRzdGFibGUsXG5cdFx0fSxcblx0fVxufVxuXG4vKipcbiAqIEZvcm1hdCB2YWx1ZSB3aXRoIHVuaXQgaW5mZXJlbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBtZXRyaWNOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gJ04vQSdcblxuXHRsZXQgbG93ZXJOYW1lID0gbWV0cmljTmFtZS50b0xvd2VyQ2FzZSgpXG5cblx0Ly8gTGF0ZW5jeS9kdXJhdGlvbiAobXMpXG5cdGlmIChsb3dlck5hbWUuaW5jbHVkZXMoJ2xhdGVuY3knKSB8fCBsb3dlck5hbWUuaW5jbHVkZXMoJ2R1cmF0aW9uJykgfHwgbG93ZXJOYW1lLmVuZHNXaXRoKCdfbXMnKSkge1xuXHRcdHJldHVybiBgJHt2YWx1ZS50b0ZpeGVkKDIpfW1zYFxuXHR9XG5cblx0Ly8gVGltZSAoc2Vjb25kcylcblx0aWYgKGxvd2VyTmFtZS5pbmNsdWRlcygndGltZScpICYmIGxvd2VyTmFtZS5lbmRzV2l0aCgnX3MnKSkge1xuXHRcdHJldHVybiBgJHt2YWx1ZS50b0ZpeGVkKDIpfXNgXG5cdH1cblxuXHQvLyBQZXJjZW50YWdlXG5cdGlmIChsb3dlck5hbWUuaW5jbHVkZXMoJ2F2YWlsYWJpbGl0eScpIHx8IGxvd2VyTmFtZS5pbmNsdWRlcygncGVyY2VudCcpIHx8IGxvd2VyTmFtZS5pbmNsdWRlcygncmF0ZScpKSB7XG5cdFx0cmV0dXJuIGAke3ZhbHVlLnRvRml4ZWQoMil9JWBcblx0fVxuXG5cdC8vIFRocm91Z2hwdXRcblx0aWYgKFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygndGhyb3VnaHB1dCcpIHx8XG5cdFx0bG93ZXJOYW1lLmluY2x1ZGVzKCdxcHMnKSB8fFxuXHRcdGxvd2VyTmFtZS5pbmNsdWRlcygncnBzJykgfHxcblx0XHRsb3dlck5hbWUuaW5jbHVkZXMoJ29wcycpXG5cdCkge1xuXHRcdGlmICh2YWx1ZSA+PSAxMDAwKSB7XG5cdFx0XHRyZXR1cm4gYCR7KHZhbHVlIC8gMTAwMCkudG9GaXhlZCgyKX1rL3NgXG5cdFx0fVxuXHRcdHJldHVybiBgJHt2YWx1ZS50b0ZpeGVkKDApfS9zYFxuXHR9XG5cblx0Ly8gRGVmYXVsdDogMiBkZWNpbWFsIHBsYWNlc1xuXHRyZXR1cm4gdmFsdWUudG9GaXhlZCgyKVxufVxuXG4vKipcbiAqIEZvcm1hdCBjaGFuZ2UgcGVyY2VudGFnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Q2hhbmdlKHBlcmNlbnQ6IG51bWJlciwgZGlyZWN0aW9uOiAnYmV0dGVyJyB8ICd3b3JzZScgfCAnbmV1dHJhbCcgfCAndW5rbm93bicpOiBzdHJpbmcge1xuXHRpZiAoaXNOYU4ocGVyY2VudCkpIHJldHVybiAnTi9BJ1xuXG5cdGxldCBzaWduID0gcGVyY2VudCA+PSAwID8gJysnIDogJydcblx0bGV0IGVtb2ppID0gZGlyZWN0aW9uID09PSAnYmV0dGVyJyA/ICfwn5+iJyA6IGRpcmVjdGlvbiA9PT0gJ3dvcnNlJyA/ICfwn5S0JyA6IGRpcmVjdGlvbiA9PT0gJ25ldXRyYWwnID8gJ+KaqicgOiAn4p2TJ1xuXG5cdHJldHVybiBgJHtzaWdufSR7cGVyY2VudC50b0ZpeGVkKDEpfSUgJHtlbW9qaX1gXG59XG4iCiAgXSwKICAibWFwcGluZ3MiOiAiOzs7QUFnQ08sU0FBUyxpQkFBaUIsQ0FBQyxTQUE2QjtBQUFBLEVBQzlELElBQUksMEJBQVUsSUFBSSxLQUNkLFFBQVEsUUFBUSxLQUFLLEVBQUUsTUFBTTtBQUFBLENBQUk7QUFBQSxFQUVyQyxTQUFTLFFBQVEsT0FBTztBQUFBLElBQ3ZCLElBQUksQ0FBQyxLQUFLLEtBQUs7QUFBQSxNQUFHO0FBQUEsSUFFbEIsSUFBSTtBQUFBLE1BQ0gsSUFBSSxTQUFTLEtBQUssTUFBTSxJQUFJO0FBQUEsTUFDNUIsUUFBUSxJQUFJLE9BQU8sTUFBTSxNQUFNO0FBQUEsTUFDOUIsTUFBTTtBQUFBLE1BRVA7QUFBQTtBQUFBO0FBQUEsRUFJRixPQUFPO0FBQUE7QUFXRCxTQUFTLGFBQWEs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LFVBQVUsU0FBUyxjQUFjLEtBQUssVUFBVSxTQUFTLFNBQVMsS0FBSyxVQUFVLFNBQVMsTUFBTTtBQUFBLElBQ25HLE9BQU8sR0FBRyxNQUFNLFFBQVEsQ0FBQztBQUFBLEVBSTFCLElBQ0MsVUFBVSxTQUFTLFlBQVksS0FDL0IsVUFBVSxTQUFTLEtBQUssS0FDeEIsVUFBVSxTQUFTLEtBQUssS0FDeEIsVUFBVSxTQUFTLEtBQUssR0FDdkI7QUFBQSxJQUNELElBQUksU0FBUztBQUFBLE1BQ1osT0FBTyxJQUFJLFFBQVEsTUFBTSxRQUFRLENBQUM7QUFBQSxJQUVuQyxPQUFPLEdBQUcsTUFBTSxRQUFRLENBQUM7QUFBQTtBQUFBLEVBSTFCLE9BQU8sTUFBTSxRQUFRLENBQUM7QUFBQTtBQU1oQixTQUFTLFlBQVksQ0FBQyxTQUFpQixXQUErRDtBQUFBLEVBQzVHLElBQUksTUFBTSxPQUFPO0FBQUEsSUFBRyxPQUFPO0FBQUEsRUFFM0IsSUFBSSxPQUFPLFdBQVcsSUFBSSxNQUFNLElBQzVCLFFBQVEsY0FBYyxXQUFXLGlCQUFNLGNBQWMsVUFBVSxpQkFBTyxjQUFjLFlBQVksTUFBTTtBQUFBLEVBRTFHLE9BQU8sR0FBRyxPQUFPLFFBQVEsUUFBUSxDQUFDLE1BQU07QUFBQTsiLAogICJkZWJ1Z0lkIjogIkQwQ0M2NDk2OTgyOTlFODY2NDc1NkUyMTY0NzU2RTIxIiwKICAibmFtZXMiOiBbXQp9
