import {
  require_core,
  require_exec
} from "../../main-gq2p93nb.js";
import"../../main-zqznhazw.js";
import {
  __toESM
} from "../../main-ynsbc1hx.js";

// report/lib/thresholds.ts
var import_exec = __toESM(require_exec(), 1), import_core = __toESM(require_core(), 1);
import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";
async function parseThresholdsYaml(yamlContent) {
  if (!yamlContent || yamlContent.trim() === "")
    return null;
  try {
    let chunks = [];
    await import_exec.exec("yq", ["-o=json", "."], {
      input: Buffer.from(yamlContent, "utf-8"),
      silent: !0,
      listeners: {
        stdout: (data) => chunks.push(data.toString())
      }
    });
    let json = chunks.join("");
    return JSON.parse(json);
  } catch (error) {
    return import_core.warning(`Failed to parse thresholds YAML: ${String(error)}`), null;
  }
}
function mergeThresholdConfigs(defaultConfig, customConfig) {
  return {
    neutral_change_percent: customConfig.neutral_change_percent ?? defaultConfig.neutral_change_percent,
    default: {
      warning_change_percent: customConfig.default?.warning_change_percent ?? defaultConfig.default.warning_change_percent,
      critical_change_percent: customConfig.default?.critical_change_percent ?? defaultConfig.default.critical_change_percent
    },
    metrics: [...customConfig.metrics || [], ...defaultConfig.metrics || []]
  };
}
async function loadDefaultThresholds() {
  import_core.debug("Loading default thresholds from deploy/thresholds.yaml");
  let actionRoot = path.resolve(path.dirname(fileURLToPath(import.meta.url)), "../../"), defaultPath = path.join(actionRoot, "deploy", "thresholds.yaml");
  if (fs.existsSync(defaultPath)) {
    let content = fs.readFileSync(defaultPath, { encoding: "utf-8" }), config = await parseThresholdsYaml(content);
    if (config)
      return config;
  }
  return import_core.warning("Could not load default thresholds, using hardcoded defaults"), {
    neutral_change_percent: 5,
    default: {
      warning_change_percent: 20,
      critical_change_percent: 50
    }
  };
}
async function loadThresholds(customYaml, customPath) {
  let config = await loadDefaultThresholds();
  if (customYaml) {
    import_core.debug("Merging custom thresholds from inline YAML");
    let customConfig = await parseThresholdsYaml(customYaml);
    if (customConfig)
      config = mergeThresholdConfigs(config, customConfig);
  }
  if (customPath && fs.existsSync(customPath)) {
    import_core.debug(`Merging custom thresholds from file: ${customPath}`);
    let content = fs.readFileSync(customPath, { encoding: "utf-8" }), customConfig = await parseThresholdsYaml(content);
    if (customConfig)
      config = mergeThresholdConfigs(config, customConfig);
  }
  return config;
}
function matchPattern(metricName, pattern) {
  let regexPattern = pattern.replace(/\*/g, ".*").replace(/\?/g, ".");
  return new RegExp(`^${regexPattern}$`, "i").test(metricName);
}
function findMatchingThreshold(metricName, config) {
  if (!config.metrics)
    return null;
  for (let threshold of config.metrics)
    if (threshold.name && threshold.name === metricName)
      return threshold;
  for (let threshold of config.metrics)
    if (threshold.pattern && matchPattern(metricName, threshold.pattern))
      return threshold;
  return null;
}
function evaluateThreshold(comparison, config) {
  if (!comparison.base.available)
    return "success";
  let threshold = findMatchingThreshold(comparison.name, config);
  if (threshold) {
    if (threshold.critical_min !== void 0 && comparison.current.value < threshold.critical_min)
      return import_core.debug(`${comparison.name}: below critical_min (${comparison.current.value} < ${threshold.critical_min})`), "failure";
    if (threshold.warning_min !== void 0 && comparison.current.value < threshold.warning_min)
      return import_core.debug(`${comparison.name}: below warning_min (${comparison.current.value} < ${threshold.warning_min})`), "warning";
    if (threshold.critical_max !== void 0 && comparison.current.value > threshold.critical_max)
      return import_core.debug(`${comparison.name}: above critical_max (${comparison.current.value} > ${threshold.critical_max})`), "failure";
    if (threshold.warning_max !== void 0 && comparison.current.value > threshold.warning_max)
      return import_core.debug(`${comparison.name}: above warning_max (${comparison.current.value} > ${threshold.warning_max})`), "warning";
  }
  if (!isNaN(comparison.change.percent)) {
    let changePercent = Math.abs(comparison.change.percent), warningThreshold = threshold?.warning_change_percent ?? config.default.warning_change_percent, criticalThreshold = threshold?.critical_change_percent ?? config.default.critical_change_percent;
    if (comparison.change.direction === "worse") {
      if (changePercent > criticalThreshold)
        return import_core.debug(`${comparison.name}: critical regression (${changePercent.toFixed(1)}% > ${criticalThreshold}%)`), "failure";
      if (changePercent > warningThreshold)
        return import_core.debug(`${comparison.name}: warning regression (${changePercent.toFixed(1)}% > ${warningThreshold}%)`), "warning";
    }
  }
  return "success";
}
function evaluateWorkloadThresholds(comparisons, config) {
  let failures = [], warnings = [];
  for (let comparison of comparisons) {
    let severity = evaluateThreshold(comparison, config);
    if (severity === "failure")
      failures.push(comparison);
    else if (severity === "warning")
      warnings.push(comparison);
  }
  let overall = "success";
  if (failures.length > 0)
    overall = "failure";
  else if (warnings.length > 0)
    overall = "warning";
  return { overall, failures, warnings };
}
export {
  loadThresholds,
  evaluateWorkloadThresholds,
  evaluateThreshold
};

export { loadThresholds, evaluateWorkloadThresholds };

//# debugId=4B27A4727C34A22464756E2164756E21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vcmVwb3J0L2xpYi90aHJlc2hvbGRzLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWwogICAgIi8qKlxuICogVGhyZXNob2xkcyBjb25maWd1cmF0aW9uIGFuZCBldmFsdWF0aW9uXG4gKi9cblxuaW1wb3J0ICogYXMgZnMgZnJvbSAnbm9kZTpmcydcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAnbm9kZTpwYXRoJ1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gJ25vZGU6dXJsJ1xuXG5pbXBvcnQgeyBleGVjIH0gZnJvbSAnQGFjdGlvbnMvZXhlYydcbmltcG9ydCB7IGRlYnVnLCB3YXJuaW5nIH0gZnJvbSAnQGFjdGlvbnMvY29yZSdcblxuaW1wb3J0IHR5cGUgeyBNZXRyaWNDb21wYXJpc29uIH0gZnJvbSAnLi9hbmFseXNpcy5qcydcblxuZXhwb3J0IGludGVyZmFjZSBNZXRyaWNUaHJlc2hvbGQge1xuXHRuYW1lPzogc3RyaW5nIC8vIEV4YWN0IG1ldHJpYyBuYW1lIChoaWdoZXIgcHJpb3JpdHkgdGhhbiBwYXR0ZXJuKVxuXHRwYXR0ZXJuPzogc3RyaW5nIC8vIEdsb2IgcGF0dGVybiAobG93ZXIgcHJpb3JpdHkpXG5cdGRpcmVjdGlvbj86ICdsb3dlcl9pc19iZXR0ZXInIHwgJ2hpZ2hlcl9pc19iZXR0ZXInIHwgJ25ldXRyYWwnXG5cdHdhcm5pbmdfbWluPzogbnVtYmVyXG5cdGNyaXRpY2FsX21pbj86IG51bWJlclxuXHR3YXJuaW5nX21heD86IG51bWJlclxuXHRjcml0aWNhbF9tYXg/OiBudW1iZXJcblx0d2FybmluZ19jaGFuZ2VfcGVyY2VudD86IG51bWJlclxuXHRjcml0aWNhbF9jaGFuZ2VfcGVyY2VudD86IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRocmVzaG9sZENvbmZpZyB7XG5cdG5ldXRyYWxfY2hhbmdlX3BlcmNlbnQ6IG51bWJlclxuXHRkZWZhdWx0OiB7XG5cdFx0d2FybmluZ19jaGFuZ2VfcGVyY2VudDogbnVtYmVyXG5cdFx0Y3JpdGljYWxfY2hhbmdlX3BlcmNlbnQ6IG51bWJlclxuXHR9XG5cdG1ldHJpY3M/OiBNZXRyaWNUaHJlc2hvbGRbXVxufVxuXG5leHBvcnQgdHlwZSBUaHJlc2hvbGRTZXZlcml0eSA9ICdzdWNjZXNzJyB8ICd3YXJuaW5nJyB8ICdmYWlsdXJlJ1xuXG4vKipcbiAqIFBhcnNlIFlBTUwgdGhyZXNob2xkcyBjb25maWdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VUaHJlc2hvbGRzWWFtbCh5YW1sQ29udGVudDogc3RyaW5nKTogUHJvbWlzZTxUaHJlc2hvbGRDb25maWcgfCBudWxsPiB7XG5cdGlmICgheWFtbENvbnRlbnQgfHwgeWFtbENvbnRlbnQudHJpbSgpID09PSAnJykge1xuXHRcdHJldHVybiBudWxsXG5cdH1cblxuXHR0cnkge1xuXHRcdGxldCBjaHVua3M6IHN0cmluZ1tdID0gW11cblxuXHRcdGF3YWl0IGV4ZWMoJ3lxJywgWyctbz1qc29uJywgJy4nXSwge1xuXHRcdFx0aW5wdXQ6IEJ1ZmZlci5mcm9tKHlhbWxDb250ZW50LCAndXRmLTgnKSxcblx0XHRcdHNpbGVudDogdHJ1ZSxcblx0XHRcdGxpc3RlbmVyczoge1xuXHRcdFx0XHRzdGRvdXQ6IChkYXRhKSA9PiBjaHVua3MucHVzaChkYXRhLnRvU3RyaW5nKCkpLFxuXHRcdFx0fSxcblx0XHR9KVxuXG5cdFx0bGV0IGpzb24gPSBjaHVua3Muam9pbignJylcblx0XHRsZXQgcGFyc2VkID0gSlNPTi5wYXJzZShqc29uKSBhcyBUaHJlc2hvbGRDb25maWdcblxuXHRcdHJldHVybiBwYXJzZWRcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHR3YXJuaW5nKGBGYWlsZWQgdG8gcGFyc2UgdGhyZXNob2xkcyBZQU1MOiAke1N0cmluZyhlcnJvcil9YClcblx0XHRyZXR1cm4gbnVsbFxuXHR9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIHRocmVzaG9sZCBjb25maWdzIChjdXN0b20gZXh0ZW5kcy9vdmVycmlkZXMgZGVmYXVsdClcbiAqL1xuZnVuY3Rpb24gbWVyZ2VUaHJlc2hvbGRDb25maWdzKGRlZmF1bHRDb25maWc6IFRocmVzaG9sZENvbmZpZywgY3VzdG9tQ29uZmlnOiBUaHJlc2hvbGRDb25maWcpOiBUaHJlc2hvbGRDb25maWcge1xuXHRyZXR1cm4ge1xuXHRcdG5ldXRyYWxfY2hhbmdlX3BlcmNlbnQ6IGN1c3RvbUNvbmZpZy5uZXV0cmFsX2NoYW5nZV9wZXJjZW50ID8/IGRlZmF1bHRDb25maWcubmV1dHJhbF9jaGFuZ2VfcGVyY2VudCxcblx0XHRkZWZhdWx0OiB7XG5cdFx0XHR3YXJuaW5nX2NoYW5nZV9wZXJjZW50OlxuXHRcdFx0XHRjdXN0b21Db25maWcuZGVmYXVsdD8ud2FybmluZ19jaGFuZ2VfcGVyY2VudCA/PyBkZWZhdWx0Q29uZmlnLmRlZmF1bHQud2FybmluZ19jaGFuZ2VfcGVyY2VudCxcblx0XHRcdGNyaXRpY2FsX2NoYW5nZV9wZXJjZW50OlxuXHRcdFx0XHRjdXN0b21Db25maWcuZGVmYXVsdD8uY3JpdGljYWxfY2hhbmdlX3BlcmNlbnQgPz8gZGVmYXVsdENvbmZpZy5kZWZhdWx0LmNyaXRpY2FsX2NoYW5nZV9wZXJjZW50LFxuXHRcdH0sXG5cdFx0bWV0cmljczogWy4uLihjdXN0b21Db25maWcubWV0cmljcyB8fCBbXSksIC4uLihkZWZhdWx0Q29uZmlnLm1ldHJpY3MgfHwgW10pXSxcblx0XHQvLyBDdXN0b20gbWV0cmljcyBjb21lIGZpcnN0LCBzbyB0aGV5IGhhdmUgaGlnaGVyIHByaW9yaXR5IGluIGZpbmRNYXRjaGluZ1RocmVzaG9sZCgpXG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGRlZmF1bHQgdGhyZXNob2xkcyBmcm9tIGRlcGxveS90aHJlc2hvbGRzLnlhbWxcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZERlZmF1bHRUaHJlc2hvbGRzKCk6IFByb21pc2U8VGhyZXNob2xkQ29uZmlnPiB7XG5cdGRlYnVnKCdMb2FkaW5nIGRlZmF1bHQgdGhyZXNob2xkcyBmcm9tIGRlcGxveS90aHJlc2hvbGRzLnlhbWwnKVxuXHRsZXQgYWN0aW9uUm9vdCA9IHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpKSwgJy4uLy4uLycpXG5cdGxldCBkZWZhdWx0UGF0aCA9IHBhdGguam9pbihhY3Rpb25Sb290LCAnZGVwbG95JywgJ3RocmVzaG9sZHMueWFtbCcpXG5cblx0aWYgKGZzLmV4aXN0c1N5bmMoZGVmYXVsdFBhdGgpKSB7XG5cdFx0bGV0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoZGVmYXVsdFBhdGgsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSlcblx0XHRsZXQgY29uZmlnID0gYXdhaXQgcGFyc2VUaHJlc2hvbGRzWWFtbChjb250ZW50KVxuXHRcdGlmIChjb25maWcpIHJldHVybiBjb25maWdcblx0fVxuXG5cdC8vIEZhbGxiYWNrIHRvIGhhcmRjb2RlZCBkZWZhdWx0c1xuXHR3YXJuaW5nKCdDb3VsZCBub3QgbG9hZCBkZWZhdWx0IHRocmVzaG9sZHMsIHVzaW5nIGhhcmRjb2RlZCBkZWZhdWx0cycpXG5cdHJldHVybiB7XG5cdFx0bmV1dHJhbF9jaGFuZ2VfcGVyY2VudDogNS4wLFxuXHRcdGRlZmF1bHQ6IHtcblx0XHRcdHdhcm5pbmdfY2hhbmdlX3BlcmNlbnQ6IDIwLjAsXG5cdFx0XHRjcml0aWNhbF9jaGFuZ2VfcGVyY2VudDogNTAuMCxcblx0XHR9LFxuXHR9XG59XG5cbi8qKlxuICogTG9hZCB0aHJlc2hvbGRzIGNvbmZpZ3VyYXRpb24gd2l0aCBtZXJnaW5nOlxuICogMS4gTG9hZCBkZWZhdWx0IGZyb20gZGVwbG95L3RocmVzaG9sZHMueWFtbFxuICogMi4gTWVyZ2Ugd2l0aCBjdXN0b20gWUFNTCAoaW5saW5lKSBpZiBwcm92aWRlZFxuICogMy4gTWVyZ2Ugd2l0aCBjdXN0b20gZmlsZSBpZiBwcm92aWRlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFRocmVzaG9sZHMoY3VzdG9tWWFtbD86IHN0cmluZywgY3VzdG9tUGF0aD86IHN0cmluZyk6IFByb21pc2U8VGhyZXNob2xkQ29uZmlnPiB7XG5cdC8vIEFsd2F5cyBsb2FkIGRlZmF1bHRzIGZpcnN0XG5cdGxldCBjb25maWcgPSBhd2FpdCBsb2FkRGVmYXVsdFRocmVzaG9sZHMoKVxuXG5cdC8vIE1lcmdlIHdpdGggY3VzdG9tIFlBTUwgKGlubGluZSlcblx0aWYgKGN1c3RvbVlhbWwpIHtcblx0XHRkZWJ1ZygnTWVyZ2luZyBjdXN0b20gdGhyZXNob2xkcyBmcm9tIGlubGluZSBZQU1MJylcblx0XHRsZXQgY3VzdG9tQ29uZmlnID0gYXdhaXQgcGFyc2VUaHJlc2hvbGRzWWFtbChjdXN0b21ZYW1sKVxuXHRcdGlmIChjdXN0b21Db25maWcpIHtcblx0XHRcdGNvbmZpZyA9IG1lcmdlVGhyZXNob2xkQ29uZmlncyhjb25maWcsIGN1c3RvbUNvbmZpZylcblx0XHR9XG5cdH1cblxuXHQvLyBNZXJnZSB3aXRoIGN1c3RvbSBmaWxlXG5cdGlmIChjdXN0b21QYXRoICYmIGZzLmV4aXN0c1N5bmMoY3VzdG9tUGF0aCkpIHtcblx0XHRkZWJ1ZyhgTWVyZ2luZyBjdXN0b20gdGhyZXNob2xkcyBmcm9tIGZpbGU6ICR7Y3VzdG9tUGF0aH1gKVxuXHRcdGxldCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGN1c3RvbVBhdGgsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSlcblx0XHRsZXQgY3VzdG9tQ29uZmlnID0gYXdhaXQgcGFyc2VUaHJlc2hvbGRzWWFtbChjb250ZW50KVxuXHRcdGlmIChjdXN0b21Db25maWcpIHtcblx0XHRcdGNvbmZpZyA9IG1lcmdlVGhyZXNob2xkQ29uZmlncyhjb25maWcsIGN1c3RvbUNvbmZpZylcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29uZmlnXG59XG5cbi8qKlxuICogTWF0Y2ggbWV0cmljIG5hbWUgYWdhaW5zdCBwYXR0ZXJuIChzdXBwb3J0cyB3aWxkY2FyZHMpXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUGF0dGVybihtZXRyaWNOYW1lOiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyk6IGJvb2xlYW4ge1xuXHQvLyBDb252ZXJ0IGdsb2IgcGF0dGVybiB0byByZWdleFxuXHRsZXQgcmVnZXhQYXR0ZXJuID0gcGF0dGVyblxuXHRcdC5yZXBsYWNlKC9cXCovZywgJy4qJykgLy8gKiAtPiAuKlxuXHRcdC5yZXBsYWNlKC9cXD8vZywgJy4nKSAvLyA/IC0+IC5cblxuXHRsZXQgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHtyZWdleFBhdHRlcm59JGAsICdpJylcblx0cmV0dXJuIHJlZ2V4LnRlc3QobWV0cmljTmFtZSlcbn1cblxuLyoqXG4gKiBGaW5kIG1hdGNoaW5nIHRocmVzaG9sZCBmb3IgbWV0cmljIChleGFjdCBtYXRjaCBmaXJzdCwgdGhlbiBwYXR0ZXJuKVxuICovXG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdUaHJlc2hvbGQobWV0cmljTmFtZTogc3RyaW5nLCBjb25maWc6IFRocmVzaG9sZENvbmZpZyk6IE1ldHJpY1RocmVzaG9sZCB8IG51bGwge1xuXHRpZiAoIWNvbmZpZy5tZXRyaWNzKSByZXR1cm4gbnVsbFxuXG5cdC8vIEZpcnN0IHBhc3M6IGV4YWN0IG1hdGNoIChoaWdoZXN0IHByaW9yaXR5KVxuXHRmb3IgKGxldCB0aHJlc2hvbGQgb2YgY29uZmlnLm1ldHJpY3MpIHtcblx0XHRpZiAodGhyZXNob2xkLm5hbWUgJiYgdGhyZXNob2xkLm5hbWUgPT09IG1ldHJpY05hbWUpIHtcblx0XHRcdHJldHVybiB0aHJlc2hvbGRcblx0XHR9XG5cdH1cblxuXHQvLyBTZWNvbmQgcGFzczogcGF0dGVybiBtYXRjaFxuXHRmb3IgKGxldCB0aHJlc2hvbGQgb2YgY29uZmlnLm1ldHJpY3MpIHtcblx0XHRpZiAodGhyZXNob2xkLnBhdHRlcm4gJiYgbWF0Y2hQYXR0ZXJuKG1ldHJpY05hbWUsIHRocmVzaG9sZC5wYXR0ZXJuKSkge1xuXHRcdFx0cmV0dXJuIHRocmVzaG9sZFxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsXG59XG5cbi8qKlxuICogRXZhbHVhdGUgdGhyZXNob2xkIGZvciBhIG1ldHJpYyBjb21wYXJpc29uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldmFsdWF0ZVRocmVzaG9sZChjb21wYXJpc29uOiBNZXRyaWNDb21wYXJpc29uLCBjb25maWc6IFRocmVzaG9sZENvbmZpZyk6IFRocmVzaG9sZFNldmVyaXR5IHtcblx0Ly8gQ2FuJ3QgZXZhbHVhdGUgd2l0aG91dCBiYXNlXG5cdGlmICghY29tcGFyaXNvbi5iYXNlLmF2YWlsYWJsZSkge1xuXHRcdHJldHVybiAnc3VjY2Vzcydcblx0fVxuXG5cdGxldCB0aHJlc2hvbGQgPSBmaW5kTWF0Y2hpbmdUaHJlc2hvbGQoY29tcGFyaXNvbi5uYW1lLCBjb25maWcpXG5cblx0Ly8gQ2hlY2sgYWJzb2x1dGUgdmFsdWUgdGhyZXNob2xkcyBmaXJzdFxuXHRpZiAodGhyZXNob2xkKSB7XG5cdFx0Ly8gQ2hlY2sgY3JpdGljYWxfbWluXG5cdFx0aWYgKHRocmVzaG9sZC5jcml0aWNhbF9taW4gIT09IHVuZGVmaW5lZCAmJiBjb21wYXJpc29uLmN1cnJlbnQudmFsdWUgPCB0aHJlc2hvbGQuY3JpdGljYWxfbWluKSB7XG5cdFx0XHRkZWJ1ZyhgJHtjb21wYXJpc29uLm5hbWV9OiBiZWxvdyBjcml0aWNhbF9taW4gKCR7Y29tcGFyaXNvbi5jdXJyZW50LnZhbHVlfSA8ICR7dGhyZXNob2xkLmNyaXRpY2FsX21pbn0pYClcblx0XHRcdHJldHVybiAnZmFpbHVyZSdcblx0XHR9XG5cblx0XHQvLyBDaGVjayB3YXJuaW5nX21pblxuXHRcdGlmICh0aHJlc2hvbGQud2FybmluZ19taW4gIT09IHVuZGVmaW5lZCAmJiBjb21wYXJpc29uLmN1cnJlbnQudmFsdWUgPCB0aHJlc2hvbGQud2FybmluZ19taW4pIHtcblx0XHRcdGRlYnVnKGAke2NvbXBhcmlzb24ubmFtZX06IGJlbG93IHdhcm5pbmdfbWluICgke2NvbXBhcmlzb24uY3VycmVudC52YWx1ZX0gPCAke3RocmVzaG9sZC53YXJuaW5nX21pbn0pYClcblx0XHRcdHJldHVybiAnd2FybmluZydcblx0XHR9XG5cblx0XHQvLyBDaGVjayBjcml0aWNhbF9tYXhcblx0XHRpZiAodGhyZXNob2xkLmNyaXRpY2FsX21heCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmlzb24uY3VycmVudC52YWx1ZSA+IHRocmVzaG9sZC5jcml0aWNhbF9tYXgpIHtcblx0XHRcdGRlYnVnKGAke2NvbXBhcmlzb24ubmFtZX06IGFib3ZlIGNyaXRpY2FsX21heCAoJHtjb21wYXJpc29uLmN1cnJlbnQudmFsdWV9ID4gJHt0aHJlc2hvbGQuY3JpdGljYWxfbWF4fSlgKVxuXHRcdFx0cmV0dXJuICdmYWlsdXJlJ1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIHdhcm5pbmdfbWF4XG5cdFx0aWYgKHRocmVzaG9sZC53YXJuaW5nX21heCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmlzb24uY3VycmVudC52YWx1ZSA+IHRocmVzaG9sZC53YXJuaW5nX21heCkge1xuXHRcdFx0ZGVidWcoYCR7Y29tcGFyaXNvbi5uYW1lfTogYWJvdmUgd2FybmluZ19tYXggKCR7Y29tcGFyaXNvbi5jdXJyZW50LnZhbHVlfSA+ICR7dGhyZXNob2xkLndhcm5pbmdfbWF4fSlgKVxuXHRcdFx0cmV0dXJuICd3YXJuaW5nJ1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGNoYW5nZSBwZXJjZW50IHRocmVzaG9sZHNcblx0aWYgKCFpc05hTihjb21wYXJpc29uLmNoYW5nZS5wZXJjZW50KSkge1xuXHRcdGxldCBjaGFuZ2VQZXJjZW50ID0gTWF0aC5hYnMoY29tcGFyaXNvbi5jaGFuZ2UucGVyY2VudClcblxuXHRcdC8vIFVzZSBtZXRyaWMtc3BlY2lmaWMgb3IgZGVmYXVsdCB0aHJlc2hvbGRzXG5cdFx0bGV0IHdhcm5pbmdUaHJlc2hvbGQgPSB0aHJlc2hvbGQ/Lndhcm5pbmdfY2hhbmdlX3BlcmNlbnQgPz8gY29uZmlnLmRlZmF1bHQud2FybmluZ19jaGFuZ2VfcGVyY2VudFxuXHRcdGxldCBjcml0aWNhbFRocmVzaG9sZCA9IHRocmVzaG9sZD8uY3JpdGljYWxfY2hhbmdlX3BlcmNlbnQgPz8gY29uZmlnLmRlZmF1bHQuY3JpdGljYWxfY2hhbmdlX3BlcmNlbnRcblxuXHRcdC8vIE9ubHkgdHJpZ2dlciBpZiBjaGFuZ2UgaXMgaW4gXCJ3b3JzZVwiIGRpcmVjdGlvblxuXHRcdGlmIChjb21wYXJpc29uLmNoYW5nZS5kaXJlY3Rpb24gPT09ICd3b3JzZScpIHtcblx0XHRcdGlmIChjaGFuZ2VQZXJjZW50ID4gY3JpdGljYWxUaHJlc2hvbGQpIHtcblx0XHRcdFx0ZGVidWcoYCR7Y29tcGFyaXNvbi5uYW1lfTogY3JpdGljYWwgcmVncmVzc2lvbiAoJHtjaGFuZ2VQZXJjZW50LnRvRml4ZWQoMSl9JSA+ICR7Y3JpdGljYWxUaHJlc2hvbGR9JSlgKVxuXHRcdFx0XHRyZXR1cm4gJ2ZhaWx1cmUnXG5cdFx0XHR9XG5cblx0XHRcdGlmIChjaGFuZ2VQZXJjZW50ID4gd2FybmluZ1RocmVzaG9sZCkge1xuXHRcdFx0XHRkZWJ1ZyhgJHtjb21wYXJpc29uLm5hbWV9OiB3YXJuaW5nIHJlZ3Jlc3Npb24gKCR7Y2hhbmdlUGVyY2VudC50b0ZpeGVkKDEpfSUgPiAke3dhcm5pbmdUaHJlc2hvbGR9JSlgKVxuXHRcdFx0XHRyZXR1cm4gJ3dhcm5pbmcnXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuICdzdWNjZXNzJ1xufVxuXG4vKipcbiAqIEV2YWx1YXRlIGFsbCBtZXRyaWNzIGFuZCByZXR1cm4gb3ZlcmFsbCBzZXZlcml0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVXb3JrbG9hZFRocmVzaG9sZHMoXG5cdGNvbXBhcmlzb25zOiBNZXRyaWNDb21wYXJpc29uW10sXG5cdGNvbmZpZzogVGhyZXNob2xkQ29uZmlnXG4pOiB7XG5cdG92ZXJhbGw6IFRocmVzaG9sZFNldmVyaXR5XG5cdGZhaWx1cmVzOiBNZXRyaWNDb21wYXJpc29uW11cblx0d2FybmluZ3M6IE1ldHJpY0NvbXBhcmlzb25bXVxufSB7XG5cdGxldCBmYWlsdXJlczogTWV0cmljQ29tcGFyaXNvbltdID0gW11cblx0bGV0IHdhcm5pbmdzOiBNZXRyaWNDb21wYXJpc29uW10gPSBbXVxuXG5cdGZvciAobGV0IGNvbXBhcmlzb24gb2YgY29tcGFyaXNvbnMpIHtcblx0XHRsZXQgc2V2ZXJpdHkgPSBldmFsdWF0ZVRocmVzaG9sZChjb21wYXJpc29uLCBjb25maWcpXG5cblx0XHRpZiAoc2V2ZXJpdHkgPT09ICdmYWlsdXJlJykge1xuXHRcdFx0ZmFpbHVyZXMucHVzaChjb21wYXJpc29uKVxuXHRcdH0gZWxzZSBpZiAoc2V2ZXJpdHkgPT09ICd3YXJuaW5nJykge1xuXHRcdFx0d2FybmluZ3MucHVzaChjb21wYXJpc29uKVxuXHRcdH1cblx0fVxuXG5cdGxldCBvdmVyYWxsOiBUaHJlc2hvbGRTZXZlcml0eSA9ICdzdWNjZXNzJ1xuXHRpZiAoZmFpbHVyZXMubGVuZ3RoID4gMCkge1xuXHRcdG92ZXJhbGwgPSAnZmFpbHVyZSdcblx0fSBlbHNlIGlmICh3YXJuaW5ncy5sZW5ndGggPiAwKSB7XG5cdFx0b3ZlcmFsbCA9ICd3YXJuaW5nJ1xuXHR9XG5cblx0cmV0dXJuIHsgb3ZlcmFsbCwgZmFpbHVyZXMsIHdhcm5pbmdzIH1cbn1cbiIKICBdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7QUFRQSw4Q0FDQTtBQUxBO0FBQ0E7QUFDQTtBQWlDQSxlQUFlLG1CQUFtQixDQUFDLGFBQXNEO0FBQUEsRUFDeEYsSUFBSSxDQUFDLGVBQWUsWUFBWSxLQUFLLE1BQU07QUFBQSxJQUMxQyxPQUFPO0FBQUEsRUFHUixJQUFJO0FBQUEsSUFDSCxJQUFJLFNBQW1CLENBQUM7QUFBQSxJQUV4QixNQUFNLGlCQUFLLE1BQU0sQ0FBQyxXQUFXLEdBQUcsR0FBRztBQUFBLE1BQ2xDLE9BQU8sT0FBTyxLQUFLLGFBQWEsT0FBTztBQUFBLE1BQ3ZDLFFBQVE7QUFBQSxNQUNSLFdBQVc7QUFB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TUFHUixJQUFJLGdCQUFnQjtBQUFBLFFBRW5CLE9BREEsa0JBQU0sR0FBRyxXQUFXLDZCQUE2QixjQUFjLFFBQVEsQ0FBQyxRQUFRLG9CQUFvQixHQUM3RjtBQUFBO0FBQUE7QUFBQSxFQUtWLE9BQU87QUFBQTtBQU1ELFNBQVMsMEJBQTBCLENBQ3pDLGFBQ0EsUUFLQztBQUFBLEVBQ0QsSUFBSSxXQUErQixDQUFDLEdBQ2hDLFdBQStCLENBQUM7QUFBQSxFQUVwQyxTQUFTLGNBQWMsYUFBYTtBQUFBLElBQ25DLElBQUksV0FBVyxrQkFBa0IsWUFBWSxNQUFNO0FBQUEsSUFFbkQsSUFBSSxhQUFhO0FBQUEsTUFDaEIsU0FBUyxLQUFLLFVBQVU7QUFBQSxJQUNsQixTQUFJLGFBQWE7QUFBQSxNQUN2QixTQUFTLEtBQUssVUFBVTtBQUFBO0FBQUEsRUFJMUIsSUFBSSxVQUE2QjtBQUFBLEVBQ2pDLElBQUksU0FBUyxTQUFTO0FBQUEsSUFDckIsVUFBVTtBQUFBLEVBQ0osU0FBSSxTQUFTLFNBQVM7QUFBQSxJQUM1QixVQUFVO0FBQUEsRUFHWCxPQUFPLEVBQUUsU0FBUyxVQUFVLFNBQVM7QUFBQTsiLAogICJkZWJ1Z0lkIjogIjRCMjdBNDcyN0MzNEEyMjQ2NDc1NkUyMTY0NzU2RTIxIiwKICAibmFtZXMiOiBbXQp9
