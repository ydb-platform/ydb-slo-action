import { createRequire } from "node:module";
var __create = Object.create;
var { getPrototypeOf: __getProtoOf, defineProperty: __defProp, getOwnPropertyNames: __getOwnPropNames } = Object;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: !0
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, _a;
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
  exports.readlink = readlink;
  exports.exists = exists;
  exports.isDirectory = isDirectory;
  exports.isRooted = isRooted;
  exports.tryGetExecutablePath = tryGetExecutablePath;
  exports.getCmdPath = getCmdPath;
  var fs = __importStar(__require("fs")), path = __importStar(__require("path"));
  _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
  exports.IS_WINDOWS = process.platform === "win32";
  function readlink(fsPath) {
    return __awaiter(this, void 0, void 0, function* () {
      let result = yield fs.promises.readlink(fsPath);
      if (exports.IS_WINDOWS && !result.endsWith("\\"))
        return `${result}\\`;
      return result;
    });
  }
  exports.UV_FS_O_EXLOCK = 268435456;
  exports.READONLY = fs.constants.O_RDONLY;
  function exists(fsPath) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield (0, exports.stat)(fsPath);
      } catch (err) {
        if (err.code === "ENOENT")
          return !1;
        throw err;
      }
      return !0;
    });
  }
  function isDirectory(fsPath_1) {
    return __awaiter(this, arguments, void 0, function* (fsPath, useStat = !1) {
      return (useStat ? yield (0, exports.stat)(fsPath) : yield (0, exports.lstat)(fsPath)).isDirectory();
    });
  }
  function isRooted(p) {
    if (p = normalizeSeparators(p), !p)
      throw Error('isRooted() parameter "p" cannot be empty');
    if (exports.IS_WINDOWS)
      return p.startsWith("\\") || /^[A-Z]:/i.test(p);
    return p.startsWith("/");
  }
  function tryGetExecutablePath(filePath, extensions) {
    return __awaiter(this, void 0, void 0, function* () {
      let stats = void 0;
      try {
        stats = yield (0, exports.stat)(filePath);
      } catch (err) {
        if (err.code !== "ENOENT")
          console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
      }
      if (stats && stats.isFile()) {
        if (exports.IS_WINDOWS) {
          let upperExt = path.extname(filePath).toUpperCase();
          if (extensions.some((validExt) => validExt.toUpperCase() === upperExt))
            return filePath;
        } else if (isUnixExecutable(stats))
          return filePath;
      }
      let originalFilePath = filePath;
      for (let extension of extensions) {
        filePath = originalFilePath + extension, stats = void 0;
        try {
          stats = yield (0, exports.stat)(filePath);
        } catch (err) {
          if (err.code !== "ENOENT")
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            try {
              let directory = path.dirname(filePath), upperName = path.basename(filePath).toUpperCase();
              for (let actualName of yield (0, exports.readdir)(directory))
                if (upperName === actualName.toUpperCase()) {
                  filePath = path.join(directory, actualName);
                  break;
                }
            } catch (err) {
              console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
            }
            return filePath;
          } else if (isUnixExecutable(stats))
            return filePath;
        }
      }
      return "";
    });
  }
  function normalizeSeparators(p) {
    if (p = p || "", exports.IS_WINDOWS)
      return p = p.replace(/\//g, "\\"), p.replace(/\\\\+/g, "\\");
    return p.replace(/\/\/+/g, "/");
  }
  function isUnixExecutable(stats) {
    return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && process.getgid !== void 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && process.getuid !== void 0 && stats.uid === process.getuid();
  }
  function getCmdPath() {
    var _a2;
    return (_a2 = process.env.COMSPEC) !== null && _a2 !== void 0 ? _a2 : "cmd.exe";
  }
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.cp = cp;
  exports.mv = mv;
  exports.rmRF = rmRF;
  exports.mkdirP = mkdirP;
  exports.which = which;
  exports.findInPath = findInPath;
  var assert_1 = __require("assert"), path = __importStar(__require("path")), ioUtil = __importStar(require_io_util());
  function cp(source_1, dest_1) {
    return __awaiter(this, arguments, void 0, function* (source, dest, options = {}) {
      let { force, recursive, copySourceDirectory } = readCopyOptions(options), destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
      if (destStat && destStat.isFile() && !force)
        return;
      let newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
      if (!(yield ioUtil.exists(source)))
        throw Error(`no such file or directory: ${source}`);
      if ((yield ioUtil.stat(source)).isDirectory())
        if (!recursive)
          throw Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
        else
          yield cpDirRecursive(source, newDest, 0, force);
      else {
        if (path.relative(source, newDest) === "")
          throw Error(`'${newDest}' and '${source}' are the same file`);
        yield copyFile(source, newDest, force);
      }
    });
  }
  function mv(source_1, dest_1) {
    return __awaiter(this, arguments, void 0, function* (source, dest, options = {}) {
      if (yield ioUtil.exists(dest)) {
        let destExists = !0;
        if (yield ioUtil.isDirectory(dest))
          dest = path.join(dest, path.basename(source)), destExists = yield ioUtil.exists(dest);
        if (destExists)
          if (options.force == null || options.force)
            yield rmRF(dest);
          else
            throw Error("Destination already exists");
      }
      yield mkdirP(path.dirname(dest)), yield ioUtil.rename(source, dest);
    });
  }
  function rmRF(inputPath) {
    return __awaiter(this, void 0, void 0, function* () {
      if (ioUtil.IS_WINDOWS) {
        if (/[*"<>|]/.test(inputPath))
          throw Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
      }
      try {
        yield ioUtil.rm(inputPath, {
          force: !0,
          maxRetries: 3,
          recursive: !0,
          retryDelay: 300
        });
      } catch (err) {
        throw Error(`File was unable to be removed ${err}`);
      }
    });
  }
  function mkdirP(fsPath) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, assert_1.ok)(fsPath, "a path argument must be provided"), yield ioUtil.mkdir(fsPath, { recursive: !0 });
    });
  }
  function which(tool, check) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!tool)
        throw Error("parameter 'tool' is required");
      if (check) {
        let result = yield which(tool, !1);
        if (!result)
          if (ioUtil.IS_WINDOWS)
            throw Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
          else
            throw Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
        return result;
      }
      let matches = yield findInPath(tool);
      if (matches && matches.length > 0)
        return matches[0];
      return "";
    });
  }
  function findInPath(tool) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!tool)
        throw Error("parameter 'tool' is required");
      let extensions = [];
      if (ioUtil.IS_WINDOWS && process.env.PATHEXT) {
        for (let extension of process.env.PATHEXT.split(path.delimiter))
          if (extension)
            extensions.push(extension);
      }
      if (ioUtil.isRooted(tool)) {
        let filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
        if (filePath)
          return [filePath];
        return [];
      }
      if (tool.includes(path.sep))
        return [];
      let directories = [];
      if (process.env.PATH) {
        for (let p of process.env.PATH.split(path.delimiter))
          if (p)
            directories.push(p);
      }
      let matches = [];
      for (let directory of directories) {
        let filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
        if (filePath)
          matches.push(filePath);
      }
      return matches;
    });
  }
  function readCopyOptions(options) {
    let force = options.force == null ? !0 : options.force, recursive = Boolean(options.recursive), copySourceDirectory = options.copySourceDirectory == null ? !0 : Boolean(options.copySourceDirectory);
    return { force, recursive, copySourceDirectory };
  }
  function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
    return __awaiter(this, void 0, void 0, function* () {
      if (currentDepth >= 255)
        return;
      currentDepth++, yield mkdirP(destDir);
      let files = yield ioUtil.readdir(sourceDir);
      for (let fileName of files) {
        let srcFile = `${sourceDir}/${fileName}`, destFile = `${destDir}/${fileName}`;
        if ((yield ioUtil.lstat(srcFile)).isDirectory())
          yield cpDirRecursive(srcFile, destFile, currentDepth, force);
        else
          yield copyFile(srcFile, destFile, force);
      }
      yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
    });
  }
  function copyFile(srcFile, destFile, force) {
    return __awaiter(this, void 0, void 0, function* () {
      if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
        try {
          yield ioUtil.lstat(destFile), yield ioUtil.unlink(destFile);
        } catch (e) {
          if (e.code === "EPERM")
            yield ioUtil.chmod(destFile, "0666"), yield ioUtil.unlink(destFile);
        }
        let symlinkFull = yield ioUtil.readlink(srcFile);
        yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
      } else if (!(yield ioUtil.exists(destFile)) || force)
        yield ioUtil.copyFile(srcFile, destFile);
    });
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ToolRunner = void 0;
  exports.argStringToArray = argStringToArray;
  var os = __importStar(__require("os")), events = __importStar(__require("events")), child = __importStar(__require("child_process")), path = __importStar(__require("path")), io = __importStar(require_io()), ioUtil = __importStar(require_io_util()), timers_1 = __require("timers"), IS_WINDOWS = process.platform === "win32";

  class ToolRunner extends events.EventEmitter {
    constructor(toolPath, args, options) {
      super();
      if (!toolPath)
        throw Error("Parameter 'toolPath' cannot be null or empty.");
      this.toolPath = toolPath, this.args = args || [], this.options = options || {};
    }
    _debug(message) {
      if (this.options.listeners && this.options.listeners.debug)
        this.options.listeners.debug(message);
    }
    _getCommandString(options, noPrefix) {
      let toolPath = this._getSpawnFileName(), args = this._getSpawnArgs(options), cmd = noPrefix ? "" : "[command]";
      if (IS_WINDOWS)
        if (this._isCmdFile()) {
          cmd += toolPath;
          for (let a of args)
            cmd += ` ${a}`;
        } else if (options.windowsVerbatimArguments) {
          cmd += `"${toolPath}"`;
          for (let a of args)
            cmd += ` ${a}`;
        } else {
          cmd += this._windowsQuoteCmdArg(toolPath);
          for (let a of args)
            cmd += ` ${this._windowsQuoteCmdArg(a)}`;
        }
      else {
        cmd += toolPath;
        for (let a of args)
          cmd += ` ${a}`;
      }
      return cmd;
    }
    _processLineBuffer(data, strBuffer, onLine) {
      try {
        let s = strBuffer + data.toString(), n = s.indexOf(os.EOL);
        while (n > -1) {
          let line = s.substring(0, n);
          onLine(line), s = s.substring(n + os.EOL.length), n = s.indexOf(os.EOL);
        }
        return s;
      } catch (err) {
        return this._debug(`error processing line. Failed with error ${err}`), "";
      }
    }
    _getSpawnFileName() {
      if (IS_WINDOWS) {
        if (this._isCmdFile())
          return process.env.COMSPEC || "cmd.exe";
      }
      return this.toolPath;
    }
    _getSpawnArgs(options) {
      if (IS_WINDOWS) {
        if (this._isCmdFile()) {
          let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
          for (let a of this.args)
            argline += " ", argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
          return argline += '"', [argline];
        }
      }
      return this.args;
    }
    _endsWith(str, end) {
      return str.endsWith(end);
    }
    _isCmdFile() {
      let upperToolPath = this.toolPath.toUpperCase();
      return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
    }
    _windowsQuoteCmdArg(arg) {
      if (!this._isCmdFile())
        return this._uvQuoteCmdArg(arg);
      if (!arg)
        return '""';
      let cmdSpecialChars = [
        " ",
        "\t",
        "&",
        "(",
        ")",
        "[",
        "]",
        "{",
        "}",
        "^",
        "=",
        ";",
        "!",
        "'",
        "+",
        ",",
        "`",
        "~",
        "|",
        "<",
        ">",
        '"'
      ], needsQuotes = !1;
      for (let char of arg)
        if (cmdSpecialChars.some((x) => x === char)) {
          needsQuotes = !0;
          break;
        }
      if (!needsQuotes)
        return arg;
      let reverse = '"', quoteHit = !0;
      for (let i = arg.length;i > 0; i--)
        if (reverse += arg[i - 1], quoteHit && arg[i - 1] === "\\")
          reverse += "\\";
        else if (arg[i - 1] === '"')
          quoteHit = !0, reverse += '"';
        else
          quoteHit = !1;
      return reverse += '"', reverse.split("").reverse().join("");
    }
    _uvQuoteCmdArg(arg) {
      if (!arg)
        return '""';
      if (!arg.includes(" ") && !arg.includes("\t") && !arg.includes('"'))
        return arg;
      if (!arg.includes('"') && !arg.includes("\\"))
        return `"${arg}"`;
      let reverse = '"', quoteHit = !0;
      for (let i = arg.length;i > 0; i--)
        if (reverse += arg[i - 1], quoteHit && arg[i - 1] === "\\")
          reverse += "\\";
        else if (arg[i - 1] === '"')
          quoteHit = !0, reverse += "\\";
        else
          quoteHit = !1;
      return reverse += '"', reverse.split("").reverse().join("");
    }
    _cloneExecOptions(options) {
      options = options || {};
      let result = {
        cwd: options.cwd || process.cwd(),
        env: options.env || process.env,
        silent: options.silent || !1,
        windowsVerbatimArguments: options.windowsVerbatimArguments || !1,
        failOnStdErr: options.failOnStdErr || !1,
        ignoreReturnCode: options.ignoreReturnCode || !1,
        delay: options.delay || 1e4
      };
      return result.outStream = options.outStream || process.stdout, result.errStream = options.errStream || process.stderr, result;
    }
    _getSpawnOptions(options, toolPath) {
      options = options || {};
      let result = {};
      if (result.cwd = options.cwd, result.env = options.env, result.windowsVerbatimArguments = options.windowsVerbatimArguments || this._isCmdFile(), options.windowsVerbatimArguments)
        result.argv0 = `"${toolPath}"`;
      return result;
    }
    exec() {
      return __awaiter(this, void 0, void 0, function* () {
        if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\")))
          this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
        return this.toolPath = yield io.which(this.toolPath, !0), new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          this._debug(`exec tool: ${this.toolPath}`), this._debug("arguments:");
          for (let arg of this.args)
            this._debug(`   ${arg}`);
          let optionsNonNull = this._cloneExecOptions(this.options);
          if (!optionsNonNull.silent && optionsNonNull.outStream)
            optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
          let state = new ExecState(optionsNonNull, this.toolPath);
          if (state.on("debug", (message) => {
            this._debug(message);
          }), this.options.cwd && !(yield ioUtil.exists(this.options.cwd)))
            return reject(Error(`The cwd: ${this.options.cwd} does not exist!`));
          let fileName = this._getSpawnFileName(), cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName)), stdbuffer = "";
          if (cp.stdout)
            cp.stdout.on("data", (data) => {
              if (this.options.listeners && this.options.listeners.stdout)
                this.options.listeners.stdout(data);
              if (!optionsNonNull.silent && optionsNonNull.outStream)
                optionsNonNull.outStream.write(data);
              stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.stdline)
                  this.options.listeners.stdline(line);
              });
            });
          let errbuffer = "";
          if (cp.stderr)
            cp.stderr.on("data", (data) => {
              if (state.processStderr = !0, this.options.listeners && this.options.listeners.stderr)
                this.options.listeners.stderr(data);
              if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream)
                (optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream).write(data);
              errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                if (this.options.listeners && this.options.listeners.errline)
                  this.options.listeners.errline(line);
              });
            });
          if (cp.on("error", (err) => {
            state.processError = err.message, state.processExited = !0, state.processClosed = !0, state.CheckComplete();
          }), cp.on("exit", (code) => {
            state.processExitCode = code, state.processExited = !0, this._debug(`Exit code ${code} received from tool '${this.toolPath}'`), state.CheckComplete();
          }), cp.on("close", (code) => {
            state.processExitCode = code, state.processExited = !0, state.processClosed = !0, this._debug(`STDIO streams have closed for tool '${this.toolPath}'`), state.CheckComplete();
          }), state.on("done", (error, exitCode) => {
            if (stdbuffer.length > 0)
              this.emit("stdline", stdbuffer);
            if (errbuffer.length > 0)
              this.emit("errline", errbuffer);
            if (cp.removeAllListeners(), error)
              reject(error);
            else
              resolve(exitCode);
          }), this.options.input) {
            if (!cp.stdin)
              throw Error("child process missing stdin");
            cp.stdin.end(this.options.input);
          }
        }));
      });
    }
  }
  exports.ToolRunner = ToolRunner;
  function argStringToArray(argString) {
    let args = [], inQuotes = !1, escaped = !1, arg = "";
    function append(c) {
      if (escaped && c !== '"')
        arg += "\\";
      arg += c, escaped = !1;
    }
    for (let i = 0;i < argString.length; i++) {
      let c = argString.charAt(i);
      if (c === '"') {
        if (!escaped)
          inQuotes = !inQuotes;
        else
          append(c);
        continue;
      }
      if (c === "\\" && escaped) {
        append(c);
        continue;
      }
      if (c === "\\" && inQuotes) {
        escaped = !0;
        continue;
      }
      if (c === " " && !inQuotes) {
        if (arg.length > 0)
          args.push(arg), arg = "";
        continue;
      }
      append(c);
    }
    if (arg.length > 0)
      args.push(arg.trim());
    return args;
  }

  class ExecState extends events.EventEmitter {
    constructor(options, toolPath) {
      super();
      if (this.processClosed = !1, this.processError = "", this.processExitCode = 0, this.processExited = !1, this.processStderr = !1, this.delay = 1e4, this.done = !1, this.timeout = null, !toolPath)
        throw Error("toolPath must not be empty");
      if (this.options = options, this.toolPath = toolPath, options.delay)
        this.delay = options.delay;
    }
    CheckComplete() {
      if (this.done)
        return;
      if (this.processClosed)
        this._setResult();
      else if (this.processExited)
        this.timeout = (0, timers_1.setTimeout)(ExecState.HandleTimeout, this.delay, this);
    }
    _debug(message) {
      this.emit("debug", message);
    }
    _setResult() {
      let error;
      if (this.processExited) {
        if (this.processError)
          error = Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
        else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode)
          error = Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
        else if (this.processStderr && this.options.failOnStdErr)
          error = Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
      }
      if (this.timeout)
        clearTimeout(this.timeout), this.timeout = null;
      this.done = !0, this.emit("done", error, this.processExitCode);
    }
    static HandleTimeout(state) {
      if (state.done)
        return;
      if (!state.processClosed && state.processExited) {
        let message = `The STDIO streams did not close within ${state.delay / 1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
        state._debug(message);
      }
      state._setResult();
    }
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.exec = exec;
  exports.getExecOutput = getExecOutput;
  var string_decoder_1 = __require("string_decoder"), tr = __importStar(require_toolrunner());
  function exec(commandLine, args, options) {
    return __awaiter(this, void 0, void 0, function* () {
      let commandArgs = tr.argStringToArray(commandLine);
      if (commandArgs.length === 0)
        throw Error("Parameter 'commandLine' cannot be null or empty.");
      let toolPath = commandArgs[0];
      return args = commandArgs.slice(1).concat(args || []), new tr.ToolRunner(toolPath, args, options).exec();
    });
  }
  function getExecOutput(commandLine, args, options) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a, _b;
      let stdout = "", stderr = "", stdoutDecoder = new string_decoder_1.StringDecoder("utf8"), stderrDecoder = new string_decoder_1.StringDecoder("utf8"), originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout, originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr, stdErrListener = (data) => {
        if (stderr += stderrDecoder.write(data), originalStdErrListener)
          originalStdErrListener(data);
      }, stdOutListener = (data) => {
        if (stdout += stdoutDecoder.write(data), originalStdoutListener)
          originalStdoutListener(data);
      }, listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener }), exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
      return stdout += stdoutDecoder.end(), stderr += stderrDecoder.end(), {
        exitCode,
        stdout,
        stderr
      };
    });
  }
});

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.toCommandValue = toCommandValue;
  exports.toCommandProperties = toCommandProperties;
  function toCommandValue(input) {
    if (input === null || input === void 0)
      return "";
    else if (typeof input === "string" || input instanceof String)
      return input;
    return JSON.stringify(input);
  }
  function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length)
      return {};
    return {
      title: annotationProperties.title,
      file: annotationProperties.file,
      line: annotationProperties.startLine,
      endLine: annotationProperties.endLine,
      col: annotationProperties.startColumn,
      endColumn: annotationProperties.endColumn
    };
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.issueCommand = issueCommand;
  exports.issue = issue;
  var os = __importStar(__require("os")), utils_1 = require_utils();
  function issueCommand(command, properties, message) {
    let cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
  }
  function issue(name, message = "") {
    issueCommand(name, {}, message);
  }
  var CMD_STRING = "::";

  class Command {
    constructor(command, properties, message) {
      if (!command)
        command = "missing.command";
      this.command = command, this.properties = properties, this.message = message;
    }
    toString() {
      let cmdStr = CMD_STRING + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        cmdStr += " ";
        let first = !0;
        for (let key in this.properties)
          if (this.properties.hasOwnProperty(key)) {
            let val = this.properties[key];
            if (val) {
              if (first)
                first = !1;
              else
                cmdStr += ",";
              cmdStr += `${key}=${escapeProperty(val)}`;
            }
          }
      }
      return cmdStr += `${CMD_STRING}${escapeData(this.message)}`, cmdStr;
    }
  }
  function escapeData(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  function escapeProperty(s) {
    return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.issueFileCommand = issueFileCommand;
  exports.prepareKeyValueMessage = prepareKeyValueMessage;
  var crypto2 = __importStar(__require("crypto")), fs = __importStar(__require("fs")), os = __importStar(__require("os")), utils_1 = require_utils();
  function issueFileCommand(command, message) {
    let filePath = process.env[`GITHUB_${command}`];
    if (!filePath)
      throw Error(`Unable to find environment variable for file command ${command}`);
    if (!fs.existsSync(filePath))
      throw Error(`Missing file at path: ${filePath}`);
    fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
      encoding: "utf8"
    });
  }
  function prepareKeyValueMessage(key, value) {
    let delimiter = `ghadelimiter_${crypto2.randomUUID()}`, convertedValue = (0, utils_1.toCommandValue)(value);
    if (key.includes(delimiter))
      throw Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    if (convertedValue.includes(delimiter))
      throw Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
  }
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getProxyUrl = getProxyUrl;
  exports.checkBypass = checkBypass;
  function getProxyUrl(reqUrl) {
    let usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl))
      return;
    let proxyVar = (() => {
      if (usingSsl)
        return process.env.https_proxy || process.env.HTTPS_PROXY;
      else
        return process.env.http_proxy || process.env.HTTP_PROXY;
    })();
    if (proxyVar)
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    else
      return;
  }
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname)
      return !1;
    let reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost))
      return !0;
    let noProxy = process.env.no_proxy || process.env.NO_PROXY || "";
    if (!noProxy)
      return !1;
    let reqPort;
    if (reqUrl.port)
      reqPort = Number(reqUrl.port);
    else if (reqUrl.protocol === "http:")
      reqPort = 80;
    else if (reqUrl.protocol === "https:")
      reqPort = 443;
    let upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number")
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    for (let upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x))
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`)))
        return !0;
    return !1;
  }
  function isLoopbackAddress(host) {
    let hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }

  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username), this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS((exports) => {
  var net = __require("net"), tls = __require("tls"), http = __require("http"), https = __require("https"), events = __require("events"), assert = __require("assert"), util = __require("util");
  exports.httpOverHttp = httpOverHttp;
  exports.httpsOverHttp = httpsOverHttp;
  exports.httpOverHttps = httpOverHttps;
  exports.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    return agent.request = http.request, agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    return agent.request = http.request, agent.createSocket = createSecureSocket, agent.defaultPort = 443, agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    return agent.request = https.request, agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    return agent.request = https.request, agent.createSocket = createSecureSocket, agent.defaultPort = 443, agent;
  }
  function TunnelingAgent(options) {
    var self2 = this;
    self2.options = options || {}, self2.proxyOptions = self2.options.proxy || {}, self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets, self2.requests = [], self2.sockets = [], self2.on("free", function(socket, host, port, localAddress) {
      var options2 = toOptions(host, port, localAddress);
      for (var i = 0, len = self2.requests.length;i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === options2.host && pending.port === options2.port) {
          self2.requests.splice(i, 1), pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy(), self2.removeSocket(socket);
    });
  }
  util.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function(req, host, port, localAddress) {
    var self2 = this, options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push(options);
      return;
    }
    self2.createSocket(options, function(socket) {
      socket.on("free", onFree), socket.on("close", onCloseOrRemove), socket.on("agentRemove", onCloseOrRemove), req.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, options);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket), socket.removeListener("free", onFree), socket.removeListener("close", onCloseOrRemove), socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function(options, cb) {
    var self2 = this, placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self2.proxyOptions, {
      method: "CONNECT",
      path: options.host + ":" + options.port,
      agent: !1,
      headers: {
        host: options.host + ":" + options.port
      }
    });
    if (options.localAddress)
      connectOptions.localAddress = options.localAddress;
    if (connectOptions.proxyAuth)
      connectOptions.headers = connectOptions.headers || {}, connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
    debug("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = !1, connectReq.once("response", onResponse), connectReq.once("upgrade", onUpgrade), connectReq.once("connect", onConnect), connectReq.once("error", onError), connectReq.end();
    function onResponse(res) {
      res.upgrade = !0;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      if (connectReq.removeAllListeners(), socket.removeAllListeners(), res.statusCode !== 200) {
        debug("tunneling socket could not be established, statusCode=%d", res.statusCode), socket.destroy();
        var error = Error("tunneling socket could not be established, statusCode=" + res.statusCode);
        error.code = "ECONNRESET", options.request.emit("error", error), self2.removeSocket(placeholder);
        return;
      }
      if (head.length > 0) {
        debug("got illegal response body from proxy"), socket.destroy();
        var error = Error("got illegal response body from proxy");
        error.code = "ECONNRESET", options.request.emit("error", error), self2.removeSocket(placeholder);
        return;
      }
      return debug("tunneling connection has established"), self2.sockets[self2.sockets.indexOf(placeholder)] = socket, cb(socket);
    }
    function onError(cause) {
      connectReq.removeAllListeners(), debug(`tunneling socket could not be established, cause=%s
`, cause.message, cause.stack);
      var error = Error("tunneling socket could not be established, cause=" + cause.message);
      error.code = "ECONNRESET", options.request.emit("error", error), self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1)
      return;
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending)
      this.createSocket(pending, function(socket2) {
        pending.request.onSocket(socket2);
      });
  };
  function createSecureSocket(options, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
      var hostHeader = options.request.getHeader("host"), tlsOptions = mergeOptions({}, self2.options, {
        socket,
        servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
      }), secureSocket = tls.connect(0, tlsOptions);
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket, cb(secureSocket);
    });
  }
  function toOptions(host, port, localAddress) {
    if (typeof host === "string")
      return {
        host,
        port,
        localAddress
      };
    return host;
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length;i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length;j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== void 0)
            target[k] = overrides[k];
        }
      }
    }
    return target;
  }
  var debug;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG))
    debug = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string")
        args[0] = "TUNNEL: " + args[0];
      else
        args.unshift("TUNNEL:");
      console.error.apply(console, args);
    };
  else
    debug = function() {};
  exports.debug = debug;
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS((exports, module) => {
  module.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kHeadersList: Symbol("headers list"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kHTTP2BuildRequest: Symbol("http2 build request"),
    kHTTP1BuildRequest: Symbol("http1 build request"),
    kHTTP2CopyHeaders: Symbol("http2 copy headers"),
    kHTTPConnVersion: Symbol("http connection version"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable")
  };
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS((exports, module) => {
  class UndiciError extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError", this.code = "UND_ERR";
    }
  }

  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ConnectTimeoutError), this.name = "ConnectTimeoutError", this.message = message || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }

  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersTimeoutError), this.name = "HeadersTimeoutError", this.message = message || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }

  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersOverflowError), this.name = "HeadersOverflowError", this.message = message || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }

  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, BodyTimeoutError), this.name = "BodyTimeoutError", this.message = message || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }

  class ResponseStatusCodeError extends UndiciError {
    constructor(message, statusCode, headers, body) {
      super(message);
      Error.captureStackTrace(this, ResponseStatusCodeError), this.name = "ResponseStatusCodeError", this.message = message || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = body, this.status = statusCode, this.statusCode = statusCode, this.headers = headers;
    }
  }

  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidArgumentError), this.name = "InvalidArgumentError", this.message = message || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
    }
  }

  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidReturnValueError), this.name = "InvalidReturnValueError", this.message = message || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }

  class RequestAbortedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestAbortedError), this.name = "AbortError", this.message = message || "Request aborted", this.code = "UND_ERR_ABORTED";
    }
  }

  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InformationalError), this.name = "InformationalError", this.message = message || "Request information", this.code = "UND_ERR_INFO";
    }
  }

  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestContentLengthMismatchError), this.name = "RequestContentLengthMismatchError", this.message = message || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseContentLengthMismatchError), this.name = "ResponseContentLengthMismatchError", this.message = message || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientDestroyedError), this.name = "ClientDestroyedError", this.message = message || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
    }
  }

  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientClosedError), this.name = "ClientClosedError", this.message = message || "The client is closed", this.code = "UND_ERR_CLOSED";
    }
  }

  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      Error.captureStackTrace(this, SocketError), this.name = "SocketError", this.message = message || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = socket;
    }
  }

  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError), this.name = "NotSupportedError", this.message = message || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }

  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError), this.name = "MissingUpstreamError", this.message = message || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }

  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      Error.captureStackTrace(this, HTTPParserError), this.name = "HTTPParserError", this.code = code ? `HPE_${code}` : void 0, this.data = data ? data.toString() : void 0;
    }
  }

  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseExceededMaxSizeError), this.name = "ResponseExceededMaxSizeError", this.message = message || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }

  class RequestRetryError extends UndiciError {
    constructor(message, code, { headers, data }) {
      super(message);
      Error.captureStackTrace(this, RequestRetryError), this.name = "RequestRetryError", this.message = message || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = code, this.data = data, this.headers = headers;
    }
  }
  module.exports = {
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError
  };
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS((exports, module) => {
  var headerNameLowerCasedRecord = {}, wellknownHeaderNames = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let i = 0;i < wellknownHeaderNames.length; ++i) {
    let key = wellknownHeaderNames[i], lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  module.exports = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  };
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS((exports, module) => {
  var assert = __require("assert"), { kDestroyed, kBodyUsed } = require_symbols(), { IncomingMessage } = __require("http"), stream = __require("stream"), net = __require("net"), { InvalidArgumentError } = require_errors(), { Blob: Blob2 } = __require("buffer"), nodeUtil = __require("util"), { stringify } = __require("querystring"), { headerNameLowerCasedRecord } = require_constants(), [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
  function nop() {}
  function isStream(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object) {
    return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
  function buildURL(url, queryParams) {
    if (url.includes("?") || url.includes("#"))
      throw Error('Query params cannot be passed when url already contains "?" or "#".');
    let stringified = stringify(queryParams);
    if (stringified)
      url += "?" + stringified;
    return url;
  }
  function parseURL(url) {
    if (typeof url === "string") {
      if (url = new URL(url), !/^https?:/.test(url.origin || url.protocol))
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      return url;
    }
    if (!url || typeof url !== "object")
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    if (!/^https?:/.test(url.origin || url.protocol))
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port)))
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      if (url.path != null && typeof url.path !== "string")
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      if (url.pathname != null && typeof url.pathname !== "string")
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      if (url.hostname != null && typeof url.hostname !== "string")
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      if (url.origin != null && typeof url.origin !== "string")
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      let port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80, origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`, path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin.endsWith("/"))
        origin = origin.substring(0, origin.length - 1);
      if (path && !path.startsWith("/"))
        path = `/${path}`;
      url = new URL(origin + path);
    }
    return url;
  }
  function parseOrigin(url) {
    if (url = parseURL(url), url.pathname !== "/" || url.search || url.hash)
      throw new InvalidArgumentError("invalid url");
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      let idx2 = host.indexOf("]");
      return assert(idx2 !== -1), host.substring(1, idx2);
    }
    let idx = host.indexOf(":");
    if (idx === -1)
      return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host)
      return null;
    assert.strictEqual(typeof host, "string");
    let servername = getHostname(host);
    if (net.isIP(servername))
      return "";
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return obj != null && typeof obj[Symbol.asyncIterator] === "function";
  }
  function isIterable(obj) {
    return obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function");
  }
  function bodyLength(body) {
    if (body == null)
      return 0;
    else if (isStream(body)) {
      let state = body._readableState;
      return state && state.objectMode === !1 && state.ended === !0 && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body))
      return body.size != null ? body.size : null;
    else if (isBuffer(body))
      return body.byteLength;
    return null;
  }
  function isDestroyed(stream2) {
    return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
  }
  function isReadableAborted(stream2) {
    let state = stream2 && stream2._readableState;
    return isDestroyed(stream2) && state && !state.endEmitted;
  }
  function destroy(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2))
      return;
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage)
        stream2.socket = null;
      stream2.destroy(err);
    } else if (err)
      process.nextTick((stream3, err2) => {
        stream3.emit("error", err2);
      }, stream2, err);
    if (stream2.destroyed !== !0)
      stream2[kDestroyed] = !0;
  }
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    let m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1000 : null;
  }
  function headerNameToString(value) {
    return headerNameLowerCasedRecord[value] || value.toLowerCase();
  }
  function parseHeaders(headers, obj = {}) {
    if (!Array.isArray(headers))
      return headers;
    for (let i = 0;i < headers.length; i += 2) {
      let key = headers[i].toString().toLowerCase(), val = obj[key];
      if (!val)
        if (Array.isArray(headers[i + 1]))
          obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
        else
          obj[key] = headers[i + 1].toString("utf8");
      else {
        if (!Array.isArray(val))
          val = [val], obj[key] = val;
        val.push(headers[i + 1].toString("utf8"));
      }
    }
    if ("content-length" in obj && "content-disposition" in obj)
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    return obj;
  }
  function parseRawHeaders(headers) {
    let ret = [], hasContentLength = !1, contentDispositionIdx = -1;
    for (let n = 0;n < headers.length; n += 2) {
      let key = headers[n + 0].toString(), val = headers[n + 1].toString("utf8");
      if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length"))
        ret.push(key, val), hasContentLength = !0;
      else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition"))
        contentDispositionIdx = ret.push(key, val) - 1;
      else
        ret.push(key, val);
    }
    if (hasContentLength && contentDispositionIdx !== -1)
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    return ret;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function validateHandler(handler, method, upgrade) {
    if (!handler || typeof handler !== "object")
      throw new InvalidArgumentError("handler must be an object");
    if (typeof handler.onConnect !== "function")
      throw new InvalidArgumentError("invalid onConnect method");
    if (typeof handler.onError !== "function")
      throw new InvalidArgumentError("invalid onError method");
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0)
      throw new InvalidArgumentError("invalid onBodySent method");
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function")
        throw new InvalidArgumentError("invalid onUpgrade method");
    } else {
      if (typeof handler.onHeaders !== "function")
        throw new InvalidArgumentError("invalid onHeaders method");
      if (typeof handler.onData !== "function")
        throw new InvalidArgumentError("invalid onData method");
      if (typeof handler.onComplete !== "function")
        throw new InvalidArgumentError("invalid onComplete method");
    }
  }
  function isDisturbed(body) {
    return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
  }
  function isErrored(body) {
    return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
  }
  function isReadable(body) {
    return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  async function* convertIterableToBuffer(iterable) {
    for await (let chunk of iterable)
      yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
  }
  var ReadableStream2;
  function ReadableStreamFrom(iterable) {
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    if (ReadableStream2.from)
      return ReadableStream2.from(convertIterableToBuffer(iterable));
    let iterator;
    return new ReadableStream2({
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      async pull(controller) {
        let { done, value } = await iterator.next();
        if (done)
          queueMicrotask(() => {
            controller.close();
          });
        else {
          let buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          controller.enqueue(new Uint8Array(buf));
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      }
    }, 0);
  }
  function isFormDataLike(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  }
  function throwIfAborted(signal) {
    if (!signal)
      return;
    if (typeof signal.throwIfAborted === "function")
      signal.throwIfAborted();
    else if (signal.aborted) {
      let err = Error("The operation was aborted");
      throw err.name = "AbortError", err;
    }
  }
  function addAbortListener(signal, listener) {
    if ("addEventListener" in signal)
      return signal.addEventListener("abort", listener, { once: !0 }), () => signal.removeEventListener("abort", listener);
    return signal.addListener("abort", listener), () => signal.removeListener("abort", listener);
  }
  var hasToWellFormed = !!String.prototype.toWellFormed;
  function toUSVString(val) {
    if (hasToWellFormed)
      return `${val}`.toWellFormed();
    else if (nodeUtil.toUSVString)
      return nodeUtil.toUSVString(val);
    return `${val}`;
  }
  function parseRangeHeader(range) {
    if (range == null || range === "")
      return { start: 0, end: null, size: null };
    let m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = !0;
  module.exports = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isReadableAborted,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    parseRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    throwIfAborted,
    addAbortListener,
    parseRangeHeader,
    nodeMajor,
    nodeMinor,
    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
  };
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS((exports, module) => {
  var fastNow = Date.now(), fastNowTimeout, fastTimers = [];
  function onTimeout() {
    fastNow = Date.now();
    let len = fastTimers.length, idx = 0;
    while (idx < len) {
      let timer = fastTimers[idx];
      if (timer.state === 0)
        timer.state = fastNow + timer.delay;
      else if (timer.state > 0 && fastNow >= timer.state)
        timer.state = -1, timer.callback(timer.opaque);
      if (timer.state === -1) {
        if (timer.state = -2, idx !== len - 1)
          fastTimers[idx] = fastTimers.pop();
        else
          fastTimers.pop();
        len -= 1;
      } else
        idx += 1;
    }
    if (fastTimers.length > 0)
      refreshTimeout();
  }
  function refreshTimeout() {
    if (fastNowTimeout && fastNowTimeout.refresh)
      fastNowTimeout.refresh();
    else if (clearTimeout(fastNowTimeout), fastNowTimeout = setTimeout(onTimeout, 1000), fastNowTimeout.unref)
      fastNowTimeout.unref();
  }

  class Timeout {
    constructor(callback, delay, opaque) {
      this.callback = callback, this.delay = delay, this.opaque = opaque, this.state = -2, this.refresh();
    }
    refresh() {
      if (this.state === -2) {
        if (fastTimers.push(this), !fastNowTimeout || fastTimers.length === 1)
          refreshTimeout();
      }
      this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  module.exports = {
    setTimeout(callback, delay, opaque) {
      return delay < 1000 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
    },
    clearTimeout(timeout) {
      if (timeout instanceof Timeout)
        timeout.clear();
      else
        clearTimeout(timeout);
    }
  };
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events").EventEmitter, inherits = __require("node:util").inherits;
  function SBMH(needle) {
    if (typeof needle === "string")
      needle = Buffer.from(needle);
    if (!Buffer.isBuffer(needle))
      throw TypeError("The needle has to be a String or a Buffer.");
    let needleLength = needle.length;
    if (needleLength === 0)
      throw Error("The needle cannot be an empty String/Buffer.");
    if (needleLength > 256)
      throw Error("The needle cannot have a length bigger than 256.");
    this.maxMatches = 1 / 0, this.matches = 0, this._occ = Array(256).fill(needleLength), this._lookbehind_size = 0, this._needle = needle, this._bufpos = 0, this._lookbehind = Buffer.alloc(needleLength);
    for (var i = 0;i < needleLength - 1; ++i)
      this._occ[needle[i]] = needleLength - 1 - i;
  }
  inherits(SBMH, EventEmitter);
  SBMH.prototype.reset = function() {
    this._lookbehind_size = 0, this.matches = 0, this._bufpos = 0;
  };
  SBMH.prototype.push = function(chunk, pos) {
    if (!Buffer.isBuffer(chunk))
      chunk = Buffer.from(chunk, "binary");
    let chlen = chunk.length;
    this._bufpos = pos || 0;
    let r;
    while (r !== chlen && this.matches < this.maxMatches)
      r = this._sbmh_feed(chunk);
    return r;
  };
  SBMH.prototype._sbmh_feed = function(data) {
    let len = data.length, needle = this._needle, needleLength = needle.length, lastNeedleChar = needle[needleLength - 1], pos = -this._lookbehind_size, ch;
    if (pos < 0) {
      while (pos < 0 && pos <= len - needleLength) {
        if (ch = this._sbmh_lookup_char(data, pos + needleLength - 1), ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1))
          return this._lookbehind_size = 0, ++this.matches, this.emit("info", !0), this._bufpos = pos + needleLength;
        pos += this._occ[ch];
      }
      if (pos < 0)
        while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))
          ++pos;
      if (pos >= 0)
        this.emit("info", !1, this._lookbehind, 0, this._lookbehind_size), this._lookbehind_size = 0;
      else {
        let bytesToCutOff = this._lookbehind_size + pos;
        if (bytesToCutOff > 0)
          this.emit("info", !1, this._lookbehind, 0, bytesToCutOff);
        return this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff), this._lookbehind_size -= bytesToCutOff, data.copy(this._lookbehind, this._lookbehind_size), this._lookbehind_size += len, this._bufpos = len, len;
      }
    }
    if (pos += (pos >= 0) * this._bufpos, data.indexOf(needle, pos) !== -1) {
      if (pos = data.indexOf(needle, pos), ++this.matches, pos > 0)
        this.emit("info", !0, data, this._bufpos, pos);
      else
        this.emit("info", !0);
      return this._bufpos = pos + needleLength;
    } else
      pos = len - needleLength;
    while (pos < len && (data[pos] !== needle[0] || Buffer.compare(data.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0))
      ++pos;
    if (pos < len)
      data.copy(this._lookbehind, 0, pos, pos + (len - pos)), this._lookbehind_size = len - pos;
    if (pos > 0)
      this.emit("info", !1, data, this._bufpos, pos < len ? pos : len);
    return this._bufpos = len, len;
  };
  SBMH.prototype._sbmh_lookup_char = function(data, pos) {
    return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
  };
  SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
    for (var i = 0;i < len; ++i)
      if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i])
        return !1;
    return !0;
  };
  module.exports = SBMH;
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS((exports, module) => {
  var inherits = __require("node:util").inherits, ReadableStream2 = __require("node:stream").Readable;
  function PartStream(opts) {
    ReadableStream2.call(this, opts);
  }
  inherits(PartStream, ReadableStream2);
  PartStream.prototype._read = function(n) {};
  module.exports = PartStream;
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS((exports, module) => {
  module.exports = function(limits, name, defaultLimit) {
    if (!limits || limits[name] === void 0 || limits[name] === null)
      return defaultLimit;
    if (typeof limits[name] !== "number" || isNaN(limits[name]))
      throw TypeError("Limit " + name + " is not a valid number");
    return limits[name];
  };
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events").EventEmitter, inherits = __require("node:util").inherits, getLimit = require_getLimit(), StreamSearch = require_sbmh(), B_DCRLF = Buffer.from(`\r
\r
`), RE_CRLF = /\r\n/g, RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
  function HeaderParser(cfg) {
    EventEmitter.call(this), cfg = cfg || {};
    let self2 = this;
    this.nread = 0, this.maxed = !1, this.npairs = 0, this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2000), this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 81920), this.buffer = "", this.header = {}, this.finished = !1, this.ss = new StreamSearch(B_DCRLF), this.ss.on("info", function(isMatch, data, start, end) {
      if (data && !self2.maxed) {
        if (self2.nread + end - start >= self2.maxHeaderSize)
          end = self2.maxHeaderSize - self2.nread + start, self2.nread = self2.maxHeaderSize, self2.maxed = !0;
        else
          self2.nread += end - start;
        self2.buffer += data.toString("binary", start, end);
      }
      if (isMatch)
        self2._finish();
    });
  }
  inherits(HeaderParser, EventEmitter);
  HeaderParser.prototype.push = function(data) {
    let r = this.ss.push(data);
    if (this.finished)
      return r;
  };
  HeaderParser.prototype.reset = function() {
    this.finished = !1, this.buffer = "", this.header = {}, this.ss.reset();
  };
  HeaderParser.prototype._finish = function() {
    if (this.buffer)
      this._parseHeader();
    this.ss.matches = this.ss.maxMatches;
    let header = this.header;
    this.header = {}, this.buffer = "", this.finished = !0, this.nread = this.npairs = 0, this.maxed = !1, this.emit("header", header);
  };
  HeaderParser.prototype._parseHeader = function() {
    if (this.npairs === this.maxHeaderPairs)
      return;
    let lines = this.buffer.split(RE_CRLF), len = lines.length, m, h;
    for (var i = 0;i < len; ++i) {
      if (lines[i].length === 0)
        continue;
      if (lines[i][0] === "\t" || lines[i][0] === " ") {
        if (h) {
          this.header[h][this.header[h].length - 1] += lines[i];
          continue;
        }
      }
      let posColon = lines[i].indexOf(":");
      if (posColon === -1 || posColon === 0)
        return;
      if (m = RE_HDR.exec(lines[i]), h = m[1].toLowerCase(), this.header[h] = this.header[h] || [], this.header[h].push(m[2] || ""), ++this.npairs === this.maxHeaderPairs)
        break;
    }
  };
  module.exports = HeaderParser;
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS((exports, module) => {
  var WritableStream = __require("node:stream").Writable, inherits = __require("node:util").inherits, StreamSearch = require_sbmh(), PartStream = require_PartStream(), HeaderParser = require_HeaderParser(), B_ONEDASH = Buffer.from("-"), B_CRLF = Buffer.from(`\r
`), EMPTY_FN = function() {};
  function Dicer(cfg) {
    if (!(this instanceof Dicer))
      return new Dicer(cfg);
    if (WritableStream.call(this, cfg), !cfg || !cfg.headerFirst && typeof cfg.boundary !== "string")
      throw TypeError("Boundary required");
    if (typeof cfg.boundary === "string")
      this.setBoundary(cfg.boundary);
    else
      this._bparser = void 0;
    this._headerFirst = cfg.headerFirst, this._dashes = 0, this._parts = 0, this._finished = !1, this._realFinish = !1, this._isPreamble = !0, this._justMatched = !1, this._firstWrite = !0, this._inHeader = !0, this._part = void 0, this._cb = void 0, this._ignoreData = !1, this._partOpts = { highWaterMark: cfg.partHwm }, this._pause = !1;
    let self2 = this;
    this._hparser = new HeaderParser(cfg), this._hparser.on("header", function(header) {
      self2._inHeader = !1, self2._part.emit("header", header);
    });
  }
  inherits(Dicer, WritableStream);
  Dicer.prototype.emit = function(ev) {
    if (ev === "finish" && !this._realFinish) {
      if (!this._finished) {
        let self2 = this;
        process.nextTick(function() {
          if (self2.emit("error", Error("Unexpected end of multipart data")), self2._part && !self2._ignoreData) {
            let type = self2._isPreamble ? "Preamble" : "Part";
            self2._part.emit("error", Error(type + " terminated early due to unexpected end of multipart data")), self2._part.push(null), process.nextTick(function() {
              self2._realFinish = !0, self2.emit("finish"), self2._realFinish = !1;
            });
            return;
          }
          self2._realFinish = !0, self2.emit("finish"), self2._realFinish = !1;
        });
      }
    } else
      WritableStream.prototype.emit.apply(this, arguments);
  };
  Dicer.prototype._write = function(data, encoding, cb) {
    if (!this._hparser && !this._bparser)
      return cb();
    if (this._headerFirst && this._isPreamble) {
      if (!this._part)
        if (this._part = new PartStream(this._partOpts), this.listenerCount("preamble") !== 0)
          this.emit("preamble", this._part);
        else
          this._ignore();
      let r = this._hparser.push(data);
      if (!this._inHeader && r !== void 0 && r < data.length)
        data = data.slice(r);
      else
        return cb();
    }
    if (this._firstWrite)
      this._bparser.push(B_CRLF), this._firstWrite = !1;
    if (this._bparser.push(data), this._pause)
      this._cb = cb;
    else
      cb();
  };
  Dicer.prototype.reset = function() {
    this._part = void 0, this._bparser = void 0, this._hparser = void 0;
  };
  Dicer.prototype.setBoundary = function(boundary) {
    let self2 = this;
    this._bparser = new StreamSearch(`\r
--` + boundary), this._bparser.on("info", function(isMatch, data, start, end) {
      self2._oninfo(isMatch, data, start, end);
    });
  };
  Dicer.prototype._ignore = function() {
    if (this._part && !this._ignoreData)
      this._ignoreData = !0, this._part.on("error", EMPTY_FN), this._part.resume();
  };
  Dicer.prototype._oninfo = function(isMatch, data, start, end) {
    let buf, self2 = this, i = 0, r, shouldWriteMore = !0;
    if (!this._part && this._justMatched && data) {
      while (this._dashes < 2 && start + i < end)
        if (data[start + i] === 45)
          ++i, ++this._dashes;
        else {
          if (this._dashes)
            buf = B_ONEDASH;
          this._dashes = 0;
          break;
        }
      if (this._dashes === 2) {
        if (start + i < end && this.listenerCount("trailer") !== 0)
          this.emit("trailer", data.slice(start + i, end));
        if (this.reset(), this._finished = !0, self2._parts === 0)
          self2._realFinish = !0, self2.emit("finish"), self2._realFinish = !1;
      }
      if (this._dashes)
        return;
    }
    if (this._justMatched)
      this._justMatched = !1;
    if (!this._part) {
      if (this._part = new PartStream(this._partOpts), this._part._read = function(n) {
        self2._unpause();
      }, this._isPreamble && this.listenerCount("preamble") !== 0)
        this.emit("preamble", this._part);
      else if (this._isPreamble !== !0 && this.listenerCount("part") !== 0)
        this.emit("part", this._part);
      else
        this._ignore();
      if (!this._isPreamble)
        this._inHeader = !0;
    }
    if (data && start < end && !this._ignoreData) {
      if (this._isPreamble || !this._inHeader) {
        if (buf)
          shouldWriteMore = this._part.push(buf);
        if (shouldWriteMore = this._part.push(data.slice(start, end)), !shouldWriteMore)
          this._pause = !0;
      } else if (!this._isPreamble && this._inHeader) {
        if (buf)
          this._hparser.push(buf);
        if (r = this._hparser.push(data.slice(start, end)), !this._inHeader && r !== void 0 && r < end)
          this._oninfo(!1, data, start + r, end);
      }
    }
    if (isMatch) {
      if (this._hparser.reset(), this._isPreamble)
        this._isPreamble = !1;
      else if (start !== end)
        ++this._parts, this._part.on("end", function() {
          if (--self2._parts === 0)
            if (self2._finished)
              self2._realFinish = !0, self2.emit("finish"), self2._realFinish = !1;
            else
              self2._unpause();
        });
      this._part.push(null), this._part = void 0, this._ignoreData = !1, this._justMatched = !0, this._dashes = 0;
    }
  };
  Dicer.prototype._unpause = function() {
    if (!this._pause)
      return;
    if (this._pause = !1, this._cb) {
      let cb = this._cb;
      this._cb = void 0, cb();
    }
  };
  module.exports = Dicer;
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS((exports, module) => {
  var utf8Decoder = new TextDecoder("utf-8"), textDecoders = /* @__PURE__ */ new Map([
    ["utf-8", utf8Decoder],
    ["utf8", utf8Decoder]
  ]);
  function getDecoder(charset) {
    let lc;
    while (!0)
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === void 0) {
            lc = !0, charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
  }
  var decoders = {
    utf8: (data, sourceEncoding) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, sourceEncoding);
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, sourceEncoding) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, sourceEncoding) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, sourceEncoding);
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, sourceEncoding) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, sourceEncoding);
      return data.base64Slice(0, data.length);
    },
    other: (data, sourceEncoding) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, sourceEncoding);
      if (textDecoders.has(exports.toString()))
        try {
          return textDecoders.get(exports).decode(data);
        } catch {}
      return typeof data === "string" ? data : data.toString();
    }
  };
  function decodeText(text, sourceEncoding, destEncoding) {
    if (text)
      return getDecoder(destEncoding)(text, sourceEncoding);
    return text;
  }
  module.exports = decodeText;
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS((exports, module) => {
  var decodeText = require_decodeText(), RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g, EncodedLookup = {
    "%00": "\x00",
    "%01": "\x01",
    "%02": "\x02",
    "%03": "\x03",
    "%04": "\x04",
    "%05": "\x05",
    "%06": "\x06",
    "%07": "\x07",
    "%08": "\b",
    "%09": "\t",
    "%0a": `
`,
    "%0A": `
`,
    "%0b": "\v",
    "%0B": "\v",
    "%0c": "\f",
    "%0C": "\f",
    "%0d": "\r",
    "%0D": "\r",
    "%0e": "\x0E",
    "%0E": "\x0E",
    "%0f": "\x0F",
    "%0F": "\x0F",
    "%10": "\x10",
    "%11": "\x11",
    "%12": "\x12",
    "%13": "\x13",
    "%14": "\x14",
    "%15": "\x15",
    "%16": "\x16",
    "%17": "\x17",
    "%18": "\x18",
    "%19": "\x19",
    "%1a": "\x1A",
    "%1A": "\x1A",
    "%1b": "\x1B",
    "%1B": "\x1B",
    "%1c": "\x1C",
    "%1C": "\x1C",
    "%1d": "\x1D",
    "%1D": "\x1D",
    "%1e": "\x1E",
    "%1E": "\x1E",
    "%1f": "\x1F",
    "%1F": "\x1F",
    "%20": " ",
    "%21": "!",
    "%22": '"',
    "%23": "#",
    "%24": "$",
    "%25": "%",
    "%26": "&",
    "%27": "'",
    "%28": "(",
    "%29": ")",
    "%2a": "*",
    "%2A": "*",
    "%2b": "+",
    "%2B": "+",
    "%2c": ",",
    "%2C": ",",
    "%2d": "-",
    "%2D": "-",
    "%2e": ".",
    "%2E": ".",
    "%2f": "/",
    "%2F": "/",
    "%30": "0",
    "%31": "1",
    "%32": "2",
    "%33": "3",
    "%34": "4",
    "%35": "5",
    "%36": "6",
    "%37": "7",
    "%38": "8",
    "%39": "9",
    "%3a": ":",
    "%3A": ":",
    "%3b": ";",
    "%3B": ";",
    "%3c": "<",
    "%3C": "<",
    "%3d": "=",
    "%3D": "=",
    "%3e": ">",
    "%3E": ">",
    "%3f": "?",
    "%3F": "?",
    "%40": "@",
    "%41": "A",
    "%42": "B",
    "%43": "C",
    "%44": "D",
    "%45": "E",
    "%46": "F",
    "%47": "G",
    "%48": "H",
    "%49": "I",
    "%4a": "J",
    "%4A": "J",
    "%4b": "K",
    "%4B": "K",
    "%4c": "L",
    "%4C": "L",
    "%4d": "M",
    "%4D": "M",
    "%4e": "N",
    "%4E": "N",
    "%4f": "O",
    "%4F": "O",
    "%50": "P",
    "%51": "Q",
    "%52": "R",
    "%53": "S",
    "%54": "T",
    "%55": "U",
    "%56": "V",
    "%57": "W",
    "%58": "X",
    "%59": "Y",
    "%5a": "Z",
    "%5A": "Z",
    "%5b": "[",
    "%5B": "[",
    "%5c": "\\",
    "%5C": "\\",
    "%5d": "]",
    "%5D": "]",
    "%5e": "^",
    "%5E": "^",
    "%5f": "_",
    "%5F": "_",
    "%60": "`",
    "%61": "a",
    "%62": "b",
    "%63": "c",
    "%64": "d",
    "%65": "e",
    "%66": "f",
    "%67": "g",
    "%68": "h",
    "%69": "i",
    "%6a": "j",
    "%6A": "j",
    "%6b": "k",
    "%6B": "k",
    "%6c": "l",
    "%6C": "l",
    "%6d": "m",
    "%6D": "m",
    "%6e": "n",
    "%6E": "n",
    "%6f": "o",
    "%6F": "o",
    "%70": "p",
    "%71": "q",
    "%72": "r",
    "%73": "s",
    "%74": "t",
    "%75": "u",
    "%76": "v",
    "%77": "w",
    "%78": "x",
    "%79": "y",
    "%7a": "z",
    "%7A": "z",
    "%7b": "{",
    "%7B": "{",
    "%7c": "|",
    "%7C": "|",
    "%7d": "}",
    "%7D": "}",
    "%7e": "~",
    "%7E": "~",
    "%7f": "",
    "%7F": "",
    "%80": "",
    "%81": "",
    "%82": "",
    "%83": "",
    "%84": "",
    "%85": "",
    "%86": "",
    "%87": "",
    "%88": "",
    "%89": "",
    "%8a": "",
    "%8A": "",
    "%8b": "",
    "%8B": "",
    "%8c": "",
    "%8C": "",
    "%8d": "",
    "%8D": "",
    "%8e": "",
    "%8E": "",
    "%8f": "",
    "%8F": "",
    "%90": "",
    "%91": "",
    "%92": "",
    "%93": "",
    "%94": "",
    "%95": "",
    "%96": "",
    "%97": "",
    "%98": "",
    "%99": "",
    "%9a": "",
    "%9A": "",
    "%9b": "",
    "%9B": "",
    "%9c": "",
    "%9C": "",
    "%9d": "",
    "%9D": "",
    "%9e": "",
    "%9E": "",
    "%9f": "",
    "%9F": "",
    "%a0": "",
    "%A0": "",
    "%a1": "",
    "%A1": "",
    "%a2": "",
    "%A2": "",
    "%a3": "",
    "%A3": "",
    "%a4": "",
    "%A4": "",
    "%a5": "",
    "%A5": "",
    "%a6": "",
    "%A6": "",
    "%a7": "",
    "%A7": "",
    "%a8": "",
    "%A8": "",
    "%a9": "",
    "%A9": "",
    "%aa": "",
    "%Aa": "",
    "%aA": "",
    "%AA": "",
    "%ab": "",
    "%Ab": "",
    "%aB": "",
    "%AB": "",
    "%ac": "",
    "%Ac": "",
    "%aC": "",
    "%AC": "",
    "%ad": "",
    "%Ad": "",
    "%aD": "",
    "%AD": "",
    "%ae": "",
    "%Ae": "",
    "%aE": "",
    "%AE": "",
    "%af": "",
    "%Af": "",
    "%aF": "",
    "%AF": "",
    "%b0": "",
    "%B0": "",
    "%b1": "",
    "%B1": "",
    "%b2": "",
    "%B2": "",
    "%b3": "",
    "%B3": "",
    "%b4": "",
    "%B4": "",
    "%b5": "",
    "%B5": "",
    "%b6": "",
    "%B6": "",
    "%b7": "",
    "%B7": "",
    "%b8": "",
    "%B8": "",
    "%b9": "",
    "%B9": "",
    "%ba": "",
    "%Ba": "",
    "%bA": "",
    "%BA": "",
    "%bb": "",
    "%Bb": "",
    "%bB": "",
    "%BB": "",
    "%bc": "",
    "%Bc": "",
    "%bC": "",
    "%BC": "",
    "%bd": "",
    "%Bd": "",
    "%bD": "",
    "%BD": "",
    "%be": "",
    "%Be": "",
    "%bE": "",
    "%BE": "",
    "%bf": "",
    "%Bf": "",
    "%bF": "",
    "%BF": "",
    "%c0": "",
    "%C0": "",
    "%c1": "",
    "%C1": "",
    "%c2": "",
    "%C2": "",
    "%c3": "",
    "%C3": "",
    "%c4": "",
    "%C4": "",
    "%c5": "",
    "%C5": "",
    "%c6": "",
    "%C6": "",
    "%c7": "",
    "%C7": "",
    "%c8": "",
    "%C8": "",
    "%c9": "",
    "%C9": "",
    "%ca": "",
    "%Ca": "",
    "%cA": "",
    "%CA": "",
    "%cb": "",
    "%Cb": "",
    "%cB": "",
    "%CB": "",
    "%cc": "",
    "%Cc": "",
    "%cC": "",
    "%CC": "",
    "%cd": "",
    "%Cd": "",
    "%cD": "",
    "%CD": "",
    "%ce": "",
    "%Ce": "",
    "%cE": "",
    "%CE": "",
    "%cf": "",
    "%Cf": "",
    "%cF": "",
    "%CF": "",
    "%d0": "",
    "%D0": "",
    "%d1": "",
    "%D1": "",
    "%d2": "",
    "%D2": "",
    "%d3": "",
    "%D3": "",
    "%d4": "",
    "%D4": "",
    "%d5": "",
    "%D5": "",
    "%d6": "",
    "%D6": "",
    "%d7": "",
    "%D7": "",
    "%d8": "",
    "%D8": "",
    "%d9": "",
    "%D9": "",
    "%da": "",
    "%Da": "",
    "%dA": "",
    "%DA": "",
    "%db": "",
    "%Db": "",
    "%dB": "",
    "%DB": "",
    "%dc": "",
    "%Dc": "",
    "%dC": "",
    "%DC": "",
    "%dd": "",
    "%Dd": "",
    "%dD": "",
    "%DD": "",
    "%de": "",
    "%De": "",
    "%dE": "",
    "%DE": "",
    "%df": "",
    "%Df": "",
    "%dF": "",
    "%DF": "",
    "%e0": "",
    "%E0": "",
    "%e1": "",
    "%E1": "",
    "%e2": "",
    "%E2": "",
    "%e3": "",
    "%E3": "",
    "%e4": "",
    "%E4": "",
    "%e5": "",
    "%E5": "",
    "%e6": "",
    "%E6": "",
    "%e7": "",
    "%E7": "",
    "%e8": "",
    "%E8": "",
    "%e9": "",
    "%E9": "",
    "%ea": "",
    "%Ea": "",
    "%eA": "",
    "%EA": "",
    "%eb": "",
    "%Eb": "",
    "%eB": "",
    "%EB": "",
    "%ec": "",
    "%Ec": "",
    "%eC": "",
    "%EC": "",
    "%ed": "",
    "%Ed": "",
    "%eD": "",
    "%ED": "",
    "%ee": "",
    "%Ee": "",
    "%eE": "",
    "%EE": "",
    "%ef": "",
    "%Ef": "",
    "%eF": "",
    "%EF": "",
    "%f0": "",
    "%F0": "",
    "%f1": "",
    "%F1": "",
    "%f2": "",
    "%F2": "",
    "%f3": "",
    "%F3": "",
    "%f4": "",
    "%F4": "",
    "%f5": "",
    "%F5": "",
    "%f6": "",
    "%F6": "",
    "%f7": "",
    "%F7": "",
    "%f8": "",
    "%F8": "",
    "%f9": "",
    "%F9": "",
    "%fa": "",
    "%Fa": "",
    "%fA": "",
    "%FA": "",
    "%fb": "",
    "%Fb": "",
    "%fB": "",
    "%FB": "",
    "%fc": "",
    "%Fc": "",
    "%fC": "",
    "%FC": "",
    "%fd": "",
    "%Fd": "",
    "%fD": "",
    "%FD": "",
    "%fe": "",
    "%Fe": "",
    "%fE": "",
    "%FE": "",
    "%ff": "",
    "%Ff": "",
    "%fF": "",
    "%FF": ""
  };
  function encodedReplacer(match) {
    return EncodedLookup[match];
  }
  var STATE_KEY = 0, STATE_VALUE = 1, STATE_CHARSET = 2, STATE_LANG = 3;
  function parseParams(str) {
    let res = [], state = STATE_KEY, charset = "", inquote = !1, escaping = !1, p = 0, tmp = "", len = str.length;
    for (var i = 0;i < len; ++i) {
      let char = str[i];
      if (char === "\\" && inquote)
        if (escaping)
          escaping = !1;
        else {
          escaping = !0;
          continue;
        }
      else if (char === '"')
        if (!escaping) {
          if (inquote)
            inquote = !1, state = STATE_KEY;
          else
            inquote = !0;
          continue;
        } else
          escaping = !1;
      else {
        if (escaping && inquote)
          tmp += "\\";
        if (escaping = !1, (state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
          if (state === STATE_CHARSET)
            state = STATE_LANG, charset = tmp.substring(1);
          else
            state = STATE_VALUE;
          tmp = "";
          continue;
        } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
          state = char === "*" ? STATE_CHARSET : STATE_VALUE, res[p] = [tmp, void 0], tmp = "";
          continue;
        } else if (!inquote && char === ";") {
          if (state = STATE_KEY, charset) {
            if (tmp.length)
              tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
            charset = "";
          } else if (tmp.length)
            tmp = decodeText(tmp, "binary", "utf8");
          if (res[p] === void 0)
            res[p] = tmp;
          else
            res[p][1] = tmp;
          tmp = "", ++p;
          continue;
        } else if (!inquote && (char === " " || char === "\t"))
          continue;
      }
      tmp += char;
    }
    if (charset && tmp.length)
      tmp = decodeText(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
    else if (tmp)
      tmp = decodeText(tmp, "binary", "utf8");
    if (res[p] === void 0) {
      if (tmp)
        res[p] = tmp;
    } else
      res[p][1] = tmp;
    return res;
  }
  module.exports = parseParams;
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS((exports, module) => {
  module.exports = function(path) {
    if (typeof path !== "string")
      return "";
    for (var i = path.length - 1;i >= 0; --i)
      switch (path.charCodeAt(i)) {
        case 47:
        case 92:
          return path = path.slice(i + 1), path === ".." || path === "." ? "" : path;
      }
    return path === ".." || path === "." ? "" : path;
  };
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var { Readable } = __require("node:stream"), { inherits } = __require("node:util"), Dicer = require_Dicer(), parseParams = require_parseParams(), decodeText = require_decodeText(), basename = require_basename(), getLimit = require_getLimit(), RE_BOUNDARY = /^boundary$/i, RE_FIELD = /^form-data$/i, RE_CHARSET = /^charset$/i, RE_FILENAME = /^filename$/i, RE_NAME = /^name$/i;
  Multipart.detect = /^multipart\/form-data/i;
  function Multipart(boy, cfg) {
    let i, len, self2 = this, boundary, limits = cfg.limits, isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0), parsedConType = cfg.parsedConType || [], defCharset = cfg.defCharset || "utf8", preservePath = cfg.preservePath, fileOpts = { highWaterMark: cfg.fileHwm };
    for (i = 0, len = parsedConType.length;i < len; ++i)
      if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
        boundary = parsedConType[i][1];
        break;
      }
    function checkFinished() {
      if (nends === 0 && finished && !boy._done)
        finished = !1, self2.end();
    }
    if (typeof boundary !== "string")
      throw Error("Multipart: Boundary not found");
    let fieldSizeLimit = getLimit(limits, "fieldSize", 1048576), fileSizeLimit = getLimit(limits, "fileSize", 1 / 0), filesLimit = getLimit(limits, "files", 1 / 0), fieldsLimit = getLimit(limits, "fields", 1 / 0), partsLimit = getLimit(limits, "parts", 1 / 0), headerPairsLimit = getLimit(limits, "headerPairs", 2000), headerSizeLimit = getLimit(limits, "headerSize", 81920), nfiles = 0, nfields = 0, nends = 0, curFile, curField, finished = !1;
    this._needDrain = !1, this._pause = !1, this._cb = void 0, this._nparts = 0, this._boy = boy;
    let parserCfg = {
      boundary,
      maxHeaderPairs: headerPairsLimit,
      maxHeaderSize: headerSizeLimit,
      partHwm: fileOpts.highWaterMark,
      highWaterMark: cfg.highWaterMark
    };
    this.parser = new Dicer(parserCfg), this.parser.on("drain", function() {
      if (self2._needDrain = !1, self2._cb && !self2._pause) {
        let cb = self2._cb;
        self2._cb = void 0, cb();
      }
    }).on("part", function onPart(part) {
      if (++self2._nparts > partsLimit)
        return self2.parser.removeListener("part", onPart), self2.parser.on("part", skipPart), boy.hitPartsLimit = !0, boy.emit("partsLimit"), skipPart(part);
      if (curField) {
        let field = curField;
        field.emit("end"), field.removeAllListeners("end");
      }
      part.on("header", function(header) {
        let contype, fieldname, parsed, charset, encoding, filename, nsize = 0;
        if (header["content-type"]) {
          if (parsed = parseParams(header["content-type"][0]), parsed[0]) {
            contype = parsed[0].toLowerCase();
            for (i = 0, len = parsed.length;i < len; ++i)
              if (RE_CHARSET.test(parsed[i][0])) {
                charset = parsed[i][1].toLowerCase();
                break;
              }
          }
        }
        if (contype === void 0)
          contype = "text/plain";
        if (charset === void 0)
          charset = defCharset;
        if (header["content-disposition"]) {
          if (parsed = parseParams(header["content-disposition"][0]), !RE_FIELD.test(parsed[0]))
            return skipPart(part);
          for (i = 0, len = parsed.length;i < len; ++i)
            if (RE_NAME.test(parsed[i][0]))
              fieldname = parsed[i][1];
            else if (RE_FILENAME.test(parsed[i][0])) {
              if (filename = parsed[i][1], !preservePath)
                filename = basename(filename);
            }
        } else
          return skipPart(part);
        if (header["content-transfer-encoding"])
          encoding = header["content-transfer-encoding"][0].toLowerCase();
        else
          encoding = "7bit";
        let onData, onEnd;
        if (isPartAFile(fieldname, contype, filename)) {
          if (nfiles === filesLimit) {
            if (!boy.hitFilesLimit)
              boy.hitFilesLimit = !0, boy.emit("filesLimit");
            return skipPart(part);
          }
          if (++nfiles, boy.listenerCount("file") === 0) {
            self2.parser._ignore();
            return;
          }
          ++nends;
          let file = new FileStream(fileOpts);
          curFile = file, file.on("end", function() {
            if (--nends, self2._pause = !1, checkFinished(), self2._cb && !self2._needDrain) {
              let cb = self2._cb;
              self2._cb = void 0, cb();
            }
          }), file._read = function(n) {
            if (!self2._pause)
              return;
            if (self2._pause = !1, self2._cb && !self2._needDrain) {
              let cb = self2._cb;
              self2._cb = void 0, cb();
            }
          }, boy.emit("file", fieldname, file, filename, encoding, contype), onData = function(data) {
            if ((nsize += data.length) > fileSizeLimit) {
              let extralen = fileSizeLimit - nsize + data.length;
              if (extralen > 0)
                file.push(data.slice(0, extralen));
              file.truncated = !0, file.bytesRead = fileSizeLimit, part.removeAllListeners("data"), file.emit("limit");
              return;
            } else if (!file.push(data))
              self2._pause = !0;
            file.bytesRead = nsize;
          }, onEnd = function() {
            curFile = void 0, file.push(null);
          };
        } else {
          if (nfields === fieldsLimit) {
            if (!boy.hitFieldsLimit)
              boy.hitFieldsLimit = !0, boy.emit("fieldsLimit");
            return skipPart(part);
          }
          ++nfields, ++nends;
          let buffer = "", truncated = !1;
          curField = part, onData = function(data) {
            if ((nsize += data.length) > fieldSizeLimit) {
              let extralen = fieldSizeLimit - (nsize - data.length);
              buffer += data.toString("binary", 0, extralen), truncated = !0, part.removeAllListeners("data");
            } else
              buffer += data.toString("binary");
          }, onEnd = function() {
            if (curField = void 0, buffer.length)
              buffer = decodeText(buffer, "binary", charset);
            boy.emit("field", fieldname, buffer, !1, truncated, encoding, contype), --nends, checkFinished();
          };
        }
        part._readableState.sync = !1, part.on("data", onData), part.on("end", onEnd);
      }).on("error", function(err) {
        if (curFile)
          curFile.emit("error", err);
      });
    }).on("error", function(err) {
      boy.emit("error", err);
    }).on("finish", function() {
      finished = !0, checkFinished();
    });
  }
  Multipart.prototype.write = function(chunk, cb) {
    let r = this.parser.write(chunk);
    if (r && !this._pause)
      cb();
    else
      this._needDrain = !r, this._cb = cb;
  };
  Multipart.prototype.end = function() {
    let self2 = this;
    if (self2.parser.writable)
      self2.parser.end();
    else if (!self2._boy._done)
      process.nextTick(function() {
        self2._boy._done = !0, self2._boy.emit("finish");
      });
  };
  function skipPart(part) {
    part.resume();
  }
  function FileStream(opts) {
    Readable.call(this, opts), this.bytesRead = 0, this.truncated = !1;
  }
  inherits(FileStream, Readable);
  FileStream.prototype._read = function(n) {};
  module.exports = Multipart;
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS((exports, module) => {
  var RE_PLUS = /\+/g, HEX = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  function Decoder() {
    this.buffer = void 0;
  }
  Decoder.prototype.write = function(str) {
    str = str.replace(RE_PLUS, " ");
    let res = "", i = 0, p = 0, len = str.length;
    for (;i < len; ++i)
      if (this.buffer !== void 0) {
        if (!HEX[str.charCodeAt(i)])
          res += "%" + this.buffer, this.buffer = void 0, --i;
        else if (this.buffer += str[i], ++p, this.buffer.length === 2)
          res += String.fromCharCode(parseInt(this.buffer, 16)), this.buffer = void 0;
      } else if (str[i] === "%") {
        if (i > p)
          res += str.substring(p, i), p = i;
        this.buffer = "", ++p;
      }
    if (p < len && this.buffer === void 0)
      res += str.substring(p);
    return res;
  };
  Decoder.prototype.reset = function() {
    this.buffer = void 0;
  };
  module.exports = Decoder;
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var Decoder = require_Decoder(), decodeText = require_decodeText(), getLimit = require_getLimit(), RE_CHARSET = /^charset$/i;
  UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
  function UrlEncoded(boy, cfg) {
    let { limits, parsedConType } = cfg;
    this.boy = boy, this.fieldSizeLimit = getLimit(limits, "fieldSize", 1048576), this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100), this.fieldsLimit = getLimit(limits, "fields", 1 / 0);
    let charset;
    for (var i = 0, len = parsedConType.length;i < len; ++i)
      if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
        charset = parsedConType[i][1].toLowerCase();
        break;
      }
    if (charset === void 0)
      charset = cfg.defCharset || "utf8";
    this.decoder = new Decoder, this.charset = charset, this._fields = 0, this._state = "key", this._checkingBytes = !0, this._bytesKey = 0, this._bytesVal = 0, this._key = "", this._val = "", this._keyTrunc = !1, this._valTrunc = !1, this._hitLimit = !1;
  }
  UrlEncoded.prototype.write = function(data, cb) {
    if (this._fields === this.fieldsLimit) {
      if (!this.boy.hitFieldsLimit)
        this.boy.hitFieldsLimit = !0, this.boy.emit("fieldsLimit");
      return cb();
    }
    let idxeq, idxamp, i, p = 0, len = data.length;
    while (p < len)
      if (this._state === "key") {
        idxeq = idxamp = void 0;
        for (i = p;i < len; ++i) {
          if (!this._checkingBytes)
            ++p;
          if (data[i] === 61) {
            idxeq = i;
            break;
          } else if (data[i] === 38) {
            idxamp = i;
            break;
          }
          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
            this._hitLimit = !0;
            break;
          } else if (this._checkingBytes)
            ++this._bytesKey;
        }
        if (idxeq !== void 0) {
          if (idxeq > p)
            this._key += this.decoder.write(data.toString("binary", p, idxeq));
          this._state = "val", this._hitLimit = !1, this._checkingBytes = !0, this._val = "", this._bytesVal = 0, this._valTrunc = !1, this.decoder.reset(), p = idxeq + 1;
        } else if (idxamp !== void 0) {
          ++this._fields;
          let key, keyTrunc = this._keyTrunc;
          if (idxamp > p)
            key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
          else
            key = this._key;
          if (this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), key.length)
            this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, !1);
          if (p = idxamp + 1, this._fields === this.fieldsLimit)
            return cb();
        } else if (this._hitLimit) {
          if (i > p)
            this._key += this.decoder.write(data.toString("binary", p, i));
          if (p = i, (this._bytesKey = this._key.length) === this.fieldNameSizeLimit)
            this._checkingBytes = !1, this._keyTrunc = !0;
        } else {
          if (p < len)
            this._key += this.decoder.write(data.toString("binary", p));
          p = len;
        }
      } else {
        idxamp = void 0;
        for (i = p;i < len; ++i) {
          if (!this._checkingBytes)
            ++p;
          if (data[i] === 38) {
            idxamp = i;
            break;
          }
          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
            this._hitLimit = !0;
            break;
          } else if (this._checkingBytes)
            ++this._bytesVal;
        }
        if (idxamp !== void 0) {
          if (++this._fields, idxamp > p)
            this._val += this.decoder.write(data.toString("binary", p, idxamp));
          if (this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc), this._state = "key", this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), p = idxamp + 1, this._fields === this.fieldsLimit)
            return cb();
        } else if (this._hitLimit) {
          if (i > p)
            this._val += this.decoder.write(data.toString("binary", p, i));
          if (p = i, this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit)
            this._checkingBytes = !1, this._valTrunc = !0;
        } else {
          if (p < len)
            this._val += this.decoder.write(data.toString("binary", p));
          p = len;
        }
      }
    cb();
  };
  UrlEncoded.prototype.end = function() {
    if (this.boy._done)
      return;
    if (this._state === "key" && this._key.length > 0)
      this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, !1);
    else if (this._state === "val")
      this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
    this.boy._done = !0, this.boy.emit("finish");
  };
  module.exports = UrlEncoded;
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS((exports, module) => {
  var WritableStream = __require("node:stream").Writable, { inherits } = __require("node:util"), Dicer = require_Dicer(), MultipartParser = require_multipart(), UrlencodedParser = require_urlencoded(), parseParams = require_parseParams();
  function Busboy(opts) {
    if (!(this instanceof Busboy))
      return new Busboy(opts);
    if (typeof opts !== "object")
      throw TypeError("Busboy expected an options-Object.");
    if (typeof opts.headers !== "object")
      throw TypeError("Busboy expected an options-Object with headers-attribute.");
    if (typeof opts.headers["content-type"] !== "string")
      throw TypeError("Missing Content-Type-header.");
    let {
      headers,
      ...streamOptions
    } = opts;
    this.opts = {
      autoDestroy: !1,
      ...streamOptions
    }, WritableStream.call(this, this.opts), this._done = !1, this._parser = this.getParserByHeaders(headers), this._finished = !1;
  }
  inherits(Busboy, WritableStream);
  Busboy.prototype.emit = function(ev) {
    if (ev === "finish") {
      if (!this._done) {
        this._parser?.end();
        return;
      } else if (this._finished)
        return;
      this._finished = !0;
    }
    WritableStream.prototype.emit.apply(this, arguments);
  };
  Busboy.prototype.getParserByHeaders = function(headers) {
    let parsed = parseParams(headers["content-type"]), cfg = {
      defCharset: this.opts.defCharset,
      fileHwm: this.opts.fileHwm,
      headers,
      highWaterMark: this.opts.highWaterMark,
      isPartAFile: this.opts.isPartAFile,
      limits: this.opts.limits,
      parsedConType: parsed,
      preservePath: this.opts.preservePath
    };
    if (MultipartParser.detect.test(parsed[0]))
      return new MultipartParser(this, cfg);
    if (UrlencodedParser.detect.test(parsed[0]))
      return new UrlencodedParser(this, cfg);
    throw Error("Unsupported Content-Type.");
  };
  Busboy.prototype._write = function(chunk, encoding, cb) {
    this._parser.write(chunk, cb);
  };
  module.exports = Busboy;
  module.exports.default = Busboy;
  module.exports.Busboy = Busboy;
  module.exports.Dicer = Dicer;
});

// node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS((exports, module) => {
  var { MessageChannel, receiveMessageOnPort } = __require("worker_threads"), corsSafeListedMethods = ["GET", "HEAD", "POST"], corsSafeListedMethodsSet = new Set(corsSafeListedMethods), nullBodyStatus = [101, 204, 205, 304], redirectStatus = [301, 302, 303, 307, 308], redirectStatusSet = new Set(redirectStatus), badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6697",
    "10080"
  ], badPortsSet = new Set(badPorts), referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ], referrerPolicySet = new Set(referrerPolicy), requestRedirect = ["follow", "manual", "error"], safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"], safeMethodsSet = new Set(safeMethods), requestMode = ["navigate", "same-origin", "no-cors", "cors"], requestCredentials = ["omit", "same-origin", "include"], requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ], requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    "content-length"
  ], requestDuplex = [
    "half"
  ], forbiddenMethods = ["CONNECT", "TRACE", "TRACK"], forbiddenMethodsSet = new Set(forbiddenMethods), subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ], subresourceSet = new Set(subresource), DOMException2 = globalThis.DOMException ?? (() => {
    try {
      atob("~");
    } catch (err) {
      return Object.getPrototypeOf(err).constructor;
    }
  })(), channel, structuredClone = globalThis.structuredClone ?? function(value, options = void 0) {
    if (arguments.length === 0)
      throw TypeError("missing argument");
    if (!channel)
      channel = new MessageChannel;
    return channel.port1.unref(), channel.port2.unref(), channel.port1.postMessage(value, options?.transfer), receiveMessageOnPort(channel.port2).message;
  };
  module.exports = {
    DOMException: DOMException2,
    structuredClone,
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS((exports, module) => {
  var globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === void 0) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: void 0,
        writable: !0,
        enumerable: !1,
        configurable: !1
      });
      return;
    }
    let parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:")
      throw TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: !0,
      enumerable: !1,
      configurable: !1
    });
  }
  module.exports = {
    getGlobalOrigin,
    setGlobalOrigin
  };
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS((exports, module) => {
  var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2(), { getGlobalOrigin } = require_global(), { performance: performance2 } = __require("perf_hooks"), { isBlobLike, toUSVString, ReadableStreamFrom } = require_util(), assert = __require("assert"), { isUint8Array } = __require("util/types"), supportedHashes = [], crypto2;
  try {
    crypto2 = __require("crypto");
    let possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {}
  function responseURL(response) {
    let urlList = response.urlList, length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response, requestFragment) {
    if (!redirectStatusSet.has(response.status))
      return null;
    let location = response.headersList.get("location");
    if (location !== null && isValidHeaderValue(location))
      location = new URL(location, responseURL(response));
    if (location && !location.hash)
      location.hash = requestFragment;
    return location;
  }
  function requestCurrentURL(request) {
    return request.urlList[request.urlList.length - 1];
  }
  function requestBadPort(request) {
    let url = requestCurrentURL(request);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port))
      return "blocked";
    return "allowed";
  }
  function isErrorLike(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0;i < statusText.length; ++i) {
      let c = statusText.charCodeAt(i);
      if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255))
        return !1;
    }
    return !0;
  }
  function isTokenCharCode(c) {
    switch (c) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return !1;
      default:
        return c >= 33 && c <= 126;
    }
  }
  function isValidHTTPToken(characters) {
    if (characters.length === 0)
      return !1;
    for (let i = 0;i < characters.length; ++i)
      if (!isTokenCharCode(characters.charCodeAt(i)))
        return !1;
    return !0;
  }
  function isValidHeaderName(potentialValue) {
    return isValidHTTPToken(potentialValue);
  }
  function isValidHeaderValue(potentialValue) {
    if (potentialValue.startsWith("\t") || potentialValue.startsWith(" ") || potentialValue.endsWith("\t") || potentialValue.endsWith(" "))
      return !1;
    if (potentialValue.includes("\x00") || potentialValue.includes("\r") || potentialValue.includes(`
`))
      return !1;
    return !0;
  }
  function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
    let { headersList } = actualResponse, policyHeader = (headersList.get("referrer-policy") ?? "").split(","), policy = "";
    if (policyHeader.length > 0)
      for (let i = policyHeader.length;i !== 0; i--) {
        let token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    if (policy !== "")
      request.referrerPolicy = policy;
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode, httpRequest.headersList.set("sec-fetch-mode", header);
  }
  function appendRequestOriginHeader(request) {
    let serializedOrigin = request.origin;
    if (request.responseTainting === "cors" || request.mode === "websocket") {
      if (serializedOrigin)
        request.headersList.append("origin", serializedOrigin);
    } else if (request.method !== "GET" && request.method !== "HEAD") {
      switch (request.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request)))
            serializedOrigin = null;
          break;
        case "same-origin":
          if (!sameOrigin(request, requestCurrentURL(request)))
            serializedOrigin = null;
          break;
        default:
      }
      if (serializedOrigin)
        request.headersList.append("origin", serializedOrigin);
    }
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return performance2.now();
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request) {
    let policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      let globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null")
        return "no-referrer";
      referrerSource = new URL(globalOrigin);
    } else if (request.referrer instanceof URL)
      referrerSource = request.referrer;
    let referrerURL = stripURLForReferrer(referrerSource), referrerOrigin = stripURLForReferrer(referrerSource, !0);
    if (referrerURL.toString().length > 4096)
      referrerURL = referrerOrigin;
    let areSameOrigin = sameOrigin(request, referrerURL), isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, !0);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        let currentURL = requestCurrentURL(request);
        if (sameOrigin(referrerURL, currentURL))
          return referrerURL;
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL))
          return "no-referrer";
        return referrerOrigin;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  function stripURLForReferrer(url, originOnly) {
    if (assert(url instanceof URL), url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:")
      return "no-referrer";
    if (url.username = "", url.password = "", url.hash = "", originOnly)
      url.pathname = "", url.search = "";
    return url;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL))
      return !1;
    if (url.href === "about:blank" || url.href === "about:srcdoc")
      return !0;
    if (url.protocol === "data:")
      return !0;
    if (url.protocol === "file:")
      return !0;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null")
        return !1;
      let originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:")
        return !0;
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost"))
        return !0;
      return !1;
    }
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto2 === void 0)
      return !0;
    let parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata")
      return !0;
    if (parsedMetadata.length === 0)
      return !0;
    let strongest = getStrongestMetadata(parsedMetadata), metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (let item of metadata) {
      let { algo: algorithm, hash: expectedValue } = item, actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=")
        if (actualValue[actualValue.length - 2] === "=")
          actualValue = actualValue.slice(0, -2);
        else
          actualValue = actualValue.slice(0, -1);
      if (compareBase64Mixed(actualValue, expectedValue))
        return !0;
    }
    return !1;
  }
  var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    let result = [], empty = !0;
    for (let token of metadata.split(" ")) {
      empty = !1;
      let parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0)
        continue;
      let algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm))
        result.push(parsedToken.groups);
    }
    if (empty === !0)
      return "no metadata";
    return result;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5")
      return algorithm;
    for (let i = 1;i < metadataList.length; ++i) {
      let metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3")
        continue;
      else if (metadata.algo[3] === "3")
        algorithm = "sha384";
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1)
      return metadataList;
    let pos = 0;
    for (let i = 0;i < metadataList.length; ++i)
      if (metadataList[i].algo === algorithm)
        metadataList[pos++] = metadataList[i];
    return metadataList.length = pos, metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length)
      return !1;
    for (let i = 0;i < actualValue.length; ++i)
      if (actualValue[i] !== expectedValue[i]) {
        if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_")
          continue;
        return !1;
      }
    return !0;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null")
      return !0;
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port)
      return !0;
    return !1;
  }
  function createDeferredPromise() {
    let res, rej;
    return { promise: new Promise((resolve, reject) => {
      res = resolve, rej = reject;
    }), resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  var normalizeMethodRecord = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  Object.setPrototypeOf(normalizeMethodRecord, null);
  function normalizeMethod(method) {
    return normalizeMethodRecord[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    let result = JSON.stringify(value);
    if (result === void 0)
      throw TypeError("Value is not JSON serializable");
    return assert(typeof result === "string"), result;
  }
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function makeIterator(iterator, name, kind) {
    let object = {
      index: 0,
      kind,
      target: iterator
    }, i = {
      next() {
        if (Object.getPrototypeOf(this) !== i)
          throw TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        let { index, kind: kind2, target } = object, values = target(), len = values.length;
        if (index >= len)
          return { value: void 0, done: !0 };
        let pair = values[index];
        return object.index = index + 1, iteratorResult(pair, kind2);
      },
      [Symbol.toStringTag]: `${name} Iterator`
    };
    return Object.setPrototypeOf(i, esIteratorPrototype), Object.setPrototypeOf({}, i);
  }
  function iteratorResult(pair, kind) {
    let result;
    switch (kind) {
      case "key": {
        result = pair[0];
        break;
      }
      case "value": {
        result = pair[1];
        break;
      }
      case "key+value": {
        result = pair;
        break;
      }
    }
    return { value: result, done: !1 };
  }
  async function fullyReadBody(body, processBody, processBodyError) {
    let successSteps = processBody, errorSteps = processBodyError, reader;
    try {
      reader = body.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      let result = await readAllBytes(reader);
      successSteps(result);
    } catch (e) {
      errorSteps(e);
    }
  }
  var ReadableStream2 = globalThis.ReadableStream;
  function isReadableStreamLike(stream) {
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    return stream instanceof ReadableStream2 || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
  }
  var MAXIMUM_ARGUMENT_LENGTH = 65535;
  function isomorphicDecode(input) {
    if (input.length < MAXIMUM_ARGUMENT_LENGTH)
      return String.fromCharCode(...input);
    return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
    } catch (err) {
      if (!err.message.includes("Controller is already closed"))
        throw err;
    }
  }
  function isomorphicEncode(input) {
    for (let i = 0;i < input.length; i++)
      assert(input.charCodeAt(i) <= 255);
    return input;
  }
  async function readAllBytes(reader) {
    let bytes = [], byteLength = 0;
    while (!0) {
      let { done, value: chunk } = await reader.read();
      if (done)
        return Buffer.concat(bytes, byteLength);
      if (!isUint8Array(chunk))
        throw TypeError("Received non-Uint8Array chunk");
      bytes.push(chunk), byteLength += chunk.length;
    }
  }
  function urlIsLocal(url) {
    assert("protocol" in url);
    let protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    if (typeof url === "string")
      return url.startsWith("https:");
    return url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    let protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
  module.exports = {
    isAborted,
    isCancelled,
    createDeferredPromise,
    ReadableStreamFrom,
    toUSVString,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue,
    hasOwn,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    isomorphicDecode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    normalizeMethodRecord,
    parseMetadata
  };
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS((exports, module) => {
  module.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm")
  };
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS((exports, module) => {
  var { types } = __require("util"), { hasOwn, toUSVString } = require_util2(), webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    let plural = context.types.length === 1 ? "" : " one of", message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts = void 0) {
    if (opts?.strict !== !1 && !(V instanceof I))
      throw TypeError("Illegal invocation");
    else
      return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min)
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
        ...ctx
      });
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null)
          return "Null";
        return "Object";
      }
    }
  };
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
    let upperBound, lowerBound;
    if (bitLength === 64)
      if (upperBound = Math.pow(2, 53) - 1, signedness === "unsigned")
        lowerBound = 0;
      else
        lowerBound = Math.pow(-2, 53) + 1;
    else if (signedness === "unsigned")
      lowerBound = 0, upperBound = Math.pow(2, bitLength) - 1;
    else
      lowerBound = Math.pow(-2, bitLength) - 1, upperBound = Math.pow(2, bitLength - 1) - 1;
    let x = Number(V);
    if (x === 0)
      x = 0;
    if (opts.enforceRange === !0) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY)
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${V} to an integer.`
        });
      if (x = webidl.util.IntegerPart(x), x < lowerBound || x > upperBound)
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      return x;
    }
    if (!Number.isNaN(x) && opts.clamp === !0) {
      if (x = Math.min(Math.max(x, lowerBound), upperBound), Math.floor(x) % 2 === 0)
        x = Math.floor(x);
      else
        x = Math.ceil(x);
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY)
      return 0;
    if (x = webidl.util.IntegerPart(x), x = x % Math.pow(2, bitLength), signedness === "signed" && x >= Math.pow(2, bitLength) - 1)
      return x - Math.pow(2, bitLength);
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    let r = Math.floor(Math.abs(n));
    if (n < 0)
      return -1 * r;
    return r;
  };
  webidl.sequenceConverter = function(converter) {
    return (V) => {
      if (webidl.util.Type(V) !== "Object")
        throw webidl.errors.exception({
          header: "Sequence",
          message: `Value of type ${webidl.util.Type(V)} is not an Object.`
        });
      let method = V?.[Symbol.iterator]?.(), seq = [];
      if (method === void 0 || typeof method.next !== "function")
        throw webidl.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator."
        });
      while (!0) {
        let { done, value } = method.next();
        if (done)
          break;
        seq.push(converter(value));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O) => {
      if (webidl.util.Type(O) !== "Object")
        throw webidl.errors.exception({
          header: "Record",
          message: `Value of type ${webidl.util.Type(O)} is not an Object.`
        });
      let result = {};
      if (!types.isProxy(O)) {
        let keys2 = Object.keys(O);
        for (let key of keys2) {
          let typedKey = keyConverter(key), typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
        return result;
      }
      let keys = Reflect.ownKeys(O);
      for (let key of keys)
        if (Reflect.getOwnPropertyDescriptor(O, key)?.enumerable) {
          let typedKey = keyConverter(key), typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, opts = {}) => {
      if (opts.strict !== !1 && !(V instanceof i))
        throw webidl.errors.exception({
          header: i.name,
          message: `Expected ${V} to be an instance of ${i.name}.`
        });
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary) => {
      let type = webidl.util.Type(dictionary), dict = {};
      if (type === "Null" || type === "Undefined")
        return dict;
      else if (type !== "Object")
        throw webidl.errors.exception({
          header: "Dictionary",
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      for (let options of converters) {
        let { key, defaultValue, required, converter } = options;
        if (required === !0) {
          if (!hasOwn(dictionary, key))
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `Missing required key "${key}".`
            });
        }
        let value = dictionary[key], hasDefault = hasOwn(options, "defaultValue");
        if (hasDefault && value !== null)
          value = value ?? defaultValue;
        if (required || hasDefault || value !== void 0) {
          if (value = converter(value), options.allowedValues && !options.allowedValues.includes(value))
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V) => {
      if (V === null)
        return V;
      return converter(V);
    };
  };
  webidl.converters.DOMString = function(V, opts = {}) {
    if (V === null && opts.legacyNullToEmptyString)
      return "";
    if (typeof V === "symbol")
      throw TypeError("Could not convert argument of type symbol to string.");
    return String(V);
  };
  webidl.converters.ByteString = function(V) {
    let x = webidl.converters.DOMString(V);
    for (let index = 0;index < x.length; index++)
      if (x.charCodeAt(index) > 255)
        throw TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    return Boolean(V);
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V) {
    return webidl.util.ConvertToInt(V, 64, "signed");
  };
  webidl.converters["unsigned long long"] = function(V) {
    return webidl.util.ConvertToInt(V, 64, "unsigned");
  };
  webidl.converters["unsigned long"] = function(V) {
    return webidl.util.ConvertToInt(V, 32, "unsigned");
  };
  webidl.converters["unsigned short"] = function(V, opts) {
    return webidl.util.ConvertToInt(V, 16, "unsigned", opts);
  };
  webidl.converters.ArrayBuffer = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V))
      throw webidl.errors.conversionFailed({
        prefix: `${V}`,
        argument: `${V}`,
        types: ["ArrayBuffer"]
      });
    if (opts.allowShared === !1 && types.isSharedArrayBuffer(V))
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return V;
  };
  webidl.converters.TypedArray = function(V, T, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name)
      throw webidl.errors.conversionFailed({
        prefix: `${T.name}`,
        argument: `${V}`,
        types: [T.name]
      });
    if (opts.allowShared === !1 && types.isSharedArrayBuffer(V.buffer))
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return V;
  };
  webidl.converters.DataView = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V))
      throw webidl.errors.exception({
        header: "DataView",
        message: "Object is not a DataView."
      });
    if (opts.allowShared === !1 && types.isSharedArrayBuffer(V.buffer))
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return V;
  };
  webidl.converters.BufferSource = function(V, opts = {}) {
    if (types.isAnyArrayBuffer(V))
      return webidl.converters.ArrayBuffer(V, opts);
    if (types.isTypedArray(V))
      return webidl.converters.TypedArray(V, V.constructor);
    if (types.isDataView(V))
      return webidl.converters.DataView(V, opts);
    throw TypeError(`Could not convert ${V} to a BufferSource.`);
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  module.exports = {
    webidl
  };
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS((exports, module) => {
  var assert = __require("assert"), { atob: atob2 } = __require("buffer"), { isomorphicDecode } = require_util2(), encoder = /* @__PURE__ */ new TextEncoder, HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/, HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/, HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, !0);
    input = input.slice(5);
    let position = { position: 0 }, mimeType = collectASequenceOfCodePointsFast(",", input, position), mimeTypeLength = mimeType.length;
    if (mimeType = removeASCIIWhitespace(mimeType, !0, !0), position.position >= input.length)
      return "failure";
    position.position++;
    let encodedBody = input.slice(mimeTypeLength + 1), body = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      let stringBody = isomorphicDecode(body);
      if (body = forgivingBase64(stringBody), body === "failure")
        return "failure";
      mimeType = mimeType.slice(0, -6), mimeType = mimeType.replace(/(\u0020)+$/, ""), mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";"))
      mimeType = "text/plain" + mimeType;
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure")
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    return { mimeType: mimeTypeRecord, body };
  }
  function URLSerializer(url, excludeFragment = !1) {
    if (!excludeFragment)
      return url.href;
    let href = url.href, hashLength = url.hash.length;
    return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position]))
      result += input[position.position], position.position++;
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    let idx = input.indexOf(char, position.position), start = position.position;
    if (idx === -1)
      return position.position = input.length, input.slice(start);
    return position.position = idx, input.slice(start, position.position);
  }
  function stringPercentDecode(input) {
    let bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function percentDecode(input) {
    let output = [];
    for (let i = 0;i < input.length; i++) {
      let byte = input[i];
      if (byte !== 37)
        output.push(byte);
      else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2])))
        output.push(37);
      else {
        let nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]), bytePoint = Number.parseInt(nextTwoBytes, 16);
        output.push(bytePoint), i += 2;
      }
    }
    return Uint8Array.from(output);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, !0, !0);
    let position = { position: 0 }, type = collectASequenceOfCodePointsFast("/", input, position);
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type))
      return "failure";
    if (position.position > input.length)
      return "failure";
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    if (subtype = removeHTTPWhitespace(subtype, !1, !0), subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype))
      return "failure";
    let typeLowercase = type.toLowerCase(), subtypeLowercase = subtype.toLowerCase(), mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      parameters: /* @__PURE__ */ new Map,
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++, collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
      if (parameterName = parameterName.toLowerCase(), position.position < input.length) {
        if (input[position.position] === ";")
          continue;
        position.position++;
      }
      if (position.position > input.length)
        break;
      let parameterValue = null;
      if (input[position.position] === '"')
        parameterValue = collectAnHTTPQuotedString(input, position, !0), collectASequenceOfCodePointsFast(";", input, position);
      else if (parameterValue = collectASequenceOfCodePointsFast(";", input, position), parameterValue = removeHTTPWhitespace(parameterValue, !1, !0), parameterValue.length === 0)
        continue;
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName))
        mimeType.parameters.set(parameterName, parameterValue);
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    if (data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, ""), data.length % 4 === 0)
      data = data.replace(/=?=$/, "");
    if (data.length % 4 === 1)
      return "failure";
    if (/[^+/0-9A-Za-z]/.test(data))
      return "failure";
    let binary = atob2(data), bytes = new Uint8Array(binary.length);
    for (let byte = 0;byte < binary.length; byte++)
      bytes[byte] = binary.charCodeAt(byte);
    return bytes;
  }
  function collectAnHTTPQuotedString(input, position, extractValue) {
    let positionStart = position.position, value = "";
    assert(input[position.position] === '"'), position.position++;
    while (!0) {
      if (value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position), position.position >= input.length)
        break;
      let quoteOrBackslash = input[position.position];
      if (position.position++, quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position], position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue)
      return value;
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    let { parameters, essence } = mimeType, serialization = essence;
    for (let [name, value] of parameters.entries()) {
      if (serialization += ";", serialization += name, serialization += "=", !HTTP_TOKEN_CODEPOINTS.test(value))
        value = value.replace(/(\\|")/g, "\\$1"), value = '"' + value, value += '"';
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === "\r" || char === `
` || char === "\t" || char === " ";
  }
  function removeHTTPWhitespace(str, leading = !0, trailing = !0) {
    let lead = 0, trail = str.length - 1;
    if (leading)
      for (;lead < str.length && isHTTPWhiteSpace(str[lead]); lead++)
        ;
    if (trailing)
      for (;trail > 0 && isHTTPWhiteSpace(str[trail]); trail--)
        ;
    return str.slice(lead, trail + 1);
  }
  function isASCIIWhitespace(char) {
    return char === "\r" || char === `
` || char === "\t" || char === "\f" || char === " ";
  }
  function removeASCIIWhitespace(str, leading = !0, trailing = !0) {
    let lead = 0, trail = str.length - 1;
    if (leading)
      for (;lead < str.length && isASCIIWhitespace(str[lead]); lead++)
        ;
    if (trailing)
      for (;trail > 0 && isASCIIWhitespace(str[trail]); trail--)
        ;
    return str.slice(lead, trail + 1);
  }
  module.exports = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType
  };
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS((exports, module) => {
  var { Blob: Blob2, File: NativeFile } = __require("buffer"), { types } = __require("util"), { kState } = require_symbols2(), { isBlobLike } = require_util2(), { webidl } = require_webidl(), { parseMIMEType, serializeAMimeType } = require_dataURL(), { kEnumerableProperty } = require_util(), encoder = /* @__PURE__ */ new TextEncoder;

  class File2 extends Blob2 {
    constructor(fileBits, fileName, options = {}) {
      webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" }), fileBits = webidl.converters["sequence<BlobPart>"](fileBits), fileName = webidl.converters.USVString(fileName), options = webidl.converters.FilePropertyBag(options);
      let n = fileName, t = options.type, d;
      substep: {
        if (t) {
          if (t = parseMIMEType(t), t === "failure") {
            t = "";
            break substep;
          }
          t = serializeAMimeType(t).toLowerCase();
        }
        d = options.lastModified;
      }
      super(processBlobParts(fileBits, options), { type: t });
      this[kState] = {
        name: n,
        lastModified: d,
        type: t
      };
    }
    get name() {
      return webidl.brandCheck(this, File2), this[kState].name;
    }
    get lastModified() {
      return webidl.brandCheck(this, File2), this[kState].lastModified;
    }
    get type() {
      return webidl.brandCheck(this, File2), this[kState].type;
    }
  }

  class FileLike {
    constructor(blobLike, fileName, options = {}) {
      let n = fileName, t = options.type, d = options.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.slice(...args);
    }
    text(...args) {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.text(...args);
    }
    get size() {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.size;
    }
    get type() {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.type;
    }
    get name() {
      return webidl.brandCheck(this, FileLike), this[kState].name;
    }
    get lastModified() {
      return webidl.brandCheck(this, FileLike), this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(File2.prototype, {
    [Symbol.toStringTag]: {
      value: "File",
      configurable: !0
    },
    name: kEnumerableProperty,
    lastModified: kEnumerableProperty
  });
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  webidl.converters.BlobPart = function(V, opts) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V))
        return webidl.converters.Blob(V, { strict: !1 });
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V))
        return webidl.converters.BufferSource(V, opts);
    }
    return webidl.converters.USVString(V, opts);
  };
  webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(webidl.converters.BlobPart);
  webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
    {
      key: "lastModified",
      converter: webidl.converters["long long"],
      get defaultValue() {
        return Date.now();
      }
    },
    {
      key: "type",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "endings",
      converter: (value) => {
        if (value = webidl.converters.DOMString(value), value = value.toLowerCase(), value !== "native")
          value = "transparent";
        return value;
      },
      defaultValue: "transparent"
    }
  ]);
  function processBlobParts(parts, options) {
    let bytes = [];
    for (let element of parts)
      if (typeof element === "string") {
        let s = element;
        if (options.endings === "native")
          s = convertLineEndingsNative(s);
        bytes.push(encoder.encode(s));
      } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element))
        if (!element.buffer)
          bytes.push(new Uint8Array(element));
        else
          bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
      else if (isBlobLike(element))
        bytes.push(element);
    return bytes;
  }
  function convertLineEndingsNative(s) {
    let nativeLineEnding = `
`;
    if (process.platform === "win32")
      nativeLineEnding = `\r
`;
    return s.replace(/\r?\n/g, nativeLineEnding);
  }
  function isFileLike(object) {
    return NativeFile && object instanceof NativeFile || object instanceof File2 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  }
  module.exports = { File: File2, FileLike, isFileLike };
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS((exports, module) => {
  var { isBlobLike, toUSVString, makeIterator } = require_util2(), { kState } = require_symbols2(), { File: UndiciFile, FileLike, isFileLike } = require_file(), { webidl } = require_webidl(), { Blob: Blob2, File: NativeFile } = __require("buffer"), File2 = NativeFile ?? UndiciFile;

  class FormData2 {
    constructor(form) {
      if (form !== void 0)
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      this[kState] = [];
    }
    append(name, value, filename = void 0) {
      if (webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" }), arguments.length === 3 && !isBlobLike(value))
        throw TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
      name = webidl.converters.USVString(name), value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: !1 }) : webidl.converters.USVString(value), filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
      let entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" }), name = webidl.converters.USVString(name), this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" }), name = webidl.converters.USVString(name);
      let idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1)
        return null;
      return this[kState][idx].value;
    }
    getAll(name) {
      return webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" }), name = webidl.converters.USVString(name), this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      return webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" }), name = webidl.converters.USVString(name), this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = void 0) {
      if (webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" }), arguments.length === 3 && !isBlobLike(value))
        throw TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
      name = webidl.converters.USVString(name), value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: !1 }) : webidl.converters.USVString(value), filename = arguments.length === 3 ? toUSVString(filename) : void 0;
      let entry = makeEntry(name, value, filename), idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1)
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      else
        this[kState].push(entry);
    }
    entries() {
      return webidl.brandCheck(this, FormData2), makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
    }
    keys() {
      return webidl.brandCheck(this, FormData2), makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key");
    }
    values() {
      return webidl.brandCheck(this, FormData2), makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      if (webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" }), typeof callbackFn !== "function")
        throw TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
      for (let [key, value] of this)
        callbackFn.apply(thisArg, [value, key, this]);
    }
  }
  FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
  Object.defineProperties(FormData2.prototype, {
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: !0
    }
  });
  function makeEntry(name, value, filename) {
    if (name = Buffer.from(name).toString("utf8"), typeof value === "string")
      value = Buffer.from(value).toString("utf8");
    else {
      if (!isFileLike(value))
        value = value instanceof Blob2 ? new File2([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      if (filename !== void 0) {
        let options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File2([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return { name, value };
  }
  module.exports = { FormData: FormData2 };
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS((exports, module) => {
  var Busboy = require_main(), util = require_util(), {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody
  } = require_util2(), { FormData: FormData2 } = require_formdata(), { kState } = require_symbols2(), { webidl } = require_webidl(), { DOMException: DOMException2, structuredClone } = require_constants2(), { Blob: Blob2, File: NativeFile } = __require("buffer"), { kBodyUsed } = require_symbols(), assert = __require("assert"), { isErrored } = require_util(), { isUint8Array, isArrayBuffer } = __require("util/types"), { File: UndiciFile } = require_file(), { parseMIMEType, serializeAMimeType } = require_dataURL(), random;
  try {
    let crypto2 = __require("node:crypto");
    random = (max) => crypto2.randomInt(0, max);
  } catch {
    random = (max) => Math.floor(Math.random(max));
  }
  var ReadableStream2 = globalThis.ReadableStream, File2 = NativeFile ?? UndiciFile, textEncoder = /* @__PURE__ */ new TextEncoder, textDecoder = /* @__PURE__ */ new TextDecoder;
  function extractBody(object, keepalive = !1) {
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    let stream = null;
    if (object instanceof ReadableStream2)
      stream = object;
    else if (isBlobLike(object))
      stream = object.stream();
    else
      stream = new ReadableStream2({
        async pull(controller) {
          controller.enqueue(typeof source === "string" ? textEncoder.encode(source) : source), queueMicrotask(() => readableStreamClose(controller));
        },
        start() {},
        type: void 0
      });
    assert(isReadableStreamLike(stream));
    let action = null, source = null, length = null, type = null;
    if (typeof object === "string")
      source = object, type = "text/plain;charset=UTF-8";
    else if (object instanceof URLSearchParams)
      source = object.toString(), type = "application/x-www-form-urlencoded;charset=UTF-8";
    else if (isArrayBuffer(object))
      source = new Uint8Array(object.slice());
    else if (ArrayBuffer.isView(object))
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    else if (util.isFormDataLike(object)) {
      let boundary = `----formdata-undici-0${`${random(100000000000)}`.padStart(11, "0")}`, prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
      let escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, `\r
`), blobParts = [], rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = !1;
      for (let [name, value] of object)
        if (typeof value === "string") {
          let chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2), length += chunk2.byteLength;
        } else {
          let chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          if (blobParts.push(chunk2, value, rn), typeof value.size === "number")
            length += chunk2.byteLength + value.size + rn.byteLength;
          else
            hasUnknownSizeValue = !0;
        }
      let chunk = textEncoder.encode(`--${boundary}--`);
      if (blobParts.push(chunk), length += chunk.byteLength, hasUnknownSizeValue)
        length = null;
      source = object, action = async function* () {
        for (let part of blobParts)
          if (part.stream)
            yield* part.stream();
          else
            yield part;
      }, type = "multipart/form-data; boundary=" + boundary;
    } else if (isBlobLike(object)) {
      if (source = object, length = object.size, object.type)
        type = object.type;
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive)
        throw TypeError("keepalive");
      if (util.isDisturbed(object) || object.locked)
        throw TypeError("Response body object should not be disturbed or locked");
      stream = object instanceof ReadableStream2 ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util.isBuffer(source))
      length = Buffer.byteLength(source);
    if (action != null) {
      let iterator;
      stream = new ReadableStream2({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          let { value, done } = await iterator.next();
          if (done)
            queueMicrotask(() => {
              controller.close();
            });
          else if (!isErrored(stream))
            controller.enqueue(new Uint8Array(value));
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: void 0
      });
    }
    return [{ stream, source, length }, type];
  }
  function safelyExtractBody(object, keepalive = !1) {
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    if (object instanceof ReadableStream2)
      assert(!util.isDisturbed(object), "The body has already been consumed."), assert(!object.locked, "The stream is locked.");
    return extractBody(object, keepalive);
  }
  function cloneBody(body) {
    let [out1, out2] = body.stream.tee(), out2Clone = structuredClone(out2, { transfer: [out2] }), [, finalClone] = out2Clone.tee();
    return body.stream = out1, {
      stream: finalClone,
      length: body.length,
      source: body.source
    };
  }
  async function* consumeBody(body) {
    if (body)
      if (isUint8Array(body))
        yield body;
      else {
        let stream = body.stream;
        if (util.isDisturbed(stream))
          throw TypeError("The body has already been consumed.");
        if (stream.locked)
          throw TypeError("The stream is locked.");
        stream[kBodyUsed] = !0, yield* stream;
      }
  }
  function throwIfAborted(state) {
    if (state.aborted)
      throw new DOMException2("The operation was aborted.", "AbortError");
  }
  function bodyMixinMethods(instance) {
    return {
      blob() {
        return specConsumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === "failure")
            mimeType = "";
          else if (mimeType)
            mimeType = serializeAMimeType(mimeType);
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return specConsumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return specConsumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return specConsumeBody(this, parseJSONFromBytes, instance);
      },
      async formData() {
        webidl.brandCheck(this, instance), throwIfAborted(this[kState]);
        let contentType = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(contentType)) {
          let headers = {};
          for (let [key, value] of this.headers)
            headers[key.toLowerCase()] = value;
          let responseFormData = new FormData2, busboy;
          try {
            busboy = new Busboy({
              headers,
              preservePath: !0
            });
          } catch (err) {
            throw new DOMException2(`${err}`, "AbortError");
          }
          busboy.on("field", (name, value) => {
            responseFormData.append(name, value);
          }), busboy.on("file", (name, value, filename, encoding, mimeType) => {
            let chunks = [];
            if (encoding === "base64" || encoding.toLowerCase() === "base64") {
              let base64chunk = "";
              value.on("data", (chunk) => {
                base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                let end = base64chunk.length - base64chunk.length % 4;
                chunks.push(Buffer.from(base64chunk.slice(0, end), "base64")), base64chunk = base64chunk.slice(end);
              }), value.on("end", () => {
                chunks.push(Buffer.from(base64chunk, "base64")), responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
            } else
              value.on("data", (chunk) => {
                chunks.push(chunk);
              }), value.on("end", () => {
                responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
          });
          let busboyResolve = new Promise((resolve, reject) => {
            busboy.on("finish", resolve), busboy.on("error", (err) => reject(TypeError(err)));
          });
          if (this.body !== null)
            for await (let chunk of consumeBody(this[kState].body))
              busboy.write(chunk);
          return busboy.end(), await busboyResolve, responseFormData;
        } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
          let entries;
          try {
            let text = "", streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: !0 });
            for await (let chunk of consumeBody(this[kState].body)) {
              if (!isUint8Array(chunk))
                throw TypeError("Expected Uint8Array chunk");
              text += streamingDecoder.decode(chunk, { stream: !0 });
            }
            text += streamingDecoder.decode(), entries = new URLSearchParams(text);
          } catch (err) {
            throw Object.assign(TypeError(), { cause: err });
          }
          let formData = new FormData2;
          for (let [name, value] of entries)
            formData.append(name, value);
          return formData;
        } else
          throw await Promise.resolve(), throwIfAborted(this[kState]), webidl.errors.exception({
            header: `${instance.name}.formData`,
            message: "Could not parse content as FormData."
          });
      }
    };
  }
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  async function specConsumeBody(object, convertBytesToJSValue, instance) {
    if (webidl.brandCheck(object, instance), throwIfAborted(object[kState]), bodyUnusable(object[kState].body))
      throw TypeError("Body is unusable");
    let promise = createDeferredPromise(), errorSteps = (error) => promise.reject(error), successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null)
      return successSteps(new Uint8Array), promise.promise;
    return await fullyReadBody(object[kState].body, successSteps, errorSteps), promise.promise;
  }
  function bodyUnusable(body) {
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  }
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0)
      return "";
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191)
      buffer = buffer.subarray(3);
    return textDecoder.decode(buffer);
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(object) {
    let { headersList } = object[kState], contentType = headersList.get("content-type");
    if (contentType === null)
      return "failure";
    return parseMIMEType(contentType);
  }
  module.exports = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody
  };
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS((exports, module) => {
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors(), assert = __require("assert"), { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols(), util = require_util(), tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/, headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/, invalidPathRegex = /[^\u0021-\u00ff]/, kHandler = Symbol("handler"), channels = {}, extractBody;
  try {
    let diagnosticsChannel = __require("diagnostics_channel");
    channels.create = diagnosticsChannel.channel("undici:request:create"), channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent"), channels.headers = diagnosticsChannel.channel("undici:request:headers"), channels.trailers = diagnosticsChannel.channel("undici:request:trailers"), channels.error = diagnosticsChannel.channel("undici:request:error");
  } catch {
    channels.create = { hasSubscribers: !1 }, channels.bodySent = { hasSubscribers: !1 }, channels.headers = { hasSubscribers: !1 }, channels.trailers = { hasSubscribers: !1 }, channels.error = { hasSubscribers: !1 };
  }

  class Request {
    constructor(origin, {
      path,
      method,
      body,
      headers,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      throwOnError,
      expectContinue
    }, handler) {
      if (typeof path !== "string")
        throw new InvalidArgumentError("path must be a string");
      else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT")
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      else if (invalidPathRegex.exec(path) !== null)
        throw new InvalidArgumentError("invalid request path");
      if (typeof method !== "string")
        throw new InvalidArgumentError("method must be a string");
      else if (tokenRegExp.exec(method) === null)
        throw new InvalidArgumentError("invalid request method");
      if (upgrade && typeof upgrade !== "string")
        throw new InvalidArgumentError("upgrade must be a string");
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0))
        throw new InvalidArgumentError("invalid headersTimeout");
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0))
        throw new InvalidArgumentError("invalid bodyTimeout");
      if (reset != null && typeof reset !== "boolean")
        throw new InvalidArgumentError("invalid reset");
      if (expectContinue != null && typeof expectContinue !== "boolean")
        throw new InvalidArgumentError("invalid expectContinue");
      if (this.headersTimeout = headersTimeout, this.bodyTimeout = bodyTimeout, this.throwOnError = throwOnError === !0, this.method = method, this.abort = null, body == null)
        this.body = null;
      else if (util.isStream(body)) {
        this.body = body;
        let rState = this.body._readableState;
        if (!rState || !rState.autoDestroy)
          this.endHandler = function() {
            util.destroy(this);
          }, this.body.on("end", this.endHandler);
        this.errorHandler = (err) => {
          if (this.abort)
            this.abort(err);
          else
            this.error = err;
        }, this.body.on("error", this.errorHandler);
      } else if (util.isBuffer(body))
        this.body = body.byteLength ? body : null;
      else if (ArrayBuffer.isView(body))
        this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
      else if (body instanceof ArrayBuffer)
        this.body = body.byteLength ? Buffer.from(body) : null;
      else if (typeof body === "string")
        this.body = body.length ? Buffer.from(body) : null;
      else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body))
        this.body = body;
      else
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      if (this.completed = !1, this.aborted = !1, this.upgrade = upgrade || null, this.path = query ? util.buildURL(path, query) : path, this.origin = origin, this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent, this.blocking = blocking == null ? !1 : blocking, this.reset = reset == null ? null : reset, this.host = null, this.contentLength = null, this.contentType = null, this.headers = "", this.expectContinue = expectContinue != null ? expectContinue : !1, Array.isArray(headers)) {
        if (headers.length % 2 !== 0)
          throw new InvalidArgumentError("headers array must be even");
        for (let i = 0;i < headers.length; i += 2)
          processHeader(this, headers[i], headers[i + 1]);
      } else if (headers && typeof headers === "object") {
        let keys = Object.keys(headers);
        for (let i = 0;i < keys.length; i++) {
          let key = keys[i];
          processHeader(this, key, headers[key]);
        }
      } else if (headers != null)
        throw new InvalidArgumentError("headers must be an object or an array");
      if (util.isFormDataLike(this.body)) {
        if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8)
          throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
        if (!extractBody)
          extractBody = require_body().extractBody;
        let [bodyStream, contentType] = extractBody(body);
        if (this.contentType == null)
          this.contentType = contentType, this.headers += `content-type: ${contentType}\r
`;
        this.body = bodyStream.stream, this.contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && this.contentType == null && body.type)
        this.contentType = body.type, this.headers += `content-type: ${body.type}\r
`;
      if (util.validateHandler(handler, method, upgrade), this.servername = util.getServerName(this.host), this[kHandler] = handler, channels.create.hasSubscribers)
        channels.create.publish({ request: this });
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent)
        try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers)
        channels.bodySent.publish({ request: this });
      if (this[kHandler].onRequestSent)
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
    }
    onConnect(abort) {
      if (assert(!this.aborted), assert(!this.completed), this.error)
        abort(this.error);
      else
        return this.abort = abort, this[kHandler].onConnect(abort);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      if (assert(!this.aborted), assert(!this.completed), channels.headers.hasSubscribers)
        channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
      try {
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk) {
      assert(!this.aborted), assert(!this.completed);
      try {
        return this[kHandler].onData(chunk);
      } catch (err) {
        return this.abort(err), !1;
      }
    }
    onUpgrade(statusCode, headers, socket) {
      return assert(!this.aborted), assert(!this.completed), this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      if (this.onFinally(), assert(!this.aborted), this.completed = !0, channels.trailers.hasSubscribers)
        channels.trailers.publish({ request: this, trailers });
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error) {
      if (this.onFinally(), channels.error.hasSubscribers)
        channels.error.publish({ request: this, error });
      if (this.aborted)
        return;
      return this.aborted = !0, this[kHandler].onError(error);
    }
    onFinally() {
      if (this.errorHandler)
        this.body.off("error", this.errorHandler), this.errorHandler = null;
      if (this.endHandler)
        this.body.off("end", this.endHandler), this.endHandler = null;
    }
    addHeader(key, value) {
      return processHeader(this, key, value), this;
    }
    static [kHTTP1BuildRequest](origin, opts, handler) {
      return new Request(origin, opts, handler);
    }
    static [kHTTP2BuildRequest](origin, opts, handler) {
      let headers = opts.headers;
      opts = { ...opts, headers: null };
      let request = new Request(origin, opts, handler);
      if (request.headers = {}, Array.isArray(headers)) {
        if (headers.length % 2 !== 0)
          throw new InvalidArgumentError("headers array must be even");
        for (let i = 0;i < headers.length; i += 2)
          processHeader(request, headers[i], headers[i + 1], !0);
      } else if (headers && typeof headers === "object") {
        let keys = Object.keys(headers);
        for (let i = 0;i < keys.length; i++) {
          let key = keys[i];
          processHeader(request, key, headers[key], !0);
        }
      } else if (headers != null)
        throw new InvalidArgumentError("headers must be an object or an array");
      return request;
    }
    static [kHTTP2CopyHeaders](raw) {
      let rawHeaders = raw.split(`\r
`), headers = {};
      for (let header of rawHeaders) {
        let [key, value] = header.split(": ");
        if (value == null || value.length === 0)
          continue;
        if (headers[key])
          headers[key] += `,${value}`;
        else
          headers[key] = value;
      }
      return headers;
    }
  }
  function processHeaderValue(key, val, skipAppend) {
    if (val && typeof val === "object")
      throw new InvalidArgumentError(`invalid ${key} header`);
    if (val = val != null ? `${val}` : "", headerCharRegex.exec(val) !== null)
      throw new InvalidArgumentError(`invalid ${key} header`);
    return skipAppend ? val : `${key}: ${val}\r
`;
  }
  function processHeader(request, key, val, skipAppend = !1) {
    if (val && (typeof val === "object" && !Array.isArray(val)))
      throw new InvalidArgumentError(`invalid ${key} header`);
    else if (val === void 0)
      return;
    if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
      if (headerCharRegex.exec(val) !== null)
        throw new InvalidArgumentError(`invalid ${key} header`);
      request.host = val;
    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      if (request.contentLength = parseInt(val, 10), !Number.isFinite(request.contentLength))
        throw new InvalidArgumentError("invalid content-length header");
    } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type")
      if (request.contentType = val, skipAppend)
        request.headers[key] = processHeaderValue(key, val, skipAppend);
      else
        request.headers += processHeaderValue(key, val);
    else if (key.length === 17 && key.toLowerCase() === "transfer-encoding")
      throw new InvalidArgumentError("invalid transfer-encoding header");
    else if (key.length === 10 && key.toLowerCase() === "connection") {
      let value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive")
        throw new InvalidArgumentError("invalid connection header");
      else if (value === "close")
        request.reset = !0;
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive")
      throw new InvalidArgumentError("invalid keep-alive header");
    else if (key.length === 7 && key.toLowerCase() === "upgrade")
      throw new InvalidArgumentError("invalid upgrade header");
    else if (key.length === 6 && key.toLowerCase() === "expect")
      throw new NotSupportedError("expect header not supported");
    else if (tokenRegExp.exec(key) === null)
      throw new InvalidArgumentError("invalid header key");
    else if (Array.isArray(val))
      for (let i = 0;i < val.length; i++)
        if (skipAppend)
          if (request.headers[key])
            request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
          else
            request.headers[key] = processHeaderValue(key, val[i], skipAppend);
        else
          request.headers += processHeaderValue(key, val[i]);
    else if (skipAppend)
      request.headers[key] = processHeaderValue(key, val, skipAppend);
    else
      request.headers += processHeaderValue(key, val);
  }
  module.exports = Request;
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS((exports, module) => {
  var EventEmitter = __require("events");

  class Dispatcher extends EventEmitter {
    dispatch() {
      throw Error("not implemented");
    }
    close() {
      throw Error("not implemented");
    }
    destroy() {
      throw Error("not implemented");
    }
  }
  module.exports = Dispatcher;
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher(), {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = require_errors(), { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols(), kDestroyed = Symbol("destroyed"), kClosed = Symbol("closed"), kOnDestroyed = Symbol("onDestroyed"), kOnClosed = Symbol("onClosed"), kInterceptedDispatch = Symbol("Intercepted Dispatch");

  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = !1, this[kOnDestroyed] = null, this[kClosed] = !1, this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i = newInterceptors.length - 1;i >= 0; i--)
          if (typeof this[kInterceptors][i] !== "function")
            throw new InvalidArgumentError("interceptor must be an function");
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === void 0)
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      if (typeof callback !== "function")
        throw new InvalidArgumentError("invalid callback");
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed])
          this[kOnClosed].push(callback);
        else
          queueMicrotask(() => callback(null, null));
        return;
      }
      this[kClosed] = !0, this[kOnClosed].push(callback);
      let onClosed = () => {
        let callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0;i < callbacks.length; i++)
          callbacks[i](null, null);
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function")
        callback = err, err = null;
      if (callback === void 0)
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      if (typeof callback !== "function")
        throw new InvalidArgumentError("invalid callback");
      if (this[kDestroyed]) {
        if (this[kOnDestroyed])
          this[kOnDestroyed].push(callback);
        else
          queueMicrotask(() => callback(null, null));
        return;
      }
      if (!err)
        err = new ClientDestroyedError;
      this[kDestroyed] = !0, this[kOnDestroyed] = this[kOnDestroyed] || [], this[kOnDestroyed].push(callback);
      let onDestroyed = () => {
        let callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0;i < callbacks.length; i++)
          callbacks[i](null, null);
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0)
        return this[kInterceptedDispatch] = this[kDispatch], this[kDispatch](opts, handler);
      let dispatch = this[kDispatch].bind(this);
      for (let i = this[kInterceptors].length - 1;i >= 0; i--)
        dispatch = this[kInterceptors][i](dispatch);
      return this[kInterceptedDispatch] = dispatch, dispatch(opts, handler);
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object")
        throw new InvalidArgumentError("handler must be an object");
      try {
        if (!opts || typeof opts !== "object")
          throw new InvalidArgumentError("opts must be an object.");
        if (this[kDestroyed] || this[kOnDestroyed])
          throw new ClientDestroyedError;
        if (this[kClosed])
          throw new ClientClosedError;
        return this[kInterceptedDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function")
          throw new InvalidArgumentError("invalid onError method");
        return handler.onError(err), !1;
      }
    }
  }
  module.exports = DispatcherBase;
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS((exports, module) => {
  var net = __require("net"), assert = __require("assert"), util = require_util(), { InvalidArgumentError, ConnectTimeoutError } = require_errors(), tls, SessionCache;
  if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE)
    SessionCache = class {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions, this._sessionCache = /* @__PURE__ */ new Map, this._sessionRegistry = new global.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions)
            return;
          let ref = this._sessionCache.get(key);
          if (ref !== void 0 && ref.deref() === void 0)
            this._sessionCache.delete(key);
        });
      }
      get(sessionKey) {
        let ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0)
          return;
        this._sessionCache.set(sessionKey, new WeakRef(session)), this._sessionRegistry.register(session, sessionKey);
      }
    };
  else
    SessionCache = class {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions, this._sessionCache = /* @__PURE__ */ new Map;
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0)
          return;
        if (this._sessionCache.size >= this._maxCachedSessions) {
          let { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0))
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    let options = { path: socketPath, ...opts }, sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    return timeout = timeout == null ? 1e4 : timeout, allowH2 = allowH2 != null ? allowH2 : !1, function({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls)
          tls = __require("tls");
        servername = servername || options.servername || util.getServerName(host) || null;
        let sessionKey = servername || hostname, session = sessionCache.get(sessionKey) || null;
        assert(sessionKey), socket = tls.connect({
          highWaterMark: 16384,
          ...options,
          servername,
          session,
          localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          port: port || 443,
          host: hostname
        }), socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else
        assert(!httpSocket, "httpSocket can only be sent on TLS update"), socket = net.connect({
          highWaterMark: 65536,
          ...options,
          localAddress,
          port: port || 80,
          host: hostname
        });
      if (options.keepAlive == null || options.keepAlive) {
        let keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 60000 : options.keepAliveInitialDelay;
        socket.setKeepAlive(!0, keepAliveInitialDelay);
      }
      let cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
      return socket.setNoDelay(!0).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        if (cancelTimeout(), callback) {
          let cb = callback;
          callback = null, cb(null, this);
        }
      }).on("error", function(err) {
        if (cancelTimeout(), callback) {
          let cb = callback;
          callback = null, cb(err);
        }
      }), socket;
    };
  }
  function setupTimeout(onConnectTimeout2, timeout) {
    if (!timeout)
      return () => {};
    let s1 = null, s2 = null, timeoutId = setTimeout(() => {
      s1 = setImmediate(() => {
        if (process.platform === "win32")
          s2 = setImmediate(() => onConnectTimeout2());
        else
          onConnectTimeout2();
      });
    }, timeout);
    return () => {
      clearTimeout(timeoutId), clearImmediate(s1), clearImmediate(s2);
    };
  }
  function onConnectTimeout(socket) {
    util.destroy(socket, new ConnectTimeoutError);
  }
  module.exports = buildConnector;
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.enumToMap = void 0;
  function enumToMap(obj) {
    let res = {};
    return Object.keys(obj).forEach((key) => {
      let value = obj[key];
      if (typeof value === "number")
        res[key] = value;
    }), res;
  }
  exports.enumToMap = enumToMap;
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
  var utils_1 = require_utils2(), ERROR;
  (function(ERROR2) {
    ERROR2[ERROR2.OK = 0] = "OK", ERROR2[ERROR2.INTERNAL = 1] = "INTERNAL", ERROR2[ERROR2.STRICT = 2] = "STRICT", ERROR2[ERROR2.LF_EXPECTED = 3] = "LF_EXPECTED", ERROR2[ERROR2.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", ERROR2[ERROR2.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", ERROR2[ERROR2.INVALID_METHOD = 6] = "INVALID_METHOD", ERROR2[ERROR2.INVALID_URL = 7] = "INVALID_URL", ERROR2[ERROR2.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", ERROR2[ERROR2.INVALID_VERSION = 9] = "INVALID_VERSION", ERROR2[ERROR2.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", ERROR2[ERROR2.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", ERROR2[ERROR2.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", ERROR2[ERROR2.INVALID_STATUS = 13] = "INVALID_STATUS", ERROR2[ERROR2.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", ERROR2[ERROR2.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", ERROR2[ERROR2.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", ERROR2[ERROR2.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", ERROR2[ERROR2.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", ERROR2[ERROR2.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", ERROR2[ERROR2.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", ERROR2[ERROR2.PAUSED = 21] = "PAUSED", ERROR2[ERROR2.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", ERROR2[ERROR2.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", ERROR2[ERROR2.USER = 24] = "USER";
  })(ERROR = exports.ERROR || (exports.ERROR = {}));
  var TYPE;
  (function(TYPE2) {
    TYPE2[TYPE2.BOTH = 0] = "BOTH", TYPE2[TYPE2.REQUEST = 1] = "REQUEST", TYPE2[TYPE2.RESPONSE = 2] = "RESPONSE";
  })(TYPE = exports.TYPE || (exports.TYPE = {}));
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", FLAGS2[FLAGS2.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", FLAGS2[FLAGS2.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", FLAGS2[FLAGS2.CHUNKED = 8] = "CHUNKED", FLAGS2[FLAGS2.UPGRADE = 16] = "UPGRADE", FLAGS2[FLAGS2.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", FLAGS2[FLAGS2.SKIPBODY = 64] = "SKIPBODY", FLAGS2[FLAGS2.TRAILING = 128] = "TRAILING", FLAGS2[FLAGS2.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
  })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
  var LENIENT_FLAGS;
  (function(LENIENT_FLAGS2) {
    LENIENT_FLAGS2[LENIENT_FLAGS2.HEADERS = 1] = "HEADERS", LENIENT_FLAGS2[LENIENT_FLAGS2.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", LENIENT_FLAGS2[LENIENT_FLAGS2.KEEP_ALIVE = 4] = "KEEP_ALIVE";
  })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
  var METHODS;
  (function(METHODS2) {
    METHODS2[METHODS2.DELETE = 0] = "DELETE", METHODS2[METHODS2.GET = 1] = "GET", METHODS2[METHODS2.HEAD = 2] = "HEAD", METHODS2[METHODS2.POST = 3] = "POST", METHODS2[METHODS2.PUT = 4] = "PUT", METHODS2[METHODS2.CONNECT = 5] = "CONNECT", METHODS2[METHODS2.OPTIONS = 6] = "OPTIONS", METHODS2[METHODS2.TRACE = 7] = "TRACE", METHODS2[METHODS2.COPY = 8] = "COPY", METHODS2[METHODS2.LOCK = 9] = "LOCK", METHODS2[METHODS2.MKCOL = 10] = "MKCOL", METHODS2[METHODS2.MOVE = 11] = "MOVE", METHODS2[METHODS2.PROPFIND = 12] = "PROPFIND", METHODS2[METHODS2.PROPPATCH = 13] = "PROPPATCH", METHODS2[METHODS2.SEARCH = 14] = "SEARCH", METHODS2[METHODS2.UNLOCK = 15] = "UNLOCK", METHODS2[METHODS2.BIND = 16] = "BIND", METHODS2[METHODS2.REBIND = 17] = "REBIND", METHODS2[METHODS2.UNBIND = 18] = "UNBIND", METHODS2[METHODS2.ACL = 19] = "ACL", METHODS2[METHODS2.REPORT = 20] = "REPORT", METHODS2[METHODS2.MKACTIVITY = 21] = "MKACTIVITY", METHODS2[METHODS2.CHECKOUT = 22] = "CHECKOUT", METHODS2[METHODS2.MERGE = 23] = "MERGE", METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH", METHODS2[METHODS2.NOTIFY = 25] = "NOTIFY", METHODS2[METHODS2.SUBSCRIBE = 26] = "SUBSCRIBE", METHODS2[METHODS2.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", METHODS2[METHODS2.PATCH = 28] = "PATCH", METHODS2[METHODS2.PURGE = 29] = "PURGE", METHODS2[METHODS2.MKCALENDAR = 30] = "MKCALENDAR", METHODS2[METHODS2.LINK = 31] = "LINK", METHODS2[METHODS2.UNLINK = 32] = "UNLINK", METHODS2[METHODS2.SOURCE = 33] = "SOURCE", METHODS2[METHODS2.PRI = 34] = "PRI", METHODS2[METHODS2.DESCRIBE = 35] = "DESCRIBE", METHODS2[METHODS2.ANNOUNCE = 36] = "ANNOUNCE", METHODS2[METHODS2.SETUP = 37] = "SETUP", METHODS2[METHODS2.PLAY = 38] = "PLAY", METHODS2[METHODS2.PAUSE = 39] = "PAUSE", METHODS2[METHODS2.TEARDOWN = 40] = "TEARDOWN", METHODS2[METHODS2.GET_PARAMETER = 41] = "GET_PARAMETER", METHODS2[METHODS2.SET_PARAMETER = 42] = "SET_PARAMETER", METHODS2[METHODS2.REDIRECT = 43] = "REDIRECT", METHODS2[METHODS2.RECORD = 44] = "RECORD", METHODS2[METHODS2.FLUSH = 45] = "FLUSH";
  })(METHODS = exports.METHODS || (exports.METHODS = {}));
  exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS["M-SEARCH"],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    METHODS.SOURCE
  ];
  exports.METHODS_ICE = [
    METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    METHODS.GET,
    METHODS.POST
  ];
  exports.METHOD_MAP = utils_1.enumToMap(METHODS);
  exports.H_METHOD_MAP = {};
  Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key))
      exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
  });
  var FINISH;
  (function(FINISH2) {
    FINISH2[FINISH2.SAFE = 0] = "SAFE", FINISH2[FINISH2.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", FINISH2[FINISH2.UNSAFE = 2] = "UNSAFE";
  })(FINISH = exports.FINISH || (exports.FINISH = {}));
  exports.ALPHA = [];
  for (let i = 65;i <= 90; i++)
    exports.ALPHA.push(String.fromCharCode(i)), exports.ALPHA.push(String.fromCharCode(i + 32));
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["\t", "\f"]);
  for (let i = 128;i <= 255; i++)
    exports.URL_CHAR.push(i);
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
  exports.HEADER_CHARS = ["\t"];
  for (let i = 32;i <= 255; i++)
    if (i !== 127)
      exports.HEADER_CHARS.push(i);
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  var HEADER_STATE;
  (function(HEADER_STATE2) {
    HEADER_STATE2[HEADER_STATE2.GENERAL = 0] = "GENERAL", HEADER_STATE2[HEADER_STATE2.CONNECTION = 1] = "CONNECTION", HEADER_STATE2[HEADER_STATE2.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", HEADER_STATE2[HEADER_STATE2.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", HEADER_STATE2[HEADER_STATE2.UPGRADE = 4] = "UPGRADE", HEADER_STATE2[HEADER_STATE2.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", HEADER_STATE2[HEADER_STATE2.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", HEADER_STATE2[HEADER_STATE2.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", HEADER_STATE2[HEADER_STATE2.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
  })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
  exports.SPECIAL_HEADERS = {
    connection: HEADER_STATE.CONNECTION,
    "content-length": HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": HEADER_STATE.CONNECTION,
    "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
    upgrade: HEADER_STATE.UPGRADE
  };
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS((exports, module) => {
  var util = require_util(), { kBodyUsed } = require_symbols(), assert = __require("assert"), { InvalidArgumentError } = require_errors(), EE = __require("events"), redirectableStatusCodes = [300, 301, 302, 303, 307, 308], kBody = Symbol("body");

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body, this[kBodyUsed] = !1;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed"), this[kBodyUsed] = !0, yield* this[kBody];
    }
  }

  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0))
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      if (util.validateHandler(handler, opts.method, opts.upgrade), this.dispatch = dispatch, this.location = null, this.abort = null, this.opts = { ...opts, maxRedirections: 0 }, this.maxRedirections = maxRedirections, this.handler = handler, this.history = [], util.isStream(this.opts.body)) {
        if (util.bodyLength(this.opts.body) === 0)
          this.opts.body.on("data", function() {
            assert(!1);
          });
        if (typeof this.opts.body.readableDidRead !== "boolean")
          this.opts.body[kBodyUsed] = !1, EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = !0;
          });
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function")
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body))
        this.opts.body = new BodyAsyncIterable(this.opts.body);
    }
    onConnect(abort) {
      this.abort = abort, this.handler.onConnect(abort, { history: this.history });
    }
    onUpgrade(statusCode, headers, socket) {
      this.handler.onUpgrade(statusCode, headers, socket);
    }
    onError(error) {
      this.handler.onError(error);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      if (this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers), this.opts.origin)
        this.history.push(new URL(this.opts.path, this.opts.origin));
      if (!this.location)
        return this.handler.onHeaders(statusCode, headers, resume, statusText);
      let { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), path = search ? `${pathname}${search}` : pathname;
      if (this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin), this.opts.path = path, this.opts.origin = origin, this.opts.maxRedirections = 0, this.opts.query = null, statusCode === 303 && this.opts.method !== "HEAD")
        this.opts.method = "GET", this.opts.body = null;
    }
    onData(chunk) {
      if (this.location)
        ;
      else
        return this.handler.onData(chunk);
    }
    onComplete(trailers) {
      if (this.location)
        this.location = null, this.abort = null, this.dispatch(this.opts, this);
      else
        this.handler.onComplete(trailers);
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent)
        this.handler.onBodySent(chunk);
    }
  }
  function parseLocation(statusCode, headers) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1)
      return null;
    for (let i = 0;i < headers.length; i += 2)
      if (headers[i].toString().toLowerCase() === "location")
        return headers[i + 1];
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4)
      return util.headerNameToString(header) === "host";
    if (removeContent && util.headerNameToString(header).startsWith("content-"))
      return !0;
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      let name = util.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return !1;
  }
  function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
    let ret = [];
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2)
        if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin))
          ret.push(headers[i], headers[i + 1]);
    } else if (headers && typeof headers === "object") {
      for (let key of Object.keys(headers))
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin))
          ret.push(key, headers[key]);
    } else
      assert(headers == null, "headers must be an object or an array");
    return ret;
  }
  module.exports = RedirectHandler;
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS((exports, module) => {
  var RedirectHandler = require_RedirectHandler();
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function(opts, handler) {
        let { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections)
          return dispatch(opts, handler);
        let redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        return opts = { ...opts, maxRedirections: 0 }, dispatch(opts, redirectHandler);
      };
    };
  }
  module.exports = createRedirectInterceptor;
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
});

// node_modules/undici/lib/client.js
var require_client = __commonJS((exports, module) => {
  var assert = __require("assert"), net = __require("net"), http = __require("http"), { pipeline } = __require("stream"), util = require_util(), timers = require_timers(), Request = require_request(), DispatcherBase = require_dispatcher_base(), {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError,
    ClientDestroyedError
  } = require_errors(), buildConnector = require_connect(), {
    kUrl,
    kReset,
    kServerName,
    kClient,
    kBusy,
    kParser,
    kConnect,
    kBlocking,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize,
    kHTTPConnVersion,
    kHost,
    kHTTP2Session,
    kHTTP2SessionState,
    kHTTP2BuildRequest,
    kHTTP2CopyHeaders,
    kHTTP1BuildRequest
  } = require_symbols(), http2;
  try {
    http2 = __require("http2");
  } catch {
    http2 = { constants: {} };
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS
    }
  } = http2, h2ExperimentalWarned = !1, FastBuffer = Buffer[Symbol.species], kClosedResolve = Symbol("kClosedResolve"), channels = {};
  try {
    let diagnosticsChannel = __require("diagnostics_channel");
    channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders"), channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect"), channels.connectError = diagnosticsChannel.channel("undici:client:connectError"), channels.connected = diagnosticsChannel.channel("undici:client:connected");
  } catch {
    channels.sendHeaders = { hasSubscribers: !1 }, channels.beforeConnect = { hasSubscribers: !1 }, channels.connectError = { hasSubscribers: !1 }, channels.connected = { hasSubscribers: !1 };
  }

  class Client extends DispatcherBase {
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect2,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      maxConcurrentStreams
    } = {}) {
      super();
      if (keepAlive !== void 0)
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      if (socketTimeout !== void 0)
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      if (requestTimeout !== void 0)
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      if (idleTimeout !== void 0)
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      if (maxKeepAliveTimeout !== void 0)
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize))
        throw new InvalidArgumentError("invalid maxHeaderSize");
      if (socketPath != null && typeof socketPath !== "string")
        throw new InvalidArgumentError("invalid socketPath");
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0))
        throw new InvalidArgumentError("invalid connectTimeout");
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0))
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0))
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold))
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0))
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0))
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object")
        throw new InvalidArgumentError("connect must be a function or an object");
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0))
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0))
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0))
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1))
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1))
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      if (allowH2 != null && typeof allowH2 !== "boolean")
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1))
        throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
      if (typeof connect2 !== "function")
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect2
        });
      this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })], this[kUrl] = util.parseOrigin(url), this[kConnector] = connect2, this[kSocket] = null, this[kPipelining] = pipelining != null ? pipelining : 1, this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize, this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4000 : keepAliveTimeout, this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600000 : keepAliveMaxTimeout, this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1000 : keepAliveTimeoutThreshold, this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout], this[kServerName] = null, this[kLocalAddress] = localAddress != null ? localAddress : null, this[kResuming] = 0, this[kNeedDrain] = 0, this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`, this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300000, this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300000, this[kStrictContentLength] = strictContentLength == null ? !0 : strictContentLength, this[kMaxRedirections] = maxRedirections, this[kMaxRequests] = maxRequestsPerClient, this[kClosedResolve] = null, this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1, this[kHTTPConnVersion] = "h1", this[kHTTP2Session] = null, this[kHTTP2SessionState] = !allowH2 ? null : {
        openStreams: 0,
        maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
      }, this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`, this[kQueue] = [], this[kRunningIdx] = 0, this[kPendingIdx] = 0;
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value, resume(this, !0);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
    }
    get [kBusy]() {
      let socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
    }
    [kConnect](cb) {
      connect(this), this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      let origin = opts.origin || this[kUrl].origin, request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
      if (this[kQueue].push(request), this[kResuming])
        ;
      else if (util.bodyLength(request.body) == null && util.isIterable(request.body))
        this[kResuming] = 1, process.nextTick(resume, this);
      else
        resume(this, !0);
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy])
        this[kNeedDrain] = 2;
      return this[kNeedDrain] < 2;
    }
    async[kClose]() {
      return new Promise((resolve) => {
        if (!this[kSize])
          resolve(null);
        else
          this[kClosedResolve] = resolve;
      });
    }
    async[kDestroy](err) {
      return new Promise((resolve) => {
        let requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0;i < requests.length; i++) {
          let request = requests[i];
          errorRequest(this, request, err);
        }
        let callback = () => {
          if (this[kClosedResolve])
            this[kClosedResolve](), this[kClosedResolve] = null;
          resolve();
        };
        if (this[kHTTP2Session] != null)
          util.destroy(this[kHTTP2Session], err), this[kHTTP2Session] = null, this[kHTTP2SessionState] = null;
        if (!this[kSocket])
          queueMicrotask(callback);
        else
          util.destroy(this[kSocket].on("close", callback), err);
        resume(this);
      });
    }
  }
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[kSocket][kError] = err, onError(this[kClient], err);
  }
  function onHttp2FrameError(type, code, id) {
    let err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
    if (id === 0)
      this[kSocket][kError] = err, onError(this[kClient], err);
  }
  function onHttp2SessionEnd() {
    util.destroy(this, new SocketError("other side closed")), util.destroy(this[kSocket], new SocketError("other side closed"));
  }
  function onHTTP2GoAway(code) {
    let client = this[kClient], err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
    if (client[kSocket] = null, client[kHTTP2Session] = null, client.destroyed) {
      assert(this[kPending] === 0);
      let requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        let request = requests[i];
        errorRequest(this, request, err);
      }
    } else if (client[kRunning] > 0) {
      let request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null, errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx], assert(client[kRunning] === 0), client.emit("disconnect", client[kUrl], [client], err), resume(client);
  }
  var constants = require_constants3(), createRedirectInterceptor = require_redirectInterceptor(), EMPTY_BUF = Buffer.alloc(0);
  async function lazyllhttp() {
    let llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0, mod;
    try {
      mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
    } catch (e) {
      mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          return assert.strictEqual(currentParser.ptr, p), currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          return assert.strictEqual(currentParser.ptr, p), currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          return assert.strictEqual(currentParser.ptr, p), currentParser.onMessageComplete() || 0;
        }
      }
    });
  }
  var llhttpInstance = null, llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null, currentBufferRef = null, currentBufferSize = 0, currentBufferPtr = null, TIMEOUT_HEADERS = 1, TIMEOUT_BODY = 2, TIMEOUT_IDLE = 3;

  class Parser {
    constructor(client, socket, { exports: exports2 }) {
      assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0), this.llhttp = exports2, this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE), this.client = client, this.socket = socket, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = !1, this.headers = [], this.headersSize = 0, this.headersMaxSize = client[kMaxHeadersSize], this.shouldKeepAlive = !1, this.paused = !1, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = client[kMaxResponseSize];
    }
    setTimeout(value, type) {
      if (this.timeoutType = type, value !== this.timeoutValue) {
        if (timers.clearTimeout(this.timeout), value) {
          if (this.timeout = timers.setTimeout(onParserTimeout, value, this), this.timeout.unref)
            this.timeout.unref();
        } else
          this.timeout = null;
        this.timeoutValue = value;
      } else if (this.timeout) {
        if (this.timeout.refresh)
          this.timeout.refresh();
      }
    }
    resume() {
      if (this.socket.destroyed || !this.paused)
        return;
      if (assert(this.ptr != null), assert(currentParser == null), this.llhttp.llhttp_resume(this.ptr), assert(this.timeoutType === TIMEOUT_BODY), this.timeout) {
        if (this.timeout.refresh)
          this.timeout.refresh();
      }
      this.paused = !1, this.execute(this.socket.read() || EMPTY_BUF), this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        let chunk = this.socket.read();
        if (chunk === null)
          break;
        this.execute(chunk);
      }
    }
    execute(data) {
      assert(this.ptr != null), assert(currentParser == null), assert(!this.paused);
      let { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr)
          llhttp.free(currentBufferPtr);
        currentBufferSize = Math.ceil(data.length / 4096) * 4096, currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data, currentParser = this, ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null, currentBufferRef = null;
        }
        let offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants.ERROR.PAUSED_UPGRADE)
          this.onUpgrade(data.slice(offset));
        else if (ret === constants.ERROR.PAUSED)
          this.paused = !0, socket.unshift(data.slice(offset));
        else if (ret !== constants.ERROR.OK) {
          let ptr = llhttp.llhttp_get_error_reason(this.ptr), message = "";
          if (ptr) {
            let len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    destroy() {
      assert(this.ptr != null), assert(currentParser == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, timers.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = !1;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      let { socket, client } = this;
      if (socket.destroyed)
        return -1;
      if (!client[kQueue][client[kRunningIdx]])
        return -1;
    }
    onHeaderField(buf) {
      let len = this.headers.length;
      if ((len & 1) === 0)
        this.headers.push(buf);
      else
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1)
        this.headers.push(buf), len += 1;
      else
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      let key = this.headers[len - 2];
      if (key.length === 10 && key.toString().toLowerCase() === "keep-alive")
        this.keepAlive += buf.toString();
      else if (key.length === 10 && key.toString().toLowerCase() === "connection")
        this.connection += buf.toString();
      else if (key.length === 14 && key.toString().toLowerCase() === "content-length")
        this.contentLength += buf.toString();
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      if (this.headersSize += len, this.headersSize >= this.headersMaxSize)
        util.destroy(this.socket, new HeadersOverflowError);
    }
    onUpgrade(head) {
      let { upgrade, client, socket, headers, statusCode } = this;
      assert(upgrade);
      let request = client[kQueue][client[kRunningIdx]];
      assert(request), assert(!socket.destroyed), assert(socket === client[kSocket]), assert(!this.paused), assert(request.upgrade || request.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, assert(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, socket.unshift(head), socket[kParser].destroy(), socket[kParser] = null, socket[kClient] = null, socket[kError] = null, socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose), client[kSocket] = null, client[kQueue][client[kRunningIdx]++] = null, client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
      try {
        request.onUpgrade(statusCode, headers, socket);
      } catch (err) {
        util.destroy(socket, err);
      }
      resume(client);
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      let { client, socket, headers, statusText } = this;
      if (socket.destroyed)
        return -1;
      let request = client[kQueue][client[kRunningIdx]];
      if (!request)
        return -1;
      if (assert(!this.upgrade), assert(this.statusCode < 200), statusCode === 100)
        return util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket))), -1;
      if (upgrade && !request.upgrade)
        return util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket))), -1;
      if (assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS), this.statusCode = statusCode, this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
        let bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh)
          this.timeout.refresh();
      }
      if (request.method === "CONNECT")
        return assert(client[kRunning] === 1), this.upgrade = !0, 2;
      if (upgrade)
        return assert(client[kRunning] === 1), this.upgrade = !0, 2;
      if (assert(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && client[kPipelining]) {
        let keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          let timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0)
            socket[kReset] = !0;
          else
            client[kKeepAliveTimeoutValue] = timeout;
        } else
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
      } else
        socket[kReset] = !0;
      let pause = request.onHeaders(statusCode, headers, this.resume, statusText) === !1;
      if (request.aborted)
        return -1;
      if (request.method === "HEAD")
        return 1;
      if (statusCode < 200)
        return 1;
      if (socket[kBlocking])
        socket[kBlocking] = !1, resume(client);
      return pause ? constants.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      let { client, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed)
        return -1;
      let request = client[kQueue][client[kRunningIdx]];
      if (assert(request), assert.strictEqual(this.timeoutType, TIMEOUT_BODY), this.timeout) {
        if (this.timeout.refresh)
          this.timeout.refresh();
      }
      if (assert(statusCode >= 200), maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize)
        return util.destroy(socket, new ResponseExceededMaxSizeError), -1;
      if (this.bytesRead += buf.length, request.onData(buf) === !1)
        return constants.ERROR.PAUSED;
    }
    onMessageComplete() {
      let { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive))
        return -1;
      if (upgrade)
        return;
      let request = client[kQueue][client[kRunningIdx]];
      if (assert(request), assert(statusCode >= 100), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", assert(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, statusCode < 200)
        return;
      if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10))
        return util.destroy(socket, new ResponseContentLengthMismatchError), -1;
      if (request.onComplete(headers), client[kQueue][client[kRunningIdx]++] = null, socket[kWriting])
        return assert.strictEqual(client[kRunning], 0), util.destroy(socket, new InformationalError("reset")), constants.ERROR.PAUSED;
      else if (!shouldKeepAlive)
        return util.destroy(socket, new InformationalError("reset")), constants.ERROR.PAUSED;
      else if (socket[kReset] && client[kRunning] === 0)
        return util.destroy(socket, new InformationalError("reset")), constants.ERROR.PAUSED;
      else if (client[kPipelining] === 1)
        setImmediate(resume, client);
      else
        resume(client);
    }
  }
  function onParserTimeout(parser) {
    let { socket, timeoutType, client } = parser;
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1)
        assert(!parser.paused, "cannot be paused while waiting for headers"), util.destroy(socket, new HeadersTimeoutError);
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!parser.paused)
        util.destroy(socket, new BodyTimeoutError);
    } else if (timeoutType === TIMEOUT_IDLE)
      assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]), util.destroy(socket, new InformationalError("socket idle timeout"));
  }
  function onSocketReadable() {
    let { [kParser]: parser } = this;
    if (parser)
      parser.readMore();
  }
  function onSocketError(err) {
    let { [kClient]: client, [kParser]: parser } = this;
    if (assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), client[kHTTPConnVersion] !== "h2") {
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    this[kError] = err, onError(this[kClient], err);
  }
  function onError(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      let requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        let request = requests[i];
        errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  }
  function onSocketEnd() {
    let { [kParser]: parser, [kClient]: client } = this;
    if (client[kHTTPConnVersion] !== "h2") {
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
  }
  function onSocketClose() {
    let { [kClient]: client, [kParser]: parser } = this;
    if (client[kHTTPConnVersion] === "h1" && parser) {
      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive)
        parser.onMessageComplete();
      this[kParser].destroy(), this[kParser] = null;
    }
    let err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
    if (client[kSocket] = null, client.destroyed) {
      assert(client[kPending] === 0);
      let requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        let request = requests[i];
        errorRequest(client, request, err);
      }
    } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
      let request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null, errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx], assert(client[kRunning] === 0), client.emit("disconnect", client[kUrl], [client], err), resume(client);
  }
  async function connect(client) {
    assert(!client[kConnecting]), assert(!client[kSocket]);
    let { host, hostname, protocol, port } = client[kUrl];
    if (hostname[0] === "[") {
      let idx = hostname.indexOf("]");
      assert(idx !== -1);
      let ip = hostname.substring(1, idx);
      assert(net.isIP(ip)), hostname = ip;
    }
    if (client[kConnecting] = !0, channels.beforeConnect.hasSubscribers)
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
    try {
      let socket = await new Promise((resolve, reject) => {
        client[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        }, (err, socket2) => {
          if (err)
            reject(err);
          else
            resolve(socket2);
        });
      });
      if (client.destroyed) {
        util.destroy(socket.on("error", () => {}), new ClientDestroyedError);
        return;
      }
      if (client[kConnecting] = !1, assert(socket), socket.alpnProtocol === "h2") {
        if (!h2ExperimentalWarned)
          h2ExperimentalWarned = !0, process.emitWarning("H2 support is experimental, expect them to change at any time.", {
            code: "UNDICI-H2"
          });
        let session = http2.connect(client[kUrl], {
          createConnection: () => socket,
          peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
        });
        client[kHTTPConnVersion] = "h2", session[kClient] = client, session[kSocket] = socket, session.on("error", onHttp2SessionError), session.on("frameError", onHttp2FrameError), session.on("end", onHttp2SessionEnd), session.on("goaway", onHTTP2GoAway), session.on("close", onSocketClose), session.unref(), client[kHTTP2Session] = session, socket[kHTTP2Session] = session;
      } else {
        if (!llhttpInstance)
          llhttpInstance = await llhttpPromise, llhttpPromise = null;
        socket[kNoRef] = !1, socket[kWriting] = !1, socket[kReset] = !1, socket[kBlocking] = !1, socket[kParser] = new Parser(client, socket, llhttpInstance);
      }
      if (socket[kCounter] = 0, socket[kMaxRequests] = client[kMaxRequests], socket[kClient] = client, socket[kError] = null, socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose), client[kSocket] = socket, channels.connected.hasSubscribers)
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        });
      client.emit("connect", client[kUrl], [client]);
    } catch (err) {
      if (client.destroyed)
        return;
      if (client[kConnecting] = !1, channels.connectError.hasSubscribers)
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          error: err
        });
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(client[kRunning] === 0);
        while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
          let request = client[kQueue][client[kPendingIdx]++];
          errorRequest(client, request, err);
        }
      } else
        onError(client, err);
      client.emit("connectionError", client[kUrl], [client], err);
    }
    resume(client);
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0, client.emit("drain", client[kUrl], [client]);
  }
  function resume(client, sync) {
    if (client[kResuming] === 2)
      return;
    if (client[kResuming] = 2, _resume(client, sync), client[kResuming] = 0, client[kRunningIdx] > 256)
      client[kQueue].splice(0, client[kRunningIdx]), client[kPendingIdx] -= client[kRunningIdx], client[kRunningIdx] = 0;
  }
  function _resume(client, sync) {
    while (!0) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve](), client[kClosedResolve] = null;
        return;
      }
      let socket = client[kSocket];
      if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref)
            socket.unref(), socket[kNoRef] = !0;
        } else if (socket[kNoRef] && socket.ref)
          socket.ref(), socket[kNoRef] = !1;
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_IDLE)
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            let request2 = client[kQueue][client[kRunningIdx]], headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
      if (client[kBusy])
        client[kNeedDrain] = 2;
      else if (client[kNeedDrain] === 2) {
        if (sync)
          client[kNeedDrain] = 1, process.nextTick(emitDrain, client);
        else
          emitDrain(client);
        continue;
      }
      if (client[kPending] === 0)
        return;
      if (client[kRunning] >= (client[kPipelining] || 1))
        return;
      let request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0)
          return;
        if (client[kServerName] = request.servername, socket && socket.servername !== request.servername) {
          util.destroy(socket, new InformationalError("servername changed"));
          return;
        }
      }
      if (client[kConnecting])
        return;
      if (!socket && !client[kHTTP2Session]) {
        connect(client);
        return;
      }
      if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking])
        return;
      if (client[kRunning] > 0 && !request.idempotent)
        return;
      if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT"))
        return;
      if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body)))
        return;
      if (!request.aborted && write(client, request))
        client[kPendingIdx]++;
      else
        client[kQueue].splice(client[kPendingIdx], 1);
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function write(client, request) {
    if (client[kHTTPConnVersion] === "h2") {
      writeH2(client, client[kHTTP2Session], request);
      return;
    }
    let { body, method, path, host, upgrade, headers, blocking, reset } = request, expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function")
      body.read(0);
    let bodyLength = util.bodyLength(body), contentLength = bodyLength;
    if (contentLength === null)
      contentLength = request.contentLength;
    if (contentLength === 0 && !expectsPayload)
      contentLength = null;
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength])
        return errorRequest(client, request, new RequestContentLengthMismatchError), !1;
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    let socket = client[kSocket];
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed)
          return;
        errorRequest(client, request, err || new RequestAbortedError), util.destroy(socket, new InformationalError("aborted"));
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted)
      return !1;
    if (method === "HEAD")
      socket[kReset] = !0;
    if (upgrade || method === "CONNECT")
      socket[kReset] = !0;
    if (reset != null)
      socket[kReset] = reset;
    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests])
      socket[kReset] = !0;
    if (blocking)
      socket[kBlocking] = !0;
    let header = `${method} ${path} HTTP/1.1\r
`;
    if (typeof host === "string")
      header += `host: ${host}\r
`;
    else
      header += client[kHostHeader];
    if (upgrade)
      header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
    else if (client[kPipelining] && !socket[kReset])
      header += `connection: keep-alive\r
`;
    else
      header += `connection: close\r
`;
    if (headers)
      header += headers;
    if (channels.sendHeaders.hasSubscribers)
      channels.sendHeaders.publish({ request, headers: header, socket });
    if (!body || bodyLength === 0) {
      if (contentLength === 0)
        socket.write(`${header}content-length: 0\r
\r
`, "latin1");
      else
        assert(contentLength === null, "no body must not have content length"), socket.write(`${header}\r
`, "latin1");
      request.onRequestSent();
    } else if (util.isBuffer(body)) {
      if (assert(contentLength === body.byteLength, "buffer body must have content length"), socket.cork(), socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1"), socket.write(body), socket.uncork(), request.onBodySent(body), request.onRequestSent(), !expectsPayload)
        socket[kReset] = !0;
    } else if (util.isBlobLike(body))
      if (typeof body.stream === "function")
        writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
      else
        writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
    else if (util.isStream(body))
      writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
    else if (util.isIterable(body))
      writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
    else
      assert(!1);
    return !0;
  }
  function writeH2(client, session, request) {
    let { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request, headers;
    if (typeof reqHeaders === "string")
      headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
    else
      headers = reqHeaders;
    if (upgrade)
      return errorRequest(client, request, Error("Upgrade not supported for H2")), !1;
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed)
          return;
        errorRequest(client, request, err || new RequestAbortedError);
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted)
      return !1;
    let stream, h2State = client[kHTTP2SessionState];
    if (headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost], headers[HTTP2_HEADER_METHOD] = method, method === "CONNECT") {
      if (session.ref(), stream = session.request(headers, { endStream: !1, signal }), stream.id && !stream.pending)
        request.onUpgrade(null, null, stream), ++h2State.openStreams;
      else
        stream.once("ready", () => {
          request.onUpgrade(null, null, stream), ++h2State.openStreams;
        });
      return stream.once("close", () => {
        if (h2State.openStreams -= 1, h2State.openStreams === 0)
          session.unref();
      }), !0;
    }
    headers[HTTP2_HEADER_PATH] = path, headers[HTTP2_HEADER_SCHEME] = "https";
    let expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function")
      body.read(0);
    let contentLength = util.bodyLength(body);
    if (contentLength == null)
      contentLength = request.contentLength;
    if (contentLength === 0 || !expectsPayload)
      contentLength = null;
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength])
        return errorRequest(client, request, new RequestContentLengthMismatchError), !1;
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    if (contentLength != null)
      assert(body, "no body must not have content length"), headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    session.ref();
    let shouldEndStream = method === "GET" || method === "HEAD";
    if (expectContinue)
      headers[HTTP2_HEADER_EXPECT] = "100-continue", stream = session.request(headers, { endStream: shouldEndStream, signal }), stream.once("continue", writeBodyH2);
    else
      stream = session.request(headers, {
        endStream: shouldEndStream,
        signal
      }), writeBodyH2();
    return ++h2State.openStreams, stream.once("response", (headers2) => {
      let { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
      if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === !1)
        stream.pause();
    }), stream.once("end", () => {
      request.onComplete([]);
    }), stream.on("data", (chunk) => {
      if (request.onData(chunk) === !1)
        stream.pause();
    }), stream.once("close", () => {
      if (h2State.openStreams -= 1, h2State.openStreams === 0)
        session.unref();
    }), stream.once("error", function(err) {
      if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed)
        h2State.streams -= 1, util.destroy(stream, err);
    }), stream.once("frameError", (type, code) => {
      let err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (errorRequest(client, request, err), client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed)
        h2State.streams -= 1, util.destroy(stream, err);
    }), !0;
    function writeBodyH2() {
      if (!body)
        request.onRequestSent();
      else if (util.isBuffer(body))
        assert(contentLength === body.byteLength, "buffer body must have content length"), stream.cork(), stream.write(body), stream.uncork(), stream.end(), request.onBodySent(body), request.onRequestSent();
      else if (util.isBlobLike(body))
        if (typeof body.stream === "function")
          writeIterable({
            client,
            request,
            contentLength,
            h2stream: stream,
            expectsPayload,
            body: body.stream(),
            socket: client[kSocket],
            header: ""
          });
        else
          writeBlob({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            h2stream: stream,
            header: "",
            socket: client[kSocket]
          });
      else if (util.isStream(body))
        writeStream({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          socket: client[kSocket],
          h2stream: stream,
          header: ""
        });
      else if (util.isIterable(body))
        writeIterable({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          header: "",
          h2stream: stream,
          socket: client[kSocket]
        });
      else
        assert(!1);
    }
  }
  function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    if (assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined"), client[kHTTPConnVersion] === "h2") {
      let onPipeData = function(chunk) {
        request.onBodySent(chunk);
      }, pipe = pipeline(body, h2stream, (err) => {
        if (err)
          util.destroy(body, err), util.destroy(h2stream, err);
        else
          request.onRequestSent();
      });
      pipe.on("data", onPipeData), pipe.once("end", () => {
        pipe.removeListener("data", onPipeData), util.destroy(pipe);
      });
      return;
    }
    let finished = !1, writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header }), onData = function(chunk) {
      if (finished)
        return;
      try {
        if (!writer.write(chunk) && this.pause)
          this.pause();
      } catch (err) {
        util.destroy(this, err);
      }
    }, onDrain = function() {
      if (finished)
        return;
      if (body.resume)
        body.resume();
    }, onAbort = function() {
      if (finished)
        return;
      let err = new RequestAbortedError;
      queueMicrotask(() => onFinished(err));
    }, onFinished = function(err) {
      if (finished)
        return;
      if (finished = !0, assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1), socket.off("drain", onDrain).off("error", onFinished), body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort), !err)
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      if (writer.destroy(err), err && (err.code !== "UND_ERR_INFO" || err.message !== "reset"))
        util.destroy(body, err);
      else
        util.destroy(body);
    };
    if (body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort), body.resume)
      body.resume();
    socket.on("drain", onDrain).on("error", onFinished);
  }
  async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength === body.size, "blob body must have content length");
    let isH2 = client[kHTTPConnVersion] === "h2";
    try {
      if (contentLength != null && contentLength !== body.size)
        throw new RequestContentLengthMismatchError;
      let buffer = Buffer.from(await body.arrayBuffer());
      if (isH2)
        h2stream.cork(), h2stream.write(buffer), h2stream.uncork();
      else
        socket.cork(), socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1"), socket.write(buffer), socket.uncork();
      if (request.onBodySent(buffer), request.onRequestSent(), !expectsPayload)
        socket[kReset] = !0;
      resume(client);
    } catch (err) {
      util.destroy(isH2 ? h2stream : socket, err);
    }
  }
  async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        let cb = callback;
        callback = null, cb();
      }
    }
    let waitForDrain = () => new Promise((resolve, reject) => {
      if (assert(callback === null), socket[kError])
        reject(socket[kError]);
      else
        callback = resolve;
    });
    if (client[kHTTPConnVersion] === "h2") {
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (let chunk of body) {
          if (socket[kError])
            throw socket[kError];
          let res = h2stream.write(chunk);
          if (request.onBodySent(chunk), !res)
            await waitForDrain();
        }
      } catch (err) {
        h2stream.destroy(err);
      } finally {
        request.onRequestSent(), h2stream.end(), h2stream.off("close", onDrain).off("drain", onDrain);
      }
      return;
    }
    socket.on("close", onDrain).on("drain", onDrain);
    let writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    try {
      for await (let chunk of body) {
        if (socket[kError])
          throw socket[kError];
        if (!writer.write(chunk))
          await waitForDrain();
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }

  class AsyncWriter {
    constructor({ socket, request, contentLength, client, expectsPayload, header }) {
      this.socket = socket, this.request = request, this.contentLength = contentLength, this.client = client, this.bytesWritten = 0, this.expectsPayload = expectsPayload, this.header = header, socket[kWriting] = !0;
    }
    write(chunk) {
      let { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
      if (socket[kError])
        throw socket[kError];
      if (socket.destroyed)
        return !1;
      let len = Buffer.byteLength(chunk);
      if (!len)
        return !0;
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength])
          throw new RequestContentLengthMismatchError;
        process.emitWarning(new RequestContentLengthMismatchError);
      }
      if (socket.cork(), bytesWritten === 0) {
        if (!expectsPayload)
          socket[kReset] = !0;
        if (contentLength === null)
          socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
        else
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      }
      if (contentLength === null)
        socket.write(`\r
${len.toString(16)}\r
`, "latin1");
      this.bytesWritten += len;
      let ret = socket.write(chunk);
      if (socket.uncork(), request.onBodySent(chunk), !ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh)
            socket[kParser].timeout.refresh();
        }
      }
      return ret;
    }
    end() {
      let { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
      if (request.onRequestSent(), socket[kWriting] = !1, socket[kError])
        throw socket[kError];
      if (socket.destroyed)
        return;
      if (bytesWritten === 0)
        if (expectsPayload)
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        else
          socket.write(`${header}\r
`, "latin1");
      else if (contentLength === null)
        socket.write(`\r
0\r
\r
`, "latin1");
      if (contentLength !== null && bytesWritten !== contentLength)
        if (client[kStrictContentLength])
          throw new RequestContentLengthMismatchError;
        else
          process.emitWarning(new RequestContentLengthMismatchError);
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh)
          socket[kParser].timeout.refresh();
      }
      resume(client);
    }
    destroy(err) {
      let { socket, client } = this;
      if (socket[kWriting] = !1, err)
        assert(client[kRunning] <= 1, "pipeline should only contain this request"), util.destroy(socket, err);
    }
  }
  function errorRequest(client, request, err) {
    try {
      request.onError(err), assert(request.aborted);
    } catch (err2) {
      client.emit("error", err2);
    }
  }
  module.exports = Client;
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS((exports, module) => {
  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0, this.top = 0, this.list = Array(2048), this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & 2047) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data, this.top = this.top + 1 & 2047;
    }
    shift() {
      let nextItem = this.list[this.bottom];
      if (nextItem === void 0)
        return null;
      return this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & 2047, nextItem;
    }
  }
  module.exports = class {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull())
        this.head = this.head.next = new FixedCircularBuffer;
      this.head.push(data);
    }
    shift() {
      let tail = this.tail, next = tail.shift();
      if (tail.isEmpty() && tail.next !== null)
        this.tail = tail.next;
      return next;
    }
  };
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS((exports, module) => {
  var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols(), kPool = Symbol("pool");

  class PoolStats {
    constructor(pool) {
      this[kPool] = pool;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  module.exports = PoolStats;
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base(), FixedQueue = require_fixed_queue(), { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols(), PoolStats = require_pool_stats(), kClients = Symbol("clients"), kNeedDrain = Symbol("needDrain"), kQueue = Symbol("queue"), kClosedResolve = Symbol("closed resolve"), kOnDrain = Symbol("onDrain"), kOnConnect = Symbol("onConnect"), kOnDisconnect = Symbol("onDisconnect"), kOnConnectionError = Symbol("onConnectionError"), kGetDispatcher = Symbol("get dispatcher"), kAddClient = Symbol("add client"), kRemoveClient = Symbol("remove client"), kStats = Symbol("stats");

  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue, this[kClients] = [], this[kQueued] = 0;
      let pool = this;
      this[kOnDrain] = function(origin, targets) {
        let queue = pool[kQueue], needDrain = !1;
        while (!needDrain) {
          let item = queue.shift();
          if (!item)
            break;
          pool[kQueued]--, needDrain = !this.dispatch(item.opts, item.handler);
        }
        if (this[kNeedDrain] = needDrain, !this[kNeedDrain] && pool[kNeedDrain])
          pool[kNeedDrain] = !1, pool.emit("drain", origin, [pool, ...targets]);
        if (pool[kClosedResolve] && queue.isEmpty())
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
      }, this[kOnConnect] = (origin, targets) => {
        pool.emit("connect", origin, [pool, ...targets]);
      }, this[kOnDisconnect] = (origin, targets, err) => {
        pool.emit("disconnect", origin, [pool, ...targets], err);
      }, this[kOnConnectionError] = (origin, targets, err) => {
        pool.emit("connectionError", origin, [pool, ...targets], err);
      }, this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client) => client[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (let { [kPending]: pending } of this[kClients])
        ret += pending;
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (let { [kRunning]: running } of this[kClients])
        ret += running;
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (let { [kSize]: size } of this[kClients])
        ret += size;
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose]() {
      if (this[kQueue].isEmpty())
        return Promise.all(this[kClients].map((c) => c.close()));
      else
        return new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
    }
    async[kDestroy](err) {
      while (!0) {
        let item = this[kQueue].shift();
        if (!item)
          break;
        item.handler.onError(err);
      }
      return Promise.all(this[kClients].map((c) => c.destroy(err)));
    }
    [kDispatch](opts, handler) {
      let dispatcher = this[kGetDispatcher]();
      if (!dispatcher)
        this[kNeedDrain] = !0, this[kQueue].push({ opts, handler }), this[kQueued]++;
      else if (!dispatcher.dispatch(opts, handler))
        dispatcher[kNeedDrain] = !0, this[kNeedDrain] = !this[kGetDispatcher]();
      return !this[kNeedDrain];
    }
    [kAddClient](client) {
      if (client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].push(client), this[kNeedDrain])
        process.nextTick(() => {
          if (this[kNeedDrain])
            this[kOnDrain](client[kUrl], [this, client]);
        });
      return this;
    }
    [kRemoveClient](client) {
      client.close(() => {
        let idx = this[kClients].indexOf(client);
        if (idx !== -1)
          this[kClients].splice(idx, 1);
      }), this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== !0 && dispatcher.destroyed !== !0);
    }
  }
  module.exports = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS((exports, module) => {
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = require_pool_base(), Client = require_client(), {
    InvalidArgumentError
  } = require_errors(), util = require_util(), { kUrl, kInterceptors } = require_symbols(), buildConnector = require_connect(), kOptions = Symbol("options"), kConnections = Symbol("connections"), kFactory = Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client(origin, opts);
  }

  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      ...options
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0))
        throw new InvalidArgumentError("invalid connections");
      if (typeof factory !== "function")
        throw new InvalidArgumentError("factory must be a function.");
      if (connect != null && typeof connect !== "function" && typeof connect !== "object")
        throw new InvalidArgumentError("connect must be a function or an object");
      if (typeof connect !== "function")
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect
        });
      this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [], this[kConnections] = connections || null, this[kUrl] = util.parseOrigin(origin), this[kOptions] = { ...util.deepClone(options), connect, allowH2 }, this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0, this[kFactory] = factory, this.on("connectionError", (origin2, targets, error) => {
        for (let target of targets) {
          let idx = this[kClients].indexOf(target);
          if (idx !== -1)
            this[kClients].splice(idx, 1);
        }
      });
    }
    [kGetDispatcher]() {
      let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
      if (dispatcher)
        return dispatcher;
      if (!this[kConnections] || this[kClients].length < this[kConnections])
        dispatcher = this[kFactory](this[kUrl], this[kOptions]), this[kAddClient](dispatcher);
      return dispatcher;
    }
  }
  module.exports = Pool;
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS((exports, module) => {
  var {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = require_errors(), {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = require_pool_base(), Pool = require_pool(), { kUrl, kInterceptors } = require_symbols(), { parseOrigin } = require_util(), kFactory = Symbol("factory"), kOptions = Symbol("options"), kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor"), kCurrentWeight = Symbol("kCurrentWeight"), kIndex = Symbol("kIndex"), kWeight = Symbol("kWeight"), kMaxWeightPerServer = Symbol("kMaxWeightPerServer"), kErrorPenalty = Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a, b) {
    if (b === 0)
      return a;
    return getGreatestCommonDivisor(b, a % b);
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }

  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      if (this[kOptions] = opts, this[kIndex] = -1, this[kCurrentWeight] = 0, this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100, this[kErrorPenalty] = this[kOptions].errorPenalty || 15, !Array.isArray(upstreams))
        upstreams = [upstreams];
      if (typeof factory !== "function")
        throw new InvalidArgumentError("factory must be a function.");
      this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [], this[kFactory] = factory;
      for (let upstream of upstreams)
        this.addUpstream(upstream);
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      let upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== !0 && pool2.destroyed !== !0))
        return this;
      let pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool), pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      }), pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]), this._updateBalancedPoolStats();
      }), pool.on("disconnect", (...args) => {
        let err = args[2];
        if (err && err.code === "UND_ERR_SOCKET")
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]), this._updateBalancedPoolStats();
      });
      for (let client of this[kClients])
        client[kWeight] = this[kMaxWeightPerServer];
      return this._updateBalancedPoolStats(), this;
    }
    _updateBalancedPoolStats() {
      this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
    }
    removeUpstream(upstream) {
      let upstreamOrigin = parseOrigin(upstream).origin, pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== !0 && pool2.destroyed !== !0);
      if (pool)
        this[kRemoveClient](pool);
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher) => dispatcher.closed !== !0 && dispatcher.destroyed !== !0).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0)
        throw new BalancedPoolMissingUpstreamError;
      if (!this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== !0 && dispatcher2.destroyed !== !0))
        return;
      if (this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, !0))
        return;
      let counter = 0, maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        let pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain])
          maxWeightIndex = this[kIndex];
        if (this[kIndex] === 0) {
          if (this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor], this[kCurrentWeight] <= 0)
            this[kCurrentWeight] = this[kMaxWeightPerServer];
        }
        if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain])
          return pool;
      }
      return this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight], this[kIndex] = maxWeightIndex, this[kClients][maxWeightIndex];
    }
  }
  module.exports = BalancedPool;
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS((exports, module) => {
  var { kConnected, kSize } = require_symbols();

  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
    }
  }

  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher, key) {
      if (dispatcher.on)
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0)
            this.finalizer(key);
        });
    }
  }
  module.exports = function() {
    if (process.env.NODE_V8_COVERAGE)
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    return {
      WeakRef: global.WeakRef || CompatWeakRef,
      FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
    };
  };
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS((exports, module) => {
  var { InvalidArgumentError } = require_errors(), { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols(), DispatcherBase = require_dispatcher_base(), Pool = require_pool(), Client = require_client(), util = require_util(), createRedirectInterceptor = require_redirectInterceptor(), { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()(), kOnConnect = Symbol("onConnect"), kOnDisconnect = Symbol("onDisconnect"), kOnConnectionError = Symbol("onConnectionError"), kMaxRedirections = Symbol("maxRedirections"), kOnDrain = Symbol("onDrain"), kFactory = Symbol("factory"), kFinalizer = Symbol("finalizer"), kOptions = Symbol("options");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
  }

  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
      super();
      if (typeof factory !== "function")
        throw new InvalidArgumentError("factory must be a function.");
      if (connect != null && typeof connect !== "function" && typeof connect !== "object")
        throw new InvalidArgumentError("connect must be a function or an object");
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0)
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      if (connect && typeof connect !== "function")
        connect = { ...connect };
      this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })], this[kOptions] = { ...util.deepClone(options), connect }, this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0, this[kMaxRedirections] = maxRedirections, this[kFactory] = factory, this[kClients] = /* @__PURE__ */ new Map, this[kFinalizer] = new FinalizationRegistry((key) => {
        let ref = this[kClients].get(key);
        if (ref !== void 0 && ref.deref() === void 0)
          this[kClients].delete(key);
      });
      let agent = this;
      this[kOnDrain] = (origin, targets) => {
        agent.emit("drain", origin, [agent, ...targets]);
      }, this[kOnConnect] = (origin, targets) => {
        agent.emit("connect", origin, [agent, ...targets]);
      }, this[kOnDisconnect] = (origin, targets, err) => {
        agent.emit("disconnect", origin, [agent, ...targets], err);
      }, this[kOnConnectionError] = (origin, targets, err) => {
        agent.emit("connectionError", origin, [agent, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (let ref of this[kClients].values()) {
        let client = ref.deref();
        if (client)
          ret += client[kRunning];
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL))
        key = String(opts.origin);
      else
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      let ref = this[kClients].get(key), dispatcher = ref ? ref.deref() : null;
      if (!dispatcher)
        dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].set(key, new WeakRef2(dispatcher)), this[kFinalizer].register(dispatcher, key);
      return dispatcher.dispatch(opts, handler);
    }
    async[kClose]() {
      let closePromises = [];
      for (let ref of this[kClients].values()) {
        let client = ref.deref();
        if (client)
          closePromises.push(client.close());
      }
      await Promise.all(closePromises);
    }
    async[kDestroy](err) {
      let destroyPromises = [];
      for (let ref of this[kClients].values()) {
        let client = ref.deref();
        if (client)
          destroyPromises.push(client.destroy(err));
      }
      await Promise.all(destroyPromises);
    }
  }
  module.exports = Agent;
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS((exports, module) => {
  var assert = __require("assert"), { Readable } = __require("stream"), { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors(), util = require_util(), { ReadableStreamFrom, toUSVString } = require_util(), Blob2, kConsume = Symbol("kConsume"), kReading = Symbol("kReading"), kBody = Symbol("kBody"), kAbort = Symbol("abort"), kContentType = Symbol("kContentType"), noop = () => {};
  module.exports = class extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      highWaterMark = 65536
    }) {
      super({
        autoDestroy: !0,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = !1, this[kAbort] = abort, this[kConsume] = null, this[kBody] = null, this[kContentType] = contentType, this[kReading] = !1;
    }
    destroy(err) {
      if (this.destroyed)
        return this;
      if (!err && !this._readableState.endEmitted)
        err = new RequestAbortedError;
      if (err)
        this[kAbort]();
      return super.destroy(err);
    }
    emit(ev, ...args) {
      if (ev === "data")
        this._readableState.dataEmitted = !0;
      else if (ev === "error")
        this._readableState.errorEmitted = !0;
      return super.emit(ev, ...args);
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable")
        this[kReading] = !0;
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      let ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable")
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null && this.readableLength === 0)
        return consumePush(this[kConsume], chunk), this[kReading] ? super.push(chunk) : !0;
      return super.push(chunk);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util.isDisturbed(this);
    }
    get body() {
      if (!this[kBody]) {
        if (this[kBody] = ReadableStreamFrom(this), this[kConsume])
          this[kBody].getReader(), assert(this[kBody].locked);
      }
      return this[kBody];
    }
    dump(opts) {
      let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144, signal = opts && opts.signal;
      if (signal)
        try {
          if (typeof signal !== "object" || !("aborted" in signal))
            throw new InvalidArgumentError("signal must be an AbortSignal");
          util.throwIfAborted(signal);
        } catch (err) {
          return Promise.reject(err);
        }
      if (this.closed)
        return Promise.resolve(null);
      return new Promise((resolve, reject) => {
        let signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
          this.destroy();
        }) : noop;
        this.on("close", function() {
          if (signalListenerCleanup(), signal && signal.aborted)
            reject(signal.reason || Object.assign(Error("The operation was aborted"), { name: "AbortError" }));
          else
            resolve(null);
        }).on("error", noop).on("data", function(chunk) {
          if (limit -= chunk.length, limit <= 0)
            this.destroy();
        }).resume();
      });
    }
  };
  function isLocked(self2) {
    return self2[kBody] && self2[kBody].locked === !0 || self2[kConsume];
  }
  function isUnusable(self2) {
    return util.isDisturbed(self2) || isLocked(self2);
  }
  async function consume(stream, type) {
    if (isUnusable(stream))
      throw TypeError("unusable");
    return assert(!stream[kConsume]), new Promise((resolve, reject) => {
      stream[kConsume] = {
        type,
        stream,
        resolve,
        reject,
        length: 0,
        body: []
      }, stream.on("error", function(err) {
        consumeFinish(this[kConsume], err);
      }).on("close", function() {
        if (this[kConsume].body !== null)
          consumeFinish(this[kConsume], new RequestAbortedError);
      }), process.nextTick(consumeStart, stream[kConsume]);
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null)
      return;
    let { _readableState: state } = consume2.stream;
    for (let chunk of state.buffer)
      consumePush(consume2, chunk);
    if (state.endEmitted)
      consumeEnd(this[kConsume]);
    else
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    consume2.stream.resume();
    while (consume2.stream.read() != null)
      ;
  }
  function consumeEnd(consume2) {
    let { type, body, resolve, stream, length } = consume2;
    try {
      if (type === "text")
        resolve(toUSVString(Buffer.concat(body)));
      else if (type === "json")
        resolve(JSON.parse(Buffer.concat(body)));
      else if (type === "arrayBuffer") {
        let dst = new Uint8Array(length), pos = 0;
        for (let buf of body)
          dst.set(buf, pos), pos += buf.byteLength;
        resolve(dst.buffer);
      } else if (type === "blob") {
        if (!Blob2)
          Blob2 = __require("buffer").Blob;
        resolve(new Blob2(body, { type: stream[kContentType] }));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  }
  function consumePush(consume2, chunk) {
    consume2.length += chunk.length, consume2.body.push(chunk);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null)
      return;
    if (err)
      consume2.reject(err);
    else
      consume2.resolve();
    consume2.type = null, consume2.stream = null, consume2.resolve = null, consume2.reject = null, consume2.length = 0, consume2.body = null;
  }
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS((exports, module) => {
  var assert = __require("assert"), {
    ResponseStatusCodeError
  } = require_errors(), { toUSVString } = require_util();
  async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
    assert(body);
    let chunks = [], limit = 0;
    for await (let chunk of body)
      if (chunks.push(chunk), limit += chunk.length, limit > 131072) {
        chunks = null;
        break;
      }
    if (statusCode === 204 || !contentType || !chunks) {
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
      return;
    }
    try {
      if (contentType.startsWith("application/json")) {
        let payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
      if (contentType.startsWith("text/")) {
        let payload = toUSVString(Buffer.concat(chunks));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
    } catch (err) {}
    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
  }
  module.exports = { getResolveErrorBodyCallback };
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS((exports, module) => {
  var { addAbortListener } = require_util(), { RequestAbortedError } = require_errors(), kListener = Symbol("kListener"), kSignal = Symbol("kSignal");
  function abort(self2) {
    if (self2.abort)
      self2.abort();
    else
      self2.onError(new RequestAbortedError);
  }
  function addSignal(self2, signal) {
    if (self2[kSignal] = null, self2[kListener] = null, !signal)
      return;
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal, self2[kListener] = () => {
      abort(self2);
    }, addAbortListener(self2[kSignal], self2[kListener]);
  }
  function removeSignal(self2) {
    if (!self2[kSignal])
      return;
    if ("removeEventListener" in self2[kSignal])
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    else
      self2[kSignal].removeListener("abort", self2[kListener]);
    self2[kSignal] = null, self2[kListener] = null;
  }
  module.exports = {
    addSignal,
    removeSignal
  };
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS((exports, module) => {
  var Readable = require_readable(), {
    InvalidArgumentError,
    RequestAbortedError
  } = require_errors(), util = require_util(), { getResolveErrorBodyCallback } = require_util3(), { AsyncResource } = __require("async_hooks"), { addSignal, removeSignal } = require_abort_signal();

  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      let { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function")
          throw new InvalidArgumentError("invalid callback");
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0))
          throw new InvalidArgumentError("invalid highWaterMark");
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        if (method === "CONNECT")
          throw new InvalidArgumentError("invalid method");
        if (onInfo && typeof onInfo !== "function")
          throw new InvalidArgumentError("invalid onInfo callback");
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body))
          util.destroy(body.on("error", util.nop), err);
        throw err;
      }
      if (this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.callback = callback, this.res = null, this.abort = null, this.body = body, this.trailers = {}, this.context = null, this.onInfo = onInfo || null, this.throwOnError = throwOnError, this.highWaterMark = highWaterMark, util.isStream(body))
        body.on("error", (err) => {
          this.onError(err);
        });
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback)
        throw new RequestAbortedError;
      this.abort = abort, this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      let { callback, opaque, abort, context, responseHeaders, highWaterMark } = this, headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo)
          this.onInfo({ statusCode, headers });
        return;
      }
      let contentType = (responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers)["content-type"], body = new Readable({ resume, abort, contentType, highWaterMark });
      if (this.callback = null, this.res = body, callback !== null)
        if (this.throwOnError && statusCode >= 400)
          this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body, contentType, statusCode, statusMessage, headers });
        else
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body,
            context
          });
    }
    onData(chunk) {
      let { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      let { res } = this;
      removeSignal(this), util.parseHeaders(trailers, this.trailers), res.push(null);
    }
    onError(err) {
      let { res, callback, body, opaque } = this;
      if (removeSignal(this), callback)
        this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      if (res)
        this.res = null, queueMicrotask(() => {
          util.destroy(res, err);
        });
      if (body)
        this.body = null, util.destroy(body, err);
    }
  }
  function request(opts, callback) {
    if (callback === void 0)
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function")
        throw err;
      let opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = request;
  module.exports.RequestHandler = RequestHandler;
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS((exports, module) => {
  var { finished, PassThrough } = __require("stream"), {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors(), util = require_util(), { getResolveErrorBodyCallback } = require_util3(), { AsyncResource } = __require("async_hooks"), { addSignal, removeSignal } = require_abort_signal();

  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      let { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function")
          throw new InvalidArgumentError("invalid callback");
        if (typeof factory !== "function")
          throw new InvalidArgumentError("invalid factory");
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        if (method === "CONNECT")
          throw new InvalidArgumentError("invalid method");
        if (onInfo && typeof onInfo !== "function")
          throw new InvalidArgumentError("invalid onInfo callback");
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body))
          util.destroy(body.on("error", util.nop), err);
        throw err;
      }
      if (this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.factory = factory, this.callback = callback, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = body, this.onInfo = onInfo || null, this.throwOnError = throwOnError || !1, util.isStream(body))
        body.on("error", (err) => {
          this.onError(err);
        });
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback)
        throw new RequestAbortedError;
      this.abort = abort, this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      let { factory, opaque, context, callback, responseHeaders } = this, headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo)
          this.onInfo({ statusCode, headers });
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        let contentType = (responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers)["content-type"];
        res = new PassThrough, this.callback = null, this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
      } else {
        if (factory === null)
          return;
        if (res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        }), !res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function")
          throw new InvalidReturnValueError("expected Writable");
        finished(res, { readable: !1 }, (err) => {
          let { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          if (this.res = null, err || !res2.readable)
            util.destroy(res2, err);
          if (this.callback = null, this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers }), err)
            abort();
        });
      }
      return res.on("drain", resume), this.res = res, (res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain) !== !0;
    }
    onData(chunk) {
      let { res } = this;
      return res ? res.write(chunk) : !0;
    }
    onComplete(trailers) {
      let { res } = this;
      if (removeSignal(this), !res)
        return;
      this.trailers = util.parseHeaders(trailers), res.end();
    }
    onError(err) {
      let { res, callback, opaque, body } = this;
      if (removeSignal(this), this.factory = null, res)
        this.res = null, util.destroy(res, err);
      else if (callback)
        this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      if (body)
        this.body = null, util.destroy(body, err);
    }
  }
  function stream(opts, factory, callback) {
    if (callback === void 0)
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function")
        throw err;
      let opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = stream;
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS((exports, module) => {
  var {
    Readable,
    Duplex,
    PassThrough
  } = __require("stream"), {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors(), util = require_util(), { AsyncResource } = __require("async_hooks"), { addSignal, removeSignal } = require_abort_signal(), assert = __require("assert"), kResume = Symbol("resume");

  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: !0 });
      this[kResume] = null;
    }
    _read() {
      let { [kResume]: resume } = this;
      if (resume)
        this[kResume] = null, resume();
    }
    _destroy(err, callback) {
      this._read(), callback(err);
    }
  }

  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: !0 });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted)
        err = new RequestAbortedError;
      callback(err);
    }
  }

  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      if (typeof handler !== "function")
        throw new InvalidArgumentError("invalid handler");
      let { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      if (method === "CONNECT")
        throw new InvalidArgumentError("invalid method");
      if (onInfo && typeof onInfo !== "function")
        throw new InvalidArgumentError("invalid onInfo callback");
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null, this.responseHeaders = responseHeaders || null, this.handler = handler, this.abort = null, this.context = null, this.onInfo = onInfo || null, this.req = new PipelineRequest().on("error", util.nop), this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: !0,
        read: () => {
          let { body } = this;
          if (body && body.resume)
            body.resume();
        },
        write: (chunk, encoding, callback) => {
          let { req } = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed)
            callback();
          else
            req[kResume] = callback;
        },
        destroy: (err, callback) => {
          let { body, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted)
            err = new RequestAbortedError;
          if (abort && err)
            abort();
          util.destroy(body, err), util.destroy(req, err), util.destroy(res, err), removeSignal(this), callback(err);
        }
      }).on("prefinish", () => {
        let { req } = this;
        req.push(null);
      }), this.res = null, addSignal(this, signal);
    }
    onConnect(abort, context) {
      let { ret, res } = this;
      if (assert(!res, "pipeline cannot be retried"), ret.destroyed)
        throw new RequestAbortedError;
      this.abort = abort, this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      let { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        throw this.res.on("error", util.nop), err;
      }
      if (!body || typeof body.on !== "function")
        throw new InvalidReturnValueError("expected Readable");
      body.on("data", (chunk) => {
        let { ret, body: body2 } = this;
        if (!ret.push(chunk) && body2.pause)
          body2.pause();
      }).on("error", (err) => {
        let { ret } = this;
        util.destroy(ret, err);
      }).on("end", () => {
        let { ret } = this;
        ret.push(null);
      }).on("close", () => {
        let { ret } = this;
        if (!ret._readableState.ended)
          util.destroy(ret, new RequestAbortedError);
      }), this.body = body;
    }
    onData(chunk) {
      let { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      let { res } = this;
      res.push(null);
    }
    onError(err) {
      let { ret } = this;
      this.handler = null, util.destroy(ret, err);
    }
  }
  function pipeline(opts, handler) {
    try {
      let pipelineHandler = new PipelineHandler(opts, handler);
      return this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler), pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  module.exports = pipeline;
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS((exports, module) => {
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors(), { AsyncResource } = __require("async_hooks"), util = require_util(), { addSignal, removeSignal } = require_abort_signal(), assert = __require("assert");

  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      if (typeof callback !== "function")
        throw new InvalidArgumentError("invalid callback");
      let { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.callback = callback, this.abort = null, this.context = null, addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback)
        throw new RequestAbortedError;
      this.abort = abort, this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      let { callback, opaque, context } = this;
      assert.strictEqual(statusCode, 101), removeSignal(this), this.callback = null;
      let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      let { callback, opaque } = this;
      if (removeSignal(this), callback)
        this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
    }
  }
  function upgrade(opts, callback) {
    if (callback === void 0)
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    try {
      let upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function")
        throw err;
      let opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = upgrade;
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS((exports, module) => {
  var { AsyncResource } = __require("async_hooks"), { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors(), util = require_util(), { addSignal, removeSignal } = require_abort_signal();

  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      if (typeof callback !== "function")
        throw new InvalidArgumentError("invalid callback");
      let { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      super("UNDICI_CONNECT");
      this.opaque = opaque || null, this.responseHeaders = responseHeaders || null, this.callback = callback, this.abort = null, addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback)
        throw new RequestAbortedError;
      this.abort = abort, this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      let { callback, opaque, context } = this;
      removeSignal(this), this.callback = null;
      let headers = rawHeaders;
      if (headers != null)
        headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      let { callback, opaque } = this;
      if (removeSignal(this), callback)
        this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
    }
  }
  function connect(opts, callback) {
    if (callback === void 0)
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    try {
      let connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function")
        throw err;
      let opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = connect;
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS((exports, module) => {
  exports.request = require_api_request();
  exports.stream = require_api_stream();
  exports.pipeline = require_api_pipeline();
  exports.upgrade = require_api_upgrade();
  exports.connect = require_api_connect();
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS((exports, module) => {
  var { UndiciError } = require_errors();

  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, MockNotMatchedError), this.name = "MockNotMatchedError", this.message = message || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  module.exports = {
    MockNotMatchedError
  };
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS((exports, module) => {
  module.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS((exports, module) => {
  var { MockNotMatchedError } = require_mock_errors(), {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = require_mock_symbols(), { buildURL, nop } = require_util(), { STATUS_CODES } = __require("http"), {
    types: {
      isPromise
    }
  } = __require("util");
  function matchValue(match, value) {
    if (typeof match === "string")
      return match === value;
    if (match instanceof RegExp)
      return match.test(value);
    if (typeof match === "function")
      return match(value) === !0;
    return !1;
  }
  function lowerCaseEntries(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    }));
  }
  function getHeaderByName(headers, key) {
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2)
        if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase())
          return headers[i + 1];
      return;
    } else if (typeof headers.get === "function")
      return headers.get(key);
    else
      return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
  }
  function buildHeadersFromArray(headers) {
    let clone = headers.slice(), entries = [];
    for (let index = 0;index < clone.length; index += 2)
      entries.push([clone[index], clone[index + 1]]);
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers))
        headers = buildHeadersFromArray(headers);
      return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
    }
    if (typeof mockDispatch2.headers > "u")
      return !0;
    if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object")
      return !1;
    for (let [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      let headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue))
        return !1;
    }
    return !0;
  }
  function safeUrl(path) {
    if (typeof path !== "string")
      return path;
    let pathSegments = path.split("?");
    if (pathSegments.length !== 2)
      return path;
    let qp = new URLSearchParams(pathSegments.pop());
    return qp.sort(), [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path, method, body, headers }) {
    let pathMatch = matchValue(mockDispatch2.path, path), methodMatch = matchValue(mockDispatch2.method, method), bodyMatch = typeof mockDispatch2.body < "u" ? matchValue(mockDispatch2.body, body) : !0, headersMatch = matchHeaders(mockDispatch2, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data) {
    if (Buffer.isBuffer(data))
      return data;
    else if (typeof data === "object")
      return JSON.stringify(data);
    else
      return data.toString();
  }
  function getMockDispatch(mockDispatches, key) {
    let basePath = key.query ? buildURL(key.path, key.query) : key.path, resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath, matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
    if (matchedMockDispatches.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    if (matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method)), matchedMockDispatches.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
    if (matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body < "u" ? matchValue(body, key.body) : !0), matchedMockDispatches.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
    if (matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers)), matchedMockDispatches.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data) {
    let baseData = { timesInvoked: 0, times: 1, persist: !1, consumed: !1 }, replyData = typeof data === "function" ? { callback: data } : { ...data }, newMockDispatch = { ...baseData, ...key, pending: !0, data: { error: null, ...replyData } };
    return mockDispatches.push(newMockDispatch), newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    let index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed)
        return !1;
      return matchKey(dispatch, key);
    });
    if (index !== -1)
      mockDispatches.splice(index, 1);
  }
  function buildKey(opts) {
    let { path, method, body, headers, query } = opts;
    return {
      path,
      method,
      body,
      headers,
      query
    };
  }
  function generateKeyValues(data) {
    return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
      ...keyValuePairs,
      Buffer.from(`${key}`),
      Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
    ], []);
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body) {
    let buffers = [];
    for await (let data of body)
      buffers.push(data);
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler) {
    let key = buildKey(opts), mockDispatch2 = getMockDispatch(this[kDispatches], key);
    if (mockDispatch2.timesInvoked++, mockDispatch2.data.callback)
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    let { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2, { timesInvoked, times } = mockDispatch2;
    if (mockDispatch2.consumed = !persist && timesInvoked >= times, mockDispatch2.pending = timesInvoked < times, error !== null)
      return deleteMockDispatch(this[kDispatches], key), handler.onError(error), !0;
    if (typeof delay === "number" && delay > 0)
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    else
      handleReply(this[kDispatches]);
    function handleReply(mockDispatches, _data = data) {
      let optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers, body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body)) {
        body.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      let responseData = getResponseData(body), responseHeaders = generateKeyValues(headers), responseTrailers = generateKeyValues(trailers);
      handler.abort = nop, handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode)), handler.onData(Buffer.from(responseData)), handler.onComplete(responseTrailers), deleteMockDispatch(mockDispatches, key);
    }
    function resume() {}
    return !0;
  }
  function buildMockDispatch() {
    let agent = this[kMockAgent], origin = this[kOrigin], originalDispatch = this[kOriginalDispatch];
    return function(opts, handler) {
      if (agent.isMockActive)
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error) {
          if (error instanceof MockNotMatchedError) {
            let netConnect = agent[kGetNetConnect]();
            if (netConnect === !1)
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            if (checkNetConnect(netConnect, origin))
              originalDispatch.call(this, opts, handler);
            else
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
          } else
            throw error;
        }
      else
        originalDispatch.call(this, opts, handler);
    };
  }
  function checkNetConnect(netConnect, origin) {
    let url = new URL(origin);
    if (netConnect === !0)
      return !0;
    else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host)))
      return !0;
    return !1;
  }
  function buildMockOptions(opts) {
    if (opts) {
      let { agent, ...mockOptions } = opts;
      return mockOptions;
    }
  }
  module.exports = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName
  };
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS((exports, module) => {
  var { getResponseData, buildKey, addMockDispatch } = require_mock_utils(), {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = require_mock_symbols(), { InvalidArgumentError } = require_errors(), { buildURL } = require_util();

  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0)
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      return this[kMockDispatch].delay = waitInMs, this;
    }
    persist() {
      return this[kMockDispatch].persist = !0, this;
    }
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0)
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      return this[kMockDispatch].times = repeatTimes, this;
    }
  }

  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object")
        throw new InvalidArgumentError("opts must be an object");
      if (typeof opts.path > "u")
        throw new InvalidArgumentError("opts.path must be defined");
      if (typeof opts.method > "u")
        opts.method = "GET";
      if (typeof opts.path === "string")
        if (opts.query)
          opts.path = buildURL(opts.path, opts.query);
        else {
          let parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      if (typeof opts.method === "string")
        opts.method = opts.method.toUpperCase();
      this[kDispatchKey] = buildKey(opts), this[kDispatches] = mockDispatches, this[kDefaultHeaders] = {}, this[kDefaultTrailers] = {}, this[kContentLength] = !1;
    }
    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
      let responseData = getResponseData(data), contentLength = this[kContentLength] ? { "content-length": responseData.length } : {}, headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }, trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers, trailers };
    }
    validateReplyParameters(statusCode, data, responseOptions) {
      if (typeof statusCode > "u")
        throw new InvalidArgumentError("statusCode must be defined");
      if (typeof data > "u")
        throw new InvalidArgumentError("data must be defined");
      if (typeof responseOptions !== "object")
        throw new InvalidArgumentError("responseOptions must be an object");
    }
    reply(replyData) {
      if (typeof replyData === "function") {
        let wrappedDefaultsCallback = (opts) => {
          let resolvedData = replyData(opts);
          if (typeof resolvedData !== "object")
            throw new InvalidArgumentError("reply options callback must return an object");
          let { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
          return this.validateReplyParameters(statusCode2, data2, responseOptions2), {
            ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
          };
        }, newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      let [statusCode, data = "", responseOptions = {}] = [...arguments];
      this.validateReplyParameters(statusCode, data, responseOptions);
      let dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions), newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    replyWithError(error) {
      if (typeof error > "u")
        throw new InvalidArgumentError("error must be defined");
      let newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
      return new MockScope(newMockDispatch);
    }
    defaultReplyHeaders(headers) {
      if (typeof headers > "u")
        throw new InvalidArgumentError("headers must be defined");
      return this[kDefaultHeaders] = headers, this;
    }
    defaultReplyTrailers(trailers) {
      if (typeof trailers > "u")
        throw new InvalidArgumentError("trailers must be defined");
      return this[kDefaultTrailers] = trailers, this;
    }
    replyContentLength() {
      return this[kContentLength] = !0, this;
    }
  }
  exports.MockInterceptor = MockInterceptor;
  exports.MockScope = MockScope;
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS((exports, module) => {
  var { promisify } = __require("util"), Client = require_client(), { buildMockDispatch } = require_mock_utils(), {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols(), { MockInterceptor } = require_mock_interceptor(), Symbols = require_symbols(), { InvalidArgumentError } = require_errors();

  class MockClient extends Client {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function")
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      this[kMockAgent] = opts.agent, this[kOrigin] = origin, this[kDispatches] = [], this[kConnected] = 1, this[kOriginalDispatch] = this.dispatch, this[kOriginalClose] = this.close.bind(this), this.dispatch = buildMockDispatch.call(this), this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])(), this[kConnected] = 0, this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockClient;
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS((exports, module) => {
  var { promisify } = __require("util"), Pool = require_pool(), { buildMockDispatch } = require_mock_utils(), {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols(), { MockInterceptor } = require_mock_interceptor(), Symbols = require_symbols(), { InvalidArgumentError } = require_errors();

  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function")
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      this[kMockAgent] = opts.agent, this[kOrigin] = origin, this[kDispatches] = [], this[kConnected] = 1, this[kOriginalDispatch] = this.dispatch, this[kOriginalClose] = this.close.bind(this), this.dispatch = buildMockDispatch.call(this), this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])(), this[kConnected] = 0, this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockPool;
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS((exports, module) => {
  var singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  }, plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  module.exports = class {
    constructor(singular, plural) {
      this.singular = singular, this.plural = plural;
    }
    pluralize(count) {
      let one = count === 1, keys = one ? singulars : plurals, noun = one ? this.singular : this.plural;
      return { ...keys, count, noun };
    }
  };
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS((exports, module) => {
  var { Transform } = __require("stream"), { Console } = __require("console");
  module.exports = class {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      }), this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      let withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        "Status code": statusCode,
        Persistent: persist ? "" : "",
        Invocations: timesInvoked,
        Remaining: persist ? 1 / 0 : times - timesInvoked
      }));
      return this.logger.table(withPrettyHeaders), this.transform.read().toString();
    }
  };
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS((exports, module) => {
  var { kClients } = require_symbols(), Agent = require_agent(), {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = require_mock_symbols(), MockClient = require_mock_client(), MockPool = require_mock_pool(), { matchValue, buildMockOptions } = require_mock_utils(), { InvalidArgumentError, UndiciError } = require_errors(), Dispatcher = require_dispatcher(), Pluralizer = require_pluralizer(), PendingInterceptorsFormatter = require_pending_interceptors_formatter();

  class FakeWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  }

  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      if (this[kNetConnect] = !0, this[kIsMockActive] = !0, opts && opts.agent && typeof opts.agent.dispatch !== "function")
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      let agent = opts && opts.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent, this[kClients] = agent[kClients], this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher = this[kMockAgentGet](origin);
      if (!dispatcher)
        dispatcher = this[kFactory](origin), this[kMockAgentSet](origin, dispatcher);
      return dispatcher;
    }
    dispatch(opts, handler) {
      return this.get(opts.origin), this[kAgent].dispatch(opts, handler);
    }
    async close() {
      await this[kAgent].close(), this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = !1;
    }
    activate() {
      this[kIsMockActive] = !0;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp)
        if (Array.isArray(this[kNetConnect]))
          this[kNetConnect].push(matcher);
        else
          this[kNetConnect] = [matcher];
      else if (typeof matcher > "u")
        this[kNetConnect] = !0;
      else
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
    }
    disableNetConnect() {
      this[kNetConnect] = !1;
    }
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher) {
      this[kClients].set(origin, new FakeWeakRef(dispatcher));
    }
    [kFactory](origin) {
      let mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      let ref = this[kClients].get(origin);
      if (ref)
        return ref.deref();
      if (typeof origin !== "string") {
        let dispatcher = this[kFactory]("http://localhost:9999");
        return this[kMockAgentSet](origin, dispatcher), dispatcher;
      }
      for (let [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
        let nonExplicitDispatcher = nonExplicitRef.deref();
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          let dispatcher = this[kFactory](origin);
          return this[kMockAgentSet](origin, dispatcher), dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches], dispatcher;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      let mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter } = {}) {
      let pending = this.pendingInterceptors();
      if (pending.length === 0)
        return;
      let pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
    }
  }
  module.exports = MockAgent;
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS((exports, module) => {
  var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols(), { URL: URL2 } = __require("url"), Agent = require_agent(), Pool = require_pool(), DispatcherBase = require_dispatcher_base(), { InvalidArgumentError, RequestAbortedError } = require_errors(), buildConnector = require_connect(), kAgent = Symbol("proxy agent"), kClient = Symbol("proxy client"), kProxyHeaders = Symbol("proxy headers"), kRequestTls = Symbol("request tls settings"), kProxyTls = Symbol("proxy tls settings"), kConnectEndpoint = Symbol("connect endpoint function");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function buildProxyOptions(opts) {
    if (typeof opts === "string")
      opts = { uri: opts };
    if (!opts || !opts.uri)
      throw new InvalidArgumentError("Proxy opts.uri is mandatory");
    return {
      uri: opts.uri,
      protocol: opts.protocol || "https"
    };
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }

  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super(opts);
      if (this[kProxy] = buildProxyOptions(opts), this[kAgent] = new Agent(opts), this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [], typeof opts === "string")
        opts = { uri: opts };
      if (!opts || !opts.uri)
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      let { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function")
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      this[kRequestTls] = opts.requestTls, this[kProxyTls] = opts.proxyTls, this[kProxyHeaders] = opts.headers || {};
      let resolvedUrl = new URL2(opts.uri), { origin, port, host, username, password } = resolvedUrl;
      if (opts.auth && opts.token)
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      else if (opts.auth)
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      else if (opts.token)
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      else if (username && password)
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      let connect = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls }), this[kClient] = clientFactory(resolvedUrl, { connect }), this[kAgent] = new Agent({
        ...opts,
        connect: async (opts2, callback) => {
          let requestedHost = opts2.host;
          if (!opts2.port)
            requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
          try {
            let { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedHost,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host
              }
            });
            if (statusCode !== 200)
              socket.on("error", () => {}).destroy(), callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls])
              servername = this[kRequestTls].servername;
            else
              servername = opts2.servername;
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            callback(err);
          }
        }
      });
    }
    dispatch(opts, handler) {
      let { host } = new URL2(opts.origin), headers = buildHeaders(opts.headers);
      return throwIfProxyAuthIsSent(headers), this[kAgent].dispatch({
        ...opts,
        headers: {
          ...headers,
          host
        }
      }, handler);
    }
    async[kClose]() {
      await this[kAgent].close(), await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy(), await this[kClient].destroy();
    }
  }
  function buildHeaders(headers) {
    if (Array.isArray(headers)) {
      let headersPair = {};
      for (let i = 0;i < headers.length; i += 2)
        headersPair[headers[i]] = headers[i + 1];
      return headersPair;
    }
    return headers;
  }
  function throwIfProxyAuthIsSent(headers) {
    if (headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization"))
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
  }
  module.exports = ProxyAgent;
});

// node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS((exports, module) => {
  var assert = __require("assert"), { kRetryHandlerDefaultRetry } = require_symbols(), { RequestRetryError } = require_errors(), { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
  function calculateRetryAfterHeader(retryAfter) {
    let current = Date.now();
    return new Date(retryAfter).getTime() - current;
  }

  class RetryHandler {
    constructor(opts, handlers) {
      let { retryOptions, ...dispatchOpts } = opts, {
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        methods,
        errorCodes,
        retryAfter,
        statusCodes
      } = retryOptions ?? {};
      this.dispatch = handlers.dispatch, this.handler = handlers.handler, this.opts = dispatchOpts, this.abort = null, this.aborted = !1, this.retryOpts = {
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? !0,
        maxTimeout: maxTimeout ?? 30000,
        timeout: minTimeout ?? 500,
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE"
        ]
      }, this.retryCount = 0, this.start = 0, this.end = null, this.etag = null, this.resume = null, this.handler.onConnect((reason) => {
        if (this.aborted = !0, this.abort)
          this.abort(reason);
        else
          this.reason = reason;
      });
    }
    onRequestSent() {
      if (this.handler.onRequestSent)
        this.handler.onRequestSent();
    }
    onUpgrade(statusCode, headers, socket) {
      if (this.handler.onUpgrade)
        this.handler.onUpgrade(statusCode, headers, socket);
    }
    onConnect(abort) {
      if (this.aborted)
        abort(this.reason);
      else
        this.abort = abort;
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent)
        return this.handler.onBodySent(chunk);
    }
    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
      let { statusCode, code, headers } = err, { method, retryOptions } = opts, {
        maxRetries,
        timeout,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods
      } = retryOptions, { counter, currentTimeout } = state;
      if (currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout, code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers != null && headers["retry-after"];
      if (retryAfterHeader)
        retryAfterHeader = Number(retryAfterHeader), retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1000;
      let retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
      state.currentTimeout = retryTimeout, setTimeout(() => cb(null), retryTimeout);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      let headers = parseHeaders(rawHeaders);
      if (this.retryCount += 1, statusCode >= 300)
        return this.abort(new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        })), !1;
      if (this.resume != null) {
        if (this.resume = null, statusCode !== 206)
          return !0;
        let contentRange = parseRangeHeader(headers["content-range"]);
        if (!contentRange)
          return this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
            headers,
            count: this.retryCount
          })), !1;
        if (this.etag != null && this.etag !== headers.etag)
          return this.abort(new RequestRetryError("ETag mismatch", statusCode, {
            headers,
            count: this.retryCount
          })), !1;
        let { start, size, end = size } = contentRange;
        return assert(this.start === start, "content-range mismatch"), assert(this.end == null || this.end === end, "content-range mismatch"), this.resume = resume, !0;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          let range = parseRangeHeader(headers["content-range"]);
          if (range == null)
            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
          let { start, size, end = size } = range;
          assert(start != null && Number.isFinite(start) && this.start !== start, "content-range mismatch"), assert(Number.isFinite(start)), assert(end != null && Number.isFinite(end) && this.end !== end, "invalid content-length"), this.start = start, this.end = end;
        }
        if (this.end == null) {
          let contentLength = headers["content-length"];
          this.end = contentLength != null ? Number(contentLength) : null;
        }
        return assert(Number.isFinite(this.start)), assert(this.end == null || Number.isFinite(this.end), "invalid content-length"), this.resume = resume, this.etag = headers.etag != null ? headers.etag : null, this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
      }
      let err = new RequestRetryError("Request failed", statusCode, {
        headers,
        count: this.retryCount
      });
      return this.abort(err), !1;
    }
    onData(chunk) {
      return this.start += chunk.length, this.handler.onData(chunk);
    }
    onComplete(rawTrailers) {
      return this.retryCount = 0, this.handler.onComplete(rawTrailers);
    }
    onError(err) {
      if (this.aborted || isDisturbed(this.opts.body))
        return this.handler.onError(err);
      this.retryOpts.retry(err, {
        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      }, onRetry.bind(this));
      function onRetry(err2) {
        if (err2 != null || this.aborted || isDisturbed(this.opts.body))
          return this.handler.onError(err2);
        if (this.start !== 0)
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              range: `bytes=${this.start}-${this.end ?? ""}`
            }
          };
        try {
          this.dispatch(this.opts, this);
        } catch (err3) {
          this.handler.onError(err3);
        }
      }
    }
  }
  module.exports = RetryHandler;
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS((exports, module) => {
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError } = require_errors(), Agent = require_agent();
  if (getGlobalDispatcher() === void 0)
    setGlobalDispatcher(new Agent);
  function setGlobalDispatcher(agent) {
    if (!agent || typeof agent.dispatch !== "function")
      throw new InvalidArgumentError("Argument agent must implement Agent");
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent,
      writable: !0,
      enumerable: !1,
      configurable: !1
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  module.exports = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS((exports, module) => {
  module.exports = class {
    constructor(handler) {
      this.handler = handler;
    }
    onConnect(...args) {
      return this.handler.onConnect(...args);
    }
    onError(...args) {
      return this.handler.onError(...args);
    }
    onUpgrade(...args) {
      return this.handler.onUpgrade(...args);
    }
    onHeaders(...args) {
      return this.handler.onHeaders(...args);
    }
    onData(...args) {
      return this.handler.onData(...args);
    }
    onComplete(...args) {
      return this.handler.onComplete(...args);
    }
    onBodySent(...args) {
      return this.handler.onBodySent(...args);
    }
  };
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS((exports, module) => {
  var { kHeadersList, kConstruct } = require_symbols(), { kGuard } = require_symbols2(), { kEnumerableProperty } = require_util(), {
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue
  } = require_util2(), util = __require("util"), { webidl } = require_webidl(), assert = __require("assert"), kHeadersMap = Symbol("headers map"), kHeadersSortedMap = Symbol("headers map sorted");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0, j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))
      --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
      ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers, object) {
    if (Array.isArray(object))
      for (let i = 0;i < object.length; ++i) {
        let header = object[i];
        if (header.length !== 2)
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        appendHeader(headers, header[0], header[1]);
      }
    else if (typeof object === "object" && object !== null) {
      let keys = Object.keys(object);
      for (let i = 0;i < keys.length; ++i)
        appendHeader(headers, keys[i], object[keys[i]]);
    } else
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
  }
  function appendHeader(headers, name, value) {
    if (value = headerValueNormalize(value), !isValidHeaderName(name))
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    else if (!isValidHeaderValue(value))
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    if (headers[kGuard] === "immutable")
      throw TypeError("immutable");
    else if (headers[kGuard] === "request-no-cors")
      ;
    return headers[kHeadersList].append(name, value);
  }

  class HeadersList {
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList)
        this[kHeadersMap] = new Map(init[kHeadersMap]), this[kHeadersSortedMap] = init[kHeadersSortedMap], this.cookies = init.cookies === null ? null : [...init.cookies];
      else
        this[kHeadersMap] = new Map(init), this[kHeadersSortedMap] = null;
    }
    contains(name) {
      return name = name.toLowerCase(), this[kHeadersMap].has(name);
    }
    clear() {
      this[kHeadersMap].clear(), this[kHeadersSortedMap] = null, this.cookies = null;
    }
    append(name, value) {
      this[kHeadersSortedMap] = null;
      let lowercaseName = name.toLowerCase(), exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        let delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else
        this[kHeadersMap].set(lowercaseName, { name, value });
      if (lowercaseName === "set-cookie")
        this.cookies ??= [], this.cookies.push(value);
    }
    set(name, value) {
      this[kHeadersSortedMap] = null;
      let lowercaseName = name.toLowerCase();
      if (lowercaseName === "set-cookie")
        this.cookies = [value];
      this[kHeadersMap].set(lowercaseName, { name, value });
    }
    delete(name) {
      if (this[kHeadersSortedMap] = null, name = name.toLowerCase(), name === "set-cookie")
        this.cookies = null;
      this[kHeadersMap].delete(name);
    }
    get(name) {
      let value = this[kHeadersMap].get(name.toLowerCase());
      return value === void 0 ? null : value.value;
    }
    *[Symbol.iterator]() {
      for (let [name, { value }] of this[kHeadersMap])
        yield [name, value];
    }
    get entries() {
      let headers = {};
      if (this[kHeadersMap].size)
        for (let { name, value } of this[kHeadersMap].values())
          headers[name] = value;
      return headers;
    }
  }

  class Headers {
    constructor(init = void 0) {
      if (init === kConstruct)
        return;
      if (this[kHeadersList] = new HeadersList, this[kGuard] = "none", init !== void 0)
        init = webidl.converters.HeadersInit(init), fill(this, init);
    }
    append(name, value) {
      return webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" }), name = webidl.converters.ByteString(name), value = webidl.converters.ByteString(value), appendHeader(this, name, value);
    }
    delete(name) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" }), name = webidl.converters.ByteString(name), !isValidHeaderName(name))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      if (this[kGuard] === "immutable")
        throw TypeError("immutable");
      else if (this[kGuard] === "request-no-cors")
        ;
      if (!this[kHeadersList].contains(name))
        return;
      this[kHeadersList].delete(name);
    }
    get(name) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" }), name = webidl.converters.ByteString(name), !isValidHeaderName(name))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.get",
          value: name,
          type: "header name"
        });
      return this[kHeadersList].get(name);
    }
    has(name) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" }), name = webidl.converters.ByteString(name), !isValidHeaderName(name))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.has",
          value: name,
          type: "header name"
        });
      return this[kHeadersList].contains(name);
    }
    set(name, value) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" }), name = webidl.converters.ByteString(name), value = webidl.converters.ByteString(value), value = headerValueNormalize(value), !isValidHeaderName(name))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value: name,
          type: "header name"
        });
      else if (!isValidHeaderValue(value))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value,
          type: "header value"
        });
      if (this[kGuard] === "immutable")
        throw TypeError("immutable");
      else if (this[kGuard] === "request-no-cors")
        ;
      this[kHeadersList].set(name, value);
    }
    getSetCookie() {
      webidl.brandCheck(this, Headers);
      let list = this[kHeadersList].cookies;
      if (list)
        return [...list];
      return [];
    }
    get [kHeadersSortedMap]() {
      if (this[kHeadersList][kHeadersSortedMap])
        return this[kHeadersList][kHeadersSortedMap];
      let headers = [], names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1), cookies = this[kHeadersList].cookies;
      for (let i = 0;i < names.length; ++i) {
        let [name, value] = names[i];
        if (name === "set-cookie")
          for (let j = 0;j < cookies.length; ++j)
            headers.push([name, cookies[j]]);
        else
          assert(value !== null), headers.push([name, value]);
      }
      return this[kHeadersList][kHeadersSortedMap] = headers, headers;
    }
    keys() {
      if (webidl.brandCheck(this, Headers), this[kGuard] === "immutable") {
        let value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "key");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
    }
    values() {
      if (webidl.brandCheck(this, Headers), this[kGuard] === "immutable") {
        let value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "value");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
    }
    entries() {
      if (webidl.brandCheck(this, Headers), this[kGuard] === "immutable") {
        let value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "key+value");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" }), typeof callbackFn !== "function")
        throw TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
      for (let [key, value] of this)
        callbackFn.apply(thisArg, [value, key, this]);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return webidl.brandCheck(this, Headers), this[kHeadersList];
    }
  }
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    keys: kEnumerableProperty,
    values: kEnumerableProperty,
    entries: kEnumerableProperty,
    forEach: kEnumerableProperty,
    [Symbol.iterator]: { enumerable: !1 },
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: !0
    },
    [util.inspect.custom]: {
      enumerable: !1
    }
  });
  webidl.converters.HeadersInit = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (V[Symbol.iterator])
        return webidl.converters["sequence<sequence<ByteString>>"](V);
      return webidl.converters["record<ByteString, ByteString>"](V);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill,
    Headers,
    HeadersList
  };
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS((exports, module) => {
  var { Headers, HeadersList, fill } = require_headers(), { extractBody, cloneBody, mixinBody } = require_body(), util = require_util(), { kEnumerableProperty } = util, {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode
  } = require_util2(), {
    redirectStatusSet,
    nullBodyStatus,
    DOMException: DOMException2
  } = require_constants2(), { kState, kHeaders, kGuard, kRealm } = require_symbols2(), { webidl } = require_webidl(), { FormData: FormData2 } = require_formdata(), { getGlobalOrigin } = require_global(), { URLSerializer } = require_dataURL(), { kHeadersList, kConstruct } = require_symbols(), assert = __require("assert"), { types } = __require("util"), ReadableStream2 = globalThis.ReadableStream || __require("stream/web").ReadableStream, textEncoder = new TextEncoder("utf-8");

  class Response {
    static error() {
      let relevantRealm = { settingsObject: {} }, responseObject = new Response;
      return responseObject[kState] = makeNetworkError(), responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList, responseObject[kHeaders][kGuard] = "immutable", responseObject[kHeaders][kRealm] = relevantRealm, responseObject;
    }
    static json(data, init = {}) {
      if (webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" }), init !== null)
        init = webidl.converters.ResponseInit(init);
      let bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data)), body = extractBody(bytes), relevantRealm = { settingsObject: {} }, responseObject = new Response;
      return responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kGuard] = "response", responseObject[kHeaders][kRealm] = relevantRealm, initializeResponse(responseObject, init, { body: body[0], type: "application/json" }), responseObject;
    }
    static redirect(url, status = 302) {
      let relevantRealm = { settingsObject: {} };
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" }), url = webidl.converters.USVString(url), status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, getGlobalOrigin());
      } catch (err) {
        throw Object.assign(TypeError("Failed to parse URL from " + url), {
          cause: err
        });
      }
      if (!redirectStatusSet.has(status))
        throw RangeError("Invalid status code " + status);
      let responseObject = new Response;
      responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kGuard] = "immutable", responseObject[kHeaders][kRealm] = relevantRealm, responseObject[kState].status = status;
      let value = isomorphicEncode(URLSerializer(parsedURL));
      return responseObject[kState].headersList.append("location", value), responseObject;
    }
    constructor(body = null, init = {}) {
      if (body !== null)
        body = webidl.converters.BodyInit(body);
      init = webidl.converters.ResponseInit(init), this[kRealm] = { settingsObject: {} }, this[kState] = makeResponse({}), this[kHeaders] = new Headers(kConstruct), this[kHeaders][kGuard] = "response", this[kHeaders][kHeadersList] = this[kState].headersList, this[kHeaders][kRealm] = this[kRealm];
      let bodyWithType = null;
      if (body != null) {
        let [extractedBody, type] = extractBody(body);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    get type() {
      return webidl.brandCheck(this, Response), this[kState].type;
    }
    get url() {
      webidl.brandCheck(this, Response);
      let urlList = this[kState].urlList, url = urlList[urlList.length - 1] ?? null;
      if (url === null)
        return "";
      return URLSerializer(url, !0);
    }
    get redirected() {
      return webidl.brandCheck(this, Response), this[kState].urlList.length > 1;
    }
    get status() {
      return webidl.brandCheck(this, Response), this[kState].status;
    }
    get ok() {
      return webidl.brandCheck(this, Response), this[kState].status >= 200 && this[kState].status <= 299;
    }
    get statusText() {
      return webidl.brandCheck(this, Response), this[kState].statusText;
    }
    get headers() {
      return webidl.brandCheck(this, Response), this[kHeaders];
    }
    get body() {
      return webidl.brandCheck(this, Response), this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      return webidl.brandCheck(this, Response), !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    clone() {
      if (webidl.brandCheck(this, Response), this.bodyUsed || this.body && this.body.locked)
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      let clonedResponse = cloneResponse(this[kState]), clonedResponseObject = new Response;
      return clonedResponseObject[kState] = clonedResponse, clonedResponseObject[kRealm] = this[kRealm], clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList, clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard], clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm], clonedResponseObject;
    }
  }
  mixinBody(Response);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: !0
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response) {
    if (response.internalResponse)
      return filterResponse(cloneResponse(response.internalResponse), response.type);
    let newResponse = makeResponse({ ...response, body: null });
    if (response.body != null)
      newResponse.body = cloneBody(response.body);
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: !1,
      rangeRequested: !1,
      timingAllowPassed: !1,
      requestIncludesCredentials: !1,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList,
      urlList: init.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    let isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function makeFilteredResponse(response, state) {
    return state = {
      internalResponse: response,
      ...state
    }, new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        return assert(!(p in state)), target[p] = value, !0;
      }
    });
  }
  function filterResponse(response, type) {
    if (type === "basic")
      return makeFilteredResponse(response, {
        type: "basic",
        headersList: response.headersList
      });
    else if (type === "cors")
      return makeFilteredResponse(response, {
        type: "cors",
        headersList: response.headersList
      });
    else if (type === "opaque")
      return makeFilteredResponse(response, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    else if (type === "opaqueredirect")
      return makeFilteredResponse(response, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    else
      assert(!1);
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    return assert(isCancelled(fetchParams)), isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599))
      throw RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText)))
        throw TypeError("Invalid statusText");
    }
    if ("status" in init && init.status != null)
      response[kState].status = init.status;
    if ("statusText" in init && init.statusText != null)
      response[kState].statusText = init.statusText;
    if ("headers" in init && init.headers != null)
      fill(response[kHeaders], init.headers);
    if (body) {
      if (nullBodyStatus.includes(response.status))
        throw webidl.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + response.status
        });
      if (response[kState].body = body.body, body.type != null && !response[kState].headersList.contains("Content-Type"))
        response[kState].headersList.append("content-type", body.type);
    }
  }
  webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream2);
  webidl.converters.FormData = webidl.interfaceConverter(FormData2);
  webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
  webidl.converters.XMLHttpRequestBodyInit = function(V) {
    if (typeof V === "string")
      return webidl.converters.USVString(V);
    if (isBlobLike(V))
      return webidl.converters.Blob(V, { strict: !1 });
    if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V))
      return webidl.converters.BufferSource(V);
    if (util.isFormDataLike(V))
      return webidl.converters.FormData(V, { strict: !1 });
    if (V instanceof URLSearchParams)
      return webidl.converters.URLSearchParams(V);
    return webidl.converters.DOMString(V);
  };
  webidl.converters.BodyInit = function(V) {
    if (V instanceof ReadableStream2)
      return webidl.converters.ReadableStream(V);
    if (V?.[Symbol.asyncIterator])
      return V;
    return webidl.converters.XMLHttpRequestBodyInit(V);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  module.exports = {
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response,
    cloneResponse
  };
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS((exports, module) => {
  var { extractBody, mixinBody, cloneBody } = require_body(), { Headers, fill: fillHeaders, HeadersList } = require_headers(), { FinalizationRegistry } = require_dispatcher_weakref()(), util = require_util(), {
    isValidHTTPToken,
    sameOrigin,
    normalizeMethod,
    makePolicyContainer,
    normalizeMethodRecord
  } = require_util2(), {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = require_constants2(), { kEnumerableProperty } = util, { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2(), { webidl } = require_webidl(), { getGlobalOrigin } = require_global(), { URLSerializer } = require_dataURL(), { kHeadersList, kConstruct } = require_symbols(), assert = __require("assert"), { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events"), TransformStream = globalThis.TransformStream, kAbortController = Symbol("abortController"), requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });

  class Request {
    constructor(input, init = {}) {
      if (input === kConstruct)
        return;
      webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" }), input = webidl.converters.RequestInfo(input), init = webidl.converters.RequestInit(init), this[kRealm] = {
        settingsObject: {
          baseUrl: getGlobalOrigin(),
          get origin() {
            return this.baseUrl?.origin;
          },
          policyContainer: makePolicyContainer()
        }
      };
      let request = null, fallbackMode = null, baseUrl = this[kRealm].settingsObject.baseUrl, signal = null;
      if (typeof input === "string") {
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password)
          throw TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
        request = makeRequest({ urlList: [parsedURL] }), fallbackMode = "cors";
      } else
        assert(input instanceof Request), request = input[kState], signal = input[kSignal];
      let origin = this[kRealm].settingsObject.origin, window2 = "client";
      if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin))
        window2 = request.window;
      if (init.window != null)
        throw TypeError(`'window' option '${window2}' must be null`);
      if ("window" in init)
        window2 = "no-window";
      request = makeRequest({
        method: request.method,
        headersList: request.headersList,
        unsafeRequest: request.unsafeRequest,
        client: this[kRealm].settingsObject,
        window: window2,
        priority: request.priority,
        origin: request.origin,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
        keepalive: request.keepalive,
        reloadNavigation: request.reloadNavigation,
        historyNavigation: request.historyNavigation,
        urlList: [...request.urlList]
      });
      let initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request.mode === "navigate")
          request.mode = "same-origin";
        request.reloadNavigation = !1, request.historyNavigation = !1, request.origin = "client", request.referrer = "client", request.referrerPolicy = "", request.url = request.urlList[request.urlList.length - 1], request.urlList = [request.url];
      }
      if (init.referrer !== void 0) {
        let referrer = init.referrer;
        if (referrer === "")
          request.referrer = "no-referrer";
        else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl))
            request.referrer = "client";
          else
            request.referrer = parsedReferrer;
        }
      }
      if (init.referrerPolicy !== void 0)
        request.referrerPolicy = init.referrerPolicy;
      let mode;
      if (init.mode !== void 0)
        mode = init.mode;
      else
        mode = fallbackMode;
      if (mode === "navigate")
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      if (mode != null)
        request.mode = mode;
      if (init.credentials !== void 0)
        request.credentials = init.credentials;
      if (init.cache !== void 0)
        request.cache = init.cache;
      if (request.cache === "only-if-cached" && request.mode !== "same-origin")
        throw TypeError("'only-if-cached' can be set only with 'same-origin' mode");
      if (init.redirect !== void 0)
        request.redirect = init.redirect;
      if (init.integrity != null)
        request.integrity = String(init.integrity);
      if (init.keepalive !== void 0)
        request.keepalive = Boolean(init.keepalive);
      if (init.method !== void 0) {
        let method = init.method;
        if (!isValidHTTPToken(method))
          throw TypeError(`'${method}' is not a valid HTTP method.`);
        if (forbiddenMethodsSet.has(method.toUpperCase()))
          throw TypeError(`'${method}' HTTP method is unsupported.`);
        method = normalizeMethodRecord[method] ?? normalizeMethod(method), request.method = method;
      }
      if (init.signal !== void 0)
        signal = init.signal;
      this[kState] = request;
      let ac = new AbortController;
      if (this[kSignal] = ac.signal, this[kSignal][kRealm] = this[kRealm], signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function")
          throw TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
        if (signal.aborted)
          ac.abort(signal.reason);
        else {
          this[kAbortController] = ac;
          let acRef = new WeakRef(ac), abort = function() {
            let ac2 = acRef.deref();
            if (ac2 !== void 0)
              ac2.abort(this.reason);
          };
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners)
              setMaxListeners(100, signal);
            else if (getEventListeners(signal, "abort").length >= defaultMaxListeners)
              setMaxListeners(100, signal);
          } catch {}
          util.addAbortListener(signal, abort), requestFinalizer.register(ac, { signal, abort });
        }
      }
      if (this[kHeaders] = new Headers(kConstruct), this[kHeaders][kHeadersList] = request.headersList, this[kHeaders][kGuard] = "request", this[kHeaders][kRealm] = this[kRealm], mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request.method))
          throw TypeError(`'${request.method} is unsupported in no-cors mode.`);
        this[kHeaders][kGuard] = "request-no-cors";
      }
      if (initHasKey) {
        let headersList = this[kHeaders][kHeadersList], headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
        if (headersList.clear(), headers instanceof HeadersList) {
          for (let [key, val] of headers)
            headersList.append(key, val);
          headersList.cookies = headers.cookies;
        } else
          fillHeaders(this[kHeaders], headers);
      }
      let inputBody = input instanceof Request ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD"))
        throw TypeError("Request with GET/HEAD method cannot have body.");
      let initBody = null;
      if (init.body != null) {
        let [extractedBody, contentType] = extractBody(init.body, request.keepalive);
        if (initBody = extractedBody, contentType && !this[kHeaders][kHeadersList].contains("content-type"))
          this[kHeaders].append("content-type", contentType);
      }
      let inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null)
          throw TypeError("RequestInit: duplex option is required when sending a body.");
        if (request.mode !== "same-origin" && request.mode !== "cors")
          throw TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
        request.useCORSPreflightFlag = !0;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked)
          throw TypeError("Cannot construct a Request with a Request object that has already been used.");
        if (!TransformStream)
          TransformStream = __require("stream/web").TransformStream;
        let identityTransform = new TransformStream;
        inputBody.stream.pipeThrough(identityTransform), finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    get method() {
      return webidl.brandCheck(this, Request), this[kState].method;
    }
    get url() {
      return webidl.brandCheck(this, Request), URLSerializer(this[kState].url);
    }
    get headers() {
      return webidl.brandCheck(this, Request), this[kHeaders];
    }
    get destination() {
      return webidl.brandCheck(this, Request), this[kState].destination;
    }
    get referrer() {
      if (webidl.brandCheck(this, Request), this[kState].referrer === "no-referrer")
        return "";
      if (this[kState].referrer === "client")
        return "about:client";
      return this[kState].referrer.toString();
    }
    get referrerPolicy() {
      return webidl.brandCheck(this, Request), this[kState].referrerPolicy;
    }
    get mode() {
      return webidl.brandCheck(this, Request), this[kState].mode;
    }
    get credentials() {
      return this[kState].credentials;
    }
    get cache() {
      return webidl.brandCheck(this, Request), this[kState].cache;
    }
    get redirect() {
      return webidl.brandCheck(this, Request), this[kState].redirect;
    }
    get integrity() {
      return webidl.brandCheck(this, Request), this[kState].integrity;
    }
    get keepalive() {
      return webidl.brandCheck(this, Request), this[kState].keepalive;
    }
    get isReloadNavigation() {
      return webidl.brandCheck(this, Request), this[kState].reloadNavigation;
    }
    get isHistoryNavigation() {
      return webidl.brandCheck(this, Request), this[kState].historyNavigation;
    }
    get signal() {
      return webidl.brandCheck(this, Request), this[kSignal];
    }
    get body() {
      return webidl.brandCheck(this, Request), this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      return webidl.brandCheck(this, Request), !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      return webidl.brandCheck(this, Request), "half";
    }
    clone() {
      if (webidl.brandCheck(this, Request), this.bodyUsed || this.body?.locked)
        throw TypeError("unusable");
      let clonedRequest = cloneRequest(this[kState]), clonedRequestObject = new Request(kConstruct);
      clonedRequestObject[kState] = clonedRequest, clonedRequestObject[kRealm] = this[kRealm], clonedRequestObject[kHeaders] = new Headers(kConstruct), clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList, clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard], clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      let ac = new AbortController;
      if (this.signal.aborted)
        ac.abort(this.signal.reason);
      else
        util.addAbortListener(this.signal, () => {
          ac.abort(this.signal.reason);
        });
      return clonedRequestObject[kSignal] = ac.signal, clonedRequestObject;
    }
  }
  mixinBody(Request);
  function makeRequest(init) {
    let request = {
      method: "GET",
      localURLsOnly: !1,
      unsafeRequest: !1,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: !1,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: !1,
      credentials: "same-origin",
      useCredentials: !1,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: !1,
      historyNavigation: !1,
      userActivation: !1,
      taintedOrigin: !1,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: !1,
      done: !1,
      timingAllowFailed: !1,
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList
    };
    return request.url = request.urlList[0], request;
  }
  function cloneRequest(request) {
    let newRequest = makeRequest({ ...request, body: null });
    if (request.body != null)
      newRequest.body = cloneBody(request.body);
    return newRequest;
  }
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: !0
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(Request);
  webidl.converters.RequestInfo = function(V) {
    if (typeof V === "string")
      return webidl.converters.USVString(V);
    if (V instanceof Request)
      return webidl.converters.Request(V);
    return webidl.converters.USVString(V);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(webidl.converters.BodyInit)
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, { strict: !1 }))
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    }
  ]);
  module.exports = { Request, makeRequest };
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  var {
    Response,
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse
  } = require_response(), { Headers } = require_headers(), { Request, makeRequest } = require_request2(), zlib = __require("zlib"), {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme
  } = require_util2(), { kState, kHeaders, kGuard, kRealm } = require_symbols2(), assert = __require("assert"), { safelyExtractBody } = require_body(), {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet,
    DOMException: DOMException2
  } = require_constants2(), { kHeadersList } = require_symbols(), EE = __require("events"), { Readable, pipeline } = __require("stream"), { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util(), { dataURLProcessor, serializeAMimeType } = require_dataURL(), { TransformStream } = __require("stream/web"), { getGlobalDispatcher } = require_global2(), { webidl } = require_webidl(), { STATUS_CODES } = __require("http"), GET_OR_HEAD = ["GET", "HEAD"], resolveObjectURL, ReadableStream2 = globalThis.ReadableStream;

  class Fetch extends EE {
    constructor(dispatcher) {
      super();
      this.dispatcher = dispatcher, this.connection = null, this.dump = !1, this.state = "ongoing", this.setMaxListeners(21);
    }
    terminate(reason) {
      if (this.state !== "ongoing")
        return;
      this.state = "terminated", this.connection?.destroy(reason), this.emit("terminated", reason);
    }
    abort(error) {
      if (this.state !== "ongoing")
        return;
      if (this.state = "aborted", !error)
        error = new DOMException2("The operation was aborted.", "AbortError");
      this.serializedAbortReason = error, this.connection?.destroy(error), this.emit("terminated", error);
    }
  }
  function fetch(input, init = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    let p = createDeferredPromise(), requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      return p.reject(e), p.promise;
    }
    let request = requestObject[kState];
    if (requestObject.signal.aborted)
      return abortFetch(p, request, null, requestObject.signal.reason), p.promise;
    if (request.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope")
      request.serviceWorkers = "none";
    let responseObject = null, relevantRealm = null, locallyAborted = !1, controller = null;
    return addAbortListener(requestObject.signal, () => {
      locallyAborted = !0, assert(controller != null), controller.abort(requestObject.signal.reason), abortFetch(p, request, responseObject, requestObject.signal.reason);
    }), controller = fetching({
      request,
      processResponseEndOfBody: (response) => finalizeAndReportTiming(response, "fetch"),
      processResponse: (response) => {
        if (locallyAborted)
          return Promise.resolve();
        if (response.aborted)
          return abortFetch(p, request, responseObject, controller.serializedAbortReason), Promise.resolve();
        if (response.type === "error")
          return p.reject(Object.assign(TypeError("fetch failed"), { cause: response.error })), Promise.resolve();
        responseObject = new Response, responseObject[kState] = response, responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kHeadersList] = response.headersList, responseObject[kHeaders][kGuard] = "immutable", responseObject[kHeaders][kRealm] = relevantRealm, p.resolve(responseObject);
      },
      dispatcher: init.dispatcher ?? getGlobalDispatcher()
    }), p.promise;
  }
  function finalizeAndReportTiming(response, initiatorType = "other") {
    if (response.type === "error" && response.aborted)
      return;
    if (!response.urlList?.length)
      return;
    let originalURL = response.urlList[0], timingInfo = response.timingInfo, cacheState = response.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL))
      return;
    if (timingInfo === null)
      return;
    if (!response.timingAllowPassed)
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      }), cacheState = "";
    timingInfo.endTime = coarsenedSharedCurrentTime(), response.timingInfo = timingInfo, markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
  }
  function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2)
      performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
  }
  function abortFetch(p, request, responseObject, error) {
    if (!error)
      error = new DOMException2("The operation was aborted.", "AbortError");
    if (p.reject(error), request.body != null && isReadable(request.body?.stream))
      request.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE")
          return;
        throw err;
      });
    if (responseObject == null)
      return;
    let response = responseObject[kState];
    if (response.body != null && isReadable(response.body?.stream))
      response.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE")
          return;
        throw err;
      });
  }
  function fetching({
    request,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = !1,
    dispatcher
  }) {
    let taskDestination = null, crossOriginIsolatedCapability = !1;
    if (request.client != null)
      taskDestination = request.client.globalObject, crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
    let currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability), timingInfo = createOpaqueTimingInfo({
      startTime: currenTime
    }), fetchParams = {
      controller: new Fetch(dispatcher),
      request,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    if (assert(!request.body || request.body.stream), request.window === "client")
      request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
    if (request.origin === "client")
      request.origin = request.client?.origin;
    if (request.policyContainer === "client")
      if (request.client != null)
        request.policyContainer = clonePolicyContainer(request.client.policyContainer);
      else
        request.policyContainer = makePolicyContainer();
    if (!request.headersList.contains("accept"))
      request.headersList.append("accept", "*/*");
    if (!request.headersList.contains("accept-language"))
      request.headersList.append("accept-language", "*");
    if (request.priority === null)
      ;
    if (subresourceSet.has(request.destination))
      ;
    return mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    }), fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = !1) {
    let request = fetchParams.request, response = null;
    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request)))
      response = makeNetworkError("local URLs only");
    if (tryUpgradeRequestToAPotentiallyTrustworthyURL(request), requestBadPort(request) === "blocked")
      response = makeNetworkError("bad port");
    if (request.referrerPolicy === "")
      request.referrerPolicy = request.policyContainer.referrerPolicy;
    if (request.referrer !== "no-referrer")
      request.referrer = determineRequestsReferrer(request);
    if (response === null)
      response = await (async () => {
        let currentURL = requestCurrentURL(request);
        if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket"))
          return request.responseTainting = "basic", await schemeFetch(fetchParams);
        if (request.mode === "same-origin")
          return makeNetworkError('request mode cannot be "same-origin"');
        if (request.mode === "no-cors") {
          if (request.redirect !== "follow")
            return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
          return request.responseTainting = "opaque", await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request)))
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        return request.responseTainting = "cors", await httpFetch(fetchParams);
      })();
    if (recursive)
      return response;
    if (response.status !== 0 && !response.internalResponse) {
      if (request.responseTainting === "cors")
        ;
      if (request.responseTainting === "basic")
        response = filterResponse(response, "basic");
      else if (request.responseTainting === "cors")
        response = filterResponse(response, "cors");
      else if (request.responseTainting === "opaque")
        response = filterResponse(response, "opaque");
      else
        assert(!1);
    }
    let internalResponse = response.status === 0 ? response : response.internalResponse;
    if (internalResponse.urlList.length === 0)
      internalResponse.urlList.push(...request.urlList);
    if (!request.timingAllowFailed)
      response.timingAllowPassed = !0;
    if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range"))
      response = internalResponse = makeNetworkError();
    if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status)))
      internalResponse.body = null, fetchParams.controller.dump = !0;
    if (request.integrity) {
      let processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request.responseTainting === "opaque" || response.body == null) {
        processBodyError(response.error);
        return;
      }
      let processBody = (bytes) => {
        if (!bytesMatch(bytes, request.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response.body = safelyExtractBody(bytes)[0], fetchFinale(fetchParams, response);
      };
      await fullyReadBody(response.body, processBody, processBodyError);
    } else
      fetchFinale(fetchParams, response);
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0)
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    let { request } = fetchParams, { protocol: scheme } = requestCurrentURL(request);
    switch (scheme) {
      case "about:":
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      case "blob:": {
        if (!resolveObjectURL)
          resolveObjectURL = __require("buffer").resolveObjectURL;
        let blobURLEntry = requestCurrentURL(request);
        if (blobURLEntry.search.length !== 0)
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        let blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
        if (request.method !== "GET" || !isBlobLike(blobURLEntryObject))
          return Promise.resolve(makeNetworkError("invalid method"));
        let bodyWithType = safelyExtractBody(blobURLEntryObject), body = bodyWithType[0], length = isomorphicEncode(`${body.length}`), type = bodyWithType[1] ?? "", response = makeResponse({
          statusText: "OK",
          headersList: [
            ["content-length", { name: "Content-Length", value: length }],
            ["content-type", { name: "Content-Type", value: type }]
          ]
        });
        return response.body = body, Promise.resolve(response);
      }
      case "data:": {
        let currentURL = requestCurrentURL(request), dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure")
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        let mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:":
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      case "http:":
      case "https:":
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      default:
        return Promise.resolve(makeNetworkError("unknown scheme"));
    }
  }
  function finalizeResponse(fetchParams, response) {
    if (fetchParams.request.done = !0, fetchParams.processResponseDone != null)
      queueMicrotask(() => fetchParams.processResponseDone(response));
  }
  function fetchFinale(fetchParams, response) {
    if (response.type === "error")
      response.urlList = [fetchParams.request.urlList[0]], response.timingInfo = createOpaqueTimingInfo({
        startTime: fetchParams.timingInfo.startTime
      });
    let processResponseEndOfBody = () => {
      if (fetchParams.request.done = !0, fetchParams.processResponseEndOfBody != null)
        queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
    };
    if (fetchParams.processResponse != null)
      queueMicrotask(() => fetchParams.processResponse(response));
    if (response.body == null)
      processResponseEndOfBody();
    else {
      let transformStream = new TransformStream({
        start() {},
        transform: (chunk, controller) => {
          controller.enqueue(chunk);
        },
        flush: processResponseEndOfBody
      }, {
        size() {
          return 1;
        }
      }, {
        size() {
          return 1;
        }
      });
      response.body = { stream: response.body.stream.pipeThrough(transformStream) };
    }
    if (fetchParams.processResponseConsumeBody != null) {
      let processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes), processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
      if (response.body == null)
        queueMicrotask(() => processBody(null));
      else
        return fullyReadBody(response.body, processBody, processBodyError);
      return Promise.resolve();
    }
  }
  async function httpFetch(fetchParams) {
    let request = fetchParams.request, response = null, actualResponse = null, timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers === "all")
      ;
    if (response === null) {
      if (request.redirect === "follow")
        request.serviceWorkers = "none";
      if (actualResponse = response = await httpNetworkOrCacheFetch(fetchParams), request.responseTainting === "cors" && corsCheck(request, response) === "failure")
        return makeNetworkError("cors failure");
      if (TAOCheck(request, response) === "failure")
        request.timingAllowFailed = !0;
    }
    if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked")
      return makeNetworkError("blocked");
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request.redirect !== "manual")
        fetchParams.controller.connection.destroy();
      if (request.redirect === "error")
        response = makeNetworkError("unexpected redirect");
      else if (request.redirect === "manual")
        response = actualResponse;
      else if (request.redirect === "follow")
        response = await httpRedirectFetch(fetchParams, response);
      else
        assert(!1);
    }
    return response.timingInfo = timingInfo, response;
  }
  function httpRedirectFetch(fetchParams, response) {
    let request = fetchParams.request, actualResponse = response.internalResponse ? response.internalResponse : response, locationURL;
    try {
      if (locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash), locationURL == null)
        return response;
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL))
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    if (request.redirectCount === 20)
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    if (request.redirectCount += 1, request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL))
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password))
      return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null)
      return Promise.resolve(makeNetworkError());
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
      request.method = "GET", request.body = null;
      for (let headerName of requestBodyHeader)
        request.headersList.delete(headerName);
    }
    if (!sameOrigin(requestCurrentURL(request), locationURL))
      request.headersList.delete("authorization"), request.headersList.delete("proxy-authorization", !0), request.headersList.delete("cookie"), request.headersList.delete("host");
    if (request.body != null)
      assert(request.body.source != null), request.body = safelyExtractBody(request.body.source)[0];
    let timingInfo = fetchParams.timingInfo;
    if (timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability), timingInfo.redirectStartTime === 0)
      timingInfo.redirectStartTime = timingInfo.startTime;
    return request.urlList.push(locationURL), setRequestReferrerPolicyOnRedirect(request, actualResponse), mainFetch(fetchParams, !0);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = !1, isNewConnectionFetch = !1) {
    let request = fetchParams.request, httpFetchParams = null, httpRequest = null, response = null, httpCache = null, revalidatingFlag = !1;
    if (request.window === "no-window" && request.redirect === "error")
      httpFetchParams = fetchParams, httpRequest = request;
    else
      httpRequest = makeRequest(request), httpFetchParams = { ...fetchParams }, httpFetchParams.request = httpRequest;
    let includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic", contentLength = httpRequest.body ? httpRequest.body.length : null, contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method))
      contentLengthHeaderValue = "0";
    if (contentLength != null)
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    if (contentLengthHeaderValue != null)
      httpRequest.headersList.append("content-length", contentLengthHeaderValue);
    if (contentLength != null && httpRequest.keepalive)
      ;
    if (httpRequest.referrer instanceof URL)
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
    if (appendRequestOriginHeader(httpRequest), appendFetchMetadata(httpRequest), !httpRequest.headersList.contains("user-agent"))
      httpRequest.headersList.append("user-agent", typeof esbuildDetection > "u" ? "undici" : "node");
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range")))
      httpRequest.cache = "no-store";
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control"))
      httpRequest.headersList.append("cache-control", "max-age=0");
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma"))
        httpRequest.headersList.append("pragma", "no-cache");
      if (!httpRequest.headersList.contains("cache-control"))
        httpRequest.headersList.append("cache-control", "no-cache");
    }
    if (httpRequest.headersList.contains("range"))
      httpRequest.headersList.append("accept-encoding", "identity");
    if (!httpRequest.headersList.contains("accept-encoding"))
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest)))
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
      else
        httpRequest.headersList.append("accept-encoding", "gzip, deflate");
    if (httpRequest.headersList.delete("host"), httpCache == null)
      httpRequest.cache = "no-store";
    if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload")
      ;
    if (response == null) {
      if (httpRequest.mode === "only-if-cached")
        return makeNetworkError("only if cached");
      let forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399)
        ;
      if (revalidatingFlag && forwardResponse.status === 304)
        ;
      if (response == null)
        response = forwardResponse;
    }
    if (response.urlList = [...httpRequest.urlList], httpRequest.headersList.contains("range"))
      response.rangeRequested = !0;
    if (response.requestIncludesCredentials = includeCredentials, response.status === 407) {
      if (request.window === "no-window")
        return makeNetworkError();
      if (isCancelled(fetchParams))
        return makeAppropriateNetworkError(fetchParams);
      return makeNetworkError("proxy authentication required");
    }
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams))
        return makeAppropriateNetworkError(fetchParams);
      fetchParams.controller.connection.destroy(), response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, !0);
    }
    return response;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = !1, forceNewConnection = !1) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed), fetchParams.controller.connection = {
      abort: null,
      destroyed: !1,
      destroy(err) {
        if (!this.destroyed)
          this.destroyed = !0, this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
      }
    };
    let request = fetchParams.request, response = null, timingInfo = fetchParams.timingInfo;
    if (!0)
      request.cache = "no-store";
    let newConnection = forceNewConnection ? "yes" : "no";
    if (request.mode === "websocket")
      ;
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody)
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    else if (request.body != null) {
      let processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams))
          return;
        yield bytes, fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      }, processEndOfBody = () => {
        if (isCancelled(fetchParams))
          return;
        if (fetchParams.processRequestEndOfBody)
          fetchParams.processRequestEndOfBody();
      }, processBodyError = (e) => {
        if (isCancelled(fetchParams))
          return;
        if (e.name === "AbortError")
          fetchParams.controller.abort();
        else
          fetchParams.controller.terminate(e);
      };
      requestBody = async function* () {
        try {
          for await (let bytes of request.body.stream)
            yield* processBodyChunk(bytes);
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      let { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket)
        response = makeResponse({ status, statusText, headersList, socket });
      else {
        let iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next(), response = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError")
        return fetchParams.controller.connection.destroy(), makeAppropriateNetworkError(fetchParams, err);
      return makeNetworkError(err);
    }
    let pullAlgorithm = () => {
      fetchParams.controller.resume();
    }, cancelAlgorithm = (reason) => {
      fetchParams.controller.abort(reason);
    };
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    let stream = new ReadableStream2({
      async start(controller) {
        fetchParams.controller.controller = controller;
      },
      async pull(controller) {
        await pullAlgorithm(controller);
      },
      async cancel(reason) {
        await cancelAlgorithm(reason);
      }
    }, {
      highWaterMark: 0,
      size() {
        return 1;
      }
    });
    response.body = { stream }, fetchParams.controller.on("terminated", onAborted), fetchParams.controller.resume = async () => {
      while (!0) {
        let bytes, isFailure;
        try {
          let { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams))
            break;
          bytes = done ? void 0 : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize)
            bytes = void 0;
          else
            bytes = err, isFailure = !0;
        }
        if (bytes === void 0) {
          readableStreamClose(fetchParams.controller.controller), finalizeResponse(fetchParams, response);
          return;
        }
        if (timingInfo.decodedBodySize += bytes?.byteLength ?? 0, isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        if (fetchParams.controller.controller.enqueue(new Uint8Array(bytes)), isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (!fetchParams.controller.controller.desiredSize)
          return;
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        if (response.aborted = !0, isReadable(stream))
          fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
      } else if (isReadable(stream))
        fetchParams.controller.controller.error(TypeError("terminated", {
          cause: isErrorLike(reason) ? reason : void 0
        }));
      fetchParams.controller.connection.destroy();
    }
    return response;
    async function dispatch({ body }) {
      let url = requestCurrentURL(request), agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : void 0
      }, {
        body: null,
        abort: null,
        onConnect(abort) {
          let { connection } = fetchParams.controller;
          if (connection.destroyed)
            abort(new DOMException2("The operation was aborted.", "AbortError"));
          else
            fetchParams.controller.on("terminated", abort), this.abort = connection.abort = abort;
        },
        onHeaders(status, headersList, resume, statusText) {
          if (status < 200)
            return;
          let codings = [], location = "", headers = new Headers;
          if (Array.isArray(headersList))
            for (let n = 0;n < headersList.length; n += 2) {
              let key = headersList[n + 0].toString("latin1"), val = headersList[n + 1].toString("latin1");
              if (key.toLowerCase() === "content-encoding")
                codings = val.toLowerCase().split(",").map((x) => x.trim());
              else if (key.toLowerCase() === "location")
                location = val;
              headers[kHeadersList].append(key, val);
            }
          else {
            let keys = Object.keys(headersList);
            for (let key of keys) {
              let val = headersList[key];
              if (key.toLowerCase() === "content-encoding")
                codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
              else if (key.toLowerCase() === "location")
                location = val;
              headers[kHeadersList].append(key, val);
            }
          }
          this.body = new Readable({ read: resume });
          let decoders = [], willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
          if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow)
            for (let coding of codings)
              if (coding === "x-gzip" || coding === "gzip")
                decoders.push(zlib.createGunzip({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              else if (coding === "deflate")
                decoders.push(zlib.createInflate());
              else if (coding === "br")
                decoders.push(zlib.createBrotliDecompress());
              else {
                decoders.length = 0;
                break;
              }
          return resolve({
            status,
            statusText,
            headersList: headers[kHeadersList],
            body: decoders.length ? pipeline(this.body, ...decoders, () => {}) : this.body.on("error", () => {})
          }), !0;
        },
        onData(chunk) {
          if (fetchParams.controller.dump)
            return;
          let bytes = chunk;
          return timingInfo.encodedBodySize += bytes.byteLength, this.body.push(bytes);
        },
        onComplete() {
          if (this.abort)
            fetchParams.controller.off("terminated", this.abort);
          fetchParams.controller.ended = !0, this.body.push(null);
        },
        onError(error) {
          if (this.abort)
            fetchParams.controller.off("terminated", this.abort);
          this.body?.destroy(error), fetchParams.controller.terminate(error), reject(error);
        },
        onUpgrade(status, headersList, socket) {
          if (status !== 101)
            return;
          let headers = new Headers;
          for (let n = 0;n < headersList.length; n += 2) {
            let key = headersList[n + 0].toString("latin1"), val = headersList[n + 1].toString("latin1");
            headers[kHeadersList].append(key, val);
          }
          return resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList: headers[kHeadersList],
            socket
          }), !0;
        }
      }));
    }
  }
  module.exports = {
    fetch,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS((exports, module) => {
  module.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS((exports, module) => {
  var { webidl } = require_webidl(), kState = Symbol("ProgressEvent state");

  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      return webidl.brandCheck(this, ProgressEvent), this[kState].lengthComputable;
    }
    get loaded() {
      return webidl.brandCheck(this, ProgressEvent), this[kState].loaded;
    }
    get total() {
      return webidl.brandCheck(this, ProgressEvent), this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: !1
    }
  ]);
  module.exports = {
    ProgressEvent
  };
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS((exports, module) => {
  function getEncoding(label) {
    if (!label)
      return "failure";
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  module.exports = {
    getEncoding
  };
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS((exports, module) => {
  var {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = require_symbols3(), { ProgressEvent } = require_progressevent(), { getEncoding } = require_encoding(), { DOMException: DOMException2 } = require_constants2(), { serializeAMimeType, parseMIMEType } = require_dataURL(), { types } = __require("util"), { StringDecoder } = __require("string_decoder"), { btoa: btoa2 } = __require("buffer"), staticPropertyDescriptors = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  };
  function readOperation(fr, blob, type, encodingName) {
    if (fr[kState] === "loading")
      throw new DOMException2("Invalid state", "InvalidStateError");
    fr[kState] = "loading", fr[kResult] = null, fr[kError] = null;
    let reader = blob.stream().getReader(), bytes = [], chunkPromise = reader.read(), isFirstChunk = !0;
    (async () => {
      while (!fr[kAborted])
        try {
          let { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted])
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          if (isFirstChunk = !1, !done && types.isUint8Array(value)) {
            if (bytes.push(value), (fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted])
              fr[kLastProgressEventFired] = Date.now(), queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                let result = packageData(bytes, type, blob.type, encodingName);
                if (fr[kAborted])
                  return;
                fr[kResult] = result, fireAProgressEvent("load", fr);
              } catch (error) {
                fr[kError] = error, fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading")
                fireAProgressEvent("loadend", fr);
            });
            break;
          }
        } catch (error) {
          if (fr[kAborted])
            return;
          queueMicrotask(() => {
            if (fr[kState] = "done", fr[kError] = error, fireAProgressEvent("error", fr), fr[kState] !== "loading")
              fireAProgressEvent("loadend", fr);
          });
          break;
        }
    })();
  }
  function fireAProgressEvent(e, reader) {
    let event = new ProgressEvent(e, {
      bubbles: !1,
      cancelable: !1
    });
    reader.dispatchEvent(event);
  }
  function packageData(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL = "data:", parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure")
          dataURL += serializeAMimeType(parsed);
        dataURL += ";base64,";
        let decoder = new StringDecoder("latin1");
        for (let chunk of bytes)
          dataURL += btoa2(decoder.write(chunk));
        return dataURL += btoa2(decoder.end()), dataURL;
      }
      case "Text": {
        let encoding = "failure";
        if (encodingName)
          encoding = getEncoding(encodingName);
        if (encoding === "failure" && mimeType) {
          let type2 = parseMIMEType(mimeType);
          if (type2 !== "failure")
            encoding = getEncoding(type2.parameters.get("charset"));
        }
        if (encoding === "failure")
          encoding = "UTF-8";
        return decode(bytes, encoding);
      }
      case "ArrayBuffer":
        return combineByteSequences(bytes).buffer;
      case "BinaryString": {
        let binaryString = "", decoder = new StringDecoder("latin1");
        for (let chunk of bytes)
          binaryString += decoder.write(chunk);
        return binaryString += decoder.end(), binaryString;
      }
    }
  }
  function decode(ioQueue, encoding) {
    let bytes = combineByteSequences(ioQueue), BOMEncoding = BOMSniffing(bytes), slice = 0;
    if (BOMEncoding !== null)
      encoding = BOMEncoding, slice = BOMEncoding === "UTF-8" ? 3 : 2;
    let sliced = bytes.slice(slice);
    return new TextDecoder(encoding).decode(sliced);
  }
  function BOMSniffing(ioQueue) {
    let [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191)
      return "UTF-8";
    else if (a === 254 && b === 255)
      return "UTF-16BE";
    else if (a === 255 && b === 254)
      return "UTF-16LE";
    return null;
  }
  function combineByteSequences(sequences) {
    let size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0), offset = 0;
    return sequences.reduce((a, b) => {
      return a.set(b, offset), offset += b.byteLength, a;
    }, new Uint8Array(size));
  }
  module.exports = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS((exports, module) => {
  var {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = require_util4(), {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = require_symbols3(), { webidl } = require_webidl(), { kEnumerableProperty } = require_util();

  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty", this[kResult] = null, this[kError] = null, this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" }), blob = webidl.converters.Blob(blob, { strict: !1 }), readOperation(this, blob, "ArrayBuffer");
    }
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" }), blob = webidl.converters.Blob(blob, { strict: !1 }), readOperation(this, blob, "BinaryString");
    }
    readAsText(blob, encoding = void 0) {
      if (webidl.brandCheck(this, FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" }), blob = webidl.converters.Blob(blob, { strict: !1 }), encoding !== void 0)
        encoding = webidl.converters.DOMString(encoding);
      readOperation(this, blob, "Text", encoding);
    }
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" }), blob = webidl.converters.Blob(blob, { strict: !1 }), readOperation(this, blob, "DataURL");
    }
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading")
        this[kState] = "done", this[kResult] = null;
      if (this[kAborted] = !0, fireAProgressEvent("abort", this), this[kState] !== "loading")
        fireAProgressEvent("loadend", this);
    }
    get readyState() {
      switch (webidl.brandCheck(this, FileReader), this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    get result() {
      return webidl.brandCheck(this, FileReader), this[kResult];
    }
    get error() {
      return webidl.brandCheck(this, FileReader), this[kError];
    }
    get onloadend() {
      return webidl.brandCheck(this, FileReader), this[kEvents].loadend;
    }
    set onloadend(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].loadend)
        this.removeEventListener("loadend", this[kEvents].loadend);
      if (typeof fn === "function")
        this[kEvents].loadend = fn, this.addEventListener("loadend", fn);
      else
        this[kEvents].loadend = null;
    }
    get onerror() {
      return webidl.brandCheck(this, FileReader), this[kEvents].error;
    }
    set onerror(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].error)
        this.removeEventListener("error", this[kEvents].error);
      if (typeof fn === "function")
        this[kEvents].error = fn, this.addEventListener("error", fn);
      else
        this[kEvents].error = null;
    }
    get onloadstart() {
      return webidl.brandCheck(this, FileReader), this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].loadstart)
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      if (typeof fn === "function")
        this[kEvents].loadstart = fn, this.addEventListener("loadstart", fn);
      else
        this[kEvents].loadstart = null;
    }
    get onprogress() {
      return webidl.brandCheck(this, FileReader), this[kEvents].progress;
    }
    set onprogress(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].progress)
        this.removeEventListener("progress", this[kEvents].progress);
      if (typeof fn === "function")
        this[kEvents].progress = fn, this.addEventListener("progress", fn);
      else
        this[kEvents].progress = null;
    }
    get onload() {
      return webidl.brandCheck(this, FileReader), this[kEvents].load;
    }
    set onload(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].load)
        this.removeEventListener("load", this[kEvents].load);
      if (typeof fn === "function")
        this[kEvents].load = fn, this.addEventListener("load", fn);
      else
        this[kEvents].load = null;
    }
    get onabort() {
      return webidl.brandCheck(this, FileReader), this[kEvents].abort;
    }
    set onabort(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].abort)
        this.removeEventListener("abort", this[kEvents].abort);
      if (typeof fn === "function")
        this[kEvents].abort = fn, this.addEventListener("abort", fn);
      else
        this[kEvents].abort = null;
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  module.exports = {
    FileReader
  };
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS((exports, module) => {
  module.exports = {
    kConstruct: require_symbols().kConstruct
  };
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS((exports, module) => {
  var assert = __require("assert"), { URLSerializer } = require_dataURL(), { isValidHeaderName } = require_util2();
  function urlEquals(A, B, excludeFragment = !1) {
    let serializedA = URLSerializer(A, excludeFragment), serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function fieldValues(header) {
    assert(header !== null);
    let values = [];
    for (let value of header.split(",")) {
      if (value = value.trim(), !value.length)
        continue;
      else if (!isValidHeaderName(value))
        continue;
      values.push(value);
    }
    return values;
  }
  module.exports = {
    urlEquals,
    fieldValues
  };
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4(), { urlEquals, fieldValues: getFieldValues } = require_util5(), { kEnumerableProperty, isDisturbed } = require_util(), { kHeadersList } = require_symbols(), { webidl } = require_webidl(), { Response, cloneResponse } = require_response(), { Request } = require_request2(), { kState, kHeaders, kGuard, kRealm } = require_symbols2(), { fetching } = require_fetch(), { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2(), assert = __require("assert"), { getGlobalDispatcher } = require_global2();

  class Cache {
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct)
        webidl.illegalConstructor();
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" }), request = webidl.converters.RequestInfo(request), options = webidl.converters.CacheQueryOptions(options);
      let p = await this.matchAll(request, options);
      if (p.length === 0)
        return;
      return p[0];
    }
    async matchAll(request = void 0, options = {}) {
      if (webidl.brandCheck(this, Cache), request !== void 0)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== void 0) {
        if (request instanceof Request) {
          if (r = request[kState], r.method !== "GET" && !options.ignoreMethod)
            return [];
        } else if (typeof request === "string")
          r = new Request(request)[kState];
      }
      let responses = [];
      if (request === void 0)
        for (let requestResponse of this.#relevantRequestResponseList)
          responses.push(requestResponse[1]);
      else {
        let requestResponses = this.#queryCache(r, options);
        for (let requestResponse of requestResponses)
          responses.push(requestResponse[1]);
      }
      let responseList = [];
      for (let response of responses) {
        let responseObject = new Response(response.body?.source ?? null), body = responseObject[kState].body;
        responseObject[kState] = response, responseObject[kState].body = body, responseObject[kHeaders][kHeadersList] = response.headersList, responseObject[kHeaders][kGuard] = "immutable", responseList.push(responseObject);
      }
      return Object.freeze(responseList);
    }
    async add(request) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" }), request = webidl.converters.RequestInfo(request);
      let requests = [request];
      return await this.addAll(requests);
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" }), requests = webidl.converters["sequence<RequestInfo>"](requests);
      let responsePromises = [], requestList = [];
      for (let request of requests) {
        if (typeof request === "string")
          continue;
        let r = request[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET")
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET."
          });
      }
      let fetchControllers = [];
      for (let request of requests) {
        let r = new Request(request)[kState];
        if (!urlIsHttpHttpsScheme(r.url))
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme."
          });
        r.initiator = "fetch", r.destination = "subresource", requestList.push(r);
        let responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          dispatcher: getGlobalDispatcher(),
          processResponse(response) {
            if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299)
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            else if (response.headersList.contains("vary")) {
              let fieldValues = getFieldValues(response.headersList.get("vary"));
              for (let fieldValue of fieldValues)
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (let controller of fetchControllers)
                    controller.abort();
                  return;
                }
            }
          },
          processResponseEndOfBody(response) {
            if (response.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response);
          }
        })), responsePromises.push(responsePromise.promise);
      }
      let responses = await Promise.all(responsePromises), operations = [], index = 0;
      for (let response of responses) {
        let operation = {
          type: "put",
          request: requestList[index],
          response
        };
        operations.push(operation), index++;
      }
      let cacheJobPromise = createDeferredPromise(), errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      return queueMicrotask(() => {
        if (errorData === null)
          cacheJobPromise.resolve(void 0);
        else
          cacheJobPromise.reject(errorData);
      }), cacheJobPromise.promise;
    }
    async put(request, response) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" }), request = webidl.converters.RequestInfo(request), response = webidl.converters.Response(response);
      let innerRequest = null;
      if (request instanceof Request)
        innerRequest = request[kState];
      else
        innerRequest = new Request(request)[kState];
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET")
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET"
        });
      let innerResponse = response[kState];
      if (innerResponse.status === 206)
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Got 206 status"
        });
      if (innerResponse.headersList.contains("vary")) {
        let fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (let fieldValue of fieldValues)
          if (fieldValue === "*")
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value"
            });
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked))
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed"
        });
      let clonedResponse = cloneResponse(innerResponse), bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        let reader = innerResponse.body.stream.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else
        bodyReadPromise.resolve(void 0);
      let operations = [], operation = {
        type: "put",
        request: innerRequest,
        response: clonedResponse
      };
      operations.push(operation);
      let bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null)
        clonedResponse.body.source = bytes;
      let cacheJobPromise = createDeferredPromise(), errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      return queueMicrotask(() => {
        if (errorData === null)
          cacheJobPromise.resolve();
        else
          cacheJobPromise.reject(errorData);
      }), cacheJobPromise.promise;
    }
    async delete(request, options = {}) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" }), request = webidl.converters.RequestInfo(request), options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request instanceof Request) {
        if (r = request[kState], r.method !== "GET" && !options.ignoreMethod)
          return !1;
      } else
        assert(typeof request === "string"), r = new Request(request)[kState];
      let operations = [], operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      let cacheJobPromise = createDeferredPromise(), errorData = null, requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      return queueMicrotask(() => {
        if (errorData === null)
          cacheJobPromise.resolve(!!requestResponses?.length);
        else
          cacheJobPromise.reject(errorData);
      }), cacheJobPromise.promise;
    }
    async keys(request = void 0, options = {}) {
      if (webidl.brandCheck(this, Cache), request !== void 0)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== void 0) {
        if (request instanceof Request) {
          if (r = request[kState], r.method !== "GET" && !options.ignoreMethod)
            return [];
        } else if (typeof request === "string")
          r = new Request(request)[kState];
      }
      let promise = createDeferredPromise(), requests = [];
      if (request === void 0)
        for (let requestResponse of this.#relevantRequestResponseList)
          requests.push(requestResponse[0]);
      else {
        let requestResponses = this.#queryCache(r, options);
        for (let requestResponse of requestResponses)
          requests.push(requestResponse[0]);
      }
      return queueMicrotask(() => {
        let requestList = [];
        for (let request2 of requests) {
          let requestObject = new Request("https://a");
          requestObject[kState] = request2, requestObject[kHeaders][kHeadersList] = request2.headersList, requestObject[kHeaders][kGuard] = "immutable", requestObject[kRealm] = request2.client, requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      }), promise.promise;
    }
    #batchCacheOperations(operations) {
      let cache = this.#relevantRequestResponseList, backupCache = [...cache], addedItems = [], resultList = [];
      try {
        for (let operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put")
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          if (operation.type === "delete" && operation.response != null)
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          if (this.#queryCache(operation.request, operation.options, addedItems).length)
            throw new DOMException("???", "InvalidStateError");
          let requestResponses;
          if (operation.type === "delete") {
            if (requestResponses = this.#queryCache(operation.request, operation.options), requestResponses.length === 0)
              return [];
            for (let requestResponse of requestResponses) {
              let idx = cache.indexOf(requestResponse);
              assert(idx !== -1), cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null)
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            let r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url))
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            if (r.method !== "GET")
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            if (operation.options != null)
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            requestResponses = this.#queryCache(operation.request);
            for (let requestResponse of requestResponses) {
              let idx = cache.indexOf(requestResponse);
              assert(idx !== -1), cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]), addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        throw this.#relevantRequestResponseList.length = 0, this.#relevantRequestResponseList = backupCache, e;
      }
    }
    #queryCache(requestQuery, options, targetStorage) {
      let resultList = [], storage = targetStorage ?? this.#relevantRequestResponseList;
      for (let requestResponse of storage) {
        let [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options))
          resultList.push(requestResponse);
      }
      return resultList;
    }
    #requestMatchesCachedItem(requestQuery, request, response = null, options) {
      let queryURL = new URL(requestQuery.url), cachedURL = new URL(request.url);
      if (options?.ignoreSearch)
        cachedURL.search = "", queryURL.search = "";
      if (!urlEquals(queryURL, cachedURL, !0))
        return !1;
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary"))
        return !0;
      let fieldValues = getFieldValues(response.headersList.get("vary"));
      for (let fieldValue of fieldValues) {
        if (fieldValue === "*")
          return !1;
        let requestValue = request.headersList.get(fieldValue), queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue)
          return !1;
      }
      return !0;
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: !0
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: !1
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache
  };
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4(), { Cache } = require_cache(), { webidl } = require_webidl(), { kEnumerableProperty } = require_util();

  class CacheStorage {
    #caches = /* @__PURE__ */ new Map;
    constructor() {
      if (arguments[0] !== kConstruct)
        webidl.illegalConstructor();
    }
    async match(request, options = {}) {
      if (webidl.brandCheck(this, CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" }), request = webidl.converters.RequestInfo(request), options = webidl.converters.MultiCacheQueryOptions(options), options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          let cacheList = this.#caches.get(options.cacheName);
          return await new Cache(kConstruct, cacheList).match(request, options);
        }
      } else
        for (let cacheList of this.#caches.values()) {
          let response = await new Cache(kConstruct, cacheList).match(request, options);
          if (response !== void 0)
            return response;
        }
    }
    async has(cacheName) {
      return webidl.brandCheck(this, CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" }), cacheName = webidl.converters.DOMString(cacheName), this.#caches.has(cacheName);
    }
    async open(cacheName) {
      if (webidl.brandCheck(this, CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" }), cacheName = webidl.converters.DOMString(cacheName), this.#caches.has(cacheName)) {
        let cache2 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache2);
      }
      let cache = [];
      return this.#caches.set(cacheName, cache), new Cache(kConstruct, cache);
    }
    async delete(cacheName) {
      return webidl.brandCheck(this, CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" }), cacheName = webidl.converters.DOMString(cacheName), this.#caches.delete(cacheName);
    }
    async keys() {
      return webidl.brandCheck(this, CacheStorage), [...this.#caches.keys()];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: !0
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage
  };
});

// node_modules/undici/lib/cookies/constants.js
var require_constants4 = __commonJS((exports, module) => {
  module.exports = {
    maxAttributeValueSize: 1024,
    maxNameValuePairSize: 4096
  };
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS((exports, module) => {
  function isCTLExcludingHtab(value) {
    if (value.length === 0)
      return !1;
    for (let char of value) {
      let code = char.charCodeAt(0);
      if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127)
        return !1;
    }
  }
  function validateCookieName(name) {
    for (let char of name) {
      let code = char.charCodeAt(0);
      if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}")
        throw Error("Invalid cookie name");
    }
  }
  function validateCookieValue(value) {
    for (let char of value) {
      let code = char.charCodeAt(0);
      if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126)
        throw Error("Invalid header value");
    }
  }
  function validateCookiePath(path) {
    for (let char of path)
      if (char.charCodeAt(0) < 33 || char === ";")
        throw Error("Invalid cookie path");
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-"))
      throw Error("Invalid cookie domain");
  }
  function toIMFDate(date) {
    if (typeof date === "number")
      date = new Date(date);
    let days = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ], months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ], dayName = days[date.getUTCDay()], day = date.getUTCDate().toString().padStart(2, "0"), month = months[date.getUTCMonth()], year = date.getUTCFullYear(), hour = date.getUTCHours().toString().padStart(2, "0"), minute = date.getUTCMinutes().toString().padStart(2, "0"), second = date.getUTCSeconds().toString().padStart(2, "0");
    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0)
      throw Error("Invalid cookie max-age");
  }
  function stringify(cookie) {
    if (cookie.name.length === 0)
      return null;
    validateCookieName(cookie.name), validateCookieValue(cookie.value);
    let out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-"))
      cookie.secure = !0;
    if (cookie.name.startsWith("__Host-"))
      cookie.secure = !0, cookie.domain = null, cookie.path = "/";
    if (cookie.secure)
      out.push("Secure");
    if (cookie.httpOnly)
      out.push("HttpOnly");
    if (typeof cookie.maxAge === "number")
      validateCookieMaxAge(cookie.maxAge), out.push(`Max-Age=${cookie.maxAge}`);
    if (cookie.domain)
      validateCookieDomain(cookie.domain), out.push(`Domain=${cookie.domain}`);
    if (cookie.path)
      validateCookiePath(cookie.path), out.push(`Path=${cookie.path}`);
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date")
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    if (cookie.sameSite)
      out.push(`SameSite=${cookie.sameSite}`);
    for (let part of cookie.unparsed) {
      if (!part.includes("="))
        throw Error("Invalid unparsed");
      let [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  module.exports = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify
  };
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS((exports, module) => {
  var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4(), { isCTLExcludingHtab } = require_util6(), { collectASequenceOfCodePointsFast } = require_dataURL(), assert = __require("assert");
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header))
      return null;
    let nameValuePair = "", unparsedAttributes = "", name = "", value = "";
    if (header.includes(";")) {
      let position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position), unparsedAttributes = header.slice(position.position);
    } else
      nameValuePair = header;
    if (!nameValuePair.includes("="))
      value = nameValuePair;
    else {
      let position = { position: 0 };
      name = collectASequenceOfCodePointsFast("=", nameValuePair, position), value = nameValuePair.slice(position.position + 1);
    }
    if (name = name.trim(), value = value.trim(), name.length + value.length > maxNameValuePairSize)
      return null;
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0)
      return cookieAttributeList;
    assert(unparsedAttributes[0] === ";"), unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";"))
      cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 }), unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    else
      cookieAv = unparsedAttributes, unparsedAttributes = "";
    let attributeName = "", attributeValue = "";
    if (cookieAv.includes("=")) {
      let position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position), attributeValue = cookieAv.slice(position.position + 1);
    } else
      attributeName = cookieAv;
    if (attributeName = attributeName.trim(), attributeValue = attributeValue.trim(), attributeValue.length > maxAttributeValueSize)
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    let attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      let expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      let charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-")
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      if (!/^\d+$/.test(attributeValue))
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      let deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".")
        cookieDomain = cookieDomain.slice(1);
      cookieDomain = cookieDomain.toLowerCase(), cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/")
        cookiePath = "/";
      else
        cookiePath = attributeValue;
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure")
      cookieAttributeList.secure = !0;
    else if (attributeNameLowercase === "httponly")
      cookieAttributeList.httpOnly = !0;
    else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default", attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none"))
        enforcement = "None";
      if (attributeValueLowercase.includes("strict"))
        enforcement = "Strict";
      if (attributeValueLowercase.includes("lax"))
        enforcement = "Lax";
      cookieAttributeList.sameSite = enforcement;
    } else
      cookieAttributeList.unparsed ??= [], cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  module.exports = {
    parseSetCookie,
    parseUnparsedAttributes
  };
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS((exports, module) => {
  var { parseSetCookie } = require_parse(), { stringify } = require_util6(), { webidl } = require_webidl(), { Headers } = require_headers();
  function getCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" }), webidl.brandCheck(headers, Headers, { strict: !1 });
    let cookie = headers.get("cookie"), out = {};
    if (!cookie)
      return out;
    for (let piece of cookie.split(";")) {
      let [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers, name, attributes) {
    webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" }), webidl.brandCheck(headers, Headers, { strict: !1 }), name = webidl.converters.DOMString(name), attributes = webidl.converters.DeleteCookieAttributes(attributes), setCookie(headers, {
      name,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" }), webidl.brandCheck(headers, Headers, { strict: !1 });
    let cookies = headers.getSetCookie();
    if (!cookies)
      return [];
    return cookies.map((pair) => parseSetCookie(pair));
  }
  function setCookie(headers, cookie) {
    if (webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" }), webidl.brandCheck(headers, Headers, { strict: !1 }), cookie = webidl.converters.Cookie(cookie), stringify(cookie))
      headers.append("Set-Cookie", stringify(cookie));
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number")
          return webidl.converters["unsigned long long"](value);
        return new Date(value);
      }),
      key: "expires",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: []
    }
  ]);
  module.exports = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
});

// node_modules/undici/lib/websocket/constants.js
var require_constants5 = __commonJS((exports, module) => {
  var staticPropertyDescriptors = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  }, states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  }, opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  }, parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  }, emptyBuffer = Buffer.allocUnsafe(0);
  module.exports = {
    uid: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit: 65535,
    parserStates,
    emptyBuffer
  };
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS((exports, module) => {
  module.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS((exports, module) => {
  var { webidl } = require_webidl(), { kEnumerableProperty } = require_util(), { MessagePort } = __require("worker_threads");

  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" }), type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get data() {
      return webidl.brandCheck(this, MessageEvent), this.#eventInit.data;
    }
    get origin() {
      return webidl.brandCheck(this, MessageEvent), this.#eventInit.origin;
    }
    get lastEventId() {
      return webidl.brandCheck(this, MessageEvent), this.#eventInit.lastEventId;
    }
    get source() {
      return webidl.brandCheck(this, MessageEvent), this.#eventInit.source;
    }
    get ports() {
      if (webidl.brandCheck(this, MessageEvent), !Object.isFrozen(this.#eventInit.ports))
        Object.freeze(this.#eventInit.ports);
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = !1, cancelable = !1, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      return webidl.brandCheck(this, MessageEvent), webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" }), new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
  }

  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" }), type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get wasClean() {
      return webidl.brandCheck(this, CloseEvent), this.#eventInit.wasClean;
    }
    get code() {
      return webidl.brandCheck(this, CloseEvent), this.#eventInit.code;
    }
    get reason() {
      return webidl.brandCheck(this, CloseEvent), this.#eventInit.reason;
    }
  }

  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
      super(type, eventInitDict);
      type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {}), this.#eventInit = eventInitDict;
    }
    get message() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.message;
    }
    get filename() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.filename;
    }
    get lineno() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.lineno;
    }
    get colno() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.colno;
    }
    get error() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: !0
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: !0
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: !0
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
  var eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: !1
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "source",
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      }
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    MessageEvent,
    CloseEvent,
    ErrorEvent
  };
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS((exports, module) => {
  var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5(), { states, opcodes } = require_constants5(), { MessageEvent, ErrorEvent } = require_events();
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
    let event = new eventConstructor(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN)
      return;
    let dataForEvent;
    if (type === opcodes.TEXT)
      try {
        dataForEvent = new TextDecoder("utf-8", { fatal: !0 }).decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    else if (type === opcodes.BINARY)
      if (ws[kBinaryType] === "blob")
        dataForEvent = new Blob([data]);
      else
        dataForEvent = new Uint8Array(data).buffer;
    fireEvent("message", ws, MessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0)
      return !1;
    for (let char of protocol) {
      let code = char.charCodeAt(0);
      if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || code === 9)
        return !1;
    }
    return !0;
  }
  function isValidStatusCode(code) {
    if (code >= 1000 && code < 1015)
      return code !== 1004 && code !== 1005 && code !== 1006;
    return code >= 3000 && code <= 4999;
  }
  function failWebsocketConnection(ws, reason) {
    let { [kController]: controller, [kResponse]: response } = ws;
    if (controller.abort(), response?.socket && !response.socket.destroyed)
      response.socket.destroy();
    if (reason)
      fireEvent("error", ws, ErrorEvent, {
        error: Error(reason)
      });
  }
  module.exports = {
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived
  };
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS((exports, module) => {
  var diagnosticsChannel = __require("diagnostics_channel"), { uid, states } = require_constants5(), {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose
  } = require_symbols5(), { fireEvent, failWebsocketConnection } = require_util7(), { CloseEvent } = require_events(), { makeRequest } = require_request2(), { fetching } = require_fetch(), { Headers } = require_headers(), { getGlobalDispatcher } = require_global2(), { kHeadersList } = require_symbols(), channels = {};
  channels.open = diagnosticsChannel.channel("undici:websocket:open");
  channels.close = diagnosticsChannel.channel("undici:websocket:close");
  channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
  var crypto2;
  try {
    crypto2 = __require("crypto");
  } catch {}
  function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
    let requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    let request = makeRequest({
      urlList: [requestURL],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      let headersList = new Headers(options.headers)[kHeadersList];
      request.headersList = headersList;
    }
    let keyValue = crypto2.randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue), request.headersList.append("sec-websocket-version", "13");
    for (let protocol of protocols)
      request.headersList.append("sec-websocket-protocol", protocol);
    let permessageDeflate = "";
    return fetching({
      request,
      useParallelQueue: !0,
      dispatcher: options.dispatcher ?? getGlobalDispatcher(),
      processResponse(response) {
        if (response.type === "error" || response.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        let secWSAccept = response.headersList.get("Sec-WebSocket-Accept"), digest = crypto2.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        let secExtension = response.headersList.get("Sec-WebSocket-Extensions");
        if (secExtension !== null && secExtension !== permessageDeflate) {
          failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
          return;
        }
        let secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
          return;
        }
        if (response.socket.on("data", onSocketData), response.socket.on("close", onSocketClose), response.socket.on("error", onSocketError), channels.open.hasSubscribers)
          channels.open.publish({
            address: response.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        onEstablish(response);
      }
    });
  }
  function onSocketData(chunk) {
    if (!this.ws[kByteParser].write(chunk))
      this.pause();
  }
  function onSocketClose() {
    let { ws } = this, wasClean = ws[kSentClose] && ws[kReceivedClose], code = 1005, reason = "", result = ws[kByteParser].closingInfo;
    if (result)
      code = result.code ?? 1005, reason = result.reason;
    else if (!ws[kSentClose])
      code = 1006;
    if (ws[kReadyState] = states.CLOSED, fireEvent("close", ws, CloseEvent, {
      wasClean,
      code,
      reason
    }), channels.close.hasSubscribers)
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
  }
  function onSocketError(error) {
    let { ws } = this;
    if (ws[kReadyState] = states.CLOSING, channels.socketError.hasSubscribers)
      channels.socketError.publish(error);
    this.destroy();
  }
  module.exports = {
    establishWebSocketConnection
  };
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS((exports, module) => {
  var { maxUnsigned16Bit } = require_constants5(), crypto2;
  try {
    crypto2 = __require("crypto");
  } catch {}

  class WebsocketFrameSend {
    constructor(data) {
      this.frameData = data, this.maskKey = crypto2.randomBytes(4);
    }
    createFrame(opcode) {
      let bodyLength = this.frameData?.byteLength ?? 0, payloadLength = bodyLength, offset = 6;
      if (bodyLength > maxUnsigned16Bit)
        offset += 8, payloadLength = 127;
      else if (bodyLength > 125)
        offset += 2, payloadLength = 126;
      let buffer = Buffer.allocUnsafe(bodyLength + offset);
      buffer[0] = buffer[1] = 0, buffer[0] |= 128, buffer[0] = (buffer[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      if (buffer[offset - 4] = this.maskKey[0], buffer[offset - 3] = this.maskKey[1], buffer[offset - 2] = this.maskKey[2], buffer[offset - 1] = this.maskKey[3], buffer[1] = payloadLength, payloadLength === 126)
        buffer.writeUInt16BE(bodyLength, 2);
      else if (payloadLength === 127)
        buffer[2] = buffer[3] = 0, buffer.writeUIntBE(bodyLength, 4, 6);
      buffer[1] |= 128;
      for (let i = 0;i < bodyLength; i++)
        buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
      return buffer;
    }
  }
  module.exports = {
    WebsocketFrameSend
  };
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream"), diagnosticsChannel = __require("diagnostics_channel"), { parserStates, opcodes, states, emptyBuffer } = require_constants5(), { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5(), { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7(), { WebsocketFrameSend } = require_frame(), channels = {};
  channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
  channels.pong = diagnosticsChannel.channel("undici:websocket:pong");

  class ByteParser extends Writable {
    #buffers = [];
    #byteOffset = 0;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    constructor(ws) {
      super();
      this.ws = ws;
    }
    _write(chunk, _2, callback) {
      this.#buffers.push(chunk), this.#byteOffset += chunk.length, this.run(callback);
    }
    run(callback) {
      while (!0) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2)
            return callback();
          let buffer = this.consume(2);
          if (this.#info.fin = (buffer[0] & 128) !== 0, this.#info.opcode = buffer[0] & 15, this.#info.originalOpcode ??= this.#info.opcode, this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION, this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          let payloadLength = buffer[1] & 127;
          if (payloadLength <= 125)
            this.#info.payloadLength = payloadLength, this.#state = parserStates.READ_DATA;
          else if (payloadLength === 126)
            this.#state = parserStates.PAYLOADLENGTH_16;
          else if (payloadLength === 127)
            this.#state = parserStates.PAYLOADLENGTH_64;
          if (this.#info.fragmented && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (this.#info.opcode === opcodes.CLOSE) {
            if (payloadLength === 1) {
              failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            let body = this.consume(payloadLength);
            if (this.#info.closeInfo = this.parseCloseBody(!1, body), !this.ws[kSentClose]) {
              let body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(this.#info.closeInfo.code, 0);
              let closeFrame = new WebsocketFrameSend(body2);
              this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
                if (!err)
                  this.ws[kSentClose] = !0;
              });
            }
            this.ws[kReadyState] = states.CLOSING, this.ws[kReceivedClose] = !0, this.end();
            return;
          } else if (this.#info.opcode === opcodes.PING) {
            let body = this.consume(payloadLength);
            if (!this.ws[kReceivedClose]) {
              let frame = new WebsocketFrameSend(body);
              if (this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG)), channels.ping.hasSubscribers)
                channels.ping.publish({
                  payload: body
                });
            }
            if (this.#state = parserStates.INFO, this.#byteOffset > 0)
              continue;
            else {
              callback();
              return;
            }
          } else if (this.#info.opcode === opcodes.PONG) {
            let body = this.consume(payloadLength);
            if (channels.pong.hasSubscribers)
              channels.pong.publish({
                payload: body
              });
            if (this.#byteOffset > 0)
              continue;
            else {
              callback();
              return;
            }
          }
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2)
            return callback();
          let buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0), this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8)
            return callback();
          let buffer = this.consume(8), upper = buffer.readUInt32BE(0);
          if (upper > 2147483647) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          let lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower, this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength)
            return callback();
          else if (this.#byteOffset >= this.#info.payloadLength) {
            let body = this.consume(this.#info.payloadLength);
            if (this.#fragments.push(body), !this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
              let fullMessage = Buffer.concat(this.#fragments);
              websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage), this.#info = {}, this.#fragments.length = 0;
            }
            this.#state = parserStates.INFO;
          }
        }
        if (this.#byteOffset > 0)
          continue;
        else {
          callback();
          break;
        }
      }
    }
    consume(n) {
      if (n > this.#byteOffset)
        return null;
      else if (n === 0)
        return emptyBuffer;
      if (this.#buffers[0].length === n)
        return this.#byteOffset -= this.#buffers[0].length, this.#buffers.shift();
      let buffer = Buffer.allocUnsafe(n), offset = 0;
      while (offset !== n) {
        let next = this.#buffers[0], { length } = next;
        if (length + offset === n) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset), this.#buffers[0] = next.subarray(n - offset);
          break;
        } else
          buffer.set(this.#buffers.shift(), offset), offset += next.length;
      }
      return this.#byteOffset -= n, buffer;
    }
    parseCloseBody(onlyCode, data) {
      let code;
      if (data.length >= 2)
        code = data.readUInt16BE(0);
      if (onlyCode) {
        if (!isValidStatusCode(code))
          return null;
        return { code };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191)
        reason = reason.subarray(3);
      if (code !== void 0 && !isValidStatusCode(code))
        return null;
      try {
        reason = new TextDecoder("utf-8", { fatal: !0 }).decode(reason);
      } catch {
        return null;
      }
      return { code, reason };
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  module.exports = {
    ByteParser
  };
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var { webidl } = require_webidl(), { DOMException: DOMException2 } = require_constants2(), { URLSerializer } = require_dataURL(), { getGlobalOrigin } = require_global(), { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5(), {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = require_symbols5(), { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7(), { establishWebSocketConnection } = require_connection(), { WebsocketFrameSend } = require_frame(), { ByteParser } = require_receiver(), { kEnumerableProperty, isBlobLike } = require_util(), { getGlobalDispatcher } = require_global2(), { types } = __require("util"), experimentalWarned = !1;

  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    constructor(url, protocols = []) {
      super();
      if (webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" }), !experimentalWarned)
        experimentalWarned = !0, process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
          code: "UNDICI-WS"
        });
      let options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
      url = webidl.converters.USVString(url), protocols = options.protocols;
      let baseURL = getGlobalOrigin(), urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException2(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:")
        urlRecord.protocol = "ws:";
      else if (urlRecord.protocol === "https:")
        urlRecord.protocol = "wss:";
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:")
        throw new DOMException2(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
      if (urlRecord.hash || urlRecord.href.endsWith("#"))
        throw new DOMException2("Got fragment", "SyntaxError");
      if (typeof protocols === "string")
        protocols = [protocols];
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size)
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p)))
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      this[kWebSocketURL] = new URL(urlRecord.href), this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options), this[kReadyState] = WebSocket.CONNECTING, this[kBinaryType] = "blob";
    }
    close(code = void 0, reason = void 0) {
      if (webidl.brandCheck(this, WebSocket), code !== void 0)
        code = webidl.converters["unsigned short"](code, { clamp: !0 });
      if (reason !== void 0)
        reason = webidl.converters.USVString(reason);
      if (code !== void 0) {
        if (code !== 1000 && (code < 3000 || code > 4999))
          throw new DOMException2("invalid code", "InvalidAccessError");
      }
      let reasonByteLength = 0;
      if (reason !== void 0) {
        if (reasonByteLength = Buffer.byteLength(reason), reasonByteLength > 123)
          throw new DOMException2(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
      }
      if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED)
        ;
      else if (!isEstablished(this))
        failWebsocketConnection(this, "Connection was closed before it was established."), this[kReadyState] = WebSocket.CLOSING;
      else if (!isClosing(this)) {
        let frame = new WebsocketFrameSend;
        if (code !== void 0 && reason === void 0)
          frame.frameData = Buffer.allocUnsafe(2), frame.frameData.writeUInt16BE(code, 0);
        else if (code !== void 0 && reason !== void 0)
          frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength), frame.frameData.writeUInt16BE(code, 0), frame.frameData.write(reason, 2, "utf-8");
        else
          frame.frameData = emptyBuffer;
        this[kResponse].socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
          if (!err)
            this[kSentClose] = !0;
        }), this[kReadyState] = states.CLOSING;
      } else
        this[kReadyState] = WebSocket.CLOSING;
    }
    send(data) {
      if (webidl.brandCheck(this, WebSocket), webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" }), data = webidl.converters.WebSocketSendData(data), this[kReadyState] === WebSocket.CONNECTING)
        throw new DOMException2("Sent before connected.", "InvalidStateError");
      if (!isEstablished(this) || isClosing(this))
        return;
      let socket = this[kResponse].socket;
      if (typeof data === "string") {
        let value = Buffer.from(data), buffer = new WebsocketFrameSend(value).createFrame(opcodes.TEXT);
        this.#bufferedAmount += value.byteLength, socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (types.isArrayBuffer(data)) {
        let value = Buffer.from(data), buffer = new WebsocketFrameSend(value).createFrame(opcodes.BINARY);
        this.#bufferedAmount += value.byteLength, socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (ArrayBuffer.isView(data)) {
        let ab = Buffer.from(data, data.byteOffset, data.byteLength), buffer = new WebsocketFrameSend(ab).createFrame(opcodes.BINARY);
        this.#bufferedAmount += ab.byteLength, socket.write(buffer, () => {
          this.#bufferedAmount -= ab.byteLength;
        });
      } else if (isBlobLike(data)) {
        let frame = new WebsocketFrameSend;
        data.arrayBuffer().then((ab) => {
          let value = Buffer.from(ab);
          frame.frameData = value;
          let buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength, socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        });
      }
    }
    get readyState() {
      return webidl.brandCheck(this, WebSocket), this[kReadyState];
    }
    get bufferedAmount() {
      return webidl.brandCheck(this, WebSocket), this.#bufferedAmount;
    }
    get url() {
      return webidl.brandCheck(this, WebSocket), URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      return webidl.brandCheck(this, WebSocket), this.#extensions;
    }
    get protocol() {
      return webidl.brandCheck(this, WebSocket), this.#protocol;
    }
    get onopen() {
      return webidl.brandCheck(this, WebSocket), this.#events.open;
    }
    set onopen(fn) {
      if (webidl.brandCheck(this, WebSocket), this.#events.open)
        this.removeEventListener("open", this.#events.open);
      if (typeof fn === "function")
        this.#events.open = fn, this.addEventListener("open", fn);
      else
        this.#events.open = null;
    }
    get onerror() {
      return webidl.brandCheck(this, WebSocket), this.#events.error;
    }
    set onerror(fn) {
      if (webidl.brandCheck(this, WebSocket), this.#events.error)
        this.removeEventListener("error", this.#events.error);
      if (typeof fn === "function")
        this.#events.error = fn, this.addEventListener("error", fn);
      else
        this.#events.error = null;
    }
    get onclose() {
      return webidl.brandCheck(this, WebSocket), this.#events.close;
    }
    set onclose(fn) {
      if (webidl.brandCheck(this, WebSocket), this.#events.close)
        this.removeEventListener("close", this.#events.close);
      if (typeof fn === "function")
        this.#events.close = fn, this.addEventListener("close", fn);
      else
        this.#events.close = null;
    }
    get onmessage() {
      return webidl.brandCheck(this, WebSocket), this.#events.message;
    }
    set onmessage(fn) {
      if (webidl.brandCheck(this, WebSocket), this.#events.message)
        this.removeEventListener("message", this.#events.message);
      if (typeof fn === "function")
        this.#events.message = fn, this.addEventListener("message", fn);
      else
        this.#events.message = null;
    }
    get binaryType() {
      return webidl.brandCheck(this, WebSocket), this[kBinaryType];
    }
    set binaryType(type) {
      if (webidl.brandCheck(this, WebSocket), type !== "blob" && type !== "arraybuffer")
        this[kBinaryType] = "blob";
      else
        this[kBinaryType] = type;
    }
    #onConnectionEstablished(response) {
      this[kResponse] = response;
      let parser = new ByteParser(this);
      parser.on("drain", function() {
        this.ws[kResponse].socket.resume();
      }), response.socket.ws = this, this[kByteParser] = parser, this[kReadyState] = states.OPEN;
      let extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null)
        this.#extensions = extensions;
      let protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null)
        this.#protocol = protocol;
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V)
      return webidl.converters["sequence<DOMString>"](V);
    return webidl.converters.DOMString(V);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      }
    },
    {
      key: "dispatcher",
      converter: (V) => V,
      get defaultValue() {
        return getGlobalDispatcher();
      }
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V))
      return webidl.converters.WebSocketInit(V);
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V))
        return webidl.converters.Blob(V, { strict: !1 });
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V))
        return webidl.converters.BufferSource(V);
    }
    return webidl.converters.USVString(V);
  };
  module.exports = {
    WebSocket
  };
});

// node_modules/undici/index.js
var require_undici = __commonJS((exports, module) => {
  var Client = require_client(), Dispatcher = require_dispatcher(), errors = require_errors(), Pool = require_pool(), BalancedPool = require_balanced_pool(), Agent = require_agent(), util = require_util(), { InvalidArgumentError } = errors, api = require_api(), buildConnector = require_connect(), MockClient = require_mock_client(), MockAgent = require_mock_agent(), MockPool = require_mock_pool(), mockErrors = require_mock_errors(), ProxyAgent = require_proxy_agent(), RetryHandler = require_RetryHandler(), { getGlobalDispatcher, setGlobalDispatcher } = require_global2(), DecoratorHandler = require_DecoratorHandler(), RedirectHandler = require_RedirectHandler(), createRedirectInterceptor = require_redirectInterceptor(), hasCrypto;
  try {
    __require("crypto"), hasCrypto = !0;
  } catch {
    hasCrypto = !1;
  }
  Object.assign(Dispatcher.prototype, api);
  exports.Dispatcher = Dispatcher;
  exports.Client = Client;
  exports.Pool = Pool;
  exports.BalancedPool = BalancedPool;
  exports.Agent = Agent;
  exports.ProxyAgent = ProxyAgent;
  exports.RetryHandler = RetryHandler;
  exports.DecoratorHandler = DecoratorHandler;
  exports.RedirectHandler = RedirectHandler;
  exports.createRedirectInterceptor = createRedirectInterceptor;
  exports.buildConnector = buildConnector;
  exports.errors = errors;
  function makeDispatcher(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function")
        handler = opts, opts = null;
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL))
        throw new InvalidArgumentError("invalid url");
      if (opts != null && typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string")
          throw new InvalidArgumentError("invalid opts.path");
        let path = opts.path;
        if (!opts.path.startsWith("/"))
          path = `/${path}`;
        url = new URL(util.parseOrigin(url).origin + path);
      } else {
        if (!opts)
          opts = typeof url === "object" ? url : {};
        url = util.parseURL(url);
      }
      let { agent, dispatcher = getGlobalDispatcher() } = opts;
      if (agent)
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      return fn.call(dispatcher, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  }
  exports.setGlobalDispatcher = setGlobalDispatcher;
  exports.getGlobalDispatcher = getGlobalDispatcher;
  if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
    let fetchImpl = null;
    exports.fetch = async function(resource) {
      if (!fetchImpl)
        fetchImpl = require_fetch().fetch;
      try {
        return await fetchImpl(...arguments);
      } catch (err) {
        if (typeof err === "object")
          Error.captureStackTrace(err, this);
        throw err;
      }
    }, exports.Headers = require_headers().Headers, exports.Response = require_response().Response, exports.Request = require_request2().Request, exports.FormData = require_formdata().FormData, exports.File = require_file().File, exports.FileReader = require_filereader().FileReader;
    let { setGlobalOrigin, getGlobalOrigin } = require_global();
    exports.setGlobalOrigin = setGlobalOrigin, exports.getGlobalOrigin = getGlobalOrigin;
    let { CacheStorage } = require_cachestorage(), { kConstruct } = require_symbols4();
    exports.caches = new CacheStorage(kConstruct);
  }
  if (util.nodeMajor >= 16) {
    let { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
    exports.deleteCookie = deleteCookie, exports.getCookies = getCookies, exports.getSetCookies = getSetCookies, exports.setCookie = setCookie;
    let { parseMIMEType, serializeAMimeType } = require_dataURL();
    exports.parseMIMEType = parseMIMEType, exports.serializeAMimeType = serializeAMimeType;
  }
  if (util.nodeMajor >= 18 && hasCrypto) {
    let { WebSocket } = require_websocket();
    exports.WebSocket = WebSocket;
  }
  exports.request = makeDispatcher(api.request);
  exports.stream = makeDispatcher(api.stream);
  exports.pipeline = makeDispatcher(api.pipeline);
  exports.connect = makeDispatcher(api.connect);
  exports.upgrade = makeDispatcher(api.upgrade);
  exports.MockClient = MockClient;
  exports.MockPool = MockPool;
  exports.MockAgent = MockAgent;
  exports.mockErrors = mockErrors;
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.HttpClient = exports.HttpClientResponse = exports.HttpClientError = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
  exports.getProxyUrl = getProxyUrl;
  exports.isHttps = isHttps;
  var http = __importStar(__require("http")), https = __importStar(__require("https")), pm = __importStar(require_proxy()), tunnel = __importStar(require_tunnel()), undici_1 = require_undici(), HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2.OK = 200] = "OK", HttpCodes2[HttpCodes2.MultipleChoices = 300] = "MultipleChoices", HttpCodes2[HttpCodes2.MovedPermanently = 301] = "MovedPermanently", HttpCodes2[HttpCodes2.ResourceMoved = 302] = "ResourceMoved", HttpCodes2[HttpCodes2.SeeOther = 303] = "SeeOther", HttpCodes2[HttpCodes2.NotModified = 304] = "NotModified", HttpCodes2[HttpCodes2.UseProxy = 305] = "UseProxy", HttpCodes2[HttpCodes2.SwitchProxy = 306] = "SwitchProxy", HttpCodes2[HttpCodes2.TemporaryRedirect = 307] = "TemporaryRedirect", HttpCodes2[HttpCodes2.PermanentRedirect = 308] = "PermanentRedirect", HttpCodes2[HttpCodes2.BadRequest = 400] = "BadRequest", HttpCodes2[HttpCodes2.Unauthorized = 401] = "Unauthorized", HttpCodes2[HttpCodes2.PaymentRequired = 402] = "PaymentRequired", HttpCodes2[HttpCodes2.Forbidden = 403] = "Forbidden", HttpCodes2[HttpCodes2.NotFound = 404] = "NotFound", HttpCodes2[HttpCodes2.MethodNotAllowed = 405] = "MethodNotAllowed", HttpCodes2[HttpCodes2.NotAcceptable = 406] = "NotAcceptable", HttpCodes2[HttpCodes2.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", HttpCodes2[HttpCodes2.RequestTimeout = 408] = "RequestTimeout", HttpCodes2[HttpCodes2.Conflict = 409] = "Conflict", HttpCodes2[HttpCodes2.Gone = 410] = "Gone", HttpCodes2[HttpCodes2.TooManyRequests = 429] = "TooManyRequests", HttpCodes2[HttpCodes2.InternalServerError = 500] = "InternalServerError", HttpCodes2[HttpCodes2.NotImplemented = 501] = "NotImplemented", HttpCodes2[HttpCodes2.BadGateway = 502] = "BadGateway", HttpCodes2[HttpCodes2.ServiceUnavailable = 503] = "ServiceUnavailable", HttpCodes2[HttpCodes2.GatewayTimeout = 504] = "GatewayTimeout";
  })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2.Accept = "accept", Headers2.ContentType = "content-type";
  })(Headers || (exports.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2.ApplicationJson = "application/json";
  })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ], HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ], RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"], ExponentialBackoffCeiling = 10, ExponentialBackoffTimeSlice = 5;

  class HttpClientError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError", this.statusCode = statusCode, Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  exports.HttpClientError = HttpClientError;

  class HttpClientResponse {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          }), this.message.on("end", () => {
            resolve(output.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
          let chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          }), this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  exports.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    return new URL(requestUrl).protocol === "https:";
  }

  class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
      if (this._ignoreSslError = !1, this._allowRedirects = !0, this._allowRedirectDowngrade = !1, this._maxRedirects = 50, this._allowRetries = !1, this._maxRetries = 1, this._keepAlive = !1, this._disposed = !1, this.userAgent = userAgent, this.handlers = handlers || [], this.requestOptions = requestOptions, requestOptions) {
        if (requestOptions.ignoreSslError != null)
          this._ignoreSslError = requestOptions.ignoreSslError;
        if (this._socketTimeout = requestOptions.socketTimeout, requestOptions.allowRedirects != null)
          this._allowRedirects = requestOptions.allowRedirects;
        if (requestOptions.allowRedirectDowngrade != null)
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        if (requestOptions.maxRedirects != null)
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        if (requestOptions.keepAlive != null)
          this._keepAlive = requestOptions.keepAlive;
        if (requestOptions.allowRetries != null)
          this._allowRetries = requestOptions.allowRetries;
        if (requestOptions.maxRetries != null)
          this._maxRetries = requestOptions.maxRetries;
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      });
    }
    getJson(requestUrl_1) {
      return __awaiter(this, arguments, void 0, function* (requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        let res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        let res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        let res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        let res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    request(verb, requestUrl, data, headers) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._disposed)
          throw Error("Client has already been disposed.");
        let parsedUrl = new URL(requestUrl), info = this._prepareRequest(verb, parsedUrl, headers), maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1, numTries = 0, response;
        do {
          if (response = yield this.requestRaw(info, data), response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (let handler of this.handlers)
              if (handler.canHandleAuthentication(response)) {
                authenticationHandler = handler;
                break;
              }
            if (authenticationHandler)
              return authenticationHandler.handleAuthentication(this, info, data);
            else
              return response;
          }
          let redirectsRemaining = this._maxRedirects;
          while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            let redirectUrl = response.message.headers.location;
            if (!redirectUrl)
              break;
            let parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade)
              throw Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            if (yield response.readBody(), parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (let header in headers)
                if (header.toLowerCase() === "authorization")
                  delete headers[header];
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers), response = yield this.requestRaw(info, data), redirectsRemaining--;
          }
          if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode))
            return response;
          if (numTries += 1, numTries < maxTries)
            yield response.readBody(), yield this._performExponentialBackoff(numTries);
        } while (numTries < maxTries);
        return response;
      });
    }
    dispose() {
      if (this._agent)
        this._agent.destroy();
      this._disposed = !0;
    }
    requestRaw(info, data) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          function callbackForResult(err, res) {
            if (err)
              reject(err);
            else if (!res)
              reject(Error("Unknown error"));
            else
              resolve(res);
          }
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      });
    }
    requestRawWithCallback(info, data, onResult) {
      if (typeof data === "string") {
        if (!info.options.headers)
          info.options.headers = {};
        info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = !1;
      function handleResult(err, res) {
        if (!callbackCalled)
          callbackCalled = !0, onResult(err, res);
      }
      let req = info.httpModule.request(info.options, (msg) => {
        let res = new HttpClientResponse(msg);
        handleResult(void 0, res);
      }), socket;
      if (req.on("socket", (sock) => {
        socket = sock;
      }), req.setTimeout(this._socketTimeout || 180000, () => {
        if (socket)
          socket.end();
        handleResult(Error(`Request timeout: ${info.options.path}`));
      }), req.on("error", function(err) {
        handleResult(err);
      }), data && typeof data === "string")
        req.write(data, "utf8");
      if (data && typeof data !== "string")
        data.on("close", function() {
          req.end();
        }), data.pipe(req);
      else
        req.end();
    }
    getAgent(serverUrl) {
      let parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      let parsedUrl = new URL(serverUrl), proxyUrl = pm.getProxyUrl(parsedUrl);
      if (!(proxyUrl && proxyUrl.hostname))
        return;
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      let info = {};
      info.parsedUrl = requestUrl;
      let usingSsl = info.parsedUrl.protocol === "https:";
      info.httpModule = usingSsl ? https : http;
      let defaultPort = usingSsl ? 443 : 80;
      if (info.options = {}, info.options.host = info.parsedUrl.hostname, info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort, info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || ""), info.options.method = method, info.options.headers = this._mergeHeaders(headers), this.userAgent != null)
        info.options.headers["user-agent"] = this.userAgent;
      if (info.options.agent = this._getAgent(info.parsedUrl), this.handlers)
        for (let handler of this.handlers)
          handler.prepareRequest(info.options);
      return info;
    }
    _mergeHeaders(headers) {
      if (this.requestOptions && this.requestOptions.headers)
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
      return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        let headerValue = lowercaseKeys(this.requestOptions.headers)[header];
        if (headerValue)
          clientHeader = typeof headerValue === "number" ? headerValue.toString() : headerValue;
      }
      let additionalValue = additionalHeaders[header];
      if (additionalValue !== void 0)
        return typeof additionalValue === "number" ? additionalValue.toString() : additionalValue;
      if (clientHeader !== void 0)
        return clientHeader;
      return _default;
    }
    _getExistingOrDefaultContentTypeHeader(additionalHeaders, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        let headerValue = lowercaseKeys(this.requestOptions.headers)[Headers.ContentType];
        if (headerValue)
          if (typeof headerValue === "number")
            clientHeader = String(headerValue);
          else if (Array.isArray(headerValue))
            clientHeader = headerValue.join(", ");
          else
            clientHeader = headerValue;
      }
      let additionalValue = additionalHeaders[Headers.ContentType];
      if (additionalValue !== void 0)
        if (typeof additionalValue === "number")
          return String(additionalValue);
        else if (Array.isArray(additionalValue))
          return additionalValue.join(", ");
        else
          return additionalValue;
      if (clientHeader !== void 0)
        return clientHeader;
      return _default;
    }
    _getAgent(parsedUrl) {
      let agent, proxyUrl = pm.getProxyUrl(parsedUrl), useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy)
        agent = this._proxyAgent;
      if (!useProxy)
        agent = this._agent;
      if (agent)
        return agent;
      let usingSsl = parsedUrl.protocol === "https:", maxSockets = 100;
      if (this.requestOptions)
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      if (proxyUrl && proxyUrl.hostname) {
        let agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        }, tunnelAgent, overHttps = proxyUrl.protocol === "https:";
        if (usingSsl)
          tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
        else
          tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
        agent = tunnelAgent(agentOptions), this._proxyAgent = agent;
      }
      if (!agent) {
        let options = { keepAlive: this._keepAlive, maxSockets };
        agent = usingSsl ? new https.Agent(options) : new http.Agent(options), this._agent = agent;
      }
      if (usingSsl && this._ignoreSslError)
        agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: !1
        });
      return agent;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent;
      if (this._keepAlive)
        proxyAgent = this._proxyAgentDispatcher;
      if (proxyAgent)
        return proxyAgent;
      let usingSsl = parsedUrl.protocol === "https:";
      if (proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      })), this._proxyAgentDispatcher = proxyAgent, usingSsl && this._ignoreSslError)
        proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
          rejectUnauthorized: !1
        });
      return proxyAgent;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter(this, void 0, void 0, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        let ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      });
    }
    _processResponse(res, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          let statusCode = res.message.statusCode || 0, response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound)
            resolve(response);
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              let a = new Date(value);
              if (!isNaN(a.valueOf()))
                return a;
            }
            return value;
          }
          let obj, contents;
          try {
            if (contents = yield res.readBody(), contents && contents.length > 0) {
              if (options && options.deserializeDates)
                obj = JSON.parse(contents, dateTimeDeserializer);
              else
                obj = JSON.parse(contents);
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {}
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message)
              msg = obj.message;
            else if (contents && contents.length > 0)
              msg = contents;
            else
              msg = `Failed request: (${statusCode})`;
            let err = new HttpClientError(msg, statusCode);
            err.result = response.result, reject(err);
          } else
            resolve(response);
        }));
      });
    }
  }
  exports.HttpClient = HttpClient;
  var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;

  class BasicCredentialHandler {
    constructor(username, password) {
      this.username = username, this.password = password;
    }
    prepareRequest(options) {
      if (!options.headers)
        throw Error("The request has no headers");
      options.headers.Authorization = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return !1;
    }
    handleAuthentication() {
      return __awaiter(this, void 0, void 0, function* () {
        throw Error("not implemented");
      });
    }
  }
  exports.BasicCredentialHandler = BasicCredentialHandler;

  class BearerCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      if (!options.headers)
        throw Error("The request has no headers");
      options.headers.Authorization = `Bearer ${this.token}`;
    }
    canHandleAuthentication() {
      return !1;
    }
    handleAuthentication() {
      return __awaiter(this, void 0, void 0, function* () {
        throw Error("not implemented");
      });
    }
  }
  exports.BearerCredentialHandler = BearerCredentialHandler;

  class PersonalAccessTokenCredentialHandler {
    constructor(token) {
      this.token = token;
    }
    prepareRequest(options) {
      if (!options.headers)
        throw Error("The request has no headers");
      options.headers.Authorization = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return !1;
    }
    handleAuthentication() {
      return __awaiter(this, void 0, void 0, function* () {
        throw Error("not implemented");
      });
    }
  }
  exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.OidcClient = void 0;
  var http_client_1 = require_lib(), auth_1 = require_auth(), core_1 = require_core();

  class OidcClient {
    static createHttpClient(allowRetry = !0, maxRetry = 10) {
      let requestOptions = {
        allowRetries: allowRetry,
        maxRetries: maxRetry
      };
      return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
      let token = process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN;
      if (!token)
        throw Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
      return token;
    }
    static getIDTokenUrl() {
      let runtimeUrl = process.env.ACTIONS_ID_TOKEN_REQUEST_URL;
      if (!runtimeUrl)
        throw Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
      return runtimeUrl;
    }
    static getCall(id_token_url) {
      return __awaiter(this, void 0, void 0, function* () {
        var _a;
        let id_token = (_a = (yield OidcClient.createHttpClient().getJson(id_token_url).catch((error) => {
          throw Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
        })).result) === null || _a === void 0 ? void 0 : _a.value;
        if (!id_token)
          throw Error("Response json body do not have ID Token field");
        return id_token;
      });
    }
    static getIDToken(audience) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          let id_token_url = OidcClient.getIDTokenUrl();
          if (audience) {
            let encodedAudience = encodeURIComponent(audience);
            id_token_url = `${id_token_url}&audience=${encodedAudience}`;
          }
          (0, core_1.debug)(`ID token url is ${id_token_url}`);
          let id_token = yield OidcClient.getCall(id_token_url);
          return (0, core_1.setSecret)(id_token), id_token;
        } catch (error) {
          throw Error(`Error message: ${error.message}`);
        }
      });
    }
  }
  exports.OidcClient = OidcClient;
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
  var os_1 = __require("os"), fs_1 = __require("fs"), { access, appendFile, writeFile } = fs_1.promises;
  exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
  exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";

  class Summary {
    constructor() {
      this._buffer = "";
    }
    filePath() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._filePath)
          return this._filePath;
        let pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
        if (!pathFromEnv)
          throw Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
        try {
          yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
        } catch (_a) {
          throw Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
        }
        return this._filePath = pathFromEnv, this._filePath;
      });
    }
    wrap(tag, content, attrs = {}) {
      let htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
      if (!content)
        return `<${tag}${htmlAttrs}>`;
      return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    write(options) {
      return __awaiter(this, void 0, void 0, function* () {
        let overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite), filePath = yield this.filePath();
        return yield (overwrite ? writeFile : appendFile)(filePath, this._buffer, { encoding: "utf8" }), this.emptyBuffer();
      });
    }
    clear() {
      return __awaiter(this, void 0, void 0, function* () {
        return this.emptyBuffer().write({ overwrite: !0 });
      });
    }
    stringify() {
      return this._buffer;
    }
    isEmptyBuffer() {
      return this._buffer.length === 0;
    }
    emptyBuffer() {
      return this._buffer = "", this;
    }
    addRaw(text, addEOL = !1) {
      return this._buffer += text, addEOL ? this.addEOL() : this;
    }
    addEOL() {
      return this.addRaw(os_1.EOL);
    }
    addCodeBlock(code, lang) {
      let attrs = Object.assign({}, lang && { lang }), element = this.wrap("pre", this.wrap("code", code), attrs);
      return this.addRaw(element).addEOL();
    }
    addList(items, ordered = !1) {
      let tag = ordered ? "ol" : "ul", listItems = items.map((item) => this.wrap("li", item)).join(""), element = this.wrap(tag, listItems);
      return this.addRaw(element).addEOL();
    }
    addTable(rows) {
      let tableBody = rows.map((row) => {
        let cells = row.map((cell) => {
          if (typeof cell === "string")
            return this.wrap("td", cell);
          let { header, data, colspan, rowspan } = cell, tag = header ? "th" : "td", attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
          return this.wrap(tag, data, attrs);
        }).join("");
        return this.wrap("tr", cells);
      }).join(""), element = this.wrap("table", tableBody);
      return this.addRaw(element).addEOL();
    }
    addDetails(label, content) {
      let element = this.wrap("details", this.wrap("summary", label) + content);
      return this.addRaw(element).addEOL();
    }
    addImage(src, alt, options) {
      let { width, height } = options || {}, attrs = Object.assign(Object.assign({}, width && { width }), height && { height }), element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
      return this.addRaw(element).addEOL();
    }
    addHeading(text, level) {
      let tag = `h${level}`, allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1", element = this.wrap(allowedTag, text);
      return this.addRaw(element).addEOL();
    }
    addSeparator() {
      let element = this.wrap("hr", null);
      return this.addRaw(element).addEOL();
    }
    addBreak() {
      let element = this.wrap("br", null);
      return this.addRaw(element).addEOL();
    }
    addQuote(text, cite) {
      let attrs = Object.assign({}, cite && { cite }), element = this.wrap("blockquote", text, attrs);
      return this.addRaw(element).addEOL();
    }
    addLink(text, href) {
      let element = this.wrap("a", text, { href });
      return this.addRaw(element).addEOL();
    }
  }
  var _summary = new Summary;
  exports.markdownSummary = _summary;
  exports.summary = _summary;
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.toPosixPath = toPosixPath;
  exports.toWin32Path = toWin32Path;
  exports.toPlatformPath = toPlatformPath;
  var path = __importStar(__require("path"));
  function toPosixPath(pth) {
    return pth.replace(/[\\]/g, "/");
  }
  function toWin32Path(pth) {
    return pth.replace(/[/]/g, "\\");
  }
  function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
  }
});

// node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
  exports.getDetails = getDetails;
  var os_1 = __importDefault(__require("os")), exec = __importStar(require_exec()), getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
    let { stdout: version } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
      silent: !0
    }), { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
      silent: !0
    });
    return {
      name: name.trim(),
      version: version.trim()
    };
  }), getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d;
    let { stdout } = yield exec.getExecOutput("sw_vers", void 0, {
      silent: !0
    }), version = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
    return {
      name: (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "",
      version
    };
  }), getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {
    let { stdout } = yield exec.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
      silent: !0
    }), [name, version] = stdout.trim().split(`
`);
    return {
      name,
      version
    };
  });
  exports.platform = os_1.default.platform();
  exports.arch = os_1.default.arch();
  exports.isWindows = exports.platform === "win32";
  exports.isMacOS = exports.platform === "darwin";
  exports.isLinux = exports.platform === "linux";
  function getDetails() {
    return __awaiter(this, void 0, void 0, function* () {
      return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
        platform: exports.platform,
        arch: exports.arch,
        isWindows: exports.isWindows,
        isMacOS: exports.isMacOS,
        isLinux: exports.isLinux
      });
    });
  }
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.ExitCode = void 0;
  exports.exportVariable = exportVariable;
  exports.setSecret = setSecret;
  exports.addPath = addPath;
  exports.getInput = getInput;
  exports.getMultilineInput = getMultilineInput;
  exports.getBooleanInput = getBooleanInput;
  exports.setOutput = setOutput;
  exports.setCommandEcho = setCommandEcho;
  exports.setFailed = setFailed;
  exports.isDebug = isDebug;
  exports.debug = debug;
  exports.error = error;
  exports.warning = warning;
  exports.notice = notice;
  exports.info = info;
  exports.startGroup = startGroup;
  exports.endGroup = endGroup;
  exports.group = group;
  exports.saveState = saveState;
  exports.getState = getState;
  exports.getIDToken = getIDToken;
  var command_1 = require_command(), file_command_1 = require_file_command(), utils_1 = require_utils(), os = __importStar(__require("os")), path = __importStar(__require("path")), oidc_utils_1 = require_oidc_utils(), ExitCode;
  (function(ExitCode2) {
    ExitCode2[ExitCode2.Success = 0] = "Success", ExitCode2[ExitCode2.Failure = 1] = "Failure";
  })(ExitCode || (exports.ExitCode = ExitCode = {}));
  function exportVariable(name, val) {
    let convertedVal = (0, utils_1.toCommandValue)(val);
    if (process.env[name] = convertedVal, process.env.GITHUB_ENV || "")
      return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
    (0, command_1.issueCommand)("set-env", { name }, convertedVal);
  }
  function setSecret(secret) {
    (0, command_1.issueCommand)("add-mask", {}, secret);
  }
  function addPath(inputPath) {
    if (process.env.GITHUB_PATH || "")
      (0, file_command_1.issueFileCommand)("PATH", inputPath);
    else
      (0, command_1.issueCommand)("add-path", {}, inputPath);
    process.env.PATH = `${inputPath}${path.delimiter}${process.env.PATH}`;
  }
  function getInput(name, options) {
    let val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
    if (options && options.required && !val)
      throw Error(`Input required and not supplied: ${name}`);
    if (options && options.trimWhitespace === !1)
      return val;
    return val.trim();
  }
  function getMultilineInput(name, options) {
    let inputs = getInput(name, options).split(`
`).filter((x) => x !== "");
    if (options && options.trimWhitespace === !1)
      return inputs;
    return inputs.map((input) => input.trim());
  }
  function getBooleanInput(name, options) {
    let trueValue = ["true", "True", "TRUE"], falseValue = ["false", "False", "FALSE"], val = getInput(name, options);
    if (trueValue.includes(val))
      return !0;
    if (falseValue.includes(val))
      return !1;
    throw TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
  }
  function setOutput(name, value) {
    if (process.env.GITHUB_OUTPUT || "")
      return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
    process.stdout.write(os.EOL), (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
  }
  function setCommandEcho(enabled) {
    (0, command_1.issue)("echo", enabled ? "on" : "off");
  }
  function setFailed(message) {
    process.exitCode = ExitCode.Failure, error(message);
  }
  function isDebug() {
    return process.env.RUNNER_DEBUG === "1";
  }
  function debug(message) {
    (0, command_1.issueCommand)("debug", {}, message);
  }
  function error(message, properties = {}) {
    (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  function warning(message, properties = {}) {
    (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  function notice(message, properties = {}) {
    (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
  }
  function info(message) {
    process.stdout.write(message + os.EOL);
  }
  function startGroup(name) {
    (0, command_1.issue)("group", name);
  }
  function endGroup() {
    (0, command_1.issue)("endgroup");
  }
  function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
      startGroup(name);
      let result;
      try {
        result = yield fn();
      } finally {
        endGroup();
      }
      return result;
    });
  }
  function saveState(name, value) {
    if (process.env.GITHUB_STATE || "")
      return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
    (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
  }
  function getState(name) {
    return process.env[`STATE_${name}`] || "";
  }
  function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
  }
  var summary_1 = require_summary();
  Object.defineProperty(exports, "summary", { enumerable: !0, get: function() {
    return summary_1.summary;
  } });
  var summary_2 = require_summary();
  Object.defineProperty(exports, "markdownSummary", { enumerable: !0, get: function() {
    return summary_2.markdownSummary;
  } });
  var path_utils_1 = require_path_utils();
  Object.defineProperty(exports, "toPosixPath", { enumerable: !0, get: function() {
    return path_utils_1.toPosixPath;
  } });
  Object.defineProperty(exports, "toWin32Path", { enumerable: !0, get: function() {
    return path_utils_1.toWin32Path;
  } });
  Object.defineProperty(exports, "toPlatformPath", { enumerable: !0, get: function() {
    return path_utils_1.toPlatformPath;
  } });
  exports.platform = __importStar(require_platform());
});

// node_modules/@actions/artifact/lib/internal/shared/config.js
var require_config = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getUploadChunkSize = getUploadChunkSize;
  exports.getRuntimeToken = getRuntimeToken;
  exports.getResultsServiceUrl = getResultsServiceUrl;
  exports.isGhes = isGhes;
  exports.getGitHubWorkspaceDir = getGitHubWorkspaceDir;
  exports.getConcurrency = getConcurrency;
  exports.getUploadChunkTimeout = getUploadChunkTimeout;
  exports.getMaxArtifactListCount = getMaxArtifactListCount;
  var os_1 = __importDefault(__require("os")), core_1 = require_core();
  function getUploadChunkSize() {
    return 8388608;
  }
  function getRuntimeToken() {
    let token = process.env.ACTIONS_RUNTIME_TOKEN;
    if (!token)
      throw Error("Unable to get the ACTIONS_RUNTIME_TOKEN env variable");
    return token;
  }
  function getResultsServiceUrl() {
    let resultsUrl = process.env.ACTIONS_RESULTS_URL;
    if (!resultsUrl)
      throw Error("Unable to get the ACTIONS_RESULTS_URL env variable");
    return new URL(resultsUrl).origin;
  }
  function isGhes() {
    let hostname = new URL(process.env.GITHUB_SERVER_URL || "https://github.com").hostname.trimEnd().toUpperCase(), isGitHubHost = hostname === "GITHUB.COM", isGheHost = hostname.endsWith(".GHE.COM"), isLocalHost = hostname.endsWith(".LOCALHOST");
    return !isGitHubHost && !isGheHost && !isLocalHost;
  }
  function getGitHubWorkspaceDir() {
    let ghWorkspaceDir = process.env.GITHUB_WORKSPACE;
    if (!ghWorkspaceDir)
      throw Error("Unable to get the GITHUB_WORKSPACE env variable");
    return ghWorkspaceDir;
  }
  function getConcurrency() {
    let numCPUs = os_1.default.cpus().length, concurrencyCap = 32;
    if (numCPUs > 4) {
      let concurrency = 16 * numCPUs;
      concurrencyCap = concurrency > 300 ? 300 : concurrency;
    }
    let concurrencyOverride = process.env.ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY;
    if (concurrencyOverride) {
      let concurrency = parseInt(concurrencyOverride);
      if (isNaN(concurrency) || concurrency < 1)
        throw Error("Invalid value set for ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY env variable");
      if (concurrency < concurrencyCap)
        return (0, core_1.info)("Set concurrency based on the value set in ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY."), concurrency;
      return (0, core_1.info)(`ACTIONS_ARTIFACT_UPLOAD_CONCURRENCY is higher than the cap of ${concurrencyCap} based on the number of cpus. Set it to the maximum value allowed.`), concurrencyCap;
    }
    return 5;
  }
  function getUploadChunkTimeout() {
    let timeoutVar = process.env.ACTIONS_ARTIFACT_UPLOAD_TIMEOUT_MS;
    if (!timeoutVar)
      return 300000;
    let timeout = parseInt(timeoutVar);
    if (isNaN(timeout))
      throw Error("Invalid value set for ACTIONS_ARTIFACT_UPLOAD_TIMEOUT_MS env variable");
    return timeout;
  }
  function getMaxArtifactListCount() {
    let maxCountVar = process.env.ACTIONS_ARTIFACT_MAX_ARTIFACT_COUNT || "1000", maxCount = parseInt(maxCountVar);
    if (isNaN(maxCount) || maxCount < 1)
      throw Error("Invalid value set for ACTIONS_ARTIFACT_MAX_ARTIFACT_COUNT env variable");
    return maxCount;
  }
});

// node_modules/@protobuf-ts/runtime/build/commonjs/json-typings.js
var require_json_typings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isJsonObject = exports.typeofJsonValue = void 0;
  function typeofJsonValue(value) {
    let t = typeof value;
    if (t == "object") {
      if (Array.isArray(value))
        return "array";
      if (value === null)
        return "null";
    }
    return t;
  }
  exports.typeofJsonValue = typeofJsonValue;
  function isJsonObject(value) {
    return value !== null && typeof value == "object" && !Array.isArray(value);
  }
  exports.isJsonObject = isJsonObject;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/base64.js
var require_base64 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.base64encode = exports.base64decode = void 0;
  var encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), decTable = [];
  for (let i = 0;i < encTable.length; i++)
    decTable[encTable[i].charCodeAt(0)] = i;
  decTable[45] = encTable.indexOf("+");
  decTable[95] = encTable.indexOf("/");
  function base64decode(base64Str) {
    let es = base64Str.length * 3 / 4;
    if (base64Str[base64Str.length - 2] == "=")
      es -= 2;
    else if (base64Str[base64Str.length - 1] == "=")
      es -= 1;
    let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
    for (let i = 0;i < base64Str.length; i++) {
      if (b = decTable[base64Str.charCodeAt(i)], b === void 0)
        switch (base64Str[i]) {
          case "=":
            groupPos = 0;
          case `
`:
          case "\r":
          case "\t":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      switch (groupPos) {
        case 0:
          p = b, groupPos = 1;
          break;
        case 1:
          bytes[bytePos++] = p << 2 | (b & 48) >> 4, p = b, groupPos = 2;
          break;
        case 2:
          bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2, p = b, groupPos = 3;
          break;
        case 3:
          bytes[bytePos++] = (p & 3) << 6 | b, groupPos = 0;
          break;
      }
    }
    if (groupPos == 1)
      throw Error("invalid base64 string.");
    return bytes.subarray(0, bytePos);
  }
  exports.base64decode = base64decode;
  function base64encode(bytes) {
    let base64 = "", groupPos = 0, b, p = 0;
    for (let i = 0;i < bytes.length; i++)
      switch (b = bytes[i], groupPos) {
        case 0:
          base64 += encTable[b >> 2], p = (b & 3) << 4, groupPos = 1;
          break;
        case 1:
          base64 += encTable[p | b >> 4], p = (b & 15) << 2, groupPos = 2;
          break;
        case 2:
          base64 += encTable[p | b >> 6], base64 += encTable[b & 63], groupPos = 0;
          break;
      }
    if (groupPos) {
      if (base64 += encTable[p], base64 += "=", groupPos == 1)
        base64 += "=";
    }
    return base64;
  }
  exports.base64encode = base64encode;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/protobufjs-utf8.js
var require_protobufjs_utf8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.utf8read = void 0;
  var fromCharCodes = (chunk) => String.fromCharCode.apply(String, chunk);
  function utf8read(bytes) {
    if (bytes.length < 1)
      return "";
    let pos = 0, parts = [], chunk = [], i = 0, t, len = bytes.length;
    while (pos < len) {
      if (t = bytes[pos++], t < 128)
        chunk[i++] = t;
      else if (t > 191 && t < 224)
        chunk[i++] = (t & 31) << 6 | bytes[pos++] & 63;
      else if (t > 239 && t < 365)
        t = ((t & 7) << 18 | (bytes[pos++] & 63) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63) - 65536, chunk[i++] = 55296 + (t >> 10), chunk[i++] = 56320 + (t & 1023);
      else
        chunk[i++] = (t & 15) << 12 | (bytes[pos++] & 63) << 6 | bytes[pos++] & 63;
      if (i > 8191)
        parts.push(fromCharCodes(chunk)), i = 0;
    }
    if (parts.length) {
      if (i)
        parts.push(fromCharCodes(chunk.slice(0, i)));
      return parts.join("");
    }
    return fromCharCodes(chunk.slice(0, i));
  }
  exports.utf8read = utf8read;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-format-contract.js
var require_binary_format_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.WireType = exports.mergeBinaryOptions = exports.UnknownFieldHandler = void 0;
  var UnknownFieldHandler;
  (function(UnknownFieldHandler2) {
    UnknownFieldHandler2.symbol = Symbol.for("protobuf-ts/unknown"), UnknownFieldHandler2.onRead = (typeName, message, fieldNo, wireType, data) => {
      (is(message) ? message[UnknownFieldHandler2.symbol] : message[UnknownFieldHandler2.symbol] = []).push({ no: fieldNo, wireType, data });
    }, UnknownFieldHandler2.onWrite = (typeName, message, writer) => {
      for (let { no, wireType, data } of UnknownFieldHandler2.list(message))
        writer.tag(no, wireType).raw(data);
    }, UnknownFieldHandler2.list = (message, fieldNo) => {
      if (is(message)) {
        let all = message[UnknownFieldHandler2.symbol];
        return fieldNo ? all.filter((uf) => uf.no == fieldNo) : all;
      }
      return [];
    }, UnknownFieldHandler2.last = (message, fieldNo) => UnknownFieldHandler2.list(message, fieldNo).slice(-1)[0];
    let is = (message) => message && Array.isArray(message[UnknownFieldHandler2.symbol]);
  })(UnknownFieldHandler = exports.UnknownFieldHandler || (exports.UnknownFieldHandler = {}));
  function mergeBinaryOptions(a, b) {
    return Object.assign(Object.assign({}, a), b);
  }
  exports.mergeBinaryOptions = mergeBinaryOptions;
  var WireType;
  (function(WireType2) {
    WireType2[WireType2.Varint = 0] = "Varint", WireType2[WireType2.Bit64 = 1] = "Bit64", WireType2[WireType2.LengthDelimited = 2] = "LengthDelimited", WireType2[WireType2.StartGroup = 3] = "StartGroup", WireType2[WireType2.EndGroup = 4] = "EndGroup", WireType2[WireType2.Bit32 = 5] = "Bit32";
  })(WireType = exports.WireType || (exports.WireType = {}));
});

// node_modules/@protobuf-ts/runtime/build/commonjs/goog-varint.js
var require_goog_varint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.varint32read = exports.varint32write = exports.int64toString = exports.int64fromString = exports.varint64write = exports.varint64read = void 0;
  function varint64read() {
    let lowBits = 0, highBits = 0;
    for (let shift = 0;shift < 28; shift += 7) {
      let b = this.buf[this.pos++];
      if (lowBits |= (b & 127) << shift, (b & 128) == 0)
        return this.assertBounds(), [lowBits, highBits];
    }
    let middleByte = this.buf[this.pos++];
    if (lowBits |= (middleByte & 15) << 28, highBits = (middleByte & 112) >> 4, (middleByte & 128) == 0)
      return this.assertBounds(), [lowBits, highBits];
    for (let shift = 3;shift <= 31; shift += 7) {
      let b = this.buf[this.pos++];
      if (highBits |= (b & 127) << shift, (b & 128) == 0)
        return this.assertBounds(), [lowBits, highBits];
    }
    throw Error("invalid varint");
  }
  exports.varint64read = varint64read;
  function varint64write(lo, hi, bytes) {
    for (let i = 0;i < 28; i = i + 7) {
      let shift = lo >>> i, hasNext = !(shift >>> 7 == 0 && hi == 0), byte = (hasNext ? shift | 128 : shift) & 255;
      if (bytes.push(byte), !hasNext)
        return;
    }
    let splitBits = lo >>> 28 & 15 | (hi & 7) << 4, hasMoreBits = hi >> 3 != 0;
    if (bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255), !hasMoreBits)
      return;
    for (let i = 3;i < 31; i = i + 7) {
      let shift = hi >>> i, hasNext = shift >>> 7 != 0, byte = (hasNext ? shift | 128 : shift) & 255;
      if (bytes.push(byte), !hasNext)
        return;
    }
    bytes.push(hi >>> 31 & 1);
  }
  exports.varint64write = varint64write;
  var TWO_PWR_32_DBL = 4294967296;
  function int64fromString(dec) {
    let minus = dec[0] == "-";
    if (minus)
      dec = dec.slice(1);
    let base = 1e6, lowBits = 0, highBits = 0;
    function add1e6digit(begin, end) {
      let digit1e6 = Number(dec.slice(begin, end));
      if (highBits *= base, lowBits = lowBits * base + digit1e6, lowBits >= TWO_PWR_32_DBL)
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0), lowBits = lowBits % TWO_PWR_32_DBL;
    }
    return add1e6digit(-24, -18), add1e6digit(-18, -12), add1e6digit(-12, -6), add1e6digit(-6), [minus, lowBits, highBits];
  }
  exports.int64fromString = int64fromString;
  function int64toString(bitsLow, bitsHigh) {
    if (bitsHigh >>> 0 <= 2097151)
      return "" + (TWO_PWR_32_DBL * bitsHigh + (bitsLow >>> 0));
    let low = bitsLow & 16777215, mid = (bitsLow >>> 24 | bitsHigh << 8) >>> 0 & 16777215, high = bitsHigh >> 16 & 65535, digitA = low + mid * 6777216 + high * 6710656, digitB = mid + high * 8147497, digitC = high * 2, base = 1e7;
    if (digitA >= base)
      digitB += Math.floor(digitA / base), digitA %= base;
    if (digitB >= base)
      digitC += Math.floor(digitB / base), digitB %= base;
    function decimalFrom1e7(digit1e7, needLeadingZeros) {
      let partial = digit1e7 ? String(digit1e7) : "";
      if (needLeadingZeros)
        return "0000000".slice(partial.length) + partial;
      return partial;
    }
    return decimalFrom1e7(digitC, 0) + decimalFrom1e7(digitB, digitC) + decimalFrom1e7(digitA, 1);
  }
  exports.int64toString = int64toString;
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127)
        bytes.push(value & 127 | 128), value = value >>> 7;
      bytes.push(value);
    } else {
      for (let i = 0;i < 9; i++)
        bytes.push(value & 127 | 128), value = value >> 7;
      bytes.push(1);
    }
  }
  exports.varint32write = varint32write;
  function varint32read() {
    let b = this.buf[this.pos++], result = b & 127;
    if ((b & 128) == 0)
      return this.assertBounds(), result;
    if (b = this.buf[this.pos++], result |= (b & 127) << 7, (b & 128) == 0)
      return this.assertBounds(), result;
    if (b = this.buf[this.pos++], result |= (b & 127) << 14, (b & 128) == 0)
      return this.assertBounds(), result;
    if (b = this.buf[this.pos++], result |= (b & 127) << 21, (b & 128) == 0)
      return this.assertBounds(), result;
    b = this.buf[this.pos++], result |= (b & 15) << 28;
    for (let readBytes = 5;(b & 128) !== 0 && readBytes < 10; readBytes++)
      b = this.buf[this.pos++];
    if ((b & 128) != 0)
      throw Error("invalid varint");
    return this.assertBounds(), result >>> 0;
  }
  exports.varint32read = varint32read;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/pb-long.js
var require_pb_long = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.PbLong = exports.PbULong = exports.detectBi = void 0;
  var goog_varint_1 = require_goog_varint(), BI;
  function detectBi() {
    let dv = new DataView(new ArrayBuffer(8));
    BI = globalThis.BigInt !== void 0 && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" ? {
      MIN: BigInt("-9223372036854775808"),
      MAX: BigInt("9223372036854775807"),
      UMIN: BigInt("0"),
      UMAX: BigInt("18446744073709551615"),
      C: BigInt,
      V: dv
    } : void 0;
  }
  exports.detectBi = detectBi;
  detectBi();
  function assertBi(bi) {
    if (!bi)
      throw Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support");
  }
  var RE_DECIMAL_STR = /^-?[0-9]+$/, TWO_PWR_32_DBL = 4294967296, HALF_2_PWR_32 = 2147483648;

  class SharedPbLong {
    constructor(lo, hi) {
      this.lo = lo | 0, this.hi = hi | 0;
    }
    isZero() {
      return this.lo == 0 && this.hi == 0;
    }
    toNumber() {
      let result = this.hi * TWO_PWR_32_DBL + (this.lo >>> 0);
      if (!Number.isSafeInteger(result))
        throw Error("cannot convert to safe number");
      return result;
    }
  }

  class PbULong extends SharedPbLong {
    static from(value) {
      if (BI)
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value == "")
              throw Error("string is no integer");
            value = BI.C(value);
          case "number":
            if (value === 0)
              return this.ZERO;
            value = BI.C(value);
          case "bigint":
            if (!value)
              return this.ZERO;
            if (value < BI.UMIN)
              throw Error("signed value for ulong");
            if (value > BI.UMAX)
              throw Error("ulong too large");
            return BI.V.setBigUint64(0, value, !0), new PbULong(BI.V.getInt32(0, !0), BI.V.getInt32(4, !0));
        }
      else
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value = value.trim(), !RE_DECIMAL_STR.test(value))
              throw Error("string is no integer");
            let [minus, lo, hi] = goog_varint_1.int64fromString(value);
            if (minus)
              throw Error("signed value for ulong");
            return new PbULong(lo, hi);
          case "number":
            if (value == 0)
              return this.ZERO;
            if (!Number.isSafeInteger(value))
              throw Error("number is no integer");
            if (value < 0)
              throw Error("signed value for ulong");
            return new PbULong(value, value / TWO_PWR_32_DBL);
        }
      throw Error("unknown value " + typeof value);
    }
    toString() {
      return BI ? this.toBigInt().toString() : goog_varint_1.int64toString(this.lo, this.hi);
    }
    toBigInt() {
      return assertBi(BI), BI.V.setInt32(0, this.lo, !0), BI.V.setInt32(4, this.hi, !0), BI.V.getBigUint64(0, !0);
    }
  }
  exports.PbULong = PbULong;
  PbULong.ZERO = new PbULong(0, 0);

  class PbLong extends SharedPbLong {
    static from(value) {
      if (BI)
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value == "")
              throw Error("string is no integer");
            value = BI.C(value);
          case "number":
            if (value === 0)
              return this.ZERO;
            value = BI.C(value);
          case "bigint":
            if (!value)
              return this.ZERO;
            if (value < BI.MIN)
              throw Error("signed long too small");
            if (value > BI.MAX)
              throw Error("signed long too large");
            return BI.V.setBigInt64(0, value, !0), new PbLong(BI.V.getInt32(0, !0), BI.V.getInt32(4, !0));
        }
      else
        switch (typeof value) {
          case "string":
            if (value == "0")
              return this.ZERO;
            if (value = value.trim(), !RE_DECIMAL_STR.test(value))
              throw Error("string is no integer");
            let [minus, lo, hi] = goog_varint_1.int64fromString(value);
            if (minus) {
              if (hi > HALF_2_PWR_32 || hi == HALF_2_PWR_32 && lo != 0)
                throw Error("signed long too small");
            } else if (hi >= HALF_2_PWR_32)
              throw Error("signed long too large");
            let pbl = new PbLong(lo, hi);
            return minus ? pbl.negate() : pbl;
          case "number":
            if (value == 0)
              return this.ZERO;
            if (!Number.isSafeInteger(value))
              throw Error("number is no integer");
            return value > 0 ? new PbLong(value, value / TWO_PWR_32_DBL) : new PbLong(-value, -value / TWO_PWR_32_DBL).negate();
        }
      throw Error("unknown value " + typeof value);
    }
    isNegative() {
      return (this.hi & HALF_2_PWR_32) !== 0;
    }
    negate() {
      let hi = ~this.hi, lo = this.lo;
      if (lo)
        lo = ~lo + 1;
      else
        hi += 1;
      return new PbLong(lo, hi);
    }
    toString() {
      if (BI)
        return this.toBigInt().toString();
      if (this.isNegative()) {
        let n = this.negate();
        return "-" + goog_varint_1.int64toString(n.lo, n.hi);
      }
      return goog_varint_1.int64toString(this.lo, this.hi);
    }
    toBigInt() {
      return assertBi(BI), BI.V.setInt32(0, this.lo, !0), BI.V.setInt32(4, this.hi, !0), BI.V.getBigInt64(0, !0);
    }
  }
  exports.PbLong = PbLong;
  PbLong.ZERO = new PbLong(0, 0);
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-reader.js
var require_binary_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BinaryReader = exports.binaryReadOptions = void 0;
  var binary_format_contract_1 = require_binary_format_contract(), pb_long_1 = require_pb_long(), goog_varint_1 = require_goog_varint(), defaultsRead = {
    readUnknownField: !0,
    readerFactory: (bytes) => new BinaryReader(bytes)
  };
  function binaryReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  exports.binaryReadOptions = binaryReadOptions;

  class BinaryReader {
    constructor(buf, textDecoder) {
      this.varint64 = goog_varint_1.varint64read, this.uint32 = goog_varint_1.varint32read, this.buf = buf, this.len = buf.length, this.pos = 0, this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength), this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder("utf-8", {
        fatal: !0,
        ignoreBOM: !0
      });
    }
    tag() {
      let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
      if (fieldNo <= 0 || wireType < 0 || wireType > 5)
        throw Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
      return [fieldNo, wireType];
    }
    skip(wireType) {
      let start = this.pos;
      switch (wireType) {
        case binary_format_contract_1.WireType.Varint:
          while (this.buf[this.pos++] & 128)
            ;
          break;
        case binary_format_contract_1.WireType.Bit64:
          this.pos += 4;
        case binary_format_contract_1.WireType.Bit32:
          this.pos += 4;
          break;
        case binary_format_contract_1.WireType.LengthDelimited:
          let len = this.uint32();
          this.pos += len;
          break;
        case binary_format_contract_1.WireType.StartGroup:
          let t;
          while ((t = this.tag()[1]) !== binary_format_contract_1.WireType.EndGroup)
            this.skip(t);
          break;
        default:
          throw Error("cant skip wire type " + wireType);
      }
      return this.assertBounds(), this.buf.subarray(start, this.pos);
    }
    assertBounds() {
      if (this.pos > this.len)
        throw RangeError("premature EOF");
    }
    int32() {
      return this.uint32() | 0;
    }
    sint32() {
      let zze = this.uint32();
      return zze >>> 1 ^ -(zze & 1);
    }
    int64() {
      return new pb_long_1.PbLong(...this.varint64());
    }
    uint64() {
      return new pb_long_1.PbULong(...this.varint64());
    }
    sint64() {
      let [lo, hi] = this.varint64(), s = -(lo & 1);
      return lo = (lo >>> 1 | (hi & 1) << 31) ^ s, hi = hi >>> 1 ^ s, new pb_long_1.PbLong(lo, hi);
    }
    bool() {
      let [lo, hi] = this.varint64();
      return lo !== 0 || hi !== 0;
    }
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, !0);
    }
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, !0);
    }
    fixed64() {
      return new pb_long_1.PbULong(this.sfixed32(), this.sfixed32());
    }
    sfixed64() {
      return new pb_long_1.PbLong(this.sfixed32(), this.sfixed32());
    }
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, !0);
    }
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, !0);
    }
    bytes() {
      let len = this.uint32(), start = this.pos;
      return this.pos += len, this.assertBounds(), this.buf.subarray(start, start + len);
    }
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }
  exports.BinaryReader = BinaryReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/assert.js
var require_assert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.assertFloat32 = exports.assertUInt32 = exports.assertInt32 = exports.assertNever = exports.assert = void 0;
  function assert(condition, msg) {
    if (!condition)
      throw Error(msg);
  }
  exports.assert = assert;
  function assertNever(value, msg) {
    throw Error(msg !== null && msg !== void 0 ? msg : "Unexpected object: " + value);
  }
  exports.assertNever = assertNever;
  var FLOAT32_MAX = 340282346638528860000000000000000000000, FLOAT32_MIN = -340282346638528860000000000000000000000, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw Error("invalid int 32: " + arg);
  }
  exports.assertInt32 = assertInt32;
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw Error("invalid uint 32: " + arg);
  }
  exports.assertUInt32 = assertUInt32;
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw Error("invalid float 32: " + arg);
  }
  exports.assertFloat32 = assertFloat32;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/binary-writer.js
var require_binary_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BinaryWriter = exports.binaryWriteOptions = void 0;
  var pb_long_1 = require_pb_long(), goog_varint_1 = require_goog_varint(), assert_1 = require_assert(), defaultsWrite = {
    writeUnknownFields: !0,
    writerFactory: () => new BinaryWriter
  };
  function binaryWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }
  exports.binaryWriteOptions = binaryWriteOptions;

  class BinaryWriter {
    constructor(textEncoder) {
      this.stack = [], this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : /* @__PURE__ */ new TextEncoder, this.chunks = [], this.buf = [];
    }
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let len = 0;
      for (let i = 0;i < this.chunks.length; i++)
        len += this.chunks[i].length;
      let bytes = new Uint8Array(len), offset = 0;
      for (let i = 0;i < this.chunks.length; i++)
        bytes.set(this.chunks[i], offset), offset += this.chunks[i].length;
      return this.chunks = [], bytes;
    }
    fork() {
      return this.stack.push({ chunks: this.chunks, buf: this.buf }), this.chunks = [], this.buf = [], this;
    }
    join() {
      let chunk = this.finish(), prev = this.stack.pop();
      if (!prev)
        throw Error("invalid state, fork stack empty");
      return this.chunks = prev.chunks, this.buf = prev.buf, this.uint32(chunk.byteLength), this.raw(chunk);
    }
    tag(fieldNo, type) {
      return this.uint32((fieldNo << 3 | type) >>> 0);
    }
    raw(chunk) {
      if (this.buf.length)
        this.chunks.push(new Uint8Array(this.buf)), this.buf = [];
      return this.chunks.push(chunk), this;
    }
    uint32(value) {
      assert_1.assertUInt32(value);
      while (value > 127)
        this.buf.push(value & 127 | 128), value = value >>> 7;
      return this.buf.push(value), this;
    }
    int32(value) {
      return assert_1.assertInt32(value), goog_varint_1.varint32write(value, this.buf), this;
    }
    bool(value) {
      return this.buf.push(value ? 1 : 0), this;
    }
    bytes(value) {
      return this.uint32(value.byteLength), this.raw(value);
    }
    string(value) {
      let chunk = this.textEncoder.encode(value);
      return this.uint32(chunk.byteLength), this.raw(chunk);
    }
    float(value) {
      assert_1.assertFloat32(value);
      let chunk = new Uint8Array(4);
      return new DataView(chunk.buffer).setFloat32(0, value, !0), this.raw(chunk);
    }
    double(value) {
      let chunk = new Uint8Array(8);
      return new DataView(chunk.buffer).setFloat64(0, value, !0), this.raw(chunk);
    }
    fixed32(value) {
      assert_1.assertUInt32(value);
      let chunk = new Uint8Array(4);
      return new DataView(chunk.buffer).setUint32(0, value, !0), this.raw(chunk);
    }
    sfixed32(value) {
      assert_1.assertInt32(value);
      let chunk = new Uint8Array(4);
      return new DataView(chunk.buffer).setInt32(0, value, !0), this.raw(chunk);
    }
    sint32(value) {
      return assert_1.assertInt32(value), value = (value << 1 ^ value >> 31) >>> 0, goog_varint_1.varint32write(value, this.buf), this;
    }
    sfixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), long = pb_long_1.PbLong.from(value);
      return view.setInt32(0, long.lo, !0), view.setInt32(4, long.hi, !0), this.raw(chunk);
    }
    fixed64(value) {
      let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), long = pb_long_1.PbULong.from(value);
      return view.setInt32(0, long.lo, !0), view.setInt32(4, long.hi, !0), this.raw(chunk);
    }
    int64(value) {
      let long = pb_long_1.PbLong.from(value);
      return goog_varint_1.varint64write(long.lo, long.hi, this.buf), this;
    }
    sint64(value) {
      let long = pb_long_1.PbLong.from(value), sign = long.hi >> 31, lo = long.lo << 1 ^ sign, hi = (long.hi << 1 | long.lo >>> 31) ^ sign;
      return goog_varint_1.varint64write(lo, hi, this.buf), this;
    }
    uint64(value) {
      let long = pb_long_1.PbULong.from(value);
      return goog_varint_1.varint64write(long.lo, long.hi, this.buf), this;
    }
  }
  exports.BinaryWriter = BinaryWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/json-format-contract.js
var require_json_format_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.mergeJsonOptions = exports.jsonWriteOptions = exports.jsonReadOptions = void 0;
  var defaultsWrite = {
    emitDefaultValues: !1,
    enumAsInteger: !1,
    useProtoFieldName: !1,
    prettySpaces: 0
  }, defaultsRead = {
    ignoreUnknownFields: !1
  };
  function jsonReadOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsRead), options) : defaultsRead;
  }
  exports.jsonReadOptions = jsonReadOptions;
  function jsonWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, defaultsWrite), options) : defaultsWrite;
  }
  exports.jsonWriteOptions = jsonWriteOptions;
  function mergeJsonOptions(a, b) {
    var _a, _b;
    let c = Object.assign(Object.assign({}, a), b);
    return c.typeRegistry = [...(_a = a === null || a === void 0 ? void 0 : a.typeRegistry) !== null && _a !== void 0 ? _a : [], ...(_b = b === null || b === void 0 ? void 0 : b.typeRegistry) !== null && _b !== void 0 ? _b : []], c;
  }
  exports.mergeJsonOptions = mergeJsonOptions;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/message-type-contract.js
var require_message_type_contract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.MESSAGE_TYPE = void 0;
  exports.MESSAGE_TYPE = Symbol.for("protobuf-ts/message-type");
});

// node_modules/@protobuf-ts/runtime/build/commonjs/lower-camel-case.js
var require_lower_camel_case = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.lowerCamelCase = void 0;
  function lowerCamelCase(snakeCase) {
    let capNext = !1, sb = [];
    for (let i = 0;i < snakeCase.length; i++) {
      let next = snakeCase.charAt(i);
      if (next == "_")
        capNext = !0;
      else if (/\d/.test(next))
        sb.push(next), capNext = !0;
      else if (capNext)
        sb.push(next.toUpperCase()), capNext = !1;
      else if (i == 0)
        sb.push(next.toLowerCase());
      else
        sb.push(next);
    }
    return sb.join("");
  }
  exports.lowerCamelCase = lowerCamelCase;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-info.js
var require_reflection_info = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.readMessageOption = exports.readFieldOption = exports.readFieldOptions = exports.normalizeFieldInfo = exports.RepeatType = exports.LongType = exports.ScalarType = void 0;
  var lower_camel_case_1 = require_lower_camel_case(), ScalarType;
  (function(ScalarType2) {
    ScalarType2[ScalarType2.DOUBLE = 1] = "DOUBLE", ScalarType2[ScalarType2.FLOAT = 2] = "FLOAT", ScalarType2[ScalarType2.INT64 = 3] = "INT64", ScalarType2[ScalarType2.UINT64 = 4] = "UINT64", ScalarType2[ScalarType2.INT32 = 5] = "INT32", ScalarType2[ScalarType2.FIXED64 = 6] = "FIXED64", ScalarType2[ScalarType2.FIXED32 = 7] = "FIXED32", ScalarType2[ScalarType2.BOOL = 8] = "BOOL", ScalarType2[ScalarType2.STRING = 9] = "STRING", ScalarType2[ScalarType2.BYTES = 12] = "BYTES", ScalarType2[ScalarType2.UINT32 = 13] = "UINT32", ScalarType2[ScalarType2.SFIXED32 = 15] = "SFIXED32", ScalarType2[ScalarType2.SFIXED64 = 16] = "SFIXED64", ScalarType2[ScalarType2.SINT32 = 17] = "SINT32", ScalarType2[ScalarType2.SINT64 = 18] = "SINT64";
  })(ScalarType = exports.ScalarType || (exports.ScalarType = {}));
  var LongType;
  (function(LongType2) {
    LongType2[LongType2.BIGINT = 0] = "BIGINT", LongType2[LongType2.STRING = 1] = "STRING", LongType2[LongType2.NUMBER = 2] = "NUMBER";
  })(LongType = exports.LongType || (exports.LongType = {}));
  var RepeatType;
  (function(RepeatType2) {
    RepeatType2[RepeatType2.NO = 0] = "NO", RepeatType2[RepeatType2.PACKED = 1] = "PACKED", RepeatType2[RepeatType2.UNPACKED = 2] = "UNPACKED";
  })(RepeatType = exports.RepeatType || (exports.RepeatType = {}));
  function normalizeFieldInfo(field) {
    var _a, _b, _c, _d;
    return field.localName = (_a = field.localName) !== null && _a !== void 0 ? _a : lower_camel_case_1.lowerCamelCase(field.name), field.jsonName = (_b = field.jsonName) !== null && _b !== void 0 ? _b : lower_camel_case_1.lowerCamelCase(field.name), field.repeat = (_c = field.repeat) !== null && _c !== void 0 ? _c : RepeatType.NO, field.opt = (_d = field.opt) !== null && _d !== void 0 ? _d : field.repeat ? !1 : field.oneof ? !1 : field.kind == "message", field;
  }
  exports.normalizeFieldInfo = normalizeFieldInfo;
  function readFieldOptions(messageType, fieldName, extensionName, extensionType) {
    var _a;
    let options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : void 0;
  }
  exports.readFieldOptions = readFieldOptions;
  function readFieldOption(messageType, fieldName, extensionName, extensionType) {
    var _a;
    let options = (_a = messageType.fields.find((m, i) => m.localName == fieldName || i == fieldName)) === null || _a === void 0 ? void 0 : _a.options;
    if (!options)
      return;
    let optionVal = options[extensionName];
    if (optionVal === void 0)
      return optionVal;
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readFieldOption = readFieldOption;
  function readMessageOption(messageType, extensionName, extensionType) {
    let optionVal = messageType.options[extensionName];
    if (optionVal === void 0)
      return optionVal;
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readMessageOption = readMessageOption;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/oneof.js
var require_oneof = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getSelectedOneofValue = exports.clearOneofValue = exports.setUnknownOneofValue = exports.setOneofValue = exports.getOneofValue = exports.isOneofGroup = void 0;
  function isOneofGroup(any) {
    if (typeof any != "object" || any === null || !any.hasOwnProperty("oneofKind"))
      return !1;
    switch (typeof any.oneofKind) {
      case "string":
        if (any[any.oneofKind] === void 0)
          return !1;
        return Object.keys(any).length == 2;
      case "undefined":
        return Object.keys(any).length == 1;
      default:
        return !1;
    }
  }
  exports.isOneofGroup = isOneofGroup;
  function getOneofValue(oneof, kind) {
    return oneof[kind];
  }
  exports.getOneofValue = getOneofValue;
  function setOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== void 0)
      delete oneof[oneof.oneofKind];
    if (oneof.oneofKind = kind, value !== void 0)
      oneof[kind] = value;
  }
  exports.setOneofValue = setOneofValue;
  function setUnknownOneofValue(oneof, kind, value) {
    if (oneof.oneofKind !== void 0)
      delete oneof[oneof.oneofKind];
    if (oneof.oneofKind = kind, value !== void 0 && kind !== void 0)
      oneof[kind] = value;
  }
  exports.setUnknownOneofValue = setUnknownOneofValue;
  function clearOneofValue(oneof) {
    if (oneof.oneofKind !== void 0)
      delete oneof[oneof.oneofKind];
    oneof.oneofKind = void 0;
  }
  exports.clearOneofValue = clearOneofValue;
  function getSelectedOneofValue(oneof) {
    if (oneof.oneofKind === void 0)
      return;
    return oneof[oneof.oneofKind];
  }
  exports.getSelectedOneofValue = getSelectedOneofValue;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-type-check.js
var require_reflection_type_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ReflectionTypeCheck = void 0;
  var reflection_info_1 = require_reflection_info(), oneof_1 = require_oneof();

  class ReflectionTypeCheck {
    constructor(info) {
      var _a;
      this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    prepare() {
      if (this.data)
        return;
      let req = [], known = [], oneofs = [];
      for (let field of this.fields)
        if (field.oneof) {
          if (!oneofs.includes(field.oneof))
            oneofs.push(field.oneof), req.push(field.oneof), known.push(field.oneof);
        } else
          switch (known.push(field.localName), field.kind) {
            case "scalar":
            case "enum":
              if (!field.opt || field.repeat)
                req.push(field.localName);
              break;
            case "message":
              if (field.repeat)
                req.push(field.localName);
              break;
            case "map":
              req.push(field.localName);
              break;
          }
      this.data = { req, known, oneofs: Object.values(oneofs) };
    }
    is(message, depth, allowExcessProperties = !1) {
      if (depth < 0)
        return !0;
      if (message === null || message === void 0 || typeof message != "object")
        return !1;
      this.prepare();
      let keys = Object.keys(message), data = this.data;
      if (keys.length < data.req.length || data.req.some((n) => !keys.includes(n)))
        return !1;
      if (!allowExcessProperties) {
        if (keys.some((k) => !data.known.includes(k)))
          return !1;
      }
      if (depth < 1)
        return !0;
      for (let name of data.oneofs) {
        let group = message[name];
        if (!oneof_1.isOneofGroup(group))
          return !1;
        if (group.oneofKind === void 0)
          continue;
        let field = this.fields.find((f) => f.localName === group.oneofKind);
        if (!field)
          return !1;
        if (!this.field(group[group.oneofKind], field, allowExcessProperties, depth))
          return !1;
      }
      for (let field of this.fields) {
        if (field.oneof !== void 0)
          continue;
        if (!this.field(message[field.localName], field, allowExcessProperties, depth))
          return !1;
      }
      return !0;
    }
    field(arg, field, allowExcessProperties, depth) {
      let repeated = field.repeat;
      switch (field.kind) {
        case "scalar":
          if (arg === void 0)
            return field.opt;
          if (repeated)
            return this.scalars(arg, field.T, depth, field.L);
          return this.scalar(arg, field.T, field.L);
        case "enum":
          if (arg === void 0)
            return field.opt;
          if (repeated)
            return this.scalars(arg, reflection_info_1.ScalarType.INT32, depth);
          return this.scalar(arg, reflection_info_1.ScalarType.INT32);
        case "message":
          if (arg === void 0)
            return !0;
          if (repeated)
            return this.messages(arg, field.T(), allowExcessProperties, depth);
          return this.message(arg, field.T(), allowExcessProperties, depth);
        case "map":
          if (typeof arg != "object" || arg === null)
            return !1;
          if (depth < 2)
            return !0;
          if (!this.mapKeys(arg, field.K, depth))
            return !1;
          switch (field.V.kind) {
            case "scalar":
              return this.scalars(Object.values(arg), field.V.T, depth, field.V.L);
            case "enum":
              return this.scalars(Object.values(arg), reflection_info_1.ScalarType.INT32, depth);
            case "message":
              return this.messages(Object.values(arg), field.V.T(), allowExcessProperties, depth);
          }
          break;
      }
      return !0;
    }
    message(arg, type, allowExcessProperties, depth) {
      if (allowExcessProperties)
        return type.isAssignable(arg, depth);
      return type.is(arg, depth);
    }
    messages(arg, type, allowExcessProperties, depth) {
      if (!Array.isArray(arg))
        return !1;
      if (depth < 2)
        return !0;
      if (allowExcessProperties) {
        for (let i = 0;i < arg.length && i < depth; i++)
          if (!type.isAssignable(arg[i], depth - 1))
            return !1;
      } else
        for (let i = 0;i < arg.length && i < depth; i++)
          if (!type.is(arg[i], depth - 1))
            return !1;
      return !0;
    }
    scalar(arg, type, longType) {
      let argType = typeof arg;
      switch (type) {
        case reflection_info_1.ScalarType.UINT64:
        case reflection_info_1.ScalarType.FIXED64:
        case reflection_info_1.ScalarType.INT64:
        case reflection_info_1.ScalarType.SFIXED64:
        case reflection_info_1.ScalarType.SINT64:
          switch (longType) {
            case reflection_info_1.LongType.BIGINT:
              return argType == "bigint";
            case reflection_info_1.LongType.NUMBER:
              return argType == "number" && !isNaN(arg);
            default:
              return argType == "string";
          }
        case reflection_info_1.ScalarType.BOOL:
          return argType == "boolean";
        case reflection_info_1.ScalarType.STRING:
          return argType == "string";
        case reflection_info_1.ScalarType.BYTES:
          return arg instanceof Uint8Array;
        case reflection_info_1.ScalarType.DOUBLE:
        case reflection_info_1.ScalarType.FLOAT:
          return argType == "number" && !isNaN(arg);
        default:
          return argType == "number" && Number.isInteger(arg);
      }
    }
    scalars(arg, type, depth, longType) {
      if (!Array.isArray(arg))
        return !1;
      if (depth < 2)
        return !0;
      if (Array.isArray(arg)) {
        for (let i = 0;i < arg.length && i < depth; i++)
          if (!this.scalar(arg[i], type, longType))
            return !1;
      }
      return !0;
    }
    mapKeys(map, type, depth) {
      let keys = Object.keys(map);
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
        case reflection_info_1.ScalarType.UINT32:
          return this.scalars(keys.slice(0, depth).map((k) => parseInt(k)), type, depth);
        case reflection_info_1.ScalarType.BOOL:
          return this.scalars(keys.slice(0, depth).map((k) => k == "true" ? !0 : k == "false" ? !1 : k), type, depth);
        default:
          return this.scalars(keys, type, depth, reflection_info_1.LongType.STRING);
      }
    }
  }
  exports.ReflectionTypeCheck = ReflectionTypeCheck;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-long-convert.js
var require_reflection_long_convert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.reflectionLongConvert = void 0;
  var reflection_info_1 = require_reflection_info();
  function reflectionLongConvert(long, type) {
    switch (type) {
      case reflection_info_1.LongType.BIGINT:
        return long.toBigInt();
      case reflection_info_1.LongType.NUMBER:
        return long.toNumber();
      default:
        return long.toString();
    }
  }
  exports.reflectionLongConvert = reflectionLongConvert;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-json-reader.js
var require_reflection_json_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ReflectionJsonReader = void 0;
  var json_typings_1 = require_json_typings(), base64_1 = require_base64(), reflection_info_1 = require_reflection_info(), pb_long_1 = require_pb_long(), assert_1 = require_assert(), reflection_long_convert_1 = require_reflection_long_convert();

  class ReflectionJsonReader {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      var _a;
      if (this.fMap === void 0) {
        this.fMap = {};
        let fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
        for (let field of fieldsInput)
          this.fMap[field.name] = field, this.fMap[field.jsonName] = field, this.fMap[field.localName] = field;
      }
    }
    assert(condition, fieldName, jsonValue) {
      if (!condition) {
        let what = json_typings_1.typeofJsonValue(jsonValue);
        if (what == "number" || what == "boolean")
          what = jsonValue.toString();
        throw Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`);
      }
    }
    read(input, message, options) {
      this.prepare();
      let oneofsHandled = [];
      for (let [jsonKey, jsonValue] of Object.entries(input)) {
        let field = this.fMap[jsonKey];
        if (!field) {
          if (!options.ignoreUnknownFields)
            throw Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);
          continue;
        }
        let localName = field.localName, target;
        if (field.oneof) {
          if (jsonValue === null && (field.kind !== "enum" || field.T()[0] !== "google.protobuf.NullValue"))
            continue;
          if (oneofsHandled.includes(field.oneof))
            throw Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);
          oneofsHandled.push(field.oneof), target = message[field.oneof] = {
            oneofKind: localName
          };
        } else
          target = message;
        if (field.kind == "map") {
          if (jsonValue === null)
            continue;
          this.assert(json_typings_1.isJsonObject(jsonValue), field.name, jsonValue);
          let fieldObj = target[localName];
          for (let [jsonObjKey, jsonObjValue] of Object.entries(jsonValue)) {
            this.assert(jsonObjValue !== null, field.name + " map value", null);
            let val;
            switch (field.V.kind) {
              case "message":
                val = field.V.T().internalJsonRead(jsonObjValue, options);
                break;
              case "enum":
                if (val = this.enum(field.V.T(), jsonObjValue, field.name, options.ignoreUnknownFields), val === !1)
                  continue;
                break;
              case "scalar":
                val = this.scalar(jsonObjValue, field.V.T, field.V.L, field.name);
                break;
            }
            this.assert(val !== void 0, field.name + " map value", jsonObjValue);
            let key = jsonObjKey;
            if (field.K == reflection_info_1.ScalarType.BOOL)
              key = key == "true" ? !0 : key == "false" ? !1 : key;
            key = this.scalar(key, field.K, reflection_info_1.LongType.STRING, field.name).toString(), fieldObj[key] = val;
          }
        } else if (field.repeat) {
          if (jsonValue === null)
            continue;
          this.assert(Array.isArray(jsonValue), field.name, jsonValue);
          let fieldArr = target[localName];
          for (let jsonItem of jsonValue) {
            this.assert(jsonItem !== null, field.name, null);
            let val;
            switch (field.kind) {
              case "message":
                val = field.T().internalJsonRead(jsonItem, options);
                break;
              case "enum":
                if (val = this.enum(field.T(), jsonItem, field.name, options.ignoreUnknownFields), val === !1)
                  continue;
                break;
              case "scalar":
                val = this.scalar(jsonItem, field.T, field.L, field.name);
                break;
            }
            this.assert(val !== void 0, field.name, jsonValue), fieldArr.push(val);
          }
        } else
          switch (field.kind) {
            case "message":
              if (jsonValue === null && field.T().typeName != "google.protobuf.Value") {
                this.assert(field.oneof === void 0, field.name + " (oneof member)", null);
                continue;
              }
              target[localName] = field.T().internalJsonRead(jsonValue, options, target[localName]);
              break;
            case "enum":
              let val = this.enum(field.T(), jsonValue, field.name, options.ignoreUnknownFields);
              if (val === !1)
                continue;
              target[localName] = val;
              break;
            case "scalar":
              target[localName] = this.scalar(jsonValue, field.T, field.L, field.name);
              break;
          }
      }
    }
    enum(type, json, fieldName, ignoreUnknownFields) {
      if (type[0] == "google.protobuf.NullValue")
        assert_1.assert(json === null || json === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);
      if (json === null)
        return 0;
      switch (typeof json) {
        case "number":
          return assert_1.assert(Number.isInteger(json), `Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`), json;
        case "string":
          let localEnumName = json;
          if (type[2] && json.substring(0, type[2].length) === type[2])
            localEnumName = json.substring(type[2].length);
          let enumNumber = type[1][localEnumName];
          if (typeof enumNumber > "u" && ignoreUnknownFields)
            return !1;
          return assert_1.assert(typeof enumNumber == "number", `Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`), enumNumber;
      }
      assert_1.assert(!1, `Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`);
    }
    scalar(json, type, longType, fieldName) {
      let e;
      try {
        switch (type) {
          case reflection_info_1.ScalarType.DOUBLE:
          case reflection_info_1.ScalarType.FLOAT:
            if (json === null)
              return 0;
            if (json === "NaN")
              return Number.NaN;
            if (json === "Infinity")
              return Number.POSITIVE_INFINITY;
            if (json === "-Infinity")
              return Number.NEGATIVE_INFINITY;
            if (json === "") {
              e = "empty string";
              break;
            }
            if (typeof json == "string" && json.trim().length !== json.length) {
              e = "extra whitespace";
              break;
            }
            if (typeof json != "string" && typeof json != "number")
              break;
            let float = Number(json);
            if (Number.isNaN(float)) {
              e = "not a number";
              break;
            }
            if (!Number.isFinite(float)) {
              e = "too large or small";
              break;
            }
            if (type == reflection_info_1.ScalarType.FLOAT)
              assert_1.assertFloat32(float);
            return float;
          case reflection_info_1.ScalarType.INT32:
          case reflection_info_1.ScalarType.FIXED32:
          case reflection_info_1.ScalarType.SFIXED32:
          case reflection_info_1.ScalarType.SINT32:
          case reflection_info_1.ScalarType.UINT32:
            if (json === null)
              return 0;
            let int32;
            if (typeof json == "number")
              int32 = json;
            else if (json === "")
              e = "empty string";
            else if (typeof json == "string")
              if (json.trim().length !== json.length)
                e = "extra whitespace";
              else
                int32 = Number(json);
            if (int32 === void 0)
              break;
            if (type == reflection_info_1.ScalarType.UINT32)
              assert_1.assertUInt32(int32);
            else
              assert_1.assertInt32(int32);
            return int32;
          case reflection_info_1.ScalarType.INT64:
          case reflection_info_1.ScalarType.SFIXED64:
          case reflection_info_1.ScalarType.SINT64:
            if (json === null)
              return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.ZERO, longType);
            if (typeof json != "number" && typeof json != "string")
              break;
            return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.from(json), longType);
          case reflection_info_1.ScalarType.FIXED64:
          case reflection_info_1.ScalarType.UINT64:
            if (json === null)
              return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.ZERO, longType);
            if (typeof json != "number" && typeof json != "string")
              break;
            return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.from(json), longType);
          case reflection_info_1.ScalarType.BOOL:
            if (json === null)
              return !1;
            if (typeof json !== "boolean")
              break;
            return json;
          case reflection_info_1.ScalarType.STRING:
            if (json === null)
              return "";
            if (typeof json !== "string") {
              e = "extra whitespace";
              break;
            }
            try {
              encodeURIComponent(json);
            } catch (e2) {
              e2 = "invalid UTF8";
              break;
            }
            return json;
          case reflection_info_1.ScalarType.BYTES:
            if (json === null || json === "")
              return new Uint8Array(0);
            if (typeof json !== "string")
              break;
            return base64_1.base64decode(json);
        }
      } catch (error) {
        e = error.message;
      }
      this.assert(!1, fieldName + (e ? " - " + e : ""), json);
    }
  }
  exports.ReflectionJsonReader = ReflectionJsonReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-json-writer.js
var require_reflection_json_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ReflectionJsonWriter = void 0;
  var base64_1 = require_base64(), pb_long_1 = require_pb_long(), reflection_info_1 = require_reflection_info(), assert_1 = require_assert();

  class ReflectionJsonWriter {
    constructor(info) {
      var _a;
      this.fields = (_a = info.fields) !== null && _a !== void 0 ? _a : [];
    }
    write(message, options) {
      let json = {}, source = message;
      for (let field of this.fields) {
        if (!field.oneof) {
          let jsonValue2 = this.field(field, source[field.localName], options);
          if (jsonValue2 !== void 0)
            json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue2;
          continue;
        }
        let group = source[field.oneof];
        if (group.oneofKind !== field.localName)
          continue;
        let opt = field.kind == "scalar" || field.kind == "enum" ? Object.assign(Object.assign({}, options), { emitDefaultValues: !0 }) : options, jsonValue = this.field(field, group[field.localName], opt);
        assert_1.assert(jsonValue !== void 0), json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
      }
      return json;
    }
    field(field, value, options) {
      let jsonValue = void 0;
      if (field.kind == "map") {
        assert_1.assert(typeof value == "object" && value !== null);
        let jsonObj = {};
        switch (field.V.kind) {
          case "scalar":
            for (let [entryKey, entryValue] of Object.entries(value)) {
              let val = this.scalar(field.V.T, entryValue, field.name, !1, !0);
              assert_1.assert(val !== void 0), jsonObj[entryKey.toString()] = val;
            }
            break;
          case "message":
            let messageType = field.V.T();
            for (let [entryKey, entryValue] of Object.entries(value)) {
              let val = this.message(messageType, entryValue, field.name, options);
              assert_1.assert(val !== void 0), jsonObj[entryKey.toString()] = val;
            }
            break;
          case "enum":
            let enumInfo = field.V.T();
            for (let [entryKey, entryValue] of Object.entries(value)) {
              assert_1.assert(entryValue === void 0 || typeof entryValue == "number");
              let val = this.enum(enumInfo, entryValue, field.name, !1, !0, options.enumAsInteger);
              assert_1.assert(val !== void 0), jsonObj[entryKey.toString()] = val;
            }
            break;
        }
        if (options.emitDefaultValues || Object.keys(jsonObj).length > 0)
          jsonValue = jsonObj;
      } else if (field.repeat) {
        assert_1.assert(Array.isArray(value));
        let jsonArr = [];
        switch (field.kind) {
          case "scalar":
            for (let i = 0;i < value.length; i++) {
              let val = this.scalar(field.T, value[i], field.name, field.opt, !0);
              assert_1.assert(val !== void 0), jsonArr.push(val);
            }
            break;
          case "enum":
            let enumInfo = field.T();
            for (let i = 0;i < value.length; i++) {
              assert_1.assert(value[i] === void 0 || typeof value[i] == "number");
              let val = this.enum(enumInfo, value[i], field.name, field.opt, !0, options.enumAsInteger);
              assert_1.assert(val !== void 0), jsonArr.push(val);
            }
            break;
          case "message":
            let messageType = field.T();
            for (let i = 0;i < value.length; i++) {
              let val = this.message(messageType, value[i], field.name, options);
              assert_1.assert(val !== void 0), jsonArr.push(val);
            }
            break;
        }
        if (options.emitDefaultValues || jsonArr.length > 0 || options.emitDefaultValues)
          jsonValue = jsonArr;
      } else
        switch (field.kind) {
          case "scalar":
            jsonValue = this.scalar(field.T, value, field.name, field.opt, options.emitDefaultValues);
            break;
          case "enum":
            jsonValue = this.enum(field.T(), value, field.name, field.opt, options.emitDefaultValues, options.enumAsInteger);
            break;
          case "message":
            jsonValue = this.message(field.T(), value, field.name, options);
            break;
        }
      return jsonValue;
    }
    enum(type, value, fieldName, optional, emitDefaultValues, enumAsInteger) {
      if (type[0] == "google.protobuf.NullValue")
        return !emitDefaultValues && !optional ? void 0 : null;
      if (value === void 0) {
        assert_1.assert(optional);
        return;
      }
      if (value === 0 && !emitDefaultValues && !optional)
        return;
      if (assert_1.assert(typeof value == "number"), assert_1.assert(Number.isInteger(value)), enumAsInteger || !type[1].hasOwnProperty(value))
        return value;
      if (type[2])
        return type[2] + type[1][value];
      return type[1][value];
    }
    message(type, value, fieldName, options) {
      if (value === void 0)
        return options.emitDefaultValues ? null : void 0;
      return type.internalJsonWrite(value, options);
    }
    scalar(type, value, fieldName, optional, emitDefaultValues) {
      if (value === void 0) {
        assert_1.assert(optional);
        return;
      }
      let ed = emitDefaultValues || optional;
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
          if (value === 0)
            return ed ? 0 : void 0;
          return assert_1.assertInt32(value), value;
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.UINT32:
          if (value === 0)
            return ed ? 0 : void 0;
          return assert_1.assertUInt32(value), value;
        case reflection_info_1.ScalarType.FLOAT:
          assert_1.assertFloat32(value);
        case reflection_info_1.ScalarType.DOUBLE:
          if (value === 0)
            return ed ? 0 : void 0;
          if (assert_1.assert(typeof value == "number"), Number.isNaN(value))
            return "NaN";
          if (value === Number.POSITIVE_INFINITY)
            return "Infinity";
          if (value === Number.NEGATIVE_INFINITY)
            return "-Infinity";
          return value;
        case reflection_info_1.ScalarType.STRING:
          if (value === "")
            return ed ? "" : void 0;
          return assert_1.assert(typeof value == "string"), value;
        case reflection_info_1.ScalarType.BOOL:
          if (value === !1)
            return ed ? !1 : void 0;
          return assert_1.assert(typeof value == "boolean"), value;
        case reflection_info_1.ScalarType.UINT64:
        case reflection_info_1.ScalarType.FIXED64:
          assert_1.assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
          let ulong = pb_long_1.PbULong.from(value);
          if (ulong.isZero() && !ed)
            return;
          return ulong.toString();
        case reflection_info_1.ScalarType.INT64:
        case reflection_info_1.ScalarType.SFIXED64:
        case reflection_info_1.ScalarType.SINT64:
          assert_1.assert(typeof value == "number" || typeof value == "string" || typeof value == "bigint");
          let long = pb_long_1.PbLong.from(value);
          if (long.isZero() && !ed)
            return;
          return long.toString();
        case reflection_info_1.ScalarType.BYTES:
          if (assert_1.assert(value instanceof Uint8Array), !value.byteLength)
            return ed ? "" : void 0;
          return base64_1.base64encode(value);
      }
    }
  }
  exports.ReflectionJsonWriter = ReflectionJsonWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-scalar-default.js
var require_reflection_scalar_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.reflectionScalarDefault = void 0;
  var reflection_info_1 = require_reflection_info(), reflection_long_convert_1 = require_reflection_long_convert(), pb_long_1 = require_pb_long();
  function reflectionScalarDefault(type, longType = reflection_info_1.LongType.STRING) {
    switch (type) {
      case reflection_info_1.ScalarType.BOOL:
        return !1;
      case reflection_info_1.ScalarType.UINT64:
      case reflection_info_1.ScalarType.FIXED64:
        return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbULong.ZERO, longType);
      case reflection_info_1.ScalarType.INT64:
      case reflection_info_1.ScalarType.SFIXED64:
      case reflection_info_1.ScalarType.SINT64:
        return reflection_long_convert_1.reflectionLongConvert(pb_long_1.PbLong.ZERO, longType);
      case reflection_info_1.ScalarType.DOUBLE:
      case reflection_info_1.ScalarType.FLOAT:
        return 0;
      case reflection_info_1.ScalarType.BYTES:
        return new Uint8Array(0);
      case reflection_info_1.ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  exports.reflectionScalarDefault = reflectionScalarDefault;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-binary-reader.js
var require_reflection_binary_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ReflectionBinaryReader = void 0;
  var binary_format_contract_1 = require_binary_format_contract(), reflection_info_1 = require_reflection_info(), reflection_long_convert_1 = require_reflection_long_convert(), reflection_scalar_default_1 = require_reflection_scalar_default();

  class ReflectionBinaryReader {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      var _a;
      if (!this.fieldNoToField) {
        let fieldsInput = (_a = this.info.fields) !== null && _a !== void 0 ? _a : [];
        this.fieldNoToField = new Map(fieldsInput.map((field) => [field.no, field]));
      }
    }
    read(reader, message, options, length) {
      this.prepare();
      let end = length === void 0 ? reader.len : reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag(), field = this.fieldNoToField.get(fieldNo);
        if (!field) {
          let u = options.readUnknownField;
          if (u == "throw")
            throw Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);
          let d = reader.skip(wireType);
          if (u !== !1)
            (u === !0 ? binary_format_contract_1.UnknownFieldHandler.onRead : u)(this.info.typeName, message, fieldNo, wireType, d);
          continue;
        }
        let target = message, repeated = field.repeat, localName = field.localName;
        if (field.oneof) {
          if (target = target[field.oneof], target.oneofKind !== localName)
            target = message[field.oneof] = {
              oneofKind: localName
            };
        }
        switch (field.kind) {
          case "scalar":
          case "enum":
            let T = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T, L = field.kind == "scalar" ? field.L : void 0;
            if (repeated) {
              let arr = target[localName];
              if (wireType == binary_format_contract_1.WireType.LengthDelimited && T != reflection_info_1.ScalarType.STRING && T != reflection_info_1.ScalarType.BYTES) {
                let e = reader.uint32() + reader.pos;
                while (reader.pos < e)
                  arr.push(this.scalar(reader, T, L));
              } else
                arr.push(this.scalar(reader, T, L));
            } else
              target[localName] = this.scalar(reader, T, L);
            break;
          case "message":
            if (repeated) {
              let arr = target[localName], msg = field.T().internalBinaryRead(reader, reader.uint32(), options);
              arr.push(msg);
            } else
              target[localName] = field.T().internalBinaryRead(reader, reader.uint32(), options, target[localName]);
            break;
          case "map":
            let [mapKey, mapVal] = this.mapEntry(field, reader, options);
            target[localName][mapKey] = mapVal;
            break;
        }
      }
    }
    mapEntry(field, reader, options) {
      let length = reader.uint32(), end = reader.pos + length, key = void 0, val = void 0;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            if (field.K == reflection_info_1.ScalarType.BOOL)
              key = reader.bool().toString();
            else
              key = this.scalar(reader, field.K, reflection_info_1.LongType.STRING);
            break;
          case 2:
            switch (field.V.kind) {
              case "scalar":
                val = this.scalar(reader, field.V.T, field.V.L);
                break;
              case "enum":
                val = reader.int32();
                break;
              case "message":
                val = field.V.T().internalBinaryRead(reader, reader.uint32(), options);
                break;
            }
            break;
          default:
            throw Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`);
        }
      }
      if (key === void 0) {
        let keyRaw = reflection_scalar_default_1.reflectionScalarDefault(field.K);
        key = field.K == reflection_info_1.ScalarType.BOOL ? keyRaw.toString() : keyRaw;
      }
      if (val === void 0)
        switch (field.V.kind) {
          case "scalar":
            val = reflection_scalar_default_1.reflectionScalarDefault(field.V.T, field.V.L);
            break;
          case "enum":
            val = 0;
            break;
          case "message":
            val = field.V.T().create();
            break;
        }
      return [key, val];
    }
    scalar(reader, type, longType) {
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
          return reader.int32();
        case reflection_info_1.ScalarType.STRING:
          return reader.string();
        case reflection_info_1.ScalarType.BOOL:
          return reader.bool();
        case reflection_info_1.ScalarType.DOUBLE:
          return reader.double();
        case reflection_info_1.ScalarType.FLOAT:
          return reader.float();
        case reflection_info_1.ScalarType.INT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.int64(), longType);
        case reflection_info_1.ScalarType.UINT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.uint64(), longType);
        case reflection_info_1.ScalarType.FIXED64:
          return reflection_long_convert_1.reflectionLongConvert(reader.fixed64(), longType);
        case reflection_info_1.ScalarType.FIXED32:
          return reader.fixed32();
        case reflection_info_1.ScalarType.BYTES:
          return reader.bytes();
        case reflection_info_1.ScalarType.UINT32:
          return reader.uint32();
        case reflection_info_1.ScalarType.SFIXED32:
          return reader.sfixed32();
        case reflection_info_1.ScalarType.SFIXED64:
          return reflection_long_convert_1.reflectionLongConvert(reader.sfixed64(), longType);
        case reflection_info_1.ScalarType.SINT32:
          return reader.sint32();
        case reflection_info_1.ScalarType.SINT64:
          return reflection_long_convert_1.reflectionLongConvert(reader.sint64(), longType);
      }
    }
  }
  exports.ReflectionBinaryReader = ReflectionBinaryReader;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-binary-writer.js
var require_reflection_binary_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ReflectionBinaryWriter = void 0;
  var binary_format_contract_1 = require_binary_format_contract(), reflection_info_1 = require_reflection_info(), assert_1 = require_assert(), pb_long_1 = require_pb_long();

  class ReflectionBinaryWriter {
    constructor(info) {
      this.info = info;
    }
    prepare() {
      if (!this.fields) {
        let fieldsInput = this.info.fields ? this.info.fields.concat() : [];
        this.fields = fieldsInput.sort((a, b) => a.no - b.no);
      }
    }
    write(message, writer, options) {
      this.prepare();
      for (let field of this.fields) {
        let value, emitDefault, repeated = field.repeat, localName = field.localName;
        if (field.oneof) {
          let group = message[field.oneof];
          if (group.oneofKind !== localName)
            continue;
          value = group[localName], emitDefault = !0;
        } else
          value = message[localName], emitDefault = !1;
        switch (field.kind) {
          case "scalar":
          case "enum":
            let T = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
            if (repeated)
              if (assert_1.assert(Array.isArray(value)), repeated == reflection_info_1.RepeatType.PACKED)
                this.packed(writer, T, field.no, value);
              else
                for (let item of value)
                  this.scalar(writer, T, field.no, item, !0);
            else if (value === void 0)
              assert_1.assert(field.opt);
            else
              this.scalar(writer, T, field.no, value, emitDefault || field.opt);
            break;
          case "message":
            if (repeated) {
              assert_1.assert(Array.isArray(value));
              for (let item of value)
                this.message(writer, options, field.T(), field.no, item);
            } else
              this.message(writer, options, field.T(), field.no, value);
            break;
          case "map":
            assert_1.assert(typeof value == "object" && value !== null);
            for (let [key, val] of Object.entries(value))
              this.mapEntry(writer, options, field, key, val);
            break;
        }
      }
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u === !0 ? binary_format_contract_1.UnknownFieldHandler.onWrite : u)(this.info.typeName, message, writer);
    }
    mapEntry(writer, options, field, key, value) {
      writer.tag(field.no, binary_format_contract_1.WireType.LengthDelimited), writer.fork();
      let keyValue = key;
      switch (field.K) {
        case reflection_info_1.ScalarType.INT32:
        case reflection_info_1.ScalarType.FIXED32:
        case reflection_info_1.ScalarType.UINT32:
        case reflection_info_1.ScalarType.SFIXED32:
        case reflection_info_1.ScalarType.SINT32:
          keyValue = Number.parseInt(key);
          break;
        case reflection_info_1.ScalarType.BOOL:
          assert_1.assert(key == "true" || key == "false"), keyValue = key == "true";
          break;
      }
      switch (this.scalar(writer, field.K, 1, keyValue, !0), field.V.kind) {
        case "scalar":
          this.scalar(writer, field.V.T, 2, value, !0);
          break;
        case "enum":
          this.scalar(writer, reflection_info_1.ScalarType.INT32, 2, value, !0);
          break;
        case "message":
          this.message(writer, options, field.V.T(), 2, value);
          break;
      }
      writer.join();
    }
    message(writer, options, handler, fieldNo, value) {
      if (value === void 0)
        return;
      handler.internalBinaryWrite(value, writer.tag(fieldNo, binary_format_contract_1.WireType.LengthDelimited).fork(), options), writer.join();
    }
    scalar(writer, type, fieldNo, value, emitDefault) {
      let [wireType, method, isDefault] = this.scalarInfo(type, value);
      if (!isDefault || emitDefault)
        writer.tag(fieldNo, wireType), writer[method](value);
    }
    packed(writer, type, fieldNo, value) {
      if (!value.length)
        return;
      assert_1.assert(type !== reflection_info_1.ScalarType.BYTES && type !== reflection_info_1.ScalarType.STRING), writer.tag(fieldNo, binary_format_contract_1.WireType.LengthDelimited), writer.fork();
      let [, method] = this.scalarInfo(type);
      for (let i = 0;i < value.length; i++)
        writer[method](value[i]);
      writer.join();
    }
    scalarInfo(type, value) {
      let t = binary_format_contract_1.WireType.Varint, m, i = value === void 0, d = value === 0;
      switch (type) {
        case reflection_info_1.ScalarType.INT32:
          m = "int32";
          break;
        case reflection_info_1.ScalarType.STRING:
          d = i || !value.length, t = binary_format_contract_1.WireType.LengthDelimited, m = "string";
          break;
        case reflection_info_1.ScalarType.BOOL:
          d = value === !1, m = "bool";
          break;
        case reflection_info_1.ScalarType.UINT32:
          m = "uint32";
          break;
        case reflection_info_1.ScalarType.DOUBLE:
          t = binary_format_contract_1.WireType.Bit64, m = "double";
          break;
        case reflection_info_1.ScalarType.FLOAT:
          t = binary_format_contract_1.WireType.Bit32, m = "float";
          break;
        case reflection_info_1.ScalarType.INT64:
          d = i || pb_long_1.PbLong.from(value).isZero(), m = "int64";
          break;
        case reflection_info_1.ScalarType.UINT64:
          d = i || pb_long_1.PbULong.from(value).isZero(), m = "uint64";
          break;
        case reflection_info_1.ScalarType.FIXED64:
          d = i || pb_long_1.PbULong.from(value).isZero(), t = binary_format_contract_1.WireType.Bit64, m = "fixed64";
          break;
        case reflection_info_1.ScalarType.BYTES:
          d = i || !value.byteLength, t = binary_format_contract_1.WireType.LengthDelimited, m = "bytes";
          break;
        case reflection_info_1.ScalarType.FIXED32:
          t = binary_format_contract_1.WireType.Bit32, m = "fixed32";
          break;
        case reflection_info_1.ScalarType.SFIXED32:
          t = binary_format_contract_1.WireType.Bit32, m = "sfixed32";
          break;
        case reflection_info_1.ScalarType.SFIXED64:
          d = i || pb_long_1.PbLong.from(value).isZero(), t = binary_format_contract_1.WireType.Bit64, m = "sfixed64";
          break;
        case reflection_info_1.ScalarType.SINT32:
          m = "sint32";
          break;
        case reflection_info_1.ScalarType.SINT64:
          d = i || pb_long_1.PbLong.from(value).isZero(), m = "sint64";
          break;
      }
      return [t, m, i || d];
    }
  }
  exports.ReflectionBinaryWriter = ReflectionBinaryWriter;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-create.js
var require_reflection_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.reflectionCreate = void 0;
  var reflection_scalar_default_1 = require_reflection_scalar_default(), message_type_contract_1 = require_message_type_contract();
  function reflectionCreate(type) {
    let msg = type.messagePrototype ? Object.create(type.messagePrototype) : Object.defineProperty({}, message_type_contract_1.MESSAGE_TYPE, { value: type });
    for (let field of type.fields) {
      let name = field.localName;
      if (field.opt)
        continue;
      if (field.oneof)
        msg[field.oneof] = { oneofKind: void 0 };
      else if (field.repeat)
        msg[name] = [];
      else
        switch (field.kind) {
          case "scalar":
            msg[name] = reflection_scalar_default_1.reflectionScalarDefault(field.T, field.L);
            break;
          case "enum":
            msg[name] = 0;
            break;
          case "map":
            msg[name] = {};
            break;
        }
    }
    return msg;
  }
  exports.reflectionCreate = reflectionCreate;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-merge-partial.js
var require_reflection_merge_partial = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.reflectionMergePartial = void 0;
  function reflectionMergePartial(info, target, source) {
    let fieldValue, input = source, output;
    for (let field of info.fields) {
      let name = field.localName;
      if (field.oneof) {
        let group = input[field.oneof];
        if ((group === null || group === void 0 ? void 0 : group.oneofKind) == null)
          continue;
        if (fieldValue = group[name], output = target[field.oneof], output.oneofKind = group.oneofKind, fieldValue == null) {
          delete output[name];
          continue;
        }
      } else if (fieldValue = input[name], output = target, fieldValue == null)
        continue;
      if (field.repeat)
        output[name].length = fieldValue.length;
      switch (field.kind) {
        case "scalar":
        case "enum":
          if (field.repeat)
            for (let i = 0;i < fieldValue.length; i++)
              output[name][i] = fieldValue[i];
          else
            output[name] = fieldValue;
          break;
        case "message":
          let T = field.T();
          if (field.repeat)
            for (let i = 0;i < fieldValue.length; i++)
              output[name][i] = T.create(fieldValue[i]);
          else if (output[name] === void 0)
            output[name] = T.create(fieldValue);
          else
            T.mergePartial(output[name], fieldValue);
          break;
        case "map":
          switch (field.V.kind) {
            case "scalar":
            case "enum":
              Object.assign(output[name], fieldValue);
              break;
            case "message":
              let T2 = field.V.T();
              for (let k of Object.keys(fieldValue))
                output[name][k] = T2.create(fieldValue[k]);
              break;
          }
          break;
      }
    }
  }
  exports.reflectionMergePartial = reflectionMergePartial;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-equals.js
var require_reflection_equals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.reflectionEquals = void 0;
  var reflection_info_1 = require_reflection_info();
  function reflectionEquals(info, a, b) {
    if (a === b)
      return !0;
    if (!a || !b)
      return !1;
    for (let field of info.fields) {
      let localName = field.localName, val_a = field.oneof ? a[field.oneof][localName] : a[localName], val_b = field.oneof ? b[field.oneof][localName] : b[localName];
      switch (field.kind) {
        case "enum":
        case "scalar":
          let t = field.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.T;
          if (!(field.repeat ? repeatedPrimitiveEq(t, val_a, val_b) : primitiveEq(t, val_a, val_b)))
            return !1;
          break;
        case "map":
          if (!(field.V.kind == "message" ? repeatedMsgEq(field.V.T(), objectValues(val_a), objectValues(val_b)) : repeatedPrimitiveEq(field.V.kind == "enum" ? reflection_info_1.ScalarType.INT32 : field.V.T, objectValues(val_a), objectValues(val_b))))
            return !1;
          break;
        case "message":
          let T = field.T();
          if (!(field.repeat ? repeatedMsgEq(T, val_a, val_b) : T.equals(val_a, val_b)))
            return !1;
          break;
      }
    }
    return !0;
  }
  exports.reflectionEquals = reflectionEquals;
  var objectValues = Object.values;
  function primitiveEq(type, a, b) {
    if (a === b)
      return !0;
    if (type !== reflection_info_1.ScalarType.BYTES)
      return !1;
    let ba = a, bb = b;
    if (ba.length !== bb.length)
      return !1;
    for (let i = 0;i < ba.length; i++)
      if (ba[i] != bb[i])
        return !1;
    return !0;
  }
  function repeatedPrimitiveEq(type, a, b) {
    if (a.length !== b.length)
      return !1;
    for (let i = 0;i < a.length; i++)
      if (!primitiveEq(type, a[i], b[i]))
        return !1;
    return !0;
  }
  function repeatedMsgEq(type, a, b) {
    if (a.length !== b.length)
      return !1;
    for (let i = 0;i < a.length; i++)
      if (!type.equals(a[i], b[i]))
        return !1;
    return !0;
  }
});

// node_modules/@protobuf-ts/runtime/build/commonjs/message-type.js
var require_message_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.MessageType = void 0;
  var message_type_contract_1 = require_message_type_contract(), reflection_info_1 = require_reflection_info(), reflection_type_check_1 = require_reflection_type_check(), reflection_json_reader_1 = require_reflection_json_reader(), reflection_json_writer_1 = require_reflection_json_writer(), reflection_binary_reader_1 = require_reflection_binary_reader(), reflection_binary_writer_1 = require_reflection_binary_writer(), reflection_create_1 = require_reflection_create(), reflection_merge_partial_1 = require_reflection_merge_partial(), json_typings_1 = require_json_typings(), json_format_contract_1 = require_json_format_contract(), reflection_equals_1 = require_reflection_equals(), binary_writer_1 = require_binary_writer(), binary_reader_1 = require_binary_reader(), baseDescriptors = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));

  class MessageType {
    constructor(name, fields, options) {
      this.defaultCheckDepth = 16, this.typeName = name, this.fields = fields.map(reflection_info_1.normalizeFieldInfo), this.options = options !== null && options !== void 0 ? options : {}, this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, baseDescriptors), { [message_type_contract_1.MESSAGE_TYPE]: { value: this } })), this.refTypeCheck = new reflection_type_check_1.ReflectionTypeCheck(this), this.refJsonReader = new reflection_json_reader_1.ReflectionJsonReader(this), this.refJsonWriter = new reflection_json_writer_1.ReflectionJsonWriter(this), this.refBinReader = new reflection_binary_reader_1.ReflectionBinaryReader(this), this.refBinWriter = new reflection_binary_writer_1.ReflectionBinaryWriter(this);
    }
    create(value) {
      let message = reflection_create_1.reflectionCreate(this);
      if (value !== void 0)
        reflection_merge_partial_1.reflectionMergePartial(this, message, value);
      return message;
    }
    clone(message) {
      let copy = this.create();
      return reflection_merge_partial_1.reflectionMergePartial(this, copy, message), copy;
    }
    equals(a, b) {
      return reflection_equals_1.reflectionEquals(this, a, b);
    }
    is(arg, depth = this.defaultCheckDepth) {
      return this.refTypeCheck.is(arg, depth, !1);
    }
    isAssignable(arg, depth = this.defaultCheckDepth) {
      return this.refTypeCheck.is(arg, depth, !0);
    }
    mergePartial(target, source) {
      reflection_merge_partial_1.reflectionMergePartial(this, target, source);
    }
    fromBinary(data, options) {
      let opt = binary_reader_1.binaryReadOptions(options);
      return this.internalBinaryRead(opt.readerFactory(data), data.byteLength, opt);
    }
    fromJson(json, options) {
      return this.internalJsonRead(json, json_format_contract_1.jsonReadOptions(options));
    }
    fromJsonString(json, options) {
      let value = JSON.parse(json);
      return this.fromJson(value, options);
    }
    toJson(message, options) {
      return this.internalJsonWrite(message, json_format_contract_1.jsonWriteOptions(options));
    }
    toJsonString(message, options) {
      var _a;
      let value = this.toJson(message, options);
      return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
    }
    toBinary(message, options) {
      let opt = binary_writer_1.binaryWriteOptions(options);
      return this.internalBinaryWrite(message, opt.writerFactory(), opt).finish();
    }
    internalJsonRead(json, options, target) {
      if (json !== null && typeof json == "object" && !Array.isArray(json)) {
        let message = target !== null && target !== void 0 ? target : this.create();
        return this.refJsonReader.read(json, message, options), message;
      }
      throw Error(`Unable to parse message ${this.typeName} from JSON ${json_typings_1.typeofJsonValue(json)}.`);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.write(message, options);
    }
    internalBinaryWrite(message, writer, options) {
      return this.refBinWriter.write(message, writer, options), writer;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create();
      return this.refBinReader.read(reader, message, options, length), message;
    }
  }
  exports.MessageType = MessageType;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/reflection-contains-message-type.js
var require_reflection_contains_message_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.containsMessageType = void 0;
  var message_type_contract_1 = require_message_type_contract();
  function containsMessageType(msg) {
    return msg[message_type_contract_1.MESSAGE_TYPE] != null;
  }
  exports.containsMessageType = containsMessageType;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/enum-object.js
var require_enum_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.listEnumNumbers = exports.listEnumNames = exports.listEnumValues = exports.isEnumObject = void 0;
  function isEnumObject(arg) {
    if (typeof arg != "object" || arg === null)
      return !1;
    if (!arg.hasOwnProperty(0))
      return !1;
    for (let k of Object.keys(arg)) {
      let num = parseInt(k);
      if (!Number.isNaN(num)) {
        let nam = arg[num];
        if (nam === void 0)
          return !1;
        if (arg[nam] !== num)
          return !1;
      } else {
        let num2 = arg[k];
        if (num2 === void 0)
          return !1;
        if (typeof num2 !== "number")
          return !1;
        if (arg[num2] === void 0)
          return !1;
      }
    }
    return !0;
  }
  exports.isEnumObject = isEnumObject;
  function listEnumValues(enumObject) {
    if (!isEnumObject(enumObject))
      throw Error("not a typescript enum object");
    let values = [];
    for (let [name, number] of Object.entries(enumObject))
      if (typeof number == "number")
        values.push({ name, number });
    return values;
  }
  exports.listEnumValues = listEnumValues;
  function listEnumNames(enumObject) {
    return listEnumValues(enumObject).map((val) => val.name);
  }
  exports.listEnumNames = listEnumNames;
  function listEnumNumbers(enumObject) {
    return listEnumValues(enumObject).map((val) => val.number).filter((num, index, arr) => arr.indexOf(num) == index);
  }
  exports.listEnumNumbers = listEnumNumbers;
});

// node_modules/@protobuf-ts/runtime/build/commonjs/index.js
var require_commonjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var json_typings_1 = require_json_typings();
  Object.defineProperty(exports, "typeofJsonValue", { enumerable: !0, get: function() {
    return json_typings_1.typeofJsonValue;
  } });
  Object.defineProperty(exports, "isJsonObject", { enumerable: !0, get: function() {
    return json_typings_1.isJsonObject;
  } });
  var base64_1 = require_base64();
  Object.defineProperty(exports, "base64decode", { enumerable: !0, get: function() {
    return base64_1.base64decode;
  } });
  Object.defineProperty(exports, "base64encode", { enumerable: !0, get: function() {
    return base64_1.base64encode;
  } });
  var protobufjs_utf8_1 = require_protobufjs_utf8();
  Object.defineProperty(exports, "utf8read", { enumerable: !0, get: function() {
    return protobufjs_utf8_1.utf8read;
  } });
  var binary_format_contract_1 = require_binary_format_contract();
  Object.defineProperty(exports, "WireType", { enumerable: !0, get: function() {
    return binary_format_contract_1.WireType;
  } });
  Object.defineProperty(exports, "mergeBinaryOptions", { enumerable: !0, get: function() {
    return binary_format_contract_1.mergeBinaryOptions;
  } });
  Object.defineProperty(exports, "UnknownFieldHandler", { enumerable: !0, get: function() {
    return binary_format_contract_1.UnknownFieldHandler;
  } });
  var binary_reader_1 = require_binary_reader();
  Object.defineProperty(exports, "BinaryReader", { enumerable: !0, get: function() {
    return binary_reader_1.BinaryReader;
  } });
  Object.defineProperty(exports, "binaryReadOptions", { enumerable: !0, get: function() {
    return binary_reader_1.binaryReadOptions;
  } });
  var binary_writer_1 = require_binary_writer();
  Object.defineProperty(exports, "BinaryWriter", { enumerable: !0, get: function() {
    return binary_writer_1.BinaryWriter;
  } });
  Object.defineProperty(exports, "binaryWriteOptions", { enumerable: !0, get: function() {
    return binary_writer_1.binaryWriteOptions;
  } });
  var pb_long_1 = require_pb_long();
  Object.defineProperty(exports, "PbLong", { enumerable: !0, get: function() {
    return pb_long_1.PbLong;
  } });
  Object.defineProperty(exports, "PbULong", { enumerable: !0, get: function() {
    return pb_long_1.PbULong;
  } });
  var json_format_contract_1 = require_json_format_contract();
  Object.defineProperty(exports, "jsonReadOptions", { enumerable: !0, get: function() {
    return json_format_contract_1.jsonReadOptions;
  } });
  Object.defineProperty(exports, "jsonWriteOptions", { enumerable: !0, get: function() {
    return json_format_contract_1.jsonWriteOptions;
  } });
  Object.defineProperty(exports, "mergeJsonOptions", { enumerable: !0, get: function() {
    return json_format_contract_1.mergeJsonOptions;
  } });
  var message_type_contract_1 = require_message_type_contract();
  Object.defineProperty(exports, "MESSAGE_TYPE", { enumerable: !0, get: function() {
    return message_type_contract_1.MESSAGE_TYPE;
  } });
  var message_type_1 = require_message_type();
  Object.defineProperty(exports, "MessageType", { enumerable: !0, get: function() {
    return message_type_1.MessageType;
  } });
  var reflection_info_1 = require_reflection_info();
  Object.defineProperty(exports, "ScalarType", { enumerable: !0, get: function() {
    return reflection_info_1.ScalarType;
  } });
  Object.defineProperty(exports, "LongType", { enumerable: !0, get: function() {
    return reflection_info_1.LongType;
  } });
  Object.defineProperty(exports, "RepeatType", { enumerable: !0, get: function() {
    return reflection_info_1.RepeatType;
  } });
  Object.defineProperty(exports, "normalizeFieldInfo", { enumerable: !0, get: function() {
    return reflection_info_1.normalizeFieldInfo;
  } });
  Object.defineProperty(exports, "readFieldOptions", { enumerable: !0, get: function() {
    return reflection_info_1.readFieldOptions;
  } });
  Object.defineProperty(exports, "readFieldOption", { enumerable: !0, get: function() {
    return reflection_info_1.readFieldOption;
  } });
  Object.defineProperty(exports, "readMessageOption", { enumerable: !0, get: function() {
    return reflection_info_1.readMessageOption;
  } });
  var reflection_type_check_1 = require_reflection_type_check();
  Object.defineProperty(exports, "ReflectionTypeCheck", { enumerable: !0, get: function() {
    return reflection_type_check_1.ReflectionTypeCheck;
  } });
  var reflection_create_1 = require_reflection_create();
  Object.defineProperty(exports, "reflectionCreate", { enumerable: !0, get: function() {
    return reflection_create_1.reflectionCreate;
  } });
  var reflection_scalar_default_1 = require_reflection_scalar_default();
  Object.defineProperty(exports, "reflectionScalarDefault", { enumerable: !0, get: function() {
    return reflection_scalar_default_1.reflectionScalarDefault;
  } });
  var reflection_merge_partial_1 = require_reflection_merge_partial();
  Object.defineProperty(exports, "reflectionMergePartial", { enumerable: !0, get: function() {
    return reflection_merge_partial_1.reflectionMergePartial;
  } });
  var reflection_equals_1 = require_reflection_equals();
  Object.defineProperty(exports, "reflectionEquals", { enumerable: !0, get: function() {
    return reflection_equals_1.reflectionEquals;
  } });
  var reflection_binary_reader_1 = require_reflection_binary_reader();
  Object.defineProperty(exports, "ReflectionBinaryReader", { enumerable: !0, get: function() {
    return reflection_binary_reader_1.ReflectionBinaryReader;
  } });
  var reflection_binary_writer_1 = require_reflection_binary_writer();
  Object.defineProperty(exports, "ReflectionBinaryWriter", { enumerable: !0, get: function() {
    return reflection_binary_writer_1.ReflectionBinaryWriter;
  } });
  var reflection_json_reader_1 = require_reflection_json_reader();
  Object.defineProperty(exports, "ReflectionJsonReader", { enumerable: !0, get: function() {
    return reflection_json_reader_1.ReflectionJsonReader;
  } });
  var reflection_json_writer_1 = require_reflection_json_writer();
  Object.defineProperty(exports, "ReflectionJsonWriter", { enumerable: !0, get: function() {
    return reflection_json_writer_1.ReflectionJsonWriter;
  } });
  var reflection_contains_message_type_1 = require_reflection_contains_message_type();
  Object.defineProperty(exports, "containsMessageType", { enumerable: !0, get: function() {
    return reflection_contains_message_type_1.containsMessageType;
  } });
  var oneof_1 = require_oneof();
  Object.defineProperty(exports, "isOneofGroup", { enumerable: !0, get: function() {
    return oneof_1.isOneofGroup;
  } });
  Object.defineProperty(exports, "setOneofValue", { enumerable: !0, get: function() {
    return oneof_1.setOneofValue;
  } });
  Object.defineProperty(exports, "getOneofValue", { enumerable: !0, get: function() {
    return oneof_1.getOneofValue;
  } });
  Object.defineProperty(exports, "clearOneofValue", { enumerable: !0, get: function() {
    return oneof_1.clearOneofValue;
  } });
  Object.defineProperty(exports, "getSelectedOneofValue", { enumerable: !0, get: function() {
    return oneof_1.getSelectedOneofValue;
  } });
  var enum_object_1 = require_enum_object();
  Object.defineProperty(exports, "listEnumValues", { enumerable: !0, get: function() {
    return enum_object_1.listEnumValues;
  } });
  Object.defineProperty(exports, "listEnumNames", { enumerable: !0, get: function() {
    return enum_object_1.listEnumNames;
  } });
  Object.defineProperty(exports, "listEnumNumbers", { enumerable: !0, get: function() {
    return enum_object_1.listEnumNumbers;
  } });
  Object.defineProperty(exports, "isEnumObject", { enumerable: !0, get: function() {
    return enum_object_1.isEnumObject;
  } });
  var lower_camel_case_1 = require_lower_camel_case();
  Object.defineProperty(exports, "lowerCamelCase", { enumerable: !0, get: function() {
    return lower_camel_case_1.lowerCamelCase;
  } });
  var assert_1 = require_assert();
  Object.defineProperty(exports, "assert", { enumerable: !0, get: function() {
    return assert_1.assert;
  } });
  Object.defineProperty(exports, "assertNever", { enumerable: !0, get: function() {
    return assert_1.assertNever;
  } });
  Object.defineProperty(exports, "assertInt32", { enumerable: !0, get: function() {
    return assert_1.assertInt32;
  } });
  Object.defineProperty(exports, "assertUInt32", { enumerable: !0, get: function() {
    return assert_1.assertUInt32;
  } });
  Object.defineProperty(exports, "assertFloat32", { enumerable: !0, get: function() {
    return assert_1.assertFloat32;
  } });
});

// node_modules/@actions/artifact/lib/generated/google/protobuf/timestamp.js
var require_timestamp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Timestamp = void 0;
  var runtime_1 = require_commonjs(), runtime_2 = require_commonjs(), runtime_3 = require_commonjs(), runtime_4 = require_commonjs(), runtime_5 = require_commonjs(), runtime_6 = require_commonjs(), runtime_7 = require_commonjs();

  class Timestamp$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.Timestamp", [
        { no: 1, name: "seconds", kind: "scalar", T: 3 },
        { no: 2, name: "nanos", kind: "scalar", T: 5 }
      ]);
    }
    now() {
      let msg = this.create(), ms = Date.now();
      return msg.seconds = runtime_6.PbLong.from(Math.floor(ms / 1000)).toString(), msg.nanos = ms % 1000 * 1e6, msg;
    }
    toDate(message) {
      return new Date(runtime_6.PbLong.from(message.seconds).toNumber() * 1000 + Math.ceil(message.nanos / 1e6));
    }
    fromDate(date) {
      let msg = this.create(), ms = date.getTime();
      return msg.seconds = runtime_6.PbLong.from(Math.floor(ms / 1000)).toString(), msg.nanos = ms % 1000 * 1e6, msg;
    }
    internalJsonWrite(message, options) {
      let ms = runtime_6.PbLong.from(message.seconds).toNumber() * 1000;
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))
        throw Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      if (message.nanos < 0)
        throw Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
      let z = "Z";
      if (message.nanos > 0) {
        let nanosStr = (message.nanos + 1e9).toString().substring(1);
        if (nanosStr.substring(3) === "000000")
          z = "." + nanosStr.substring(0, 3) + "Z";
        else if (nanosStr.substring(6) === "000")
          z = "." + nanosStr.substring(0, 6) + "Z";
        else
          z = "." + nanosStr + "Z";
      }
      return new Date(ms).toISOString().replace(".000Z", z);
    }
    internalJsonRead(json, options, target) {
      if (typeof json !== "string")
        throw Error("Unable to parse Timestamp from JSON " + (0, runtime_5.typeofJsonValue)(json) + ".");
      let matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!matches)
        throw Error("Unable to parse Timestamp from JSON. Invalid format.");
      let ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
      if (Number.isNaN(ms))
        throw Error("Unable to parse Timestamp from JSON. Invalid value.");
      if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z"))
        throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      if (!target)
        target = this.create();
      if (target.seconds = runtime_6.PbLong.from(ms / 1000).toString(), target.nanos = 0, matches[7])
        target.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
      return target;
    }
    create(value) {
      let message = { seconds: "0", nanos: 0 };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.seconds = reader.int64().toString();
            break;
          case 2:
            message.nanos = reader.int32();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.seconds !== "0")
        writer.tag(1, runtime_1.WireType.Varint).int64(message.seconds);
      if (message.nanos !== 0)
        writer.tag(2, runtime_1.WireType.Varint).int32(message.nanos);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.Timestamp = new Timestamp$Type;
});

// node_modules/@actions/artifact/lib/generated/google/protobuf/wrappers.js
var require_wrappers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BytesValue = exports.StringValue = exports.BoolValue = exports.UInt32Value = exports.Int32Value = exports.UInt64Value = exports.Int64Value = exports.FloatValue = exports.DoubleValue = void 0;
  var runtime_1 = require_commonjs(), runtime_2 = require_commonjs(), runtime_3 = require_commonjs(), runtime_4 = require_commonjs(), runtime_5 = require_commonjs(), runtime_6 = require_commonjs(), runtime_7 = require_commonjs();

  class DoubleValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.DoubleValue", [
        { no: 1, name: "value", kind: "scalar", T: 1 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(2, message.value, "value", !1, !0);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      return target.value = this.refJsonReader.scalar(json, 1, void 0, "value"), target;
    }
    create(value) {
      let message = { value: 0 };
      if (globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.double();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== 0)
        writer.tag(1, runtime_3.WireType.Bit64).double(message.value);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.DoubleValue = new DoubleValue$Type;

  class FloatValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.FloatValue", [
        { no: 1, name: "value", kind: "scalar", T: 2 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(1, message.value, "value", !1, !0);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      return target.value = this.refJsonReader.scalar(json, 1, void 0, "value"), target;
    }
    create(value) {
      let message = { value: 0 };
      if (globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.float();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== 0)
        writer.tag(1, runtime_3.WireType.Bit32).float(message.value);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FloatValue = new FloatValue$Type;

  class Int64Value$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.Int64Value", [
        { no: 1, name: "value", kind: "scalar", T: 3 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(runtime_1.ScalarType.INT64, message.value, "value", !1, !0);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      return target.value = this.refJsonReader.scalar(json, runtime_1.ScalarType.INT64, runtime_2.LongType.STRING, "value"), target;
    }
    create(value) {
      let message = { value: "0" };
      if (globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== "0")
        writer.tag(1, runtime_3.WireType.Varint).int64(message.value);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.Int64Value = new Int64Value$Type;

  class UInt64Value$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.UInt64Value", [
        { no: 1, name: "value", kind: "scalar", T: 4 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(runtime_1.ScalarType.UINT64, message.value, "value", !1, !0);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      return target.value = this.refJsonReader.scalar(json, runtime_1.ScalarType.UINT64, runtime_2.LongType.STRING, "value"), target;
    }
    create(value) {
      let message = { value: "0" };
      if (globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.uint64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== "0")
        writer.tag(1, runtime_3.WireType.Varint).uint64(message.value);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.UInt64Value = new UInt64Value$Type;

  class Int32Value$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.Int32Value", [
        { no: 1, name: "value", kind: "scalar", T: 5 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(5, message.value, "value", !1, !0);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      return target.value = this.refJsonReader.scalar(json, 5, void 0, "value"), target;
    }
    create(value) {
      let message = { value: 0 };
      if (globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.int32();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== 0)
        writer.tag(1, runtime_3.WireType.Varint).int32(message.value);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.Int32Value = new Int32Value$Type;

  class UInt32Value$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.UInt32Value", [
        { no: 1, name: "value", kind: "scalar", T: 13 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(13, message.value, "value", !1, !0);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      return target.value = this.refJsonReader.scalar(json, 13, void 0, "value"), target;
    }
    create(value) {
      let message = { value: 0 };
      if (globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.uint32();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== 0)
        writer.tag(1, runtime_3.WireType.Varint).uint32(message.value);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.UInt32Value = new UInt32Value$Type;

  class BoolValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.BoolValue", [
        { no: 1, name: "value", kind: "scalar", T: 8 }
      ]);
    }
    internalJsonWrite(message, options) {
      return message.value;
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      return target.value = this.refJsonReader.scalar(json, 8, void 0, "value"), target;
    }
    create(value) {
      let message = { value: !1 };
      if (globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.bool();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== !1)
        writer.tag(1, runtime_3.WireType.Varint).bool(message.value);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.BoolValue = new BoolValue$Type;

  class StringValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.StringValue", [
        { no: 1, name: "value", kind: "scalar", T: 9 }
      ]);
    }
    internalJsonWrite(message, options) {
      return message.value;
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      return target.value = this.refJsonReader.scalar(json, 9, void 0, "value"), target;
    }
    create(value) {
      let message = { value: "" };
      if (globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value !== "")
        writer.tag(1, runtime_3.WireType.LengthDelimited).string(message.value);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.StringValue = new StringValue$Type;

  class BytesValue$Type extends runtime_7.MessageType {
    constructor() {
      super("google.protobuf.BytesValue", [
        { no: 1, name: "value", kind: "scalar", T: 12 }
      ]);
    }
    internalJsonWrite(message, options) {
      return this.refJsonWriter.scalar(12, message.value, "value", !1, !0);
    }
    internalJsonRead(json, options, target) {
      if (!target)
        target = this.create();
      return target.value = this.refJsonReader.scalar(json, 12, void 0, "value"), target;
    }
    create(value) {
      let message = { value: new Uint8Array(0) };
      if (globalThis.Object.defineProperty(message, runtime_6.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_5.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.value = reader.bytes();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_4.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.value.length)
        writer.tag(1, runtime_3.WireType.LengthDelimited).bytes(message.value);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_4.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.BytesValue = new BytesValue$Type;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/reflection-info.js
var require_reflection_info2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.readServiceOption = exports.readMethodOption = exports.readMethodOptions = exports.normalizeMethodInfo = void 0;
  var runtime_1 = require_commonjs();
  function normalizeMethodInfo(method, service) {
    var _a, _b, _c;
    let m = method;
    return m.service = service, m.localName = (_a = m.localName) !== null && _a !== void 0 ? _a : runtime_1.lowerCamelCase(m.name), m.serverStreaming = !!m.serverStreaming, m.clientStreaming = !!m.clientStreaming, m.options = (_b = m.options) !== null && _b !== void 0 ? _b : {}, m.idempotency = (_c = m.idempotency) !== null && _c !== void 0 ? _c : void 0, m;
  }
  exports.normalizeMethodInfo = normalizeMethodInfo;
  function readMethodOptions(service, methodName, extensionName, extensionType) {
    var _a;
    let options = (_a = service.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === void 0 ? void 0 : _a.options;
    return options && options[extensionName] ? extensionType.fromJson(options[extensionName]) : void 0;
  }
  exports.readMethodOptions = readMethodOptions;
  function readMethodOption(service, methodName, extensionName, extensionType) {
    var _a;
    let options = (_a = service.methods.find((m, i) => m.localName === methodName || i === methodName)) === null || _a === void 0 ? void 0 : _a.options;
    if (!options)
      return;
    let optionVal = options[extensionName];
    if (optionVal === void 0)
      return optionVal;
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readMethodOption = readMethodOption;
  function readServiceOption(service, extensionName, extensionType) {
    let options = service.options;
    if (!options)
      return;
    let optionVal = options[extensionName];
    if (optionVal === void 0)
      return optionVal;
    return extensionType ? extensionType.fromJson(optionVal) : optionVal;
  }
  exports.readServiceOption = readServiceOption;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/service-type.js
var require_service_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ServiceType = void 0;
  var reflection_info_1 = require_reflection_info2();

  class ServiceType {
    constructor(typeName, methods, options) {
      this.typeName = typeName, this.methods = methods.map((i) => reflection_info_1.normalizeMethodInfo(i, this)), this.options = options !== null && options !== void 0 ? options : {};
    }
  }
  exports.ServiceType = ServiceType;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-error.js
var require_rpc_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.RpcError = void 0;

  class RpcError extends Error {
    constructor(message, code = "UNKNOWN", meta) {
      super(message);
      this.name = "RpcError", Object.setPrototypeOf(this, new.target.prototype), this.code = code, this.meta = meta !== null && meta !== void 0 ? meta : {};
    }
    toString() {
      let l = [this.name + ": " + this.message];
      if (this.code)
        l.push(""), l.push("Code: " + this.code);
      if (this.serviceName && this.methodName)
        l.push("Method: " + this.serviceName + "/" + this.methodName);
      let m = Object.entries(this.meta);
      if (m.length) {
        l.push(""), l.push("Meta:");
        for (let [k, v] of m)
          l.push(`  ${k}: ${v}`);
      }
      return l.join(`
`);
    }
  }
  exports.RpcError = RpcError;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-options.js
var require_rpc_options = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.mergeRpcOptions = void 0;
  var runtime_1 = require_commonjs();
  function mergeRpcOptions(defaults, options) {
    if (!options)
      return defaults;
    let o = {};
    copy(defaults, o), copy(options, o);
    for (let key of Object.keys(options)) {
      let val = options[key];
      switch (key) {
        case "jsonOptions":
          o.jsonOptions = runtime_1.mergeJsonOptions(defaults.jsonOptions, o.jsonOptions);
          break;
        case "binaryOptions":
          o.binaryOptions = runtime_1.mergeBinaryOptions(defaults.binaryOptions, o.binaryOptions);
          break;
        case "meta":
          o.meta = {}, copy(defaults.meta, o.meta), copy(options.meta, o.meta);
          break;
        case "interceptors":
          o.interceptors = defaults.interceptors ? defaults.interceptors.concat(val) : val.concat();
          break;
      }
    }
    return o;
  }
  exports.mergeRpcOptions = mergeRpcOptions;
  function copy(a, into) {
    if (!a)
      return;
    let c = into;
    for (let [k, v] of Object.entries(a))
      if (v instanceof Date)
        c[k] = new Date(v.getTime());
      else if (Array.isArray(v))
        c[k] = v.concat();
      else
        c[k] = v;
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/deferred.js
var require_deferred = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Deferred = exports.DeferredState = void 0;
  var DeferredState;
  (function(DeferredState2) {
    DeferredState2[DeferredState2.PENDING = 0] = "PENDING", DeferredState2[DeferredState2.REJECTED = 1] = "REJECTED", DeferredState2[DeferredState2.RESOLVED = 2] = "RESOLVED";
  })(DeferredState = exports.DeferredState || (exports.DeferredState = {}));

  class Deferred {
    constructor(preventUnhandledRejectionWarning = !0) {
      if (this._state = DeferredState.PENDING, this._promise = new Promise((resolve, reject) => {
        this._resolve = resolve, this._reject = reject;
      }), preventUnhandledRejectionWarning)
        this._promise.catch((_2) => {});
    }
    get state() {
      return this._state;
    }
    get promise() {
      return this._promise;
    }
    resolve(value) {
      if (this.state !== DeferredState.PENDING)
        throw Error(`cannot resolve ${DeferredState[this.state].toLowerCase()}`);
      this._resolve(value), this._state = DeferredState.RESOLVED;
    }
    reject(reason) {
      if (this.state !== DeferredState.PENDING)
        throw Error(`cannot reject ${DeferredState[this.state].toLowerCase()}`);
      this._reject(reason), this._state = DeferredState.REJECTED;
    }
    resolvePending(val) {
      if (this._state === DeferredState.PENDING)
        this.resolve(val);
    }
    rejectPending(reason) {
      if (this._state === DeferredState.PENDING)
        this.reject(reason);
    }
  }
  exports.Deferred = Deferred;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-output-stream.js
var require_rpc_output_stream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.RpcOutputStreamController = void 0;
  var deferred_1 = require_deferred(), runtime_1 = require_commonjs();

  class RpcOutputStreamController {
    constructor() {
      this._lis = {
        nxt: [],
        msg: [],
        err: [],
        cmp: []
      }, this._closed = !1;
    }
    onNext(callback) {
      return this.addLis(callback, this._lis.nxt);
    }
    onMessage(callback) {
      return this.addLis(callback, this._lis.msg);
    }
    onError(callback) {
      return this.addLis(callback, this._lis.err);
    }
    onComplete(callback) {
      return this.addLis(callback, this._lis.cmp);
    }
    addLis(callback, list) {
      return list.push(callback), () => {
        let i = list.indexOf(callback);
        if (i >= 0)
          list.splice(i, 1);
      };
    }
    clearLis() {
      for (let l of Object.values(this._lis))
        l.splice(0, l.length);
    }
    get closed() {
      return this._closed !== !1;
    }
    notifyNext(message, error, complete) {
      if (runtime_1.assert((message ? 1 : 0) + (error ? 1 : 0) + (complete ? 1 : 0) <= 1, "only one emission at a time"), message)
        this.notifyMessage(message);
      if (error)
        this.notifyError(error);
      if (complete)
        this.notifyComplete();
    }
    notifyMessage(message) {
      runtime_1.assert(!this.closed, "stream is closed"), this.pushIt({ value: message, done: !1 }), this._lis.msg.forEach((l) => l(message)), this._lis.nxt.forEach((l) => l(message, void 0, !1));
    }
    notifyError(error) {
      runtime_1.assert(!this.closed, "stream is closed"), this._closed = error, this.pushIt(error), this._lis.err.forEach((l) => l(error)), this._lis.nxt.forEach((l) => l(void 0, error, !1)), this.clearLis();
    }
    notifyComplete() {
      runtime_1.assert(!this.closed, "stream is closed"), this._closed = !0, this.pushIt({ value: null, done: !0 }), this._lis.cmp.forEach((l) => l()), this._lis.nxt.forEach((l) => l(void 0, void 0, !0)), this.clearLis();
    }
    [Symbol.asyncIterator]() {
      if (!this._itState)
        this._itState = { q: [] };
      if (this._closed === !0)
        this.pushIt({ value: null, done: !0 });
      else if (this._closed !== !1)
        this.pushIt(this._closed);
      return {
        next: () => {
          let state = this._itState;
          runtime_1.assert(state, "bad state"), runtime_1.assert(!state.p, "iterator contract broken");
          let first = state.q.shift();
          if (first)
            return "value" in first ? Promise.resolve(first) : Promise.reject(first);
          return state.p = new deferred_1.Deferred, state.p.promise;
        }
      };
    }
    pushIt(result) {
      let state = this._itState;
      if (!state)
        return;
      if (state.p) {
        let p = state.p;
        runtime_1.assert(p.state == deferred_1.DeferredState.PENDING, "iterator contract broken"), "value" in result ? p.resolve(result) : p.reject(result), delete state.p;
      } else
        state.q.push(result);
    }
  }
  exports.RpcOutputStreamController = RpcOutputStreamController;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/unary-call.js
var require_unary_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.UnaryCall = void 0;

  class UnaryCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method, this.requestHeaders = requestHeaders, this.request = request, this.headers = headers, this.response = response, this.status = status, this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, void 0, void 0, function* () {
        let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          request: this.request,
          headers,
          response,
          status,
          trailers
        };
      });
    }
  }
  exports.UnaryCall = UnaryCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/server-streaming-call.js
var require_server_streaming_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ServerStreamingCall = void 0;

  class ServerStreamingCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method, this.requestHeaders = requestHeaders, this.request = request, this.headers = headers, this.responses = response, this.status = status, this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, void 0, void 0, function* () {
        let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          request: this.request,
          headers,
          status,
          trailers
        };
      });
    }
  }
  exports.ServerStreamingCall = ServerStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/client-streaming-call.js
var require_client_streaming_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ClientStreamingCall = void 0;

  class ClientStreamingCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method, this.requestHeaders = requestHeaders, this.requests = request, this.headers = headers, this.response = response, this.status = status, this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, void 0, void 0, function* () {
        let [headers, response, status, trailers] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          headers,
          response,
          status,
          trailers
        };
      });
    }
  }
  exports.ClientStreamingCall = ClientStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/duplex-streaming-call.js
var require_duplex_streaming_call = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.DuplexStreamingCall = void 0;

  class DuplexStreamingCall {
    constructor(method, requestHeaders, request, headers, response, status, trailers) {
      this.method = method, this.requestHeaders = requestHeaders, this.requests = request, this.headers = headers, this.responses = response, this.status = status, this.trailers = trailers;
    }
    then(onfulfilled, onrejected) {
      return this.promiseFinished().then((value) => onfulfilled ? Promise.resolve(onfulfilled(value)) : value, (reason) => onrejected ? Promise.resolve(onrejected(reason)) : Promise.reject(reason));
    }
    promiseFinished() {
      return __awaiter(this, void 0, void 0, function* () {
        let [headers, status, trailers] = yield Promise.all([this.headers, this.status, this.trailers]);
        return {
          method: this.method,
          requestHeaders: this.requestHeaders,
          headers,
          status,
          trailers
        };
      });
    }
  }
  exports.DuplexStreamingCall = DuplexStreamingCall;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/test-transport.js
var require_test_transport = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.TestTransport = void 0;
  var rpc_error_1 = require_rpc_error(), runtime_1 = require_commonjs(), rpc_output_stream_1 = require_rpc_output_stream(), rpc_options_1 = require_rpc_options(), unary_call_1 = require_unary_call(), server_streaming_call_1 = require_server_streaming_call(), client_streaming_call_1 = require_client_streaming_call(), duplex_streaming_call_1 = require_duplex_streaming_call();

  class TestTransport {
    constructor(data) {
      this.suppressUncaughtRejections = !0, this.headerDelay = 10, this.responseDelay = 50, this.betweenResponseDelay = 10, this.afterResponseDelay = 10, this.data = data !== null && data !== void 0 ? data : {};
    }
    get sentMessages() {
      if (this.lastInput instanceof TestInputStream)
        return this.lastInput.sent;
      else if (typeof this.lastInput == "object")
        return [this.lastInput.single];
      return [];
    }
    get sendComplete() {
      if (this.lastInput instanceof TestInputStream)
        return this.lastInput.completed;
      else if (typeof this.lastInput == "object")
        return !0;
      return !1;
    }
    promiseHeaders() {
      var _a;
      let headers = (_a = this.data.headers) !== null && _a !== void 0 ? _a : TestTransport.defaultHeaders;
      return headers instanceof rpc_error_1.RpcError ? Promise.reject(headers) : Promise.resolve(headers);
    }
    promiseSingleResponse(method) {
      if (this.data.response instanceof rpc_error_1.RpcError)
        return Promise.reject(this.data.response);
      let r;
      if (Array.isArray(this.data.response))
        runtime_1.assert(this.data.response.length > 0), r = this.data.response[0];
      else if (this.data.response !== void 0)
        r = this.data.response;
      else
        r = method.O.create();
      return runtime_1.assert(method.O.is(r)), Promise.resolve(r);
    }
    streamResponses(method, stream, abort) {
      return __awaiter(this, void 0, void 0, function* () {
        let messages = [];
        if (this.data.response === void 0)
          messages.push(method.O.create());
        else if (Array.isArray(this.data.response))
          for (let msg of this.data.response)
            runtime_1.assert(method.O.is(msg)), messages.push(msg);
        else if (!(this.data.response instanceof rpc_error_1.RpcError))
          runtime_1.assert(method.O.is(this.data.response)), messages.push(this.data.response);
        try {
          yield delay(this.responseDelay, abort)(void 0);
        } catch (error) {
          stream.notifyError(error);
          return;
        }
        if (this.data.response instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.response);
          return;
        }
        for (let msg of messages) {
          stream.notifyMessage(msg);
          try {
            yield delay(this.betweenResponseDelay, abort)(void 0);
          } catch (error) {
            stream.notifyError(error);
            return;
          }
        }
        if (this.data.status instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.status);
          return;
        }
        if (this.data.trailers instanceof rpc_error_1.RpcError) {
          stream.notifyError(this.data.trailers);
          return;
        }
        stream.notifyComplete();
      });
    }
    promiseStatus() {
      var _a;
      let status = (_a = this.data.status) !== null && _a !== void 0 ? _a : TestTransport.defaultStatus;
      return status instanceof rpc_error_1.RpcError ? Promise.reject(status) : Promise.resolve(status);
    }
    promiseTrailers() {
      var _a;
      let trailers = (_a = this.data.trailers) !== null && _a !== void 0 ? _a : TestTransport.defaultTrailers;
      return trailers instanceof rpc_error_1.RpcError ? Promise.reject(trailers) : Promise.resolve(trailers);
    }
    maybeSuppressUncaught(...promise) {
      if (this.suppressUncaughtRejections)
        for (let p of promise)
          p.catch(() => {});
    }
    mergeOptions(options) {
      return rpc_options_1.mergeRpcOptions({}, options);
    }
    unary(method, input, options) {
      var _a;
      let requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {}).then(delay(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
      return this.maybeSuppressUncaught(statusPromise, trailersPromise), this.lastInput = { single: input }, new unary_call_1.UnaryCall(method, requestHeaders, input, headersPromise, responsePromise, statusPromise, trailersPromise);
    }
    serverStreaming(method, input, options) {
      var _a;
      let requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new rpc_output_stream_1.RpcOutputStreamController, responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {}).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
      return this.maybeSuppressUncaught(statusPromise, trailersPromise), this.lastInput = { single: input }, new server_streaming_call_1.ServerStreamingCall(method, requestHeaders, input, headersPromise, outputStream, statusPromise, trailersPromise);
    }
    clientStreaming(method, options) {
      var _a;
      let requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), responsePromise = headersPromise.catch((_2) => {}).then(delay(this.responseDelay, options.abort)).then((_2) => this.promiseSingleResponse(method)), statusPromise = responsePromise.catch((_2) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseStatus()), trailersPromise = responsePromise.catch((_2) => {}).then(delay(this.afterResponseDelay, options.abort)).then((_2) => this.promiseTrailers());
      return this.maybeSuppressUncaught(statusPromise, trailersPromise), this.lastInput = new TestInputStream(this.data, options.abort), new client_streaming_call_1.ClientStreamingCall(method, requestHeaders, this.lastInput, headersPromise, responsePromise, statusPromise, trailersPromise);
    }
    duplex(method, options) {
      var _a;
      let requestHeaders = (_a = options.meta) !== null && _a !== void 0 ? _a : {}, headersPromise = this.promiseHeaders().then(delay(this.headerDelay, options.abort)), outputStream = new rpc_output_stream_1.RpcOutputStreamController, responseStreamClosedPromise = headersPromise.then(delay(this.responseDelay, options.abort)).catch(() => {}).then(() => this.streamResponses(method, outputStream, options.abort)).then(delay(this.afterResponseDelay, options.abort)), statusPromise = responseStreamClosedPromise.then(() => this.promiseStatus()), trailersPromise = responseStreamClosedPromise.then(() => this.promiseTrailers());
      return this.maybeSuppressUncaught(statusPromise, trailersPromise), this.lastInput = new TestInputStream(this.data, options.abort), new duplex_streaming_call_1.DuplexStreamingCall(method, requestHeaders, this.lastInput, headersPromise, outputStream, statusPromise, trailersPromise);
    }
  }
  exports.TestTransport = TestTransport;
  TestTransport.defaultHeaders = {
    responseHeader: "test"
  };
  TestTransport.defaultStatus = {
    code: "OK",
    detail: "all good"
  };
  TestTransport.defaultTrailers = {
    responseTrailer: "test"
  };
  function delay(ms, abort) {
    return (v) => new Promise((resolve, reject) => {
      if (abort === null || abort === void 0 ? void 0 : abort.aborted)
        reject(new rpc_error_1.RpcError("user cancel", "CANCELLED"));
      else {
        let id = setTimeout(() => resolve(v), ms);
        if (abort)
          abort.addEventListener("abort", (ev) => {
            clearTimeout(id), reject(new rpc_error_1.RpcError("user cancel", "CANCELLED"));
          });
      }
    });
  }

  class TestInputStream {
    constructor(data, abort) {
      this._completed = !1, this._sent = [], this.data = data, this.abort = abort;
    }
    get sent() {
      return this._sent;
    }
    get completed() {
      return this._completed;
    }
    send(message) {
      if (this.data.inputMessage instanceof rpc_error_1.RpcError)
        return Promise.reject(this.data.inputMessage);
      let delayMs = this.data.inputMessage === void 0 ? 10 : this.data.inputMessage;
      return Promise.resolve(void 0).then(() => {
        this._sent.push(message);
      }).then(delay(delayMs, this.abort));
    }
    complete() {
      if (this.data.inputComplete instanceof rpc_error_1.RpcError)
        return Promise.reject(this.data.inputComplete);
      let delayMs = this.data.inputComplete === void 0 ? 10 : this.data.inputComplete;
      return Promise.resolve(void 0).then(() => {
        this._completed = !0;
      }).then(delay(delayMs, this.abort));
    }
  }
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/rpc-interceptor.js
var require_rpc_interceptor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.stackDuplexStreamingInterceptors = exports.stackClientStreamingInterceptors = exports.stackServerStreamingInterceptors = exports.stackUnaryInterceptors = exports.stackIntercept = void 0;
  var runtime_1 = require_commonjs();
  function stackIntercept(kind, transport, method, options, input) {
    var _a, _b, _c, _d;
    if (kind == "unary") {
      let tail = (mtd, inp, opt) => transport.unary(mtd, inp, opt);
      for (let curr of ((_a = options.interceptors) !== null && _a !== void 0 ? _a : []).filter((i) => i.interceptUnary).reverse()) {
        let next = tail;
        tail = (mtd, inp, opt) => curr.interceptUnary(next, mtd, inp, opt);
      }
      return tail(method, input, options);
    }
    if (kind == "serverStreaming") {
      let tail = (mtd, inp, opt) => transport.serverStreaming(mtd, inp, opt);
      for (let curr of ((_b = options.interceptors) !== null && _b !== void 0 ? _b : []).filter((i) => i.interceptServerStreaming).reverse()) {
        let next = tail;
        tail = (mtd, inp, opt) => curr.interceptServerStreaming(next, mtd, inp, opt);
      }
      return tail(method, input, options);
    }
    if (kind == "clientStreaming") {
      let tail = (mtd, opt) => transport.clientStreaming(mtd, opt);
      for (let curr of ((_c = options.interceptors) !== null && _c !== void 0 ? _c : []).filter((i) => i.interceptClientStreaming).reverse()) {
        let next = tail;
        tail = (mtd, opt) => curr.interceptClientStreaming(next, mtd, opt);
      }
      return tail(method, options);
    }
    if (kind == "duplex") {
      let tail = (mtd, opt) => transport.duplex(mtd, opt);
      for (let curr of ((_d = options.interceptors) !== null && _d !== void 0 ? _d : []).filter((i) => i.interceptDuplex).reverse()) {
        let next = tail;
        tail = (mtd, opt) => curr.interceptDuplex(next, mtd, opt);
      }
      return tail(method, options);
    }
    runtime_1.assertNever(kind);
  }
  exports.stackIntercept = stackIntercept;
  function stackUnaryInterceptors(transport, method, input, options) {
    return stackIntercept("unary", transport, method, options, input);
  }
  exports.stackUnaryInterceptors = stackUnaryInterceptors;
  function stackServerStreamingInterceptors(transport, method, input, options) {
    return stackIntercept("serverStreaming", transport, method, options, input);
  }
  exports.stackServerStreamingInterceptors = stackServerStreamingInterceptors;
  function stackClientStreamingInterceptors(transport, method, options) {
    return stackIntercept("clientStreaming", transport, method, options);
  }
  exports.stackClientStreamingInterceptors = stackClientStreamingInterceptors;
  function stackDuplexStreamingInterceptors(transport, method, options) {
    return stackIntercept("duplex", transport, method, options);
  }
  exports.stackDuplexStreamingInterceptors = stackDuplexStreamingInterceptors;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/server-call-context.js
var require_server_call_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ServerCallContextController = void 0;

  class ServerCallContextController {
    constructor(method, headers, deadline, sendResponseHeadersFn, defaultStatus = { code: "OK", detail: "" }) {
      this._cancelled = !1, this._listeners = [], this.method = method, this.headers = headers, this.deadline = deadline, this.trailers = {}, this._sendRH = sendResponseHeadersFn, this.status = defaultStatus;
    }
    notifyCancelled() {
      if (!this._cancelled) {
        this._cancelled = !0;
        for (let l of this._listeners)
          l();
      }
    }
    sendResponseHeaders(data) {
      this._sendRH(data);
    }
    get cancelled() {
      return this._cancelled;
    }
    onCancel(callback) {
      let l = this._listeners;
      return l.push(callback), () => {
        let i = l.indexOf(callback);
        if (i >= 0)
          l.splice(i, 1);
      };
    }
  }
  exports.ServerCallContextController = ServerCallContextController;
});

// node_modules/@protobuf-ts/runtime-rpc/build/commonjs/index.js
var require_commonjs2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var service_type_1 = require_service_type();
  Object.defineProperty(exports, "ServiceType", { enumerable: !0, get: function() {
    return service_type_1.ServiceType;
  } });
  var reflection_info_1 = require_reflection_info2();
  Object.defineProperty(exports, "readMethodOptions", { enumerable: !0, get: function() {
    return reflection_info_1.readMethodOptions;
  } });
  Object.defineProperty(exports, "readMethodOption", { enumerable: !0, get: function() {
    return reflection_info_1.readMethodOption;
  } });
  Object.defineProperty(exports, "readServiceOption", { enumerable: !0, get: function() {
    return reflection_info_1.readServiceOption;
  } });
  var rpc_error_1 = require_rpc_error();
  Object.defineProperty(exports, "RpcError", { enumerable: !0, get: function() {
    return rpc_error_1.RpcError;
  } });
  var rpc_options_1 = require_rpc_options();
  Object.defineProperty(exports, "mergeRpcOptions", { enumerable: !0, get: function() {
    return rpc_options_1.mergeRpcOptions;
  } });
  var rpc_output_stream_1 = require_rpc_output_stream();
  Object.defineProperty(exports, "RpcOutputStreamController", { enumerable: !0, get: function() {
    return rpc_output_stream_1.RpcOutputStreamController;
  } });
  var test_transport_1 = require_test_transport();
  Object.defineProperty(exports, "TestTransport", { enumerable: !0, get: function() {
    return test_transport_1.TestTransport;
  } });
  var deferred_1 = require_deferred();
  Object.defineProperty(exports, "Deferred", { enumerable: !0, get: function() {
    return deferred_1.Deferred;
  } });
  Object.defineProperty(exports, "DeferredState", { enumerable: !0, get: function() {
    return deferred_1.DeferredState;
  } });
  var duplex_streaming_call_1 = require_duplex_streaming_call();
  Object.defineProperty(exports, "DuplexStreamingCall", { enumerable: !0, get: function() {
    return duplex_streaming_call_1.DuplexStreamingCall;
  } });
  var client_streaming_call_1 = require_client_streaming_call();
  Object.defineProperty(exports, "ClientStreamingCall", { enumerable: !0, get: function() {
    return client_streaming_call_1.ClientStreamingCall;
  } });
  var server_streaming_call_1 = require_server_streaming_call();
  Object.defineProperty(exports, "ServerStreamingCall", { enumerable: !0, get: function() {
    return server_streaming_call_1.ServerStreamingCall;
  } });
  var unary_call_1 = require_unary_call();
  Object.defineProperty(exports, "UnaryCall", { enumerable: !0, get: function() {
    return unary_call_1.UnaryCall;
  } });
  var rpc_interceptor_1 = require_rpc_interceptor();
  Object.defineProperty(exports, "stackIntercept", { enumerable: !0, get: function() {
    return rpc_interceptor_1.stackIntercept;
  } });
  Object.defineProperty(exports, "stackDuplexStreamingInterceptors", { enumerable: !0, get: function() {
    return rpc_interceptor_1.stackDuplexStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackClientStreamingInterceptors", { enumerable: !0, get: function() {
    return rpc_interceptor_1.stackClientStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackServerStreamingInterceptors", { enumerable: !0, get: function() {
    return rpc_interceptor_1.stackServerStreamingInterceptors;
  } });
  Object.defineProperty(exports, "stackUnaryInterceptors", { enumerable: !0, get: function() {
    return rpc_interceptor_1.stackUnaryInterceptors;
  } });
  var server_call_context_1 = require_server_call_context();
  Object.defineProperty(exports, "ServerCallContextController", { enumerable: !0, get: function() {
    return server_call_context_1.ServerCallContextController;
  } });
});

// node_modules/@actions/artifact/lib/generated/results/api/v1/artifact.js
var require_artifact = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ArtifactService = exports.DeleteArtifactResponse = exports.DeleteArtifactRequest = exports.GetSignedArtifactURLResponse = exports.GetSignedArtifactURLRequest = exports.ListArtifactsResponse_MonolithArtifact = exports.ListArtifactsResponse = exports.ListArtifactsRequest = exports.FinalizeArtifactResponse = exports.FinalizeArtifactRequest = exports.CreateArtifactResponse = exports.CreateArtifactRequest = exports.FinalizeMigratedArtifactResponse = exports.FinalizeMigratedArtifactRequest = exports.MigrateArtifactResponse = exports.MigrateArtifactRequest = void 0;
  var runtime_rpc_1 = require_commonjs2(), runtime_1 = require_commonjs(), runtime_2 = require_commonjs(), runtime_3 = require_commonjs(), runtime_4 = require_commonjs(), runtime_5 = require_commonjs(), wrappers_1 = require_wrappers(), wrappers_2 = require_wrappers(), timestamp_1 = require_timestamp();

  class MigrateArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.MigrateArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9 },
        { no: 3, name: "expires_at", kind: "message", T: () => timestamp_1.Timestamp }
      ]);
    }
    create(value) {
      let message = { workflowRunBackendId: "", name: "" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.name = reader.string();
            break;
          case 3:
            message.expiresAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.name !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.expiresAt)
        timestamp_1.Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.MigrateArtifactRequest = new MigrateArtifactRequest$Type;

  class MigrateArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.MigrateArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "signed_upload_url", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      let message = { ok: !1, signedUploadUrl: "" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.signedUploadUrl = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== !1)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.signedUploadUrl !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.MigrateArtifactResponse = new MigrateArtifactResponse$Type;

  class FinalizeMigratedArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeMigratedArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9 },
        { no: 3, name: "size", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      let message = { workflowRunBackendId: "", name: "", size: "0" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.name = reader.string();
            break;
          case 3:
            message.size = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.name !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.size !== "0")
        writer.tag(3, runtime_1.WireType.Varint).int64(message.size);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeMigratedArtifactRequest = new FinalizeMigratedArtifactRequest$Type;

  class FinalizeMigratedArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeMigratedArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "artifact_id", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      let message = { ok: !1, artifactId: "0" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.artifactId = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== !1)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.artifactId !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.artifactId);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeMigratedArtifactResponse = new FinalizeMigratedArtifactResponse$Type;

  class CreateArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.CreateArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 },
        { no: 4, name: "expires_at", kind: "message", T: () => timestamp_1.Timestamp },
        { no: 5, name: "version", kind: "scalar", T: 5 }
      ]);
    }
    create(value) {
      let message = { workflowRunBackendId: "", workflowJobRunBackendId: "", name: "", version: 0 };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.expiresAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expiresAt);
            break;
          case 5:
            message.version = reader.int32();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.name !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.expiresAt)
        timestamp_1.Timestamp.internalBinaryWrite(message.expiresAt, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.version !== 0)
        writer.tag(5, runtime_1.WireType.Varint).int32(message.version);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CreateArtifactRequest = new CreateArtifactRequest$Type;

  class CreateArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.CreateArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "signed_upload_url", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      let message = { ok: !1, signedUploadUrl: "" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.signedUploadUrl = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== !1)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.signedUploadUrl !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.signedUploadUrl);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.CreateArtifactResponse = new CreateArtifactResponse$Type;

  class FinalizeArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 },
        { no: 4, name: "size", kind: "scalar", T: 3 },
        { no: 5, name: "hash", kind: "message", T: () => wrappers_2.StringValue }
      ]);
    }
    create(value) {
      let message = { workflowRunBackendId: "", workflowJobRunBackendId: "", name: "", size: "0" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.name = reader.string();
            break;
          case 4:
            message.size = reader.int64().toString();
            break;
          case 5:
            message.hash = wrappers_2.StringValue.internalBinaryRead(reader, reader.uint32(), options, message.hash);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.name !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.size !== "0")
        writer.tag(4, runtime_1.WireType.Varint).int64(message.size);
      if (message.hash)
        wrappers_2.StringValue.internalBinaryWrite(message.hash, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeArtifactRequest = new FinalizeArtifactRequest$Type;

  class FinalizeArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.FinalizeArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "artifact_id", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      let message = { ok: !1, artifactId: "0" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.artifactId = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== !1)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.artifactId !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.artifactId);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.FinalizeArtifactResponse = new FinalizeArtifactResponse$Type;

  class ListArtifactsRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.ListArtifactsRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name_filter", kind: "message", T: () => wrappers_2.StringValue },
        { no: 4, name: "id_filter", kind: "message", T: () => wrappers_1.Int64Value }
      ]);
    }
    create(value) {
      let message = { workflowRunBackendId: "", workflowJobRunBackendId: "" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.nameFilter = wrappers_2.StringValue.internalBinaryRead(reader, reader.uint32(), options, message.nameFilter);
            break;
          case 4:
            message.idFilter = wrappers_1.Int64Value.internalBinaryRead(reader, reader.uint32(), options, message.idFilter);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.nameFilter)
        wrappers_2.StringValue.internalBinaryWrite(message.nameFilter, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.idFilter)
        wrappers_1.Int64Value.internalBinaryWrite(message.idFilter, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.ListArtifactsRequest = new ListArtifactsRequest$Type;

  class ListArtifactsResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.ListArtifactsResponse", [
        { no: 1, name: "artifacts", kind: "message", repeat: 1, T: () => exports.ListArtifactsResponse_MonolithArtifact }
      ]);
    }
    create(value) {
      let message = { artifacts: [] };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.artifacts.push(exports.ListArtifactsResponse_MonolithArtifact.internalBinaryRead(reader, reader.uint32(), options));
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      for (let i = 0;i < message.artifacts.length; i++)
        exports.ListArtifactsResponse_MonolithArtifact.internalBinaryWrite(message.artifacts[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.ListArtifactsResponse = new ListArtifactsResponse$Type;

  class ListArtifactsResponse_MonolithArtifact$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.ListArtifactsResponse.MonolithArtifact", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "database_id", kind: "scalar", T: 3 },
        { no: 4, name: "name", kind: "scalar", T: 9 },
        { no: 5, name: "size", kind: "scalar", T: 3 },
        { no: 6, name: "created_at", kind: "message", T: () => timestamp_1.Timestamp },
        { no: 7, name: "digest", kind: "message", T: () => wrappers_2.StringValue }
      ]);
    }
    create(value) {
      let message = { workflowRunBackendId: "", workflowJobRunBackendId: "", databaseId: "0", name: "", size: "0" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.databaseId = reader.int64().toString();
            break;
          case 4:
            message.name = reader.string();
            break;
          case 5:
            message.size = reader.int64().toString();
            break;
          case 6:
            message.createdAt = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
            break;
          case 7:
            message.digest = wrappers_2.StringValue.internalBinaryRead(reader, reader.uint32(), options, message.digest);
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.databaseId !== "0")
        writer.tag(3, runtime_1.WireType.Varint).int64(message.databaseId);
      if (message.name !== "")
        writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.name);
      if (message.size !== "0")
        writer.tag(5, runtime_1.WireType.Varint).int64(message.size);
      if (message.createdAt)
        timestamp_1.Timestamp.internalBinaryWrite(message.createdAt, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
      if (message.digest)
        wrappers_2.StringValue.internalBinaryWrite(message.digest, writer.tag(7, runtime_1.WireType.LengthDelimited).fork(), options).join();
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.ListArtifactsResponse_MonolithArtifact = new ListArtifactsResponse_MonolithArtifact$Type;

  class GetSignedArtifactURLRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.GetSignedArtifactURLRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      let message = { workflowRunBackendId: "", workflowJobRunBackendId: "", name: "" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.name = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.name !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.GetSignedArtifactURLRequest = new GetSignedArtifactURLRequest$Type;

  class GetSignedArtifactURLResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.GetSignedArtifactURLResponse", [
        { no: 1, name: "signed_url", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      let message = { signedUrl: "" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.signedUrl = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.signedUrl !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.signedUrl);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.GetSignedArtifactURLResponse = new GetSignedArtifactURLResponse$Type;

  class DeleteArtifactRequest$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.DeleteArtifactRequest", [
        { no: 1, name: "workflow_run_backend_id", kind: "scalar", T: 9 },
        { no: 2, name: "workflow_job_run_backend_id", kind: "scalar", T: 9 },
        { no: 3, name: "name", kind: "scalar", T: 9 }
      ]);
    }
    create(value) {
      let message = { workflowRunBackendId: "", workflowJobRunBackendId: "", name: "" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.workflowRunBackendId = reader.string();
            break;
          case 2:
            message.workflowJobRunBackendId = reader.string();
            break;
          case 3:
            message.name = reader.string();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.workflowRunBackendId !== "")
        writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.workflowRunBackendId);
      if (message.workflowJobRunBackendId !== "")
        writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.workflowJobRunBackendId);
      if (message.name !== "")
        writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.name);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.DeleteArtifactRequest = new DeleteArtifactRequest$Type;

  class DeleteArtifactResponse$Type extends runtime_5.MessageType {
    constructor() {
      super("github.actions.results.api.v1.DeleteArtifactResponse", [
        { no: 1, name: "ok", kind: "scalar", T: 8 },
        { no: 2, name: "artifact_id", kind: "scalar", T: 3 }
      ]);
    }
    create(value) {
      let message = { ok: !1, artifactId: "0" };
      if (globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: !1, value: this }), value !== void 0)
        (0, runtime_3.reflectionMergePartial)(this, message, value);
      return message;
    }
    internalBinaryRead(reader, length, options, target) {
      let message = target !== null && target !== void 0 ? target : this.create(), end = reader.pos + length;
      while (reader.pos < end) {
        let [fieldNo, wireType] = reader.tag();
        switch (fieldNo) {
          case 1:
            message.ok = reader.bool();
            break;
          case 2:
            message.artifactId = reader.int64().toString();
            break;
          default:
            let u = options.readUnknownField;
            if (u === "throw")
              throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
            let d = reader.skip(wireType);
            if (u !== !1)
              (u === !0 ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
        }
      }
      return message;
    }
    internalBinaryWrite(message, writer, options) {
      if (message.ok !== !1)
        writer.tag(1, runtime_1.WireType.Varint).bool(message.ok);
      if (message.artifactId !== "0")
        writer.tag(2, runtime_1.WireType.Varint).int64(message.artifactId);
      let u = options.writeUnknownFields;
      if (u !== !1)
        (u == !0 ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
      return writer;
    }
  }
  exports.DeleteArtifactResponse = new DeleteArtifactResponse$Type;
  exports.ArtifactService = new runtime_rpc_1.ServiceType("github.actions.results.api.v1.ArtifactService", [
    { name: "CreateArtifact", options: {}, I: exports.CreateArtifactRequest, O: exports.CreateArtifactResponse },
    { name: "FinalizeArtifact", options: {}, I: exports.FinalizeArtifactRequest, O: exports.FinalizeArtifactResponse },
    { name: "ListArtifacts", options: {}, I: exports.ListArtifactsRequest, O: exports.ListArtifactsResponse },
    { name: "GetSignedArtifactURL", options: {}, I: exports.GetSignedArtifactURLRequest, O: exports.GetSignedArtifactURLResponse },
    { name: "DeleteArtifact", options: {}, I: exports.DeleteArtifactRequest, O: exports.DeleteArtifactResponse },
    { name: "MigrateArtifact", options: {}, I: exports.MigrateArtifactRequest, O: exports.MigrateArtifactResponse },
    { name: "FinalizeMigratedArtifact", options: {}, I: exports.FinalizeMigratedArtifactRequest, O: exports.FinalizeMigratedArtifactResponse }
  ]);
});

// node_modules/@actions/artifact/lib/generated/results/api/v1/artifact.twirp-client.js
var require_artifact_twirp_client = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ArtifactServiceClientProtobuf = exports.ArtifactServiceClientJSON = void 0;
  var artifact_1 = require_artifact();

  class ArtifactServiceClientJSON {
    constructor(rpc) {
      this.rpc = rpc, this.CreateArtifact.bind(this), this.FinalizeArtifact.bind(this), this.ListArtifacts.bind(this), this.GetSignedArtifactURL.bind(this), this.DeleteArtifact.bind(this);
    }
    CreateArtifact(request) {
      let data = artifact_1.CreateArtifactRequest.toJson(request, {
        useProtoFieldName: !0,
        emitDefaultValues: !1
      });
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "CreateArtifact", "application/json", data).then((data2) => artifact_1.CreateArtifactResponse.fromJson(data2, {
        ignoreUnknownFields: !0
      }));
    }
    FinalizeArtifact(request) {
      let data = artifact_1.FinalizeArtifactRequest.toJson(request, {
        useProtoFieldName: !0,
        emitDefaultValues: !1
      });
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "FinalizeArtifact", "application/json", data).then((data2) => artifact_1.FinalizeArtifactResponse.fromJson(data2, {
        ignoreUnknownFields: !0
      }));
    }
    ListArtifacts(request) {
      let data = artifact_1.ListArtifactsRequest.toJson(request, {
        useProtoFieldName: !0,
        emitDefaultValues: !1
      });
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "ListArtifacts", "application/json", data).then((data2) => artifact_1.ListArtifactsResponse.fromJson(data2, { ignoreUnknownFields: !0 }));
    }
    GetSignedArtifactURL(request) {
      let data = artifact_1.GetSignedArtifactURLRequest.toJson(request, {
        useProtoFieldName: !0,
        emitDefaultValues: !1
      });
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "GetSignedArtifactURL", "application/json", data).then((data2) => artifact_1.GetSignedArtifactURLResponse.fromJson(data2, {
        ignoreUnknownFields: !0
      }));
    }
    DeleteArtifact(request) {
      let data = artifact_1.DeleteArtifactRequest.toJson(request, {
        useProtoFieldName: !0,
        emitDefaultValues: !1
      });
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "DeleteArtifact", "application/json", data).then((data2) => artifact_1.DeleteArtifactResponse.fromJson(data2, {
        ignoreUnknownFields: !0
      }));
    }
  }
  exports.ArtifactServiceClientJSON = ArtifactServiceClientJSON;

  class ArtifactServiceClientProtobuf {
    constructor(rpc) {
      this.rpc = rpc, this.CreateArtifact.bind(this), this.FinalizeArtifact.bind(this), this.ListArtifacts.bind(this), this.GetSignedArtifactURL.bind(this), this.DeleteArtifact.bind(this);
    }
    CreateArtifact(request) {
      let data = artifact_1.CreateArtifactRequest.toBinary(request);
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "CreateArtifact", "application/protobuf", data).then((data2) => artifact_1.CreateArtifactResponse.fromBinary(data2));
    }
    FinalizeArtifact(request) {
      let data = artifact_1.FinalizeArtifactRequest.toBinary(request);
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "FinalizeArtifact", "application/protobuf", data).then((data2) => artifact_1.FinalizeArtifactResponse.fromBinary(data2));
    }
    ListArtifacts(request) {
      let data = artifact_1.ListArtifactsRequest.toBinary(request);
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "ListArtifacts", "application/protobuf", data).then((data2) => artifact_1.ListArtifactsResponse.fromBinary(data2));
    }
    GetSignedArtifactURL(request) {
      let data = artifact_1.GetSignedArtifactURLRequest.toBinary(request);
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "GetSignedArtifactURL", "application/protobuf", data).then((data2) => artifact_1.GetSignedArtifactURLResponse.fromBinary(data2));
    }
    DeleteArtifact(request) {
      let data = artifact_1.DeleteArtifactRequest.toBinary(request);
      return this.rpc.request("github.actions.results.api.v1.ArtifactService", "DeleteArtifact", "application/protobuf", data).then((data2) => artifact_1.DeleteArtifactResponse.fromBinary(data2));
    }
  }
  exports.ArtifactServiceClientProtobuf = ArtifactServiceClientProtobuf;
});

// node_modules/@actions/artifact/lib/generated/index.js
var require_generated = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  __exportStar(require_timestamp(), exports);
  __exportStar(require_wrappers(), exports);
  __exportStar(require_artifact(), exports);
  __exportStar(require_artifact_twirp_client(), exports);
});

// node_modules/@actions/artifact/lib/internal/upload/retention.js
var require_retention = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getExpiration = getExpiration;
  var generated_1 = require_generated(), core = __importStar(require_core());
  function getExpiration(retentionDays) {
    if (!retentionDays)
      return;
    let maxRetentionDays = getRetentionDays();
    if (maxRetentionDays && maxRetentionDays < retentionDays)
      core.warning(`Retention days cannot be greater than the maximum allowed retention set within the repository. Using ${maxRetentionDays} instead.`), retentionDays = maxRetentionDays;
    let expirationDate = /* @__PURE__ */ new Date;
    return expirationDate.setDate(expirationDate.getDate() + retentionDays), generated_1.Timestamp.fromDate(expirationDate);
  }
  function getRetentionDays() {
    let retentionDays = process.env.GITHUB_RETENTION_DAYS;
    if (!retentionDays)
      return;
    let days = parseInt(retentionDays);
    if (isNaN(days))
      return;
    return days;
  }
});

// node_modules/@actions/artifact/lib/internal/upload/path-and-artifact-name-validation.js
var require_path_and_artifact_name_validation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.validateArtifactName = validateArtifactName;
  exports.validateFilePath = validateFilePath;
  var core_1 = require_core(), invalidArtifactFilePathCharacters = /* @__PURE__ */ new Map([
    ['"', ' Double quote "'],
    [":", " Colon :"],
    ["<", " Less than <"],
    [">", " Greater than >"],
    ["|", " Vertical bar |"],
    ["*", " Asterisk *"],
    ["?", " Question mark ?"],
    ["\r", " Carriage return \\r"],
    [`
`, " Line feed \\n"]
  ]), invalidArtifactNameCharacters = new Map([
    ...invalidArtifactFilePathCharacters,
    ["\\", " Backslash \\"],
    ["/", " Forward slash /"]
  ]);
  function validateArtifactName(name) {
    if (!name)
      throw Error("Provided artifact name input during validation is empty");
    for (let [invalidCharacterKey, errorMessageForCharacter] of invalidArtifactNameCharacters)
      if (name.includes(invalidCharacterKey))
        throw Error(`The artifact name is not valid: ${name}. Contains the following character: ${errorMessageForCharacter}
          
Invalid characters include: ${Array.from(invalidArtifactNameCharacters.values()).toString()}
          
These characters are not allowed in the artifact name due to limitations with certain file systems such as NTFS. To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential problems with downloads on different file systems.`);
    (0, core_1.info)("Artifact name is valid!");
  }
  function validateFilePath(path) {
    if (!path)
      throw Error("Provided file path input during validation is empty");
    for (let [invalidCharacterKey, errorMessageForCharacter] of invalidArtifactFilePathCharacters)
      if (path.includes(invalidCharacterKey))
        throw Error(`The path for one of the files in artifact is not valid: ${path}. Contains the following character: ${errorMessageForCharacter}
          
Invalid characters include: ${Array.from(invalidArtifactFilePathCharacters.values()).toString()}
          
The following characters are not allowed in files that are uploaded due to limitations with certain file systems such as NTFS. To maintain file system agnostic behavior, these characters are intentionally not allowed to prevent potential problems with downloads on different file systems.
          `);
  }
});

// node_modules/@actions/artifact/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "@actions/artifact",
    version: "5.0.1",
    preview: !0,
    description: "Actions artifact lib",
    keywords: [
      "github",
      "actions",
      "artifact"
    ],
    homepage: "https://github.com/actions/toolkit/tree/main/packages/artifact",
    license: "MIT",
    main: "lib/artifact.js",
    types: "lib/artifact.d.ts",
    directories: {
      lib: "lib",
      test: "__tests__"
    },
    files: [
      "lib",
      "!.DS_Store"
    ],
    publishConfig: {
      access: "public"
    },
    repository: {
      type: "git",
      url: "git+https://github.com/actions/toolkit.git",
      directory: "packages/artifact"
    },
    scripts: {
      "audit-moderate": "npm install && npm audit --json --audit-level=moderate > audit.json",
      test: "cd ../../ && npm run test ./packages/artifact",
      bootstrap: "cd ../../ && npm run bootstrap",
      "tsc-run": "tsc",
      tsc: "npm run bootstrap && npm run tsc-run",
      "gen:docs": "typedoc --plugin typedoc-plugin-markdown --out docs/generated src/artifact.ts --githubPages false --readme none"
    },
    bugs: {
      url: "https://github.com/actions/toolkit/issues"
    },
    dependencies: {
      "@actions/core": "^2.0.0",
      "@actions/github": "^6.0.1",
      "@actions/http-client": "^3.0.0",
      "@azure/storage-blob": "^12.29.1",
      "@octokit/core": "^5.2.1",
      "@octokit/plugin-request-log": "^1.0.4",
      "@octokit/plugin-retry": "^3.0.9",
      "@octokit/request": "^8.4.1",
      "@octokit/request-error": "^5.1.1",
      "@protobuf-ts/plugin": "^2.2.3-alpha.1",
      archiver: "^7.0.1",
      "jwt-decode": "^3.1.2",
      "unzip-stream": "^0.3.1"
    },
    devDependencies: {
      "@types/archiver": "^5.3.2",
      "@types/unzip-stream": "^0.3.4",
      typedoc: "^0.28.13",
      "typedoc-plugin-markdown": "^3.17.1",
      typescript: "^5.2.2"
    },
    overrides: {
      "uri-js": "npm:uri-js-replace@^1.0.1",
      "node-fetch": "^3.3.2"
    }
  };
});

// node_modules/@actions/artifact/lib/internal/shared/user-agent.js
var require_user_agent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getUserAgentString = getUserAgentString;
  var packageJson = require_package();
  function getUserAgentString() {
    return `@actions/artifact-${packageJson.version}`;
  }
});

// node_modules/@actions/artifact/lib/internal/shared/errors.js
var require_errors2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.UsageError = exports.NetworkError = exports.GHESNotSupportedError = exports.ArtifactNotFoundError = exports.InvalidResponseError = exports.FilesNotFoundError = void 0;

  class FilesNotFoundError extends Error {
    constructor(files = []) {
      let message = "No files were found to upload";
      if (files.length > 0)
        message += `: ${files.join(", ")}`;
      super(message);
      this.files = files, this.name = "FilesNotFoundError";
    }
  }
  exports.FilesNotFoundError = FilesNotFoundError;

  class InvalidResponseError extends Error {
    constructor(message) {
      super(message);
      this.name = "InvalidResponseError";
    }
  }
  exports.InvalidResponseError = InvalidResponseError;

  class ArtifactNotFoundError extends Error {
    constructor(message = "Artifact not found") {
      super(message);
      this.name = "ArtifactNotFoundError";
    }
  }
  exports.ArtifactNotFoundError = ArtifactNotFoundError;

  class GHESNotSupportedError extends Error {
    constructor(message = "@actions/artifact v2.0.0+, upload-artifact@v4+ and download-artifact@v4+ are not currently supported on GHES.") {
      super(message);
      this.name = "GHESNotSupportedError";
    }
  }
  exports.GHESNotSupportedError = GHESNotSupportedError;

  class NetworkError extends Error {
    constructor(code) {
      let message = `Unable to make request: ${code}
If you are using self-hosted runners, please make sure your runner has access to all GitHub endpoints: https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#communication-between-self-hosted-runners-and-github`;
      super(message);
      this.code = code, this.name = "NetworkError";
    }
  }
  exports.NetworkError = NetworkError;
  NetworkError.isNetworkErrorCode = (code) => {
    if (!code)
      return !1;
    return [
      "ECONNRESET",
      "ENOTFOUND",
      "ETIMEDOUT",
      "ECONNREFUSED",
      "EHOSTUNREACH"
    ].includes(code);
  };

  class UsageError extends Error {
    constructor() {
      super(`Artifact storage quota has been hit. Unable to upload any new artifacts. Usage is recalculated every 6-12 hours.
More info on storage limits: https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#calculating-minute-and-storage-spending`);
      this.name = "UsageError";
    }
  }
  exports.UsageError = UsageError;
  UsageError.isUsageErrorMessage = (msg) => {
    if (!msg)
      return !1;
    return msg.includes("insufficient usage");
  };
});

// node_modules/jwt-decode/build/jwt-decode.cjs.js
var require_jwt_decode_cjs = __commonJS((exports, module) => {
  function e(e2) {
    this.message = e2;
  }
  e.prototype = Error(), e.prototype.name = "InvalidCharacterError";
  var r = typeof window < "u" && window.atob && window.atob.bind(window) || function(r2) {
    var t2 = String(r2).replace(/=+$/, "");
    if (t2.length % 4 == 1)
      throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
    for (var n2, o2, a2 = 0, i = 0, c = "";o2 = t2.charAt(i++); ~o2 && (n2 = a2 % 4 ? 64 * n2 + o2 : o2, a2++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a2 & 6)) : 0)
      o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
    return c;
  };
  function t(e2) {
    var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
    switch (t2.length % 4) {
      case 0:
        break;
      case 2:
        t2 += "==";
        break;
      case 3:
        t2 += "=";
        break;
      default:
        throw "Illegal base64url string!";
    }
    try {
      return function(e3) {
        return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
          var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
          return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
        }));
      }(t2);
    } catch (e3) {
      return r(t2);
    }
  }
  function n(e2) {
    this.message = e2;
  }
  function o(e2, r2) {
    if (typeof e2 != "string")
      throw new n("Invalid token specified");
    var o2 = (r2 = r2 || {}).header === !0 ? 0 : 1;
    try {
      return JSON.parse(t(e2.split(".")[o2]));
    } catch (e3) {
      throw new n("Invalid token specified: " + e3.message);
    }
  }
  n.prototype = Error(), n.prototype.name = "InvalidTokenError";
  var a = o;
  a.default = o, a.InvalidTokenError = n, module.exports = a;
});

// node_modules/@actions/artifact/lib/internal/shared/util.js
var require_util8 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getBackendIdsFromToken = getBackendIdsFromToken;
  exports.maskSigUrl = maskSigUrl;
  exports.maskSecretUrls = maskSecretUrls;
  var core = __importStar(require_core()), config_1 = require_config(), jwt_decode_1 = __importDefault(require_jwt_decode_cjs()), core_1 = require_core(), InvalidJwtError = Error("Failed to get backend IDs: The provided JWT token is invalid and/or missing claims");
  function getBackendIdsFromToken() {
    let token = (0, config_1.getRuntimeToken)(), decoded = (0, jwt_decode_1.default)(token);
    if (!decoded.scp)
      throw InvalidJwtError;
    let scpParts = decoded.scp.split(" ");
    if (scpParts.length === 0)
      throw InvalidJwtError;
    for (let scopes of scpParts) {
      let scopeParts = scopes.split(":");
      if ((scopeParts === null || scopeParts === void 0 ? void 0 : scopeParts[0]) !== "Actions.Results")
        continue;
      if (scopeParts.length !== 3)
        throw InvalidJwtError;
      let ids = {
        workflowRunBackendId: scopeParts[1],
        workflowJobRunBackendId: scopeParts[2]
      };
      return core.debug(`Workflow Run Backend ID: ${ids.workflowRunBackendId}`), core.debug(`Workflow Job Run Backend ID: ${ids.workflowJobRunBackendId}`), ids;
    }
    throw InvalidJwtError;
  }
  function maskSigUrl(url) {
    if (!url)
      return;
    try {
      let signature = new URL(url).searchParams.get("sig");
      if (signature)
        (0, core_1.setSecret)(signature), (0, core_1.setSecret)(encodeURIComponent(signature));
    } catch (error) {
      (0, core_1.debug)(`Failed to parse URL: ${url} ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  function maskSecretUrls(body) {
    if (typeof body !== "object" || body === null) {
      (0, core_1.debug)("body is not an object or is null");
      return;
    }
    if ("signed_upload_url" in body && typeof body.signed_upload_url === "string")
      maskSigUrl(body.signed_upload_url);
    if ("signed_url" in body && typeof body.signed_url === "string")
      maskSigUrl(body.signed_url);
  }
});

// node_modules/@actions/artifact/lib/internal/shared/artifact-twirp-client.js
var require_artifact_twirp_client2 = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.internalArtifactTwirpClient = internalArtifactTwirpClient;
  var http_client_1 = require_lib(), auth_1 = require_auth(), core_1 = require_core(), generated_1 = require_generated(), config_1 = require_config(), user_agent_1 = require_user_agent(), errors_1 = require_errors2(), util_1 = require_util8();

  class ArtifactHttpClient {
    constructor(userAgent, maxAttempts, baseRetryIntervalMilliseconds, retryMultiplier) {
      this.maxAttempts = 5, this.baseRetryIntervalMilliseconds = 3000, this.retryMultiplier = 1.5;
      let token = (0, config_1.getRuntimeToken)();
      if (this.baseUrl = (0, config_1.getResultsServiceUrl)(), maxAttempts)
        this.maxAttempts = maxAttempts;
      if (baseRetryIntervalMilliseconds)
        this.baseRetryIntervalMilliseconds = baseRetryIntervalMilliseconds;
      if (retryMultiplier)
        this.retryMultiplier = retryMultiplier;
      this.httpClient = new http_client_1.HttpClient(userAgent, [
        new auth_1.BearerCredentialHandler(token)
      ]);
    }
    request(service, method, contentType, data) {
      return __awaiter(this, void 0, void 0, function* () {
        let url = new URL(`/twirp/${service}/${method}`, this.baseUrl).href;
        (0, core_1.debug)(`[Request] ${method} ${url}`);
        let headers = {
          "Content-Type": contentType
        };
        try {
          let { body } = yield this.retryableRequest(() => __awaiter(this, void 0, void 0, function* () {
            return this.httpClient.post(url, JSON.stringify(data), headers);
          }));
          return body;
        } catch (error) {
          throw Error(`Failed to ${method}: ${error.message}`);
        }
      });
    }
    retryableRequest(operation) {
      return __awaiter(this, void 0, void 0, function* () {
        let attempt = 0, errorMessage = "", rawBody = "";
        while (attempt < this.maxAttempts) {
          let isRetryable = !1;
          try {
            let response = yield operation(), statusCode = response.message.statusCode;
            rawBody = yield response.readBody(), (0, core_1.debug)(`[Response] - ${response.message.statusCode}`), (0, core_1.debug)(`Headers: ${JSON.stringify(response.message.headers, null, 2)}`);
            let body = JSON.parse(rawBody);
            if ((0, util_1.maskSecretUrls)(body), (0, core_1.debug)(`Body: ${JSON.stringify(body, null, 2)}`), this.isSuccessStatusCode(statusCode))
              return { response, body };
            if (isRetryable = this.isRetryableHttpStatusCode(statusCode), errorMessage = `Failed request: (${statusCode}) ${response.message.statusMessage}`, body.msg) {
              if (errors_1.UsageError.isUsageErrorMessage(body.msg))
                throw new errors_1.UsageError;
              errorMessage = `${errorMessage}: ${body.msg}`;
            }
          } catch (error) {
            if (error instanceof SyntaxError)
              (0, core_1.debug)(`Raw Body: ${rawBody}`);
            if (error instanceof errors_1.UsageError)
              throw error;
            if (errors_1.NetworkError.isNetworkErrorCode(error === null || error === void 0 ? void 0 : error.code))
              throw new errors_1.NetworkError(error === null || error === void 0 ? void 0 : error.code);
            isRetryable = !0, errorMessage = error.message;
          }
          if (!isRetryable)
            throw Error(`Received non-retryable error: ${errorMessage}`);
          if (attempt + 1 === this.maxAttempts)
            throw Error(`Failed to make request after ${this.maxAttempts} attempts: ${errorMessage}`);
          let retryTimeMilliseconds = this.getExponentialRetryTimeMilliseconds(attempt);
          (0, core_1.info)(`Attempt ${attempt + 1} of ${this.maxAttempts} failed with error: ${errorMessage}. Retrying request in ${retryTimeMilliseconds} ms...`), yield this.sleep(retryTimeMilliseconds), attempt++;
        }
        throw Error("Request failed");
      });
    }
    isSuccessStatusCode(statusCode) {
      if (!statusCode)
        return !1;
      return statusCode >= 200 && statusCode < 300;
    }
    isRetryableHttpStatusCode(statusCode) {
      if (!statusCode)
        return !1;
      return [
        http_client_1.HttpCodes.BadGateway,
        http_client_1.HttpCodes.GatewayTimeout,
        http_client_1.HttpCodes.InternalServerError,
        http_client_1.HttpCodes.ServiceUnavailable,
        http_client_1.HttpCodes.TooManyRequests
      ].includes(statusCode);
    }
    sleep(milliseconds) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => setTimeout(resolve, milliseconds));
      });
    }
    getExponentialRetryTimeMilliseconds(attempt) {
      if (attempt < 0)
        throw Error("attempt should be a positive integer");
      if (attempt === 0)
        return this.baseRetryIntervalMilliseconds;
      let minTime = this.baseRetryIntervalMilliseconds * Math.pow(this.retryMultiplier, attempt), maxTime = minTime * this.retryMultiplier;
      return Math.trunc(Math.random() * (maxTime - minTime) + minTime);
    }
  }
  function internalArtifactTwirpClient(options) {
    let client = new ArtifactHttpClient((0, user_agent_1.getUserAgentString)(), options === null || options === void 0 ? void 0 : options.maxAttempts, options === null || options === void 0 ? void 0 : options.retryIntervalMs, options === null || options === void 0 ? void 0 : options.retryMultiplier);
    return new generated_1.ArtifactServiceClientJSON(client);
  }
});

// node_modules/@actions/artifact/lib/internal/upload/upload-zip-specification.js
var require_upload_zip_specification = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.validateRootDirectory = validateRootDirectory;
  exports.getUploadZipSpecification = getUploadZipSpecification;
  var fs = __importStar(__require("fs")), core_1 = require_core(), path_1 = __require("path"), path_and_artifact_name_validation_1 = require_path_and_artifact_name_validation();
  function validateRootDirectory(rootDirectory) {
    if (!fs.existsSync(rootDirectory))
      throw Error(`The provided rootDirectory ${rootDirectory} does not exist`);
    if (!fs.statSync(rootDirectory).isDirectory())
      throw Error(`The provided rootDirectory ${rootDirectory} is not a valid directory`);
    (0, core_1.info)("Root directory input is valid!");
  }
  function getUploadZipSpecification(filesToZip, rootDirectory) {
    let specification = [];
    rootDirectory = (0, path_1.normalize)(rootDirectory), rootDirectory = (0, path_1.resolve)(rootDirectory);
    for (let file of filesToZip) {
      let stats = fs.lstatSync(file, { throwIfNoEntry: !1 });
      if (!stats)
        throw Error(`File ${file} does not exist`);
      if (!stats.isDirectory()) {
        if (file = (0, path_1.normalize)(file), file = (0, path_1.resolve)(file), !file.startsWith(rootDirectory))
          throw Error(`The rootDirectory: ${rootDirectory} is not a parent directory of the file: ${file}`);
        let uploadPath = file.replace(rootDirectory, "");
        (0, path_and_artifact_name_validation_1.validateFilePath)(uploadPath), specification.push({
          sourcePath: file,
          destinationPath: uploadPath,
          stats
        });
      } else {
        let directoryPath = file.replace(rootDirectory, "");
        (0, path_and_artifact_name_validation_1.validateFilePath)(directoryPath), specification.push({
          sourcePath: null,
          destinationPath: directoryPath,
          stats
        });
      }
    }
    return specification;
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends, __assign, __rest, __decorate, __param, __esDecorate, __runInitializers, __propKey, __setFunctionName, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet, __classPrivateFieldIn, __createBinding, __addDisposableResource, __disposeResources, __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd)
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    else if (typeof module === "object" && typeof exports === "object")
      factory(createExporter(root, createExporter(exports)));
    else
      factory(createExporter(root));
    function createExporter(exports2, previous) {
      if (exports2 !== root)
        if (typeof Object.create === "function")
          Object.defineProperty(exports2, "__esModule", { value: !0 });
        else
          exports2.__esModule = !0;
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    }, __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    }, __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++)
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
      }
      return t;
    }, __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }, __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    }, __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value", target = !descriptorIn && ctor ? contextIn.static ? ctor : ctor.prototype : null, descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {}), _2, done = !1;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw TypeError("Object expected");
          if (_2 = accept(result.get))
            descriptor.get = _2;
          if (_2 = accept(result.set))
            descriptor.set = _2;
          if (_2 = accept(result.init))
            initializers.unshift(_2);
        } else if (_2 = accept(result))
          if (kind === "field")
            initializers.unshift(_2);
          else
            descriptor[key] = _2;
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = !0;
    }, __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++)
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      return useValue ? value : void 0;
    }, __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    }, __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: !0, value: prefix ? "".concat(prefix, " ", name) : name });
    }, __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    }, __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __generator = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g.throw = verb(1), g.return = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _2.label++, { value: op[1], done: !1 };
              case 5:
                _2.label++, y = op[1], op = [0];
                continue;
              case 7:
                op = _2.ops.pop(), _2.trys.pop();
                continue;
              default:
                if ((t = _2.trys, !(t = t.length > 0 && t[t.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1], t = op;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2], _2.ops.push(op);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e) {
            op = [6, e], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: !0 };
      }
    }, __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    }, __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
        desc = { enumerable: !0, get: function() {
          return m[k];
        } };
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    }, __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i.return))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    }, __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    }, __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    }, __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) {
        for (var i = 0, l = from.length, ar;i < l; i++)
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }, __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }, __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          if (i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          }, f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    }, __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: !1 } : f ? f(v) : v;
        } : f;
      }
    }, __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    }, __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty)
        Object.defineProperty(cooked, "raw", { value: raw });
      else
        cooked.raw = raw;
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }, ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    }, __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    }, __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }, __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    }, __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw TypeError("Symbol.dispose is not defined.");
          if (dispose = value[Symbol.dispose], async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async)
        env.stack.push({ async: !0 });
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e, env.hasError = !0;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop())
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  return fail(e), next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    }, __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path))
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      return path;
    }, exporter("__extends", __extends), exporter("__assign", __assign), exporter("__rest", __rest), exporter("__decorate", __decorate), exporter("__param", __param), exporter("__esDecorate", __esDecorate), exporter("__runInitializers", __runInitializers), exporter("__propKey", __propKey), exporter("__setFunctionName", __setFunctionName), exporter("__metadata", __metadata), exporter("__awaiter", __awaiter), exporter("__generator", __generator), exporter("__exportStar", __exportStar), exporter("__createBinding", __createBinding), exporter("__values", __values), exporter("__read", __read), exporter("__spread", __spread), exporter("__spreadArrays", __spreadArrays), exporter("__spreadArray", __spreadArray), exporter("__await", __await), exporter("__asyncGenerator", __asyncGenerator), exporter("__asyncDelegator", __asyncDelegator), exporter("__asyncValues", __asyncValues), exporter("__makeTemplateObject", __makeTemplateObject), exporter("__importStar", __importStar), exporter("__importDefault", __importDefault), exporter("__classPrivateFieldGet", __classPrivateFieldGet), exporter("__classPrivateFieldSet", __classPrivateFieldSet), exporter("__classPrivateFieldIn", __classPrivateFieldIn), exporter("__addDisposableResource", __addDisposableResource), exporter("__disposeResources", __disposeResources), exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/abort-controller/AbortError.js
var require_AbortError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AbortError = void 0;

  class AbortError extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/log.js
var require_log = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.log = log;
  var tslib_1 = require_tslib(), node_os_1 = __require("node:os"), node_util_1 = tslib_1.__importDefault(__require("node:util")), node_process_1 = tslib_1.__importDefault(__require("node:process"));
  function log(message, ...args) {
    node_process_1.default.stderr.write(`${node_util_1.default.format(message, ...args)}${node_os_1.EOL}`);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/debug.js
var require_debug = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var log_js_1 = require_log(), debugEnvVariable = typeof process < "u" && process.env && process.env.DEBUG || void 0, enabledString, enabledNamespaces = [], skippedNamespaces = [], debuggers = [];
  if (debugEnvVariable)
    enable(debugEnvVariable);
  var debugObj = Object.assign((namespace) => {
    return createDebugger(namespace);
  }, {
    enable,
    enabled,
    disable,
    log: log_js_1.log
  });
  function enable(namespaces) {
    enabledString = namespaces, enabledNamespaces = [], skippedNamespaces = [];
    let namespaceList = namespaces.split(",").map((ns) => ns.trim());
    for (let ns of namespaceList)
      if (ns.startsWith("-"))
        skippedNamespaces.push(ns.substring(1));
      else
        enabledNamespaces.push(ns);
    for (let instance of debuggers)
      instance.enabled = enabled(instance.namespace);
  }
  function enabled(namespace) {
    if (namespace.endsWith("*"))
      return !0;
    for (let skipped of skippedNamespaces)
      if (namespaceMatches(namespace, skipped))
        return !1;
    for (let enabledNamespace of enabledNamespaces)
      if (namespaceMatches(namespace, enabledNamespace))
        return !0;
    return !1;
  }
  function namespaceMatches(namespace, patternToMatch) {
    if (patternToMatch.indexOf("*") === -1)
      return namespace === patternToMatch;
    let pattern = patternToMatch;
    if (patternToMatch.indexOf("**") !== -1) {
      let patternParts = [], lastCharacter = "";
      for (let character of patternToMatch)
        if (character === "*" && lastCharacter === "*")
          continue;
        else
          lastCharacter = character, patternParts.push(character);
      pattern = patternParts.join("");
    }
    let namespaceIndex = 0, patternIndex = 0, patternLength = pattern.length, namespaceLength = namespace.length, lastWildcard = -1, lastWildcardNamespace = -1;
    while (namespaceIndex < namespaceLength && patternIndex < patternLength)
      if (pattern[patternIndex] === "*") {
        if (lastWildcard = patternIndex, patternIndex++, patternIndex === patternLength)
          return !0;
        while (namespace[namespaceIndex] !== pattern[patternIndex])
          if (namespaceIndex++, namespaceIndex === namespaceLength)
            return !1;
        lastWildcardNamespace = namespaceIndex, namespaceIndex++, patternIndex++;
        continue;
      } else if (pattern[patternIndex] === namespace[namespaceIndex])
        patternIndex++, namespaceIndex++;
      else if (lastWildcard >= 0) {
        if (patternIndex = lastWildcard + 1, namespaceIndex = lastWildcardNamespace + 1, namespaceIndex === namespaceLength)
          return !1;
        while (namespace[namespaceIndex] !== pattern[patternIndex])
          if (namespaceIndex++, namespaceIndex === namespaceLength)
            return !1;
        lastWildcardNamespace = namespaceIndex, namespaceIndex++, patternIndex++;
        continue;
      } else
        return !1;
    let namespaceDone = namespaceIndex === namespace.length, patternDone = patternIndex === pattern.length, trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === "*";
    return namespaceDone && (patternDone || trailingWildCard);
  }
  function disable() {
    let result = enabledString || "";
    return enable(""), result;
  }
  function createDebugger(namespace) {
    let newDebugger = Object.assign(debug, {
      enabled: enabled(namespace),
      destroy,
      log: debugObj.log,
      namespace,
      extend
    });
    function debug(...args) {
      if (!newDebugger.enabled)
        return;
      if (args.length > 0)
        args[0] = `${namespace} ${args[0]}`;
      newDebugger.log(...args);
    }
    return debuggers.push(newDebugger), newDebugger;
  }
  function destroy() {
    let index = debuggers.indexOf(this);
    if (index >= 0)
      return debuggers.splice(index, 1), !0;
    return !1;
  }
  function extend(namespace) {
    let newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    return newDebugger.log = this.log, newDebugger;
  }
  exports.default = debugObj;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/logger.js
var require_logger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.TypeSpecRuntimeLogger = void 0;
  exports.createLoggerContext = createLoggerContext;
  exports.setLogLevel = setLogLevel;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger;
  var tslib_1 = require_tslib(), debug_js_1 = tslib_1.__importDefault(require_debug()), TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"], levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
  };
  function patchLogMethod(parent, child) {
    child.log = (...args) => {
      parent.log(...args);
    };
  }
  function isTypeSpecRuntimeLogLevel(level) {
    return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
  }
  function createLoggerContext(options) {
    let registeredLoggers = /* @__PURE__ */ new Set, logLevelFromEnv = typeof process < "u" && process.env && process.env[options.logLevelEnvVarName] || void 0, logLevel, clientLogger = (0, debug_js_1.default)(options.namespace);
    clientLogger.log = (...args) => {
      debug_js_1.default.log(...args);
    };
    function contextSetLogLevel(level) {
      if (level && !isTypeSpecRuntimeLogLevel(level))
        throw Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
      logLevel = level;
      let enabledNamespaces = [];
      for (let logger of registeredLoggers)
        if (shouldEnable(logger))
          enabledNamespaces.push(logger.namespace);
      debug_js_1.default.enable(enabledNamespaces.join(","));
    }
    if (logLevelFromEnv)
      if (isTypeSpecRuntimeLogLevel(logLevelFromEnv))
        contextSetLogLevel(logLevelFromEnv);
      else
        console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
    function shouldEnable(logger) {
      return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);
    }
    function createLogger(parent, level) {
      let logger = Object.assign(parent.extend(level), {
        level
      });
      if (patchLogMethod(parent, logger), shouldEnable(logger)) {
        let enabledNamespaces = debug_js_1.default.disable();
        debug_js_1.default.enable(enabledNamespaces + "," + logger.namespace);
      }
      return registeredLoggers.add(logger), logger;
    }
    function contextGetLogLevel() {
      return logLevel;
    }
    function contextCreateClientLogger(namespace) {
      let clientRootLogger = clientLogger.extend(namespace);
      return patchLogMethod(clientLogger, clientRootLogger), {
        error: createLogger(clientRootLogger, "error"),
        warning: createLogger(clientRootLogger, "warning"),
        info: createLogger(clientRootLogger, "info"),
        verbose: createLogger(clientRootLogger, "verbose")
      };
    }
    return {
      setLogLevel: contextSetLogLevel,
      getLogLevel: contextGetLogLevel,
      createClientLogger: contextCreateClientLogger,
      logger: clientLogger
    };
  }
  var context = createLoggerContext({
    logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
    namespace: "typeSpecRuntime"
  });
  exports.TypeSpecRuntimeLogger = context.logger;
  function setLogLevel(logLevel) {
    context.setLogLevel(logLevel);
  }
  function getLogLevel() {
    return context.getLogLevel();
  }
  function createClientLogger(namespace) {
    return context.createClientLogger(namespace);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/httpHeaders.js
var require_httpHeaders = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createHttpHeaders = createHttpHeaders;
  function normalizeName(name) {
    return name.toLowerCase();
  }
  function* headerIterator(map) {
    for (let entry of map.values())
      yield [entry.name, entry.value];
  }

  class HttpHeadersImpl {
    _headersMap;
    constructor(rawHeaders) {
      if (this._headersMap = /* @__PURE__ */ new Map, rawHeaders)
        for (let headerName of Object.keys(rawHeaders))
          this.set(headerName, rawHeaders[headerName]);
    }
    set(name, value) {
      this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
    }
    get(name) {
      return this._headersMap.get(normalizeName(name))?.value;
    }
    has(name) {
      return this._headersMap.has(normalizeName(name));
    }
    delete(name) {
      this._headersMap.delete(normalizeName(name));
    }
    toJSON(options = {}) {
      let result = {};
      if (options.preserveCase)
        for (let entry of this._headersMap.values())
          result[entry.name] = entry.value;
      else
        for (let [normalizedName, entry] of this._headersMap)
          result[normalizedName] = entry.value;
      return result;
    }
    toString() {
      return JSON.stringify(this.toJSON({ preserveCase: !0 }));
    }
    [Symbol.iterator]() {
      return headerIterator(this._headersMap);
    }
  }
  function createHttpHeaders(rawHeaders) {
    return new HttpHeadersImpl(rawHeaders);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/schemes.js
var require_schemes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/oauth2Flows.js
var require_oauth2Flows = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/uuidUtils.js
var require_uuidUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.randomUUID = randomUUID;
  function randomUUID() {
    return crypto.randomUUID();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipelineRequest.js
var require_pipelineRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createPipelineRequest = createPipelineRequest;
  var httpHeaders_js_1 = require_httpHeaders(), uuidUtils_js_1 = require_uuidUtils();

  class PipelineRequestImpl {
    url;
    method;
    headers;
    timeout;
    withCredentials;
    body;
    multipartBody;
    formData;
    streamResponseStatusCodes;
    enableBrowserStreams;
    proxySettings;
    disableKeepAlive;
    abortSignal;
    requestId;
    allowInsecureConnection;
    onUploadProgress;
    onDownloadProgress;
    requestOverrides;
    authSchemes;
    constructor(options) {
      this.url = options.url, this.body = options.body, this.headers = options.headers ?? (0, httpHeaders_js_1.createHttpHeaders)(), this.method = options.method ?? "GET", this.timeout = options.timeout ?? 0, this.multipartBody = options.multipartBody, this.formData = options.formData, this.disableKeepAlive = options.disableKeepAlive ?? !1, this.proxySettings = options.proxySettings, this.streamResponseStatusCodes = options.streamResponseStatusCodes, this.withCredentials = options.withCredentials ?? !1, this.abortSignal = options.abortSignal, this.onUploadProgress = options.onUploadProgress, this.onDownloadProgress = options.onDownloadProgress, this.requestId = options.requestId || (0, uuidUtils_js_1.randomUUID)(), this.allowInsecureConnection = options.allowInsecureConnection ?? !1, this.enableBrowserStreams = options.enableBrowserStreams ?? !1, this.requestOverrides = options.requestOverrides, this.authSchemes = options.authSchemes;
    }
  }
  function createPipelineRequest(options) {
    return new PipelineRequestImpl(options);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/pipeline.js
var require_pipeline = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createEmptyPipeline = createEmptyPipeline;
  var ValidPhaseNames = /* @__PURE__ */ new Set(["Deserialize", "Serialize", "Retry", "Sign"]);

  class HttpPipeline {
    _policies = [];
    _orderedPolicies;
    constructor(policies) {
      this._policies = policies?.slice(0) ?? [], this._orderedPolicies = void 0;
    }
    addPolicy(policy, options = {}) {
      if (options.phase && options.afterPhase)
        throw Error("Policies inside a phase cannot specify afterPhase.");
      if (options.phase && !ValidPhaseNames.has(options.phase))
        throw Error(`Invalid phase name: ${options.phase}`);
      if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase))
        throw Error(`Invalid afterPhase name: ${options.afterPhase}`);
      this._policies.push({
        policy,
        options
      }), this._orderedPolicies = void 0;
    }
    removePolicy(options) {
      let removedPolicies = [];
      return this._policies = this._policies.filter((policyDescriptor) => {
        if (options.name && policyDescriptor.policy.name === options.name || options.phase && policyDescriptor.options.phase === options.phase)
          return removedPolicies.push(policyDescriptor.policy), !1;
        else
          return !0;
      }), this._orderedPolicies = void 0, removedPolicies;
    }
    sendRequest(httpClient, request) {
      return this.getOrderedPolicies().reduceRight((next, policy) => {
        return (req) => {
          return policy.sendRequest(req, next);
        };
      }, (req) => httpClient.sendRequest(req))(request);
    }
    getOrderedPolicies() {
      if (!this._orderedPolicies)
        this._orderedPolicies = this.orderPolicies();
      return this._orderedPolicies;
    }
    clone() {
      return new HttpPipeline(this._policies);
    }
    static create() {
      return new HttpPipeline;
    }
    orderPolicies() {
      let result = [], policyMap = /* @__PURE__ */ new Map;
      function createPhase(name) {
        return {
          name,
          policies: /* @__PURE__ */ new Set,
          hasRun: !1,
          hasAfterPolicies: !1
        };
      }
      let serializePhase = createPhase("Serialize"), noPhase = createPhase("None"), deserializePhase = createPhase("Deserialize"), retryPhase = createPhase("Retry"), signPhase = createPhase("Sign"), orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
      function getPhase(phase) {
        if (phase === "Retry")
          return retryPhase;
        else if (phase === "Serialize")
          return serializePhase;
        else if (phase === "Deserialize")
          return deserializePhase;
        else if (phase === "Sign")
          return signPhase;
        else
          return noPhase;
      }
      for (let descriptor of this._policies) {
        let { policy, options } = descriptor, policyName = policy.name;
        if (policyMap.has(policyName))
          throw Error("Duplicate policy names not allowed in pipeline");
        let node = {
          policy,
          dependsOn: /* @__PURE__ */ new Set,
          dependants: /* @__PURE__ */ new Set
        };
        if (options.afterPhase)
          node.afterPhase = getPhase(options.afterPhase), node.afterPhase.hasAfterPolicies = !0;
        policyMap.set(policyName, node), getPhase(options.phase).policies.add(node);
      }
      for (let descriptor of this._policies) {
        let { policy, options } = descriptor, policyName = policy.name, node = policyMap.get(policyName);
        if (!node)
          throw Error(`Missing node for policy ${policyName}`);
        if (options.afterPolicies)
          for (let afterPolicyName of options.afterPolicies) {
            let afterNode = policyMap.get(afterPolicyName);
            if (afterNode)
              node.dependsOn.add(afterNode), afterNode.dependants.add(node);
          }
        if (options.beforePolicies)
          for (let beforePolicyName of options.beforePolicies) {
            let beforeNode = policyMap.get(beforePolicyName);
            if (beforeNode)
              beforeNode.dependsOn.add(node), node.dependants.add(beforeNode);
          }
      }
      function walkPhase(phase) {
        phase.hasRun = !0;
        for (let node of phase.policies) {
          if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size))
            continue;
          if (node.dependsOn.size === 0) {
            result.push(node.policy);
            for (let dependant of node.dependants)
              dependant.dependsOn.delete(node);
            policyMap.delete(node.policy.name), phase.policies.delete(node);
          }
        }
      }
      function walkPhases() {
        for (let phase of orderedPhases) {
          if (walkPhase(phase), phase.policies.size > 0 && phase !== noPhase) {
            if (!noPhase.hasRun)
              walkPhase(noPhase);
            return;
          }
          if (phase.hasAfterPolicies)
            walkPhase(noPhase);
        }
      }
      let iteration = 0;
      while (policyMap.size > 0) {
        iteration++;
        let initialResultLength = result.length;
        if (walkPhases(), result.length <= initialResultLength && iteration > 1)
          throw Error("Cannot satisfy policy dependencies due to requirements cycle.");
      }
      return result;
    }
  }
  function createEmptyPipeline() {
    return HttpPipeline.create();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/object.js
var require_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isObject = isObject;
  function isObject(input) {
    return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isError = isError;
  var object_js_1 = require_object();
  function isError(e) {
    if ((0, object_js_1.isObject)(e)) {
      let hasName = typeof e.name === "string", hasMessage = typeof e.message === "string";
      return hasName && hasMessage;
    }
    return !1;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/inspect.js
var require_inspect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.custom = void 0;
  var node_util_1 = __require("node:util");
  exports.custom = node_util_1.inspect.custom;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sanitizer.js
var require_sanitizer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Sanitizer = void 0;
  var object_js_1 = require_object(), RedactedString = "REDACTED", defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Accept-Encoding",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent",
    "WWW-Authenticate"
  ], defaultAllowedQueryParameters = ["api-version"];

  class Sanitizer {
    allowedHeaderNames;
    allowedQueryParameters;
    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [] } = {}) {
      allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames), allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters), this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase())), this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
    }
    sanitize(obj) {
      let seen = /* @__PURE__ */ new Set;
      return JSON.stringify(obj, (key, value) => {
        if (value instanceof Error)
          return {
            ...value,
            name: value.name,
            message: value.message
          };
        if (key === "headers")
          return this.sanitizeHeaders(value);
        else if (key === "url")
          return this.sanitizeUrl(value);
        else if (key === "query")
          return this.sanitizeQuery(value);
        else if (key === "body")
          return;
        else if (key === "response")
          return;
        else if (key === "operationSpec")
          return;
        else if (Array.isArray(value) || (0, object_js_1.isObject)(value)) {
          if (seen.has(value))
            return "[Circular]";
          seen.add(value);
        }
        return value;
      }, 2);
    }
    sanitizeUrl(value) {
      if (typeof value !== "string" || value === null || value === "")
        return value;
      let url = new URL(value);
      if (!url.search)
        return value;
      for (let [key] of url.searchParams)
        if (!this.allowedQueryParameters.has(key.toLowerCase()))
          url.searchParams.set(key, RedactedString);
      return url.toString();
    }
    sanitizeHeaders(obj) {
      let sanitized = {};
      for (let key of Object.keys(obj))
        if (this.allowedHeaderNames.has(key.toLowerCase()))
          sanitized[key] = obj[key];
        else
          sanitized[key] = RedactedString;
      return sanitized;
    }
    sanitizeQuery(value) {
      if (typeof value !== "object" || value === null)
        return value;
      let sanitized = {};
      for (let k of Object.keys(value))
        if (this.allowedQueryParameters.has(k.toLowerCase()))
          sanitized[k] = value[k];
        else
          sanitized[k] = RedactedString;
      return sanitized;
    }
  }
  exports.Sanitizer = Sanitizer;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/restError.js
var require_restError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.RestError = void 0;
  exports.isRestError = isRestError;
  var error_js_1 = require_error(), inspect_js_1 = require_inspect(), sanitizer_js_1 = require_sanitizer(), errorSanitizer = new sanitizer_js_1.Sanitizer;

  class RestError extends Error {
    static REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    static PARSE_ERROR = "PARSE_ERROR";
    code;
    statusCode;
    request;
    response;
    details;
    constructor(message, options = {}) {
      super(message);
      this.name = "RestError", this.code = options.code, this.statusCode = options.statusCode, Object.defineProperty(this, "request", { value: options.request, enumerable: !1 }), Object.defineProperty(this, "response", { value: options.response, enumerable: !1 });
      let agent = this.request?.agent ? {
        maxFreeSockets: this.request.agent.maxFreeSockets,
        maxSockets: this.request.agent.maxSockets
      } : void 0;
      Object.defineProperty(this, inspect_js_1.custom, {
        value: () => {
          return `RestError: ${this.message} 
 ${errorSanitizer.sanitize({
            ...this,
            request: { ...this.request, agent },
            response: this.response
          })}`;
        },
        enumerable: !1
      }), Object.setPrototypeOf(this, RestError.prototype);
    }
  }
  exports.RestError = RestError;
  function isRestError(e) {
    if (e instanceof RestError)
      return !0;
    return (0, error_js_1.isError)(e) && e.name === "RestError";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/bytesEncoding.js
var require_bytesEncoding = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.uint8ArrayToString = uint8ArrayToString;
  exports.stringToUint8Array = stringToUint8Array;
  function uint8ArrayToString(bytes, format) {
    return Buffer.from(bytes).toString(format);
  }
  function stringToUint8Array(value, format) {
    return Buffer.from(value, format);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/log.js
var require_log2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.logger = void 0;
  var logger_js_1 = require_logger();
  exports.logger = (0, logger_js_1.createClientLogger)("ts-http-runtime");
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/nodeHttpClient.js
var require_nodeHttpClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getBodyLength = getBodyLength;
  exports.createNodeHttpClient = createNodeHttpClient;
  var tslib_1 = require_tslib(), node_http_1 = tslib_1.__importDefault(__require("node:http")), node_https_1 = tslib_1.__importDefault(__require("node:https")), node_zlib_1 = tslib_1.__importDefault(__require("node:zlib")), node_stream_1 = __require("node:stream"), AbortError_js_1 = require_AbortError(), httpHeaders_js_1 = require_httpHeaders(), restError_js_1 = require_restError(), log_js_1 = require_log2(), sanitizer_js_1 = require_sanitizer(), DEFAULT_TLS_SETTINGS = {};
  function isReadableStream(body) {
    return body && typeof body.pipe === "function";
  }
  function isStreamComplete(stream) {
    if (stream.readable === !1)
      return Promise.resolve();
    return new Promise((resolve) => {
      let handler = () => {
        resolve(), stream.removeListener("close", handler), stream.removeListener("end", handler), stream.removeListener("error", handler);
      };
      stream.on("close", handler), stream.on("end", handler), stream.on("error", handler);
    });
  }
  function isArrayBuffer(body) {
    return body && typeof body.byteLength === "number";
  }

  class ReportTransform extends node_stream_1.Transform {
    loadedBytes = 0;
    progressCallback;
    _transform(chunk, _encoding, callback) {
      this.push(chunk), this.loadedBytes += chunk.length;
      try {
        this.progressCallback({ loadedBytes: this.loadedBytes }), callback();
      } catch (e) {
        callback(e);
      }
    }
    constructor(progressCallback) {
      super();
      this.progressCallback = progressCallback;
    }
  }

  class NodeHttpClient {
    cachedHttpAgent;
    cachedHttpsAgents = /* @__PURE__ */ new WeakMap;
    async sendRequest(request) {
      let abortController = new AbortController, abortListener;
      if (request.abortSignal) {
        if (request.abortSignal.aborted)
          throw new AbortError_js_1.AbortError("The operation was aborted. Request has already been canceled.");
        abortListener = (event) => {
          if (event.type === "abort")
            abortController.abort();
        }, request.abortSignal.addEventListener("abort", abortListener);
      }
      let timeoutId;
      if (request.timeout > 0)
        timeoutId = setTimeout(() => {
          let sanitizer = new sanitizer_js_1.Sanitizer;
          log_js_1.logger.info(`request to '${sanitizer.sanitizeUrl(request.url)}' timed out. canceling...`), abortController.abort();
        }, request.timeout);
      let acceptEncoding = request.headers.get("Accept-Encoding"), shouldDecompress = acceptEncoding?.includes("gzip") || acceptEncoding?.includes("deflate"), body = typeof request.body === "function" ? request.body() : request.body;
      if (body && !request.headers.has("Content-Length")) {
        let bodyLength = getBodyLength(body);
        if (bodyLength !== null)
          request.headers.set("Content-Length", bodyLength);
      }
      let responseStream;
      try {
        if (body && request.onUploadProgress) {
          let onUploadProgress = request.onUploadProgress, uploadReportStream = new ReportTransform(onUploadProgress);
          if (uploadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in upload progress", e);
          }), isReadableStream(body))
            body.pipe(uploadReportStream);
          else
            uploadReportStream.end(body);
          body = uploadReportStream;
        }
        let res = await this.makeRequest(request, abortController, body);
        if (timeoutId !== void 0)
          clearTimeout(timeoutId);
        let headers = getResponseHeaders(res), response = {
          status: res.statusCode ?? 0,
          headers,
          request
        };
        if (request.method === "HEAD")
          return res.resume(), response;
        responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
        let onDownloadProgress = request.onDownloadProgress;
        if (onDownloadProgress) {
          let downloadReportStream = new ReportTransform(onDownloadProgress);
          downloadReportStream.on("error", (e) => {
            log_js_1.logger.error("Error in download progress", e);
          }), responseStream.pipe(downloadReportStream), responseStream = downloadReportStream;
        }
        if (request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) || request.streamResponseStatusCodes?.has(response.status))
          response.readableStreamBody = responseStream;
        else
          response.bodyAsText = await streamToText(responseStream);
        return response;
      } finally {
        if (request.abortSignal && abortListener) {
          let uploadStreamDone = Promise.resolve();
          if (isReadableStream(body))
            uploadStreamDone = isStreamComplete(body);
          let downloadStreamDone = Promise.resolve();
          if (isReadableStream(responseStream))
            downloadStreamDone = isStreamComplete(responseStream);
          Promise.all([uploadStreamDone, downloadStreamDone]).then(() => {
            if (abortListener)
              request.abortSignal?.removeEventListener("abort", abortListener);
          }).catch((e) => {
            log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e);
          });
        }
      }
    }
    makeRequest(request, abortController, body) {
      let url = new URL(request.url), isInsecure = url.protocol !== "https:";
      if (isInsecure && !request.allowInsecureConnection)
        throw Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
      let options = {
        agent: request.agent ?? this.getOrCreateAgent(request, isInsecure),
        hostname: url.hostname,
        path: `${url.pathname}${url.search}`,
        port: url.port,
        method: request.method,
        headers: request.headers.toJSON({ preserveCase: !0 }),
        ...request.requestOverrides
      };
      return new Promise((resolve, reject) => {
        let req = isInsecure ? node_http_1.default.request(options, resolve) : node_https_1.default.request(options, resolve);
        if (req.once("error", (err) => {
          reject(new restError_js_1.RestError(err.message, { code: err.code ?? restError_js_1.RestError.REQUEST_SEND_ERROR, request }));
        }), abortController.signal.addEventListener("abort", () => {
          let abortError = new AbortError_js_1.AbortError("The operation was aborted. Rejecting from abort signal callback while making request.");
          req.destroy(abortError), reject(abortError);
        }), body && isReadableStream(body))
          body.pipe(req);
        else if (body)
          if (typeof body === "string" || Buffer.isBuffer(body))
            req.end(body);
          else if (isArrayBuffer(body))
            req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
          else
            log_js_1.logger.error("Unrecognized body type", body), reject(new restError_js_1.RestError("Unrecognized body type"));
        else
          req.end();
      });
    }
    getOrCreateAgent(request, isInsecure) {
      let disableKeepAlive = request.disableKeepAlive;
      if (isInsecure) {
        if (disableKeepAlive)
          return node_http_1.default.globalAgent;
        if (!this.cachedHttpAgent)
          this.cachedHttpAgent = new node_http_1.default.Agent({ keepAlive: !0 });
        return this.cachedHttpAgent;
      } else {
        if (disableKeepAlive && !request.tlsSettings)
          return node_https_1.default.globalAgent;
        let tlsSettings = request.tlsSettings ?? DEFAULT_TLS_SETTINGS, agent = this.cachedHttpsAgents.get(tlsSettings);
        if (agent && agent.options.keepAlive === !disableKeepAlive)
          return agent;
        return log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent"), agent = new node_https_1.default.Agent({
          keepAlive: !disableKeepAlive,
          ...tlsSettings
        }), this.cachedHttpsAgents.set(tlsSettings, agent), agent;
      }
    }
  }
  function getResponseHeaders(res) {
    let headers = (0, httpHeaders_js_1.createHttpHeaders)();
    for (let header of Object.keys(res.headers)) {
      let value = res.headers[header];
      if (Array.isArray(value)) {
        if (value.length > 0)
          headers.set(header, value[0]);
      } else if (value)
        headers.set(header, value);
    }
    return headers;
  }
  function getDecodedResponseStream(stream, headers) {
    let contentEncoding = headers.get("Content-Encoding");
    if (contentEncoding === "gzip") {
      let unzip = node_zlib_1.default.createGunzip();
      return stream.pipe(unzip), unzip;
    } else if (contentEncoding === "deflate") {
      let inflate = node_zlib_1.default.createInflate();
      return stream.pipe(inflate), inflate;
    }
    return stream;
  }
  function streamToText(stream) {
    return new Promise((resolve, reject) => {
      let buffer = [];
      stream.on("data", (chunk) => {
        if (Buffer.isBuffer(chunk))
          buffer.push(chunk);
        else
          buffer.push(Buffer.from(chunk));
      }), stream.on("end", () => {
        resolve(Buffer.concat(buffer).toString("utf8"));
      }), stream.on("error", (e) => {
        if (e && e?.name === "AbortError")
          reject(e);
        else
          reject(new restError_js_1.RestError(`Error reading response as text: ${e.message}`, {
            code: restError_js_1.RestError.PARSE_ERROR
          }));
      });
    });
  }
  function getBodyLength(body) {
    if (!body)
      return 0;
    else if (Buffer.isBuffer(body))
      return body.length;
    else if (isReadableStream(body))
      return null;
    else if (isArrayBuffer(body))
      return body.byteLength;
    else if (typeof body === "string")
      return Buffer.from(body).length;
    else
      return null;
  }
  function createNodeHttpClient() {
    return new NodeHttpClient;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createDefaultHttpClient = createDefaultHttpClient;
  var nodeHttpClient_js_1 = require_nodeHttpClient();
  function createDefaultHttpClient() {
    return (0, nodeHttpClient_js_1.createNodeHttpClient)();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/logPolicy.js
var require_logPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.logPolicyName = void 0;
  exports.logPolicy = logPolicy;
  var log_js_1 = require_log2(), sanitizer_js_1 = require_sanitizer();
  exports.logPolicyName = "logPolicy";
  function logPolicy(options = {}) {
    let logger = options.logger ?? log_js_1.logger.info, sanitizer = new sanitizer_js_1.Sanitizer({
      additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
      additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    });
    return {
      name: exports.logPolicyName,
      async sendRequest(request, next) {
        if (!logger.enabled)
          return next(request);
        logger(`Request: ${sanitizer.sanitize(request)}`);
        let response = await next(request);
        return logger(`Response status code: ${response.status}`), logger(`Headers: ${sanitizer.sanitize(response.headers)}`), response;
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.redirectPolicyName = void 0;
  exports.redirectPolicy = redirectPolicy;
  exports.redirectPolicyName = "redirectPolicy";
  var allowedRedirect = ["GET", "HEAD"];
  function redirectPolicy(options = {}) {
    let { maxRetries = 20 } = options;
    return {
      name: exports.redirectPolicyName,
      async sendRequest(request, next) {
        let response = await next(request);
        return handleRedirect(next, response, maxRetries);
      }
    };
  }
  async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
    let { request, status, headers } = response, locationHeader = headers.get("location");
    if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && currentRetries < maxRetries) {
      let url = new URL(locationHeader, request.url);
      if (request.url = url.toString(), status === 303)
        request.method = "GET", request.headers.delete("Content-Length"), delete request.body;
      request.headers.delete("Authorization");
      let res = await next(request);
      return handleRedirect(next, res, maxRetries, currentRetries + 1);
    }
    return response;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getHeaderName = getHeaderName;
  exports.setPlatformSpecificData = setPlatformSpecificData;
  var tslib_1 = require_tslib(), node_os_1 = tslib_1.__importDefault(__require("node:os")), node_process_1 = tslib_1.__importDefault(__require("node:process"));
  function getHeaderName() {
    return "User-Agent";
  }
  async function setPlatformSpecificData(map) {
    if (node_process_1.default && node_process_1.default.versions) {
      let osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`, versions = node_process_1.default.versions;
      if (versions.bun)
        map.set("Bun", `${versions.bun} (${osInfo})`);
      else if (versions.deno)
        map.set("Deno", `${versions.deno} (${osInfo})`);
      else if (versions.node)
        map.set("Node", `${versions.node} (${osInfo})`);
    }
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/constants.js
var require_constants6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = void 0;
  exports.SDK_VERSION = "0.3.2";
  exports.DEFAULT_RETRY_POLICY_COUNT = 3;
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/userAgent.js
var require_userAgent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getUserAgentHeaderName = getUserAgentHeaderName;
  exports.getUserAgentValue = getUserAgentValue;
  var userAgentPlatform_js_1 = require_userAgentPlatform(), constants_js_1 = require_constants6();
  function getUserAgentString(telemetryInfo) {
    let parts = [];
    for (let [key, value] of telemetryInfo) {
      let token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue(prefix) {
    let runtimeInfo = /* @__PURE__ */ new Map;
    runtimeInfo.set("ts-http-runtime", constants_js_1.SDK_VERSION), await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    let defaultAgent = getUserAgentString(runtimeInfo);
    return prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.userAgentPolicyName = void 0;
  exports.userAgentPolicy = userAgentPolicy;
  var userAgent_js_1 = require_userAgent(), UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
  exports.userAgentPolicyName = "userAgentPolicy";
  function userAgentPolicy(options = {}) {
    let userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    return {
      name: exports.userAgentPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(UserAgentHeaderName))
          request.headers.set(UserAgentHeaderName, await userAgentValue);
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.decompressResponsePolicyName = void 0;
  exports.decompressResponsePolicy = decompressResponsePolicy;
  exports.decompressResponsePolicyName = "decompressResponsePolicy";
  function decompressResponsePolicy() {
    return {
      name: exports.decompressResponsePolicyName,
      async sendRequest(request, next) {
        if (request.method !== "HEAD")
          request.headers.set("Accept-Encoding", "gzip,deflate");
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/random.js
var require_random = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
  function getRandomIntegerInclusive(min, max) {
    return min = Math.ceil(min), max = Math.floor(max), Math.floor(Math.random() * (max - min + 1)) + min;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/delay.js
var require_delay = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.calculateRetryDelay = calculateRetryDelay;
  var random_js_1 = require_random();
  function calculateRetryDelay(retryAttempt, config) {
    let exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt), clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    return { retryAfterInMs: clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2) };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.delay = delay;
  exports.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
  var AbortError_js_1 = require_AbortError(), StandardAbortMessage = "The operation was aborted.";
  function delay(delayInMs, value, options) {
    return new Promise((resolve, reject) => {
      let timer = void 0, onAborted = void 0, rejectOnAbort = () => {
        return reject(new AbortError_js_1.AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage));
      }, removeListeners = () => {
        if (options?.abortSignal && onAborted)
          options.abortSignal.removeEventListener("abort", onAborted);
      };
      if (onAborted = () => {
        if (timer)
          clearTimeout(timer);
        return removeListeners(), rejectOnAbort();
      }, options?.abortSignal && options.abortSignal.aborted)
        return rejectOnAbort();
      if (timer = setTimeout(() => {
        removeListeners(), resolve(value);
      }, delayInMs), options?.abortSignal)
        options.abortSignal.addEventListener("abort", onAborted);
    });
  }
  function parseHeaderValueAsNumber(response, headerName) {
    let value = response.headers.get(headerName);
    if (!value)
      return;
    let valueAsNum = Number(value);
    if (Number.isNaN(valueAsNum))
      return;
    return valueAsNum;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/throttlingRetryStrategy.js
var require_throttlingRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isThrottlingRetryResponse = isThrottlingRetryResponse;
  exports.throttlingRetryStrategy = throttlingRetryStrategy;
  var helpers_js_1 = require_helpers(), RetryAfterHeader = "Retry-After", AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
  function getRetryAfterInMs(response) {
    if (!(response && [429, 503].includes(response.status)))
      return;
    try {
      for (let header of AllRetryAfterHeaders) {
        let retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response, header);
        if (retryAfterValue === 0 || retryAfterValue)
          return retryAfterValue * (header === RetryAfterHeader ? 1000 : 1);
      }
      let retryAfterHeader = response.headers.get(RetryAfterHeader);
      if (!retryAfterHeader)
        return;
      let diff = Date.parse(retryAfterHeader) - Date.now();
      return Number.isFinite(diff) ? Math.max(0, diff) : void 0;
    } catch {
      return;
    }
  }
  function isThrottlingRetryResponse(response) {
    return Number.isFinite(getRetryAfterInMs(response));
  }
  function throttlingRetryStrategy() {
    return {
      name: "throttlingRetryStrategy",
      retry({ response }) {
        let retryAfterInMs = getRetryAfterInMs(response);
        if (!Number.isFinite(retryAfterInMs))
          return { skipStrategy: !0 };
        return {
          retryAfterInMs
        };
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/retryStrategies/exponentialRetryStrategy.js
var require_exponentialRetryStrategy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.exponentialRetryStrategy = exponentialRetryStrategy;
  exports.isExponentialRetryResponse = isExponentialRetryResponse;
  exports.isSystemError = isSystemError;
  var delay_js_1 = require_delay(), throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy(), DEFAULT_CLIENT_RETRY_INTERVAL = 1000, DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 64000;
  function exponentialRetryStrategy(options = {}) {
    let retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL, maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
    return {
      name: "exponentialRetryStrategy",
      retry({ retryCount, response, responseError }) {
        let matchedSystemError = isSystemError(responseError), ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors, isExponential = isExponentialRetryResponse(response), ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
        if (response && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response) || !isExponential) || ignoreExponentialResponse || ignoreSystemErrors)
          return { skipStrategy: !0 };
        if (responseError && !matchedSystemError && !isExponential)
          return { errorToThrow: responseError };
        return (0, delay_js_1.calculateRetryDelay)(retryCount, {
          retryDelayInMs: retryInterval,
          maxRetryDelayInMs: maxRetryInterval
        });
      }
    };
  }
  function isExponentialRetryResponse(response) {
    return Boolean(response && response.status !== void 0 && (response.status >= 500 || response.status === 408) && response.status !== 501 && response.status !== 505);
  }
  function isSystemError(err) {
    if (!err)
      return !1;
    return err.code === "ETIMEDOUT" || err.code === "ESOCKETTIMEDOUT" || err.code === "ECONNREFUSED" || err.code === "ECONNRESET" || err.code === "ENOENT" || err.code === "ENOTFOUND";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.retryPolicy = retryPolicy;
  var helpers_js_1 = require_helpers(), AbortError_js_1 = require_AbortError(), logger_js_1 = require_logger(), constants_js_1 = require_constants6(), retryPolicyLogger = (0, logger_js_1.createClientLogger)("ts-http-runtime retryPolicy"), retryPolicyName = "retryPolicy";
  function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    let logger = options.logger || retryPolicyLogger;
    return {
      name: retryPolicyName,
      async sendRequest(request, next) {
        let response, responseError, retryCount = -1;
        retryRequest:
          while (!0) {
            retryCount += 1, response = void 0, responseError = void 0;
            try {
              logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId), response = await next(request), logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
            } catch (e) {
              if (logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId), responseError = e, !e || responseError.name !== "RestError")
                throw e;
              response = responseError.response;
            }
            if (request.abortSignal?.aborted)
              throw logger.error(`Retry ${retryCount}: Request aborted.`), new AbortError_js_1.AbortError;
            if (retryCount >= (options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT))
              if (logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`), responseError)
                throw responseError;
              else if (response)
                return response;
              else
                throw Error("Maximum retries reached with no response or error to throw");
            logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
            strategiesLoop:
              for (let strategy of strategies) {
                let strategyLogger = strategy.logger || logger;
                strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
                let modifiers = strategy.retry({
                  retryCount,
                  response,
                  responseError
                });
                if (modifiers.skipStrategy) {
                  strategyLogger.info(`Retry ${retryCount}: Skipped.`);
                  continue strategiesLoop;
                }
                let { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
                if (errorToThrow)
                  throw strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow), errorToThrow;
                if (retryAfterInMs || retryAfterInMs === 0) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`), await (0, helpers_js_1.delay)(retryAfterInMs, void 0, { abortSignal: request.abortSignal });
                  continue retryRequest;
                }
                if (redirectTo) {
                  strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`), request.url = redirectTo;
                  continue retryRequest;
                }
              }
            if (responseError)
              throw logger.info("None of the retry strategies could work with the received error. Throwing it."), responseError;
            if (response)
              return logger.info("None of the retry strategies could work with the received response. Returning it."), response;
          }
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.defaultRetryPolicyName = void 0;
  exports.defaultRetryPolicy = defaultRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy(), throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy(), retryPolicy_js_1 = require_retryPolicy(), constants_js_1 = require_constants6();
  exports.defaultRetryPolicyName = "defaultRetryPolicy";
  function defaultRetryPolicy(options = {}) {
    return {
      name: exports.defaultRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options)], {
        maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/checkEnvironment.js
var require_checkEnvironment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isDeno = exports.isWebWorker = exports.isBrowser = void 0;
  exports.isBrowser = typeof window < "u" && typeof window.document < "u";
  exports.isWebWorker = typeof self === "object" && typeof self?.importScripts === "function" && (self.constructor?.name === "DedicatedWorkerGlobalScope" || self.constructor?.name === "ServiceWorkerGlobalScope" || self.constructor?.name === "SharedWorkerGlobalScope");
  exports.isDeno = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u";
  exports.isBun = typeof Bun < "u" && typeof Bun.version < "u";
  exports.isNodeLike = typeof globalThis.process < "u" && Boolean(globalThis.process.version) && Boolean(globalThis.process.versions?.node);
  exports.isNodeRuntime = exports.isNodeLike && !exports.isBun && !exports.isDeno;
  exports.isReactNative = typeof navigator < "u" && navigator?.product === "ReactNative";
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.formDataPolicyName = void 0;
  exports.formDataPolicy = formDataPolicy;
  var bytesEncoding_js_1 = require_bytesEncoding(), checkEnvironment_js_1 = require_checkEnvironment(), httpHeaders_js_1 = require_httpHeaders();
  exports.formDataPolicyName = "formDataPolicy";
  function formDataToFormDataMap(formData) {
    let formDataMap = {};
    for (let [key, value] of formData.entries())
      formDataMap[key] ??= [], formDataMap[key].push(value);
    return formDataMap;
  }
  function formDataPolicy() {
    return {
      name: exports.formDataPolicyName,
      async sendRequest(request, next) {
        if (checkEnvironment_js_1.isNodeLike && typeof FormData < "u" && request.body instanceof FormData)
          request.formData = formDataToFormDataMap(request.body), request.body = void 0;
        if (request.formData) {
          let contentType = request.headers.get("Content-Type");
          if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1)
            request.body = wwwFormUrlEncode(request.formData);
          else
            await prepareFormData(request.formData, request);
          request.formData = void 0;
        }
        return next(request);
      }
    };
  }
  function wwwFormUrlEncode(formData) {
    let urlSearchParams = new URLSearchParams;
    for (let [key, value] of Object.entries(formData))
      if (Array.isArray(value))
        for (let subValue of value)
          urlSearchParams.append(key, subValue.toString());
      else
        urlSearchParams.append(key, value.toString());
    return urlSearchParams.toString();
  }
  async function prepareFormData(formData, request) {
    let contentType = request.headers.get("Content-Type");
    if (contentType && !contentType.startsWith("multipart/form-data"))
      return;
    request.headers.set("Content-Type", contentType ?? "multipart/form-data");
    let parts = [];
    for (let [fieldName, values] of Object.entries(formData))
      for (let value of Array.isArray(values) ? values : [values])
        if (typeof value === "string")
          parts.push({
            headers: (0, httpHeaders_js_1.createHttpHeaders)({
              "Content-Disposition": `form-data; name="${fieldName}"`
            }),
            body: (0, bytesEncoding_js_1.stringToUint8Array)(value, "utf-8")
          });
        else if (value === void 0 || value === null || typeof value !== "object")
          throw Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
        else {
          let fileName = value.name || "blob", headers = (0, httpHeaders_js_1.createHttpHeaders)();
          headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`), headers.set("Content-Type", value.type || "application/octet-stream"), parts.push({
            headers,
            body: value
          });
        }
    request.multipartBody = { parts };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s = 1000, m = s * 60, h = m * 60, d = h * 24, w = d * 7, y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0)
      return parse(val);
    else if (type === "number" && isFinite(val))
      return options.long ? fmtLong(val) : fmtShort(val);
    throw Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    if (str = String(str), str.length > 100)
      return;
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match)
      return;
    var n = parseFloat(match[1]), type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d)
      return Math.round(ms / d) + "d";
    if (msAbs >= h)
      return Math.round(ms / h) + "h";
    if (msAbs >= m)
      return Math.round(ms / m) + "m";
    if (msAbs >= s)
      return Math.round(ms / s) + "s";
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d)
      return plural(ms, msAbs, d, "day");
    if (msAbs >= h)
      return plural(ms, msAbs, h, "hour");
    if (msAbs >= m)
      return plural(ms, msAbs, m, "minute");
    if (msAbs >= s)
      return plural(ms, msAbs, s, "second");
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug, createDebug.default = createDebug, createDebug.coerce = coerce, createDebug.disable = disable, createDebug.enable = enable, createDebug.enabled = enabled, createDebug.humanize = require_ms(), createDebug.destroy = destroy, Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    }), createDebug.names = [], createDebug.skips = [], createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++)
        hash = (hash << 5) - hash + namespace.charCodeAt(i), hash |= 0;
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime, enableOverride = null, namespacesCache, enabledCache;
      function debug(...args) {
        if (!debug.enabled)
          return;
        let self2 = debug, curr = Number(/* @__PURE__ */ new Date), ms = curr - (prevTime || curr);
        if (self2.diff = ms, self2.prev = prevTime, self2.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), typeof args[0] !== "string")
          args.unshift("%O");
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%")
            return "%";
          index++;
          let formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            let val = args[index];
            match = formatter.call(self2, val), args.splice(index, 1), index--;
          }
          return match;
        }), createDebug.formatArgs.call(self2, args), (self2.log || createDebug.log).apply(self2, args);
      }
      if (debug.namespace = namespace, debug.useColors = createDebug.useColors(), debug.color = createDebug.selectColor(namespace), debug.extend = extend, debug.destroy = createDebug.destroy, Object.defineProperty(debug, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => {
          if (enableOverride !== null)
            return enableOverride;
          if (namespacesCache !== createDebug.namespaces)
            namespacesCache = createDebug.namespaces, enabledCache = createDebug.enabled(namespace);
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      }), typeof createDebug.init === "function")
        createDebug.init(debug);
      return debug;
    }
    function extend(namespace, delimiter) {
      let newDebug = createDebug(this.namespace + (typeof delimiter > "u" ? ":" : delimiter) + namespace);
      return newDebug.log = this.log, newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces), createDebug.namespaces = namespaces, createDebug.names = [], createDebug.skips = [];
      let i, split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/), len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i])
          continue;
        if (namespaces = split[i].replace(/\*/g, ".*?"), namespaces[0] === "-")
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        else
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
    function disable() {
      let namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      return createDebug.enable(""), namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*")
        return !0;
      let i, len;
      for (i = 0, len = createDebug.skips.length;i < len; i++)
        if (createDebug.skips[i].test(name))
          return !1;
      for (i = 0, len = createDebug.names.length;i < len; i++)
        if (createDebug.names[i].test(name))
          return !0;
      return !1;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return createDebug.enable(createDebug.load()), createDebug;
  }
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = !1;
    return () => {
      if (!warned)
        warned = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let m;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff), !this.useColors)
      return;
    let c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0, lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%")
        return;
      if (index++, match === "%c")
        lastC = index;
    }), args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {});
  function save(namespaces) {
    try {
      if (namespaces)
        exports.storage.setItem("debug", namespaces);
      else
        exports.storage.removeItem("debug");
    } catch (error) {}
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {}
    if (!r && typeof process < "u" && "env" in process)
      r = process.env.DEBUG;
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {}
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var tty = __require("tty"), util = __require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {}, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    let supportsColor = (()=>{throw new Error("Cannot require module "+"supports-color");})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2)
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
  } catch (error) {}
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    let prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
      return k.toUpperCase();
    }), val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val))
      val = !0;
    else if (/^(no|off|false|disabled)$/i.test(val))
      val = !1;
    else if (val === "null")
      val = null;
    else
      val = Number(val);
    return obj[prop] = val, obj;
  }, {});
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    let { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      let c = this.color, colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c), prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split(`
`).join(`
` + prefix), args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else
      args[0] = getDate() + name + " " + args[0];
  }
  function getDate() {
    if (exports.inspectOpts.hideDate)
      return "";
    return (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + `
`);
  }
  function save(namespaces) {
    if (namespaces)
      process.env.DEBUG = namespaces;
    else
      delete process.env.DEBUG;
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug) {
    debug.inspectOpts = {};
    let keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++)
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts).split(`
`).map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    return this.inspectOpts.colors = this.useColors, util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process > "u" || process.type === "renderer" || !1 || process.__nwjs)
    module.exports = require_browser();
  else
    module.exports = require_node();
});

// node_modules/agent-base/dist/helpers.js
var require_helpers2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    return __setModuleDefault(result, mod), result;
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.req = exports.json = exports.toBuffer = void 0;
  var http = __importStar(__require("http")), https = __importStar(__require("https"));
  async function toBuffer(stream) {
    let length = 0, chunks = [];
    for await (let chunk of stream)
      length += chunk.length, chunks.push(chunk);
    return Buffer.concat(chunks, length);
  }
  exports.toBuffer = toBuffer;
  async function json(stream) {
    let str = (await toBuffer(stream)).toString("utf8");
    try {
      return JSON.parse(str);
    } catch (_err) {
      let err = _err;
      throw err.message += ` (input: ${str})`, err;
    }
  }
  exports.json = json;
  function req(url, opts = {}) {
    let req2 = ((typeof url === "string" ? url : url.href).startsWith("https:") ? https : http).request(url, opts), promise = new Promise((resolve, reject) => {
      req2.once("response", resolve).once("error", reject).end();
    });
    return req2.then = promise.then.bind(promise), req2;
  }
  exports.req = req;
});

// node_modules/agent-base/dist/index.js
var require_dist = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    return __setModuleDefault(result, mod), result;
  }, __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Agent = void 0;
  var net = __importStar(__require("net")), http = __importStar(__require("http")), https_1 = __require("https");
  __exportStar(require_helpers2(), exports);
  var INTERNAL = Symbol("AgentBaseInternalState");

  class Agent extends http.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean")
          return options.secureEndpoint;
        if (typeof options.protocol === "string")
          return options.protocol === "https:";
      }
      let { stack } = Error();
      if (typeof stack !== "string")
        return !1;
      return stack.split(`
`).some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    incrementSockets(name) {
      if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0)
        return null;
      if (!this.sockets[name])
        this.sockets[name] = [];
      let fakeSocket = new net.Socket({ writable: !1 });
      return this.sockets[name].push(fakeSocket), this.totalSocketCount++, fakeSocket;
    }
    decrementSockets(name, socket) {
      if (!this.sockets[name] || socket === null)
        return;
      let sockets = this.sockets[name], index = sockets.indexOf(socket);
      if (index !== -1) {
        if (sockets.splice(index, 1), this.totalSocketCount--, sockets.length === 0)
          delete this.sockets[name];
      }
    }
    getName(options) {
      if (typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options))
        return https_1.Agent.prototype.getName.call(this, options);
      return super.getName(options);
    }
    createSocket(req, options, cb) {
      let connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      }, name = this.getName(connectOpts), fakeSocket = this.incrementSockets(name);
      Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
        if (this.decrementSockets(name, fakeSocket), socket instanceof http.Agent)
          return socket.addRequest(req, connectOpts);
        this[INTERNAL].currentSocket = socket, super.createSocket(req, options, cb);
      }, (err) => {
        this.decrementSockets(name, fakeSocket), cb(err);
      });
    }
    createConnection() {
      let socket = this[INTERNAL].currentSocket;
      if (this[INTERNAL].currentSocket = void 0, !socket)
        throw Error("No socket was returned in the `connect()` function");
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL])
        this[INTERNAL].defaultPort = v;
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL])
        this[INTERNAL].protocol = v;
    }
  }
  exports.Agent = Agent;
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.parseProxyResponse = void 0;
  var debug_1 = __importDefault(require_src()), debug = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
  function parseProxyResponse(socket) {
    return new Promise((resolve, reject) => {
      let buffersLength = 0, buffers = [];
      function read() {
        let b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend), socket.removeListener("error", onerror), socket.removeListener("readable", read);
      }
      function onend() {
        cleanup(), debug("onend"), reject(Error("Proxy connection ended before receiving CONNECT response"));
      }
      function onerror(err) {
        cleanup(), debug("onerror %o", err), reject(err);
      }
      function ondata(b) {
        buffers.push(b), buffersLength += b.length;
        let buffered = Buffer.concat(buffers, buffersLength), endOfHeaders = buffered.indexOf(`\r
\r
`);
        if (endOfHeaders === -1) {
          debug("have not received end of HTTP headers yet..."), read();
          return;
        }
        let headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split(`\r
`), firstLine = headerParts.shift();
        if (!firstLine)
          return socket.destroy(), reject(Error("No header received from proxy CONNECT response"));
        let firstLineParts = firstLine.split(" "), statusCode = +firstLineParts[1], statusText = firstLineParts.slice(2).join(" "), headers = {};
        for (let header of headerParts) {
          if (!header)
            continue;
          let firstColon = header.indexOf(":");
          if (firstColon === -1)
            return socket.destroy(), reject(Error(`Invalid header from proxy CONNECT response: "${header}"`));
          let key = header.slice(0, firstColon).toLowerCase(), value = header.slice(firstColon + 1).trimStart(), current = headers[key];
          if (typeof current === "string")
            headers[key] = [current, value];
          else if (Array.isArray(current))
            current.push(value);
          else
            headers[key] = value;
        }
        debug("got proxy server response: %o %o", firstLine, headers), cleanup(), resolve({
          connect: {
            statusCode,
            statusText,
            headers
          },
          buffered
        });
      }
      socket.on("error", onerror), socket.on("end", onend), read();
    });
  }
  exports.parseProxyResponse = parseProxyResponse;
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    return __setModuleDefault(result, mod), result;
  }, __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.HttpsProxyAgent = void 0;
  var net = __importStar(__require("net")), tls = __importStar(__require("tls")), assert_1 = __importDefault(__require("assert")), debug_1 = __importDefault(require_src()), agent_base_1 = require_dist(), url_1 = __require("url"), parse_proxy_response_1 = require_parse_proxy_response(), debug = (0, debug_1.default)("https-proxy-agent");

  class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.options = { path: void 0 }, this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy, this.proxyHeaders = opts?.headers ?? {}, debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      let host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    async connect(req, opts) {
      let { proxy } = this;
      if (!opts.host)
        throw TypeError('No "host" provided');
      let socket;
      if (proxy.protocol === "https:") {
        debug("Creating `tls.Socket`: %o", this.connectOpts);
        let servername = this.connectOpts.servername || this.connectOpts.host;
        socket = tls.connect({
          ...this.connectOpts,
          servername
        });
      } else
        debug("Creating `net.Socket`: %o", this.connectOpts), socket = net.connect(this.connectOpts);
      let headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders }, host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host, payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
      if (proxy.username || proxy.password) {
        let auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      if (headers.Host = `${host}:${opts.port}`, !headers["Proxy-Connection"])
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      for (let name of Object.keys(headers))
        payload += `${name}: ${headers[name]}\r
`;
      let proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
      socket.write(`${payload}\r
`);
      let { connect, buffered } = await proxyResponsePromise;
      if (req.emit("proxyConnect", connect), this.emit("proxyConnect", connect, req), connect.statusCode === 200) {
        if (req.once("socket", resume), opts.secureEndpoint) {
          debug("Upgrading socket connection to TLS");
          let servername = opts.servername || opts.host;
          return tls.connect({
            ...omit(opts, "host", "path", "port"),
            socket,
            servername
          });
        }
        return socket;
      }
      socket.destroy();
      let fakeSocket = new net.Socket({ writable: !1 });
      return fakeSocket.readable = !0, req.once("socket", (s) => {
        debug("Replaying proxy buffer for failed request"), (0, assert_1.default)(s.listenerCount("data") > 0), s.push(buffered), s.push(null);
      }), fakeSocket;
    }
  }
  HttpsProxyAgent.protocols = ["http", "https"];
  exports.HttpsProxyAgent = HttpsProxyAgent;
  function resume(socket) {
    socket.resume();
  }
  function omit(obj, ...keys) {
    let ret = {}, key;
    for (key in obj)
      if (!keys.includes(key))
        ret[key] = obj[key];
    return ret;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    return __setModuleDefault(result, mod), result;
  }, __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.HttpProxyAgent = void 0;
  var net = __importStar(__require("net")), tls = __importStar(__require("tls")), debug_1 = __importDefault(require_src()), events_1 = __require("events"), agent_base_1 = require_dist(), url_1 = __require("url"), debug = (0, debug_1.default)("http-proxy-agent");

  class HttpProxyAgent extends agent_base_1.Agent {
    constructor(proxy, opts) {
      super(opts);
      this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy, this.proxyHeaders = opts?.headers ?? {}, debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      let host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""), port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
      this.connectOpts = {
        ...opts ? omit(opts, "headers") : null,
        host,
        port
      };
    }
    addRequest(req, opts) {
      req._header = null, this.setRequestProps(req, opts), super.addRequest(req, opts);
    }
    setRequestProps(req, opts) {
      let { proxy } = this, protocol = opts.secureEndpoint ? "https:" : "http:", hostname = req.getHeader("host") || "localhost", base = `${protocol}//${hostname}`, url = new url_1.URL(req.path, base);
      if (opts.port !== 80)
        url.port = String(opts.port);
      req.path = String(url);
      let headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
      if (proxy.username || proxy.password) {
        let auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
        headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
      }
      if (!headers["Proxy-Connection"])
        headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      for (let name of Object.keys(headers)) {
        let value = headers[name];
        if (value)
          req.setHeader(name, value);
      }
    }
    async connect(req, opts) {
      if (req._header = null, !req.path.includes("://"))
        this.setRequestProps(req, opts);
      let first, endOfHeaders;
      if (debug("Regenerating stored HTTP header string for request"), req._implicitHeader(), req.outputData && req.outputData.length > 0)
        debug("Patching connection write() output buffer with updated header"), first = req.outputData[0].data, endOfHeaders = first.indexOf(`\r
\r
`) + 4, req.outputData[0].data = req._header + first.substring(endOfHeaders), debug("Output buffer: %o", req.outputData[0].data);
      let socket;
      if (this.proxy.protocol === "https:")
        debug("Creating `tls.Socket`: %o", this.connectOpts), socket = tls.connect(this.connectOpts);
      else
        debug("Creating `net.Socket`: %o", this.connectOpts), socket = net.connect(this.connectOpts);
      return await (0, events_1.once)(socket, "connect"), socket;
    }
  }
  HttpProxyAgent.protocols = ["http", "https"];
  exports.HttpProxyAgent = HttpProxyAgent;
  function omit(obj, ...keys) {
    let ret = {}, key;
    for (key in obj)
      if (!keys.includes(key))
        ret[key] = obj[key];
    return ret;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.globalNoProxyList = exports.proxyPolicyName = void 0;
  exports.loadNoProxy = loadNoProxy;
  exports.getDefaultProxySettings = getDefaultProxySettings;
  exports.proxyPolicy = proxyPolicy;
  var https_proxy_agent_1 = require_dist2(), http_proxy_agent_1 = require_dist3(), log_js_1 = require_log2(), HTTPS_PROXY = "HTTPS_PROXY", HTTP_PROXY = "HTTP_PROXY", ALL_PROXY = "ALL_PROXY", NO_PROXY = "NO_PROXY";
  exports.proxyPolicyName = "proxyPolicy";
  exports.globalNoProxyList = [];
  var noProxyListLoaded = !1, globalBypassedMap = /* @__PURE__ */ new Map;
  function getEnvironmentValue(name) {
    if (process.env[name])
      return process.env[name];
    else if (process.env[name.toLowerCase()])
      return process.env[name.toLowerCase()];
    return;
  }
  function loadEnvironmentProxyValue() {
    if (!process)
      return;
    let httpsProxy = getEnvironmentValue(HTTPS_PROXY), allProxy = getEnvironmentValue(ALL_PROXY), httpProxy = getEnvironmentValue(HTTP_PROXY);
    return httpsProxy || allProxy || httpProxy;
  }
  function isBypassed(uri, noProxyList, bypassedMap) {
    if (noProxyList.length === 0)
      return !1;
    let host = new URL(uri).hostname;
    if (bypassedMap?.has(host))
      return bypassedMap.get(host);
    let isBypassedFlag = !1;
    for (let pattern of noProxyList)
      if (pattern[0] === ".") {
        if (host.endsWith(pattern))
          isBypassedFlag = !0;
        else if (host.length === pattern.length - 1 && host === pattern.slice(1))
          isBypassedFlag = !0;
      } else if (host === pattern)
        isBypassedFlag = !0;
    return bypassedMap?.set(host, isBypassedFlag), isBypassedFlag;
  }
  function loadNoProxy() {
    let noProxy = getEnvironmentValue(NO_PROXY);
    if (noProxyListLoaded = !0, noProxy)
      return noProxy.split(",").map((item) => item.trim()).filter((item) => item.length);
    return [];
  }
  function getDefaultProxySettings(proxyUrl) {
    if (!proxyUrl) {
      if (proxyUrl = loadEnvironmentProxyValue(), !proxyUrl)
        return;
    }
    let parsedUrl = new URL(proxyUrl);
    return {
      host: (parsedUrl.protocol ? parsedUrl.protocol + "//" : "") + parsedUrl.hostname,
      port: Number.parseInt(parsedUrl.port || "80"),
      username: parsedUrl.username,
      password: parsedUrl.password
    };
  }
  function getDefaultProxySettingsInternal() {
    let envProxy = loadEnvironmentProxyValue();
    return envProxy ? new URL(envProxy) : void 0;
  }
  function getUrlFromProxySettings(settings) {
    let parsedProxyUrl;
    try {
      parsedProxyUrl = new URL(settings.host);
    } catch {
      throw Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
    }
    if (parsedProxyUrl.port = String(settings.port), settings.username)
      parsedProxyUrl.username = settings.username;
    if (settings.password)
      parsedProxyUrl.password = settings.password;
    return parsedProxyUrl;
  }
  function setProxyAgentOnRequest(request, cachedAgents, proxyUrl) {
    if (request.agent)
      return;
    let isInsecure = new URL(request.url).protocol !== "https:";
    if (request.tlsSettings)
      log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
    let headers = request.headers.toJSON();
    if (isInsecure) {
      if (!cachedAgents.httpProxyAgent)
        cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers });
      request.agent = cachedAgents.httpProxyAgent;
    } else {
      if (!cachedAgents.httpsProxyAgent)
        cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers });
      request.agent = cachedAgents.httpsProxyAgent;
    }
  }
  function proxyPolicy(proxySettings, options) {
    if (!noProxyListLoaded)
      exports.globalNoProxyList.push(...loadNoProxy());
    let defaultProxy = proxySettings ? getUrlFromProxySettings(proxySettings) : getDefaultProxySettingsInternal(), cachedAgents = {};
    return {
      name: exports.proxyPolicyName,
      async sendRequest(request, next) {
        if (!request.proxySettings && defaultProxy && !isBypassed(request.url, options?.customNoProxyList ?? exports.globalNoProxyList, options?.customNoProxyList ? void 0 : globalBypassedMap))
          setProxyAgentOnRequest(request, cachedAgents, defaultProxy);
        else if (request.proxySettings)
          setProxyAgentOnRequest(request, cachedAgents, getUrlFromProxySettings(request.proxySettings));
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.agentPolicyName = void 0;
  exports.agentPolicy = agentPolicy;
  exports.agentPolicyName = "agentPolicy";
  function agentPolicy(agent) {
    return {
      name: exports.agentPolicyName,
      sendRequest: async (req, next) => {
        if (!req.agent)
          req.agent = agent;
        return next(req);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.tlsPolicyName = void 0;
  exports.tlsPolicy = tlsPolicy;
  exports.tlsPolicyName = "tlsPolicy";
  function tlsPolicy(tlsSettings) {
    return {
      name: exports.tlsPolicyName,
      sendRequest: async (req, next) => {
        if (!req.tlsSettings)
          req.tlsSettings = tlsSettings;
        return next(req);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/typeGuards.js
var require_typeGuards = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isNodeReadableStream = isNodeReadableStream;
  exports.isWebReadableStream = isWebReadableStream;
  exports.isBinaryBody = isBinaryBody;
  exports.isReadableStream = isReadableStream;
  exports.isBlob = isBlob;
  function isNodeReadableStream(x) {
    return Boolean(x && typeof x.pipe === "function");
  }
  function isWebReadableStream(x) {
    return Boolean(x && typeof x.getReader === "function" && typeof x.tee === "function");
  }
  function isBinaryBody(body) {
    return body !== void 0 && (body instanceof Uint8Array || isReadableStream(body) || typeof body === "function" || body instanceof Blob);
  }
  function isReadableStream(x) {
    return isNodeReadableStream(x) || isWebReadableStream(x);
  }
  function isBlob(x) {
    return typeof x.stream === "function";
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/concat.js
var require_concat = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.concat = concat;
  var stream_1 = __require("stream"), typeGuards_js_1 = require_typeGuards();
  async function* streamAsyncIterator() {
    let reader = this.getReader();
    try {
      while (!0) {
        let { done, value } = await reader.read();
        if (done)
          return;
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }
  function makeAsyncIterable(webStream) {
    if (!webStream[Symbol.asyncIterator])
      webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
    if (!webStream.values)
      webStream.values = streamAsyncIterator.bind(webStream);
  }
  function ensureNodeStream(stream) {
    if (stream instanceof ReadableStream)
      return makeAsyncIterable(stream), stream_1.Readable.fromWeb(stream);
    else
      return stream;
  }
  function toStream(source) {
    if (source instanceof Uint8Array)
      return stream_1.Readable.from(Buffer.from(source));
    else if ((0, typeGuards_js_1.isBlob)(source))
      return ensureNodeStream(source.stream());
    else
      return ensureNodeStream(source);
  }
  async function concat(sources) {
    return function() {
      let streams = sources.map((x) => typeof x === "function" ? x() : x).map(toStream);
      return stream_1.Readable.from(async function* () {
        for (let stream of streams)
          for await (let chunk of stream)
            yield chunk;
      }());
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.multipartPolicyName = void 0;
  exports.multipartPolicy = multipartPolicy;
  var bytesEncoding_js_1 = require_bytesEncoding(), typeGuards_js_1 = require_typeGuards(), uuidUtils_js_1 = require_uuidUtils(), concat_js_1 = require_concat();
  function generateBoundary() {
    return `----AzSDKFormBoundary${(0, uuidUtils_js_1.randomUUID)()}`;
  }
  function encodeHeaders(headers) {
    let result = "";
    for (let [key, value] of headers)
      result += `${key}: ${value}\r
`;
    return result;
  }
  function getLength(source) {
    if (source instanceof Uint8Array)
      return source.byteLength;
    else if ((0, typeGuards_js_1.isBlob)(source))
      return source.size === -1 ? void 0 : source.size;
    else
      return;
  }
  function getTotalLength(sources) {
    let total = 0;
    for (let source of sources) {
      let partLength = getLength(source);
      if (partLength === void 0)
        return;
      else
        total += partLength;
    }
    return total;
  }
  async function buildRequestBody(request, parts, boundary) {
    let sources = [
      (0, bytesEncoding_js_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
      ...parts.flatMap((part) => [
        (0, bytesEncoding_js_1.stringToUint8Array)(`\r
`, "utf-8"),
        (0, bytesEncoding_js_1.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"),
        (0, bytesEncoding_js_1.stringToUint8Array)(`\r
`, "utf-8"),
        part.body,
        (0, bytesEncoding_js_1.stringToUint8Array)(`\r
--${boundary}`, "utf-8")
      ]),
      (0, bytesEncoding_js_1.stringToUint8Array)(`--\r
\r
`, "utf-8")
    ], contentLength = getTotalLength(sources);
    if (contentLength)
      request.headers.set("Content-Length", contentLength);
    request.body = await (0, concat_js_1.concat)(sources);
  }
  exports.multipartPolicyName = "multipartPolicy";
  var maxBoundaryLength = 70, validBoundaryCharacters = new Set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?");
  function assertValidBoundary(boundary) {
    if (boundary.length > maxBoundaryLength)
      throw Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
    if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x)))
      throw Error(`Multipart boundary "${boundary}" contains invalid characters`);
  }
  function multipartPolicy() {
    return {
      name: exports.multipartPolicyName,
      async sendRequest(request, next) {
        if (!request.multipartBody)
          return next(request);
        if (request.body)
          throw Error("multipartBody and regular body cannot be set at the same time");
        let boundary = request.multipartBody.boundary, contentTypeHeader = request.headers.get("Content-Type") ?? "multipart/mixed", parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
        if (!parsedHeader)
          throw Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
        let [, contentType, parsedBoundary] = parsedHeader;
        if (parsedBoundary && boundary && parsedBoundary !== boundary)
          throw Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
        if (boundary ??= parsedBoundary, boundary)
          assertValidBoundary(boundary);
        else
          boundary = generateBoundary();
        return request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`), await buildRequestBody(request, request.multipartBody.parts, boundary), request.multipartBody = void 0, next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createPipelineFromOptions = createPipelineFromOptions;
  var logPolicy_js_1 = require_logPolicy(), pipeline_js_1 = require_pipeline(), redirectPolicy_js_1 = require_redirectPolicy(), userAgentPolicy_js_1 = require_userAgentPolicy(), decompressResponsePolicy_js_1 = require_decompressResponsePolicy(), defaultRetryPolicy_js_1 = require_defaultRetryPolicy(), formDataPolicy_js_1 = require_formDataPolicy(), checkEnvironment_js_1 = require_checkEnvironment(), proxyPolicy_js_1 = require_proxyPolicy(), agentPolicy_js_1 = require_agentPolicy(), tlsPolicy_js_1 = require_tlsPolicy(), multipartPolicy_js_1 = require_multipartPolicy();
  function createPipelineFromOptions(options) {
    let pipeline = (0, pipeline_js_1.createEmptyPipeline)();
    if (checkEnvironment_js_1.isNodeLike) {
      if (options.agent)
        pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
      if (options.tlsOptions)
        pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
      pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions)), pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    if (pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] }), pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions)), pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" }), pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" }), checkEnvironment_js_1.isNodeLike)
      pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
    return pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" }), pipeline;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/apiVersionPolicy.js
var require_apiVersionPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.apiVersionPolicyName = void 0;
  exports.apiVersionPolicy = apiVersionPolicy;
  exports.apiVersionPolicyName = "ApiVersionPolicy";
  function apiVersionPolicy(options) {
    return {
      name: exports.apiVersionPolicyName,
      sendRequest: (req, next) => {
        let url = new URL(req.url);
        if (!url.searchParams.get("api-version") && options.apiVersion)
          req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
        return next(req);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/auth/credentials.js
var require_credentials = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isOAuth2TokenCredential = isOAuth2TokenCredential;
  exports.isBearerTokenCredential = isBearerTokenCredential;
  exports.isBasicCredential = isBasicCredential;
  exports.isApiKeyCredential = isApiKeyCredential;
  function isOAuth2TokenCredential(credential) {
    return "getOAuth2Token" in credential;
  }
  function isBearerTokenCredential(credential) {
    return "getBearerToken" in credential;
  }
  function isBasicCredential(credential) {
    return "username" in credential && "password" in credential;
  }
  function isApiKeyCredential(credential) {
    return "key" in credential;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/checkInsecureConnection.js
var require_checkInsecureConnection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ensureSecureConnection = ensureSecureConnection;
  var log_js_1 = require_log2(), insecureConnectionWarningEmmitted = !1;
  function allowInsecureConnection(request, options) {
    if (options.allowInsecureConnection && request.allowInsecureConnection) {
      let url = new URL(request.url);
      if (url.hostname === "localhost" || url.hostname === "127.0.0.1")
        return !0;
    }
    return !1;
  }
  function emitInsecureConnectionWarning() {
    if (log_js_1.logger.warning("Sending token over insecure transport. Assume any token issued is compromised."), typeof process?.emitWarning === "function" && !insecureConnectionWarningEmmitted)
      insecureConnectionWarningEmmitted = !0, process.emitWarning("Sending token over insecure transport. Assume any token issued is compromised.");
  }
  function ensureSecureConnection(request, options) {
    if (!request.url.toLowerCase().startsWith("https://"))
      if (allowInsecureConnection(request, options))
        emitInsecureConnectionWarning();
      else
        throw Error("Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/apiKeyAuthenticationPolicy.js
var require_apiKeyAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.apiKeyAuthenticationPolicyName = void 0;
  exports.apiKeyAuthenticationPolicy = apiKeyAuthenticationPolicy;
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
  function apiKeyAuthenticationPolicy(options) {
    return {
      name: exports.apiKeyAuthenticationPolicyName,
      async sendRequest(request, next) {
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
        let scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "apiKey");
        if (!scheme)
          return next(request);
        if (scheme.apiKeyLocation !== "header")
          throw Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
        return request.headers.set(scheme.name, options.credential.key), next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/basicAuthenticationPolicy.js
var require_basicAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.basicAuthenticationPolicyName = void 0;
  exports.basicAuthenticationPolicy = basicAuthenticationPolicy;
  var bytesEncoding_js_1 = require_bytesEncoding(), checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
  function basicAuthenticationPolicy(options) {
    return {
      name: exports.basicAuthenticationPolicyName,
      async sendRequest(request, next) {
        if ((0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options), !(request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "basic"))
          return next(request);
        let { username, password } = options.credential, headerValue = (0, bytesEncoding_js_1.uint8ArrayToString)((0, bytesEncoding_js_1.stringToUint8Array)(`${username}:${password}`, "utf-8"), "base64");
        return request.headers.set("Authorization", `Basic ${headerValue}`), next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/bearerAuthenticationPolicy.js
var require_bearerAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.bearerAuthenticationPolicyName = void 0;
  exports.bearerAuthenticationPolicy = bearerAuthenticationPolicy;
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
  function bearerAuthenticationPolicy(options) {
    return {
      name: exports.bearerAuthenticationPolicyName,
      async sendRequest(request, next) {
        if ((0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options), !(request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "bearer"))
          return next(request);
        let token = await options.credential.getBearerToken({
          abortSignal: request.abortSignal
        });
        return request.headers.set("Authorization", `Bearer ${token}`), next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/auth/oauth2AuthenticationPolicy.js
var require_oauth2AuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.oauth2AuthenticationPolicyName = void 0;
  exports.oauth2AuthenticationPolicy = oauth2AuthenticationPolicy;
  var checkInsecureConnection_js_1 = require_checkInsecureConnection();
  exports.oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
  function oauth2AuthenticationPolicy(options) {
    return {
      name: exports.oauth2AuthenticationPolicyName,
      async sendRequest(request, next) {
        (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
        let scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "oauth2");
        if (!scheme)
          return next(request);
        let token = await options.credential.getOAuth2Token(scheme.flows, {
          abortSignal: request.abortSignal
        });
        return request.headers.set("Authorization", `Bearer ${token}`), next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/clientHelpers.js
var require_clientHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createDefaultPipeline = createDefaultPipeline;
  exports.getCachedDefaultHttpsClient = getCachedDefaultHttpsClient;
  var defaultHttpClient_js_1 = require_defaultHttpClient(), createPipelineFromOptions_js_1 = require_createPipelineFromOptions(), apiVersionPolicy_js_1 = require_apiVersionPolicy(), credentials_js_1 = require_credentials(), apiKeyAuthenticationPolicy_js_1 = require_apiKeyAuthenticationPolicy(), basicAuthenticationPolicy_js_1 = require_basicAuthenticationPolicy(), bearerAuthenticationPolicy_js_1 = require_bearerAuthenticationPolicy(), oauth2AuthenticationPolicy_js_1 = require_oauth2AuthenticationPolicy(), cachedHttpClient;
  function createDefaultPipeline(options = {}) {
    let pipeline = (0, createPipelineFromOptions_js_1.createPipelineFromOptions)(options);
    pipeline.addPolicy((0, apiVersionPolicy_js_1.apiVersionPolicy)(options));
    let { credential, authSchemes, allowInsecureConnection } = options;
    if (credential) {
      if ((0, credentials_js_1.isApiKeyCredential)(credential))
        pipeline.addPolicy((0, apiKeyAuthenticationPolicy_js_1.apiKeyAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      else if ((0, credentials_js_1.isBasicCredential)(credential))
        pipeline.addPolicy((0, basicAuthenticationPolicy_js_1.basicAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      else if ((0, credentials_js_1.isBearerTokenCredential)(credential))
        pipeline.addPolicy((0, bearerAuthenticationPolicy_js_1.bearerAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
      else if ((0, credentials_js_1.isOAuth2TokenCredential)(credential))
        pipeline.addPolicy((0, oauth2AuthenticationPolicy_js_1.oauth2AuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
    }
    return pipeline;
  }
  function getCachedDefaultHttpsClient() {
    if (!cachedHttpClient)
      cachedHttpClient = (0, defaultHttpClient_js_1.createDefaultHttpClient)();
    return cachedHttpClient;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/multipart.js
var require_multipart2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.buildBodyPart = buildBodyPart;
  exports.buildMultipartBody = buildMultipartBody;
  var restError_js_1 = require_restError(), httpHeaders_js_1 = require_httpHeaders(), bytesEncoding_js_1 = require_bytesEncoding(), typeGuards_js_1 = require_typeGuards();
  function getHeaderValue(descriptor, headerName) {
    if (descriptor.headers) {
      let actualHeaderName = Object.keys(descriptor.headers).find((x) => x.toLowerCase() === headerName.toLowerCase());
      if (actualHeaderName)
        return descriptor.headers[actualHeaderName];
    }
    return;
  }
  function getPartContentType(descriptor) {
    let contentTypeHeader = getHeaderValue(descriptor, "content-type");
    if (contentTypeHeader)
      return contentTypeHeader;
    if (descriptor.contentType === null)
      return;
    if (descriptor.contentType)
      return descriptor.contentType;
    let { body } = descriptor;
    if (body === null || body === void 0)
      return;
    if (typeof body === "string" || typeof body === "number" || typeof body === "boolean")
      return "text/plain; charset=UTF-8";
    if (body instanceof Blob)
      return body.type || "application/octet-stream";
    if ((0, typeGuards_js_1.isBinaryBody)(body))
      return "application/octet-stream";
    return "application/json";
  }
  function escapeDispositionField(value) {
    return JSON.stringify(value);
  }
  function getContentDisposition(descriptor) {
    let contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
    if (contentDispositionHeader)
      return contentDispositionHeader;
    if (descriptor.dispositionType === void 0 && descriptor.name === void 0 && descriptor.filename === void 0)
      return;
    let disposition = descriptor.dispositionType ?? "form-data";
    if (descriptor.name)
      disposition += `; name=${escapeDispositionField(descriptor.name)}`;
    let filename = void 0;
    if (descriptor.filename)
      filename = descriptor.filename;
    else if (typeof File < "u" && descriptor.body instanceof File) {
      let filenameFromFile = descriptor.body.name;
      if (filenameFromFile !== "")
        filename = filenameFromFile;
    }
    if (filename)
      disposition += `; filename=${escapeDispositionField(filename)}`;
    return disposition;
  }
  function normalizeBody(body, contentType) {
    if (body === void 0)
      return new Uint8Array([]);
    if ((0, typeGuards_js_1.isBinaryBody)(body))
      return body;
    if (typeof body === "string" || typeof body === "number" || typeof body === "boolean")
      return (0, bytesEncoding_js_1.stringToUint8Array)(String(body), "utf-8");
    if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType)))
      return (0, bytesEncoding_js_1.stringToUint8Array)(JSON.stringify(body), "utf-8");
    throw new restError_js_1.RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
  }
  function buildBodyPart(descriptor) {
    let contentType = getPartContentType(descriptor), contentDisposition = getContentDisposition(descriptor), headers = (0, httpHeaders_js_1.createHttpHeaders)(descriptor.headers ?? {});
    if (contentType)
      headers.set("content-type", contentType);
    if (contentDisposition)
      headers.set("content-disposition", contentDisposition);
    let body = normalizeBody(descriptor.body, contentType);
    return {
      headers,
      body
    };
  }
  function buildMultipartBody(parts) {
    return { parts: parts.map(buildBodyPart) };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/sendRequest.js
var require_sendRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.sendRequest = sendRequest;
  var restError_js_1 = require_restError(), httpHeaders_js_1 = require_httpHeaders(), pipelineRequest_js_1 = require_pipelineRequest(), clientHelpers_js_1 = require_clientHelpers(), typeGuards_js_1 = require_typeGuards(), multipart_js_1 = require_multipart2();
  async function sendRequest(method, url, pipeline, options = {}, customHttpClient) {
    let httpClient = customHttpClient ?? (0, clientHelpers_js_1.getCachedDefaultHttpsClient)(), request = buildPipelineRequest(method, url, options);
    try {
      let response = await pipeline.sendRequest(httpClient, request), headers = response.headers.toJSON(), stream = response.readableStreamBody ?? response.browserStreamBody, parsedBody = options.responseAsStream || stream !== void 0 ? void 0 : getResponseBody(response), body = stream ?? parsedBody;
      if (options?.onResponse)
        options.onResponse({ ...response, request, rawHeaders: headers, parsedBody });
      return {
        request,
        headers,
        status: `${response.status}`,
        body
      };
    } catch (e) {
      if ((0, restError_js_1.isRestError)(e) && e.response && options.onResponse) {
        let { response } = e, rawHeaders = response.headers.toJSON();
        options?.onResponse({ ...response, request, rawHeaders }, e);
      }
      throw e;
    }
  }
  function getRequestContentType(options = {}) {
    return options.contentType ?? options.headers?.["content-type"] ?? getContentType(options.body);
  }
  function getContentType(body) {
    if (ArrayBuffer.isView(body))
      return "application/octet-stream";
    if (typeof body === "string")
      try {
        return JSON.parse(body), "application/json";
      } catch (error) {
        return;
      }
    return "application/json";
  }
  function buildPipelineRequest(method, url, options = {}) {
    let requestContentType = getRequestContentType(options), { body, multipartBody } = getRequestBody(options.body, requestContentType), hasContent = body !== void 0 || multipartBody !== void 0, headers = (0, httpHeaders_js_1.createHttpHeaders)({
      ...options.headers ? options.headers : {},
      accept: options.accept ?? options.headers?.accept ?? "application/json",
      ...hasContent && requestContentType && {
        "content-type": requestContentType
      }
    });
    return (0, pipelineRequest_js_1.createPipelineRequest)({
      url,
      method,
      body,
      multipartBody,
      headers,
      allowInsecureConnection: options.allowInsecureConnection,
      abortSignal: options.abortSignal,
      onUploadProgress: options.onUploadProgress,
      onDownloadProgress: options.onDownloadProgress,
      timeout: options.timeout,
      enableBrowserStreams: !0,
      streamResponseStatusCodes: options.responseAsStream ? /* @__PURE__ */ new Set([Number.POSITIVE_INFINITY]) : void 0
    });
  }
  function getRequestBody(body, contentType = "") {
    if (body === void 0)
      return { body: void 0 };
    if (typeof FormData < "u" && body instanceof FormData)
      return { body };
    if ((0, typeGuards_js_1.isReadableStream)(body))
      return { body };
    if (ArrayBuffer.isView(body))
      return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
    switch (contentType.split(";")[0]) {
      case "application/json":
        return { body: JSON.stringify(body) };
      case "multipart/form-data":
        if (Array.isArray(body))
          return { multipartBody: (0, multipart_js_1.buildMultipartBody)(body) };
        return { body: JSON.stringify(body) };
      case "text/plain":
        return { body: String(body) };
      default:
        if (typeof body === "string")
          return { body };
        return { body: JSON.stringify(body) };
    }
  }
  function getResponseBody(response) {
    let firstType = (response.headers.get("content-type") ?? "").split(";")[0], bodyToParse = response.bodyAsText ?? "";
    if (firstType === "text/plain")
      return String(bodyToParse);
    try {
      return bodyToParse ? JSON.parse(bodyToParse) : void 0;
    } catch (error) {
      if (firstType === "application/json")
        throw createParseError(response, error);
      return String(bodyToParse);
    }
  }
  function createParseError(response, err) {
    let msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`, errCode = err.code ?? restError_js_1.RestError.PARSE_ERROR;
    return new restError_js_1.RestError(msg, {
      code: errCode,
      statusCode: response.status,
      request: response.request,
      response
    });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/urlHelpers.js
var require_urlHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.buildRequestUrl = buildRequestUrl;
  exports.buildBaseUrl = buildBaseUrl;
  exports.replaceAll = replaceAll;
  function isQueryParameterWithOptions(x) {
    let value = x.value;
    return value !== void 0 && value.toString !== void 0 && typeof value.toString === "function";
  }
  function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {
    if (routePath.startsWith("https://") || routePath.startsWith("http://"))
      return routePath;
    endpoint = buildBaseUrl(endpoint, options), routePath = buildRoutePath(routePath, pathParameters, options);
    let requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);
    return new URL(requestUrl).toString().replace(/([^:]\/)\/+/g, "$1");
  }
  function getQueryParamValue(key, allowReserved, style, param) {
    let separator;
    if (style === "pipeDelimited")
      separator = "|";
    else if (style === "spaceDelimited")
      separator = "%20";
    else
      separator = ",";
    let paramValues;
    if (Array.isArray(param))
      paramValues = param;
    else if (typeof param === "object" && param.toString === Object.prototype.toString)
      paramValues = Object.entries(param).flat();
    else
      paramValues = [param];
    let value = paramValues.map((p) => {
      if (p === null || p === void 0)
        return "";
      if (!p.toString || typeof p.toString !== "function")
        throw Error(`Query parameters must be able to be represented as string, ${key} can't`);
      let rawValue = p.toISOString !== void 0 ? p.toISOString() : p.toString();
      return allowReserved ? rawValue : encodeURIComponent(rawValue);
    }).join(separator);
    return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;
  }
  function appendQueryParams(url, options = {}) {
    if (!options.queryParameters)
      return url;
    let parsedUrl = new URL(url), queryParams = options.queryParameters, paramStrings = [];
    for (let key of Object.keys(queryParams)) {
      let param = queryParams[key];
      if (param === void 0 || param === null)
        continue;
      let hasMetadata = isQueryParameterWithOptions(param), rawValue = hasMetadata ? param.value : param, explode = hasMetadata ? param.explode ?? !1 : !1, style = hasMetadata && param.style ? param.style : "form";
      if (explode)
        if (Array.isArray(rawValue))
          for (let item of rawValue)
            paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? !1, style, item));
        else if (typeof rawValue === "object")
          for (let [actualKey, value] of Object.entries(rawValue))
            paramStrings.push(getQueryParamValue(actualKey, options.skipUrlEncoding ?? !1, style, value));
        else
          throw Error("explode can only be set to true for objects and arrays");
      else
        paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? !1, style, rawValue));
    }
    if (parsedUrl.search !== "")
      parsedUrl.search += "&";
    return parsedUrl.search += paramStrings.join("&"), parsedUrl.toString();
  }
  function buildBaseUrl(endpoint, options) {
    if (!options.pathParameters)
      return endpoint;
    let pathParams = options.pathParameters;
    for (let [key, param] of Object.entries(pathParams)) {
      if (param === void 0 || param === null)
        throw Error(`Path parameters ${key} must not be undefined or null`);
      if (!param.toString || typeof param.toString !== "function")
        throw Error(`Path parameters must be able to be represented as string, ${key} can't`);
      let value = param.toISOString !== void 0 ? param.toISOString() : String(param);
      if (!options.skipUrlEncoding)
        value = encodeURIComponent(param);
      endpoint = replaceAll(endpoint, `{${key}}`, value) ?? "";
    }
    return endpoint;
  }
  function buildRoutePath(routePath, pathParameters, options = {}) {
    for (let pathParam of pathParameters) {
      let allowReserved = typeof pathParam === "object" && (pathParam.allowReserved ?? !1), value = typeof pathParam === "object" ? pathParam.value : pathParam;
      if (!options.skipUrlEncoding && !allowReserved)
        value = encodeURIComponent(value);
      routePath = routePath.replace(/\{[\w-]+\}/, String(value));
    }
    return routePath;
  }
  function replaceAll(value, searchValue, replaceValue) {
    return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/getClient.js
var require_getClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getClient = getClient;
  var clientHelpers_js_1 = require_clientHelpers(), sendRequest_js_1 = require_sendRequest(), urlHelpers_js_1 = require_urlHelpers(), checkEnvironment_js_1 = require_checkEnvironment();
  function getClient(endpoint, clientOptions = {}) {
    let pipeline = clientOptions.pipeline ?? (0, clientHelpers_js_1.createDefaultPipeline)(clientOptions);
    if (clientOptions.additionalPolicies?.length)
      for (let { policy, position } of clientOptions.additionalPolicies) {
        let afterPhase = position === "perRetry" ? "Sign" : void 0;
        pipeline.addPolicy(policy, {
          afterPhase
        });
      }
    let { allowInsecureConnection, httpClient } = clientOptions, endpointUrl = clientOptions.endpoint ?? endpoint, client = (path, ...args) => {
      let getUrl = (requestOptions) => (0, urlHelpers_js_1.buildRequestUrl)(endpointUrl, path, args, { allowInsecureConnection, ...requestOptions });
      return {
        get: (requestOptions = {}) => {
          return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        post: (requestOptions = {}) => {
          return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        put: (requestOptions = {}) => {
          return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        patch: (requestOptions = {}) => {
          return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        delete: (requestOptions = {}) => {
          return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        head: (requestOptions = {}) => {
          return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        options: (requestOptions = {}) => {
          return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        },
        trace: (requestOptions = {}) => {
          return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
        }
      };
    };
    return {
      path: client,
      pathUnchecked: client,
      pipeline
    };
  }
  function buildOperation(method, url, pipeline, options, allowInsecureConnection, httpClient) {
    return allowInsecureConnection = options.allowInsecureConnection ?? allowInsecureConnection, {
      then: function(onFulfilled, onrejected) {
        return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection }, httpClient).then(onFulfilled, onrejected);
      },
      async asBrowserStream() {
        if (checkEnvironment_js_1.isNodeLike)
          throw Error("`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.");
        else
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: !0 }, httpClient);
      },
      async asNodeStream() {
        if (checkEnvironment_js_1.isNodeLike)
          return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: !0 }, httpClient);
        else
          throw Error("`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.");
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/operationOptionHelpers.js
var require_operationOptionHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.operationOptionsToRequestParameters = operationOptionsToRequestParameters;
  function operationOptionsToRequestParameters(options) {
    return {
      allowInsecureConnection: options.requestOptions?.allowInsecureConnection,
      timeout: options.requestOptions?.timeout,
      skipUrlEncoding: options.requestOptions?.skipUrlEncoding,
      abortSignal: options.abortSignal,
      onUploadProgress: options.requestOptions?.onUploadProgress,
      onDownloadProgress: options.requestOptions?.onDownloadProgress,
      headers: { ...options.requestOptions?.headers },
      onResponse: options.onResponse
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/client/restError.js
var require_restError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createRestError = createRestError;
  var restError_js_1 = require_restError(), httpHeaders_js_1 = require_httpHeaders();
  function createRestError(messageOrResponse, response) {
    let resp = typeof messageOrResponse === "string" ? response : messageOrResponse, internalError = resp.body?.error ?? resp.body, message = typeof messageOrResponse === "string" ? messageOrResponse : internalError?.message ?? `Unexpected status code: ${resp.status}`;
    return new restError_js_1.RestError(message, {
      statusCode: statusCodeToNumber(resp.status),
      code: internalError?.code,
      request: resp.request,
      response: toPipelineResponse(resp)
    });
  }
  function toPipelineResponse(response) {
    return {
      headers: (0, httpHeaders_js_1.createHttpHeaders)(response.headers),
      request: response.request,
      status: statusCodeToNumber(response.status) ?? -1
    };
  }
  function statusCodeToNumber(statusCode) {
    let status = Number.parseInt(statusCode);
    return Number.isNaN(status) ? void 0 : status;
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/index.js
var require_commonjs3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createRestError = exports.operationOptionsToRequestParameters = exports.getClient = exports.createDefaultHttpClient = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isRestError = exports.RestError = exports.createEmptyPipeline = exports.createPipelineRequest = exports.createHttpHeaders = exports.TypeSpecRuntimeLogger = exports.setLogLevel = exports.getLogLevel = exports.createClientLogger = exports.AbortError = void 0;
  var tslib_1 = require_tslib(), AbortError_js_1 = require_AbortError();
  Object.defineProperty(exports, "AbortError", { enumerable: !0, get: function() {
    return AbortError_js_1.AbortError;
  } });
  var logger_js_1 = require_logger();
  Object.defineProperty(exports, "createClientLogger", { enumerable: !0, get: function() {
    return logger_js_1.createClientLogger;
  } });
  Object.defineProperty(exports, "getLogLevel", { enumerable: !0, get: function() {
    return logger_js_1.getLogLevel;
  } });
  Object.defineProperty(exports, "setLogLevel", { enumerable: !0, get: function() {
    return logger_js_1.setLogLevel;
  } });
  Object.defineProperty(exports, "TypeSpecRuntimeLogger", { enumerable: !0, get: function() {
    return logger_js_1.TypeSpecRuntimeLogger;
  } });
  var httpHeaders_js_1 = require_httpHeaders();
  Object.defineProperty(exports, "createHttpHeaders", { enumerable: !0, get: function() {
    return httpHeaders_js_1.createHttpHeaders;
  } });
  tslib_1.__exportStar(require_schemes(), exports);
  tslib_1.__exportStar(require_oauth2Flows(), exports);
  var pipelineRequest_js_1 = require_pipelineRequest();
  Object.defineProperty(exports, "createPipelineRequest", { enumerable: !0, get: function() {
    return pipelineRequest_js_1.createPipelineRequest;
  } });
  var pipeline_js_1 = require_pipeline();
  Object.defineProperty(exports, "createEmptyPipeline", { enumerable: !0, get: function() {
    return pipeline_js_1.createEmptyPipeline;
  } });
  var restError_js_1 = require_restError();
  Object.defineProperty(exports, "RestError", { enumerable: !0, get: function() {
    return restError_js_1.RestError;
  } });
  Object.defineProperty(exports, "isRestError", { enumerable: !0, get: function() {
    return restError_js_1.isRestError;
  } });
  var bytesEncoding_js_1 = require_bytesEncoding();
  Object.defineProperty(exports, "stringToUint8Array", { enumerable: !0, get: function() {
    return bytesEncoding_js_1.stringToUint8Array;
  } });
  Object.defineProperty(exports, "uint8ArrayToString", { enumerable: !0, get: function() {
    return bytesEncoding_js_1.uint8ArrayToString;
  } });
  var defaultHttpClient_js_1 = require_defaultHttpClient();
  Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: !0, get: function() {
    return defaultHttpClient_js_1.createDefaultHttpClient;
  } });
  var getClient_js_1 = require_getClient();
  Object.defineProperty(exports, "getClient", { enumerable: !0, get: function() {
    return getClient_js_1.getClient;
  } });
  var operationOptionHelpers_js_1 = require_operationOptionHelpers();
  Object.defineProperty(exports, "operationOptionsToRequestParameters", { enumerable: !0, get: function() {
    return operationOptionHelpers_js_1.operationOptionsToRequestParameters;
  } });
  var restError_js_2 = require_restError2();
  Object.defineProperty(exports, "createRestError", { enumerable: !0, get: function() {
    return restError_js_2.createRestError;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipeline.js
var require_pipeline2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createEmptyPipeline = createEmptyPipeline;
  var ts_http_runtime_1 = require_commonjs3();
  function createEmptyPipeline() {
    return (0, ts_http_runtime_1.createEmptyPipeline)();
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/logger/internal.js
var require_internal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createLoggerContext = void 0;
  var logger_js_1 = require_logger();
  Object.defineProperty(exports, "createLoggerContext", { enumerable: !0, get: function() {
    return logger_js_1.createLoggerContext;
  } });
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AzureLogger = void 0;
  exports.setLogLevel = setLogLevel;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger;
  var logger_1 = require_internal(), context = (0, logger_1.createLoggerContext)({
    logLevelEnvVarName: "AZURE_LOG_LEVEL",
    namespace: "azure"
  });
  exports.AzureLogger = context.logger;
  function setLogLevel(level) {
    context.setLogLevel(level);
  }
  function getLogLevel() {
    return context.getLogLevel();
  }
  function createClientLogger(namespace) {
    return context.createClientLogger(namespace);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/log.js
var require_log3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.logger = void 0;
  var logger_1 = require_commonjs4();
  exports.logger = (0, logger_1.createClientLogger)("core-rest-pipeline");
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.exponentialRetryPolicyName = void 0;
  exports.exponentialRetryPolicy = exponentialRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy(), retryPolicy_js_1 = require_retryPolicy(), constants_js_1 = require_constants6();
  exports.exponentialRetryPolicyName = "exponentialRetryPolicy";
  function exponentialRetryPolicy(options = {}) {
    return (0, retryPolicy_js_1.retryPolicy)([
      (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
        ...options,
        ignoreSystemErrors: !0
      })
    ], {
      maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
    });
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.systemErrorRetryPolicyName = void 0;
  exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
  var exponentialRetryStrategy_js_1 = require_exponentialRetryStrategy(), retryPolicy_js_1 = require_retryPolicy(), constants_js_1 = require_constants6();
  exports.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
  function systemErrorRetryPolicy(options = {}) {
    return {
      name: exports.systemErrorRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([
        (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
          ...options,
          ignoreHttpStatusCodes: !0
        })
      ], {
        maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.throttlingRetryPolicyName = void 0;
  exports.throttlingRetryPolicy = throttlingRetryPolicy;
  var throttlingRetryStrategy_js_1 = require_throttlingRetryStrategy(), retryPolicy_js_1 = require_retryPolicy(), constants_js_1 = require_constants6();
  exports.throttlingRetryPolicyName = "throttlingRetryPolicy";
  function throttlingRetryPolicy(options = {}) {
    return {
      name: exports.throttlingRetryPolicyName,
      sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], {
        maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT
      }).sendRequest
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/policies/internal.js
var require_internal2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.userAgentPolicyName = exports.userAgentPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.retryPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.defaultRetryPolicyName = exports.defaultRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.agentPolicyName = exports.agentPolicy = void 0;
  var agentPolicy_js_1 = require_agentPolicy();
  Object.defineProperty(exports, "agentPolicy", { enumerable: !0, get: function() {
    return agentPolicy_js_1.agentPolicy;
  } });
  Object.defineProperty(exports, "agentPolicyName", { enumerable: !0, get: function() {
    return agentPolicy_js_1.agentPolicyName;
  } });
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy();
  Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: !0, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicy;
  } });
  Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: !0, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicyName;
  } });
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy();
  Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: !0, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicy;
  } });
  Object.defineProperty(exports, "defaultRetryPolicyName", { enumerable: !0, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicyName;
  } });
  var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy();
  Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: !0, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
  } });
  Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: !0, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
  } });
  var retryPolicy_js_1 = require_retryPolicy();
  Object.defineProperty(exports, "retryPolicy", { enumerable: !0, get: function() {
    return retryPolicy_js_1.retryPolicy;
  } });
  var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy();
  Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: !0, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
  } });
  Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: !0, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
  } });
  var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy();
  Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: !0, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
  } });
  Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: !0, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
  } });
  var formDataPolicy_js_1 = require_formDataPolicy();
  Object.defineProperty(exports, "formDataPolicy", { enumerable: !0, get: function() {
    return formDataPolicy_js_1.formDataPolicy;
  } });
  Object.defineProperty(exports, "formDataPolicyName", { enumerable: !0, get: function() {
    return formDataPolicy_js_1.formDataPolicyName;
  } });
  var logPolicy_js_1 = require_logPolicy();
  Object.defineProperty(exports, "logPolicy", { enumerable: !0, get: function() {
    return logPolicy_js_1.logPolicy;
  } });
  Object.defineProperty(exports, "logPolicyName", { enumerable: !0, get: function() {
    return logPolicy_js_1.logPolicyName;
  } });
  var multipartPolicy_js_1 = require_multipartPolicy();
  Object.defineProperty(exports, "multipartPolicy", { enumerable: !0, get: function() {
    return multipartPolicy_js_1.multipartPolicy;
  } });
  Object.defineProperty(exports, "multipartPolicyName", { enumerable: !0, get: function() {
    return multipartPolicy_js_1.multipartPolicyName;
  } });
  var proxyPolicy_js_1 = require_proxyPolicy();
  Object.defineProperty(exports, "proxyPolicy", { enumerable: !0, get: function() {
    return proxyPolicy_js_1.proxyPolicy;
  } });
  Object.defineProperty(exports, "proxyPolicyName", { enumerable: !0, get: function() {
    return proxyPolicy_js_1.proxyPolicyName;
  } });
  Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: !0, get: function() {
    return proxyPolicy_js_1.getDefaultProxySettings;
  } });
  var redirectPolicy_js_1 = require_redirectPolicy();
  Object.defineProperty(exports, "redirectPolicy", { enumerable: !0, get: function() {
    return redirectPolicy_js_1.redirectPolicy;
  } });
  Object.defineProperty(exports, "redirectPolicyName", { enumerable: !0, get: function() {
    return redirectPolicy_js_1.redirectPolicyName;
  } });
  var tlsPolicy_js_1 = require_tlsPolicy();
  Object.defineProperty(exports, "tlsPolicy", { enumerable: !0, get: function() {
    return tlsPolicy_js_1.tlsPolicy;
  } });
  Object.defineProperty(exports, "tlsPolicyName", { enumerable: !0, get: function() {
    return tlsPolicy_js_1.tlsPolicyName;
  } });
  var userAgentPolicy_js_1 = require_userAgentPolicy();
  Object.defineProperty(exports, "userAgentPolicy", { enumerable: !0, get: function() {
    return userAgentPolicy_js_1.userAgentPolicy;
  } });
  Object.defineProperty(exports, "userAgentPolicyName", { enumerable: !0, get: function() {
    return userAgentPolicy_js_1.userAgentPolicyName;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/logPolicy.js
var require_logPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.logPolicyName = void 0;
  exports.logPolicy = logPolicy;
  var log_js_1 = require_log3(), policies_1 = require_internal2();
  exports.logPolicyName = policies_1.logPolicyName;
  function logPolicy(options = {}) {
    return (0, policies_1.logPolicy)({
      logger: log_js_1.logger.info,
      ...options
    });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/redirectPolicy.js
var require_redirectPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.redirectPolicyName = void 0;
  exports.redirectPolicy = redirectPolicy;
  var policies_1 = require_internal2();
  exports.redirectPolicyName = policies_1.redirectPolicyName;
  function redirectPolicy(options = {}) {
    return (0, policies_1.redirectPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgentPlatform.js
var require_userAgentPlatform2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getHeaderName = getHeaderName;
  exports.setPlatformSpecificData = setPlatformSpecificData;
  var tslib_1 = require_tslib(), node_os_1 = tslib_1.__importDefault(__require("node:os")), node_process_1 = tslib_1.__importDefault(__require("node:process"));
  function getHeaderName() {
    return "User-Agent";
  }
  async function setPlatformSpecificData(map) {
    if (node_process_1.default && node_process_1.default.versions) {
      let osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`, versions = node_process_1.default.versions;
      if (versions.bun)
        map.set("Bun", `${versions.bun} (${osInfo})`);
      else if (versions.deno)
        map.set("Deno", `${versions.deno} (${osInfo})`);
      else if (versions.node)
        map.set("Node", `${versions.node} (${osInfo})`);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/constants.js
var require_constants7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.DEFAULT_RETRY_POLICY_COUNT = exports.SDK_VERSION = void 0;
  exports.SDK_VERSION = "1.22.2";
  exports.DEFAULT_RETRY_POLICY_COUNT = 3;
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/userAgent.js
var require_userAgent2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getUserAgentHeaderName = getUserAgentHeaderName;
  exports.getUserAgentValue = getUserAgentValue;
  var userAgentPlatform_js_1 = require_userAgentPlatform2(), constants_js_1 = require_constants7();
  function getUserAgentString(telemetryInfo) {
    let parts = [];
    for (let [key, value] of telemetryInfo) {
      let token = value ? `${key}/${value}` : key;
      parts.push(token);
    }
    return parts.join(" ");
  }
  function getUserAgentHeaderName() {
    return (0, userAgentPlatform_js_1.getHeaderName)();
  }
  async function getUserAgentValue(prefix) {
    let runtimeInfo = /* @__PURE__ */ new Map;
    runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION), await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
    let defaultAgent = getUserAgentString(runtimeInfo);
    return prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/userAgentPolicy.js
var require_userAgentPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.userAgentPolicyName = void 0;
  exports.userAgentPolicy = userAgentPolicy;
  var userAgent_js_1 = require_userAgent2(), UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
  exports.userAgentPolicyName = "userAgentPolicy";
  function userAgentPolicy(options = {}) {
    let userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
    return {
      name: exports.userAgentPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(UserAgentHeaderName))
          request.headers.set(UserAgentHeaderName, await userAgentValue);
        return next(request);
      }
    };
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/sha256.js
var require_sha256 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.computeSha256Hmac = computeSha256Hmac;
  exports.computeSha256Hash = computeSha256Hash;
  var node_crypto_1 = __require("node:crypto");
  async function computeSha256Hmac(key, stringToSign, encoding) {
    let decodedKey = Buffer.from(key, "base64");
    return (0, node_crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
  }
  async function computeSha256Hash(content, encoding) {
    return (0, node_crypto_1.createHash)("sha256").update(content).digest(encoding);
  }
});

// node_modules/@typespec/ts-http-runtime/dist/commonjs/util/internal.js
var require_internal3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Sanitizer = exports.uint8ArrayToString = exports.stringToUint8Array = exports.isWebWorker = exports.isReactNative = exports.isDeno = exports.isNodeRuntime = exports.isNodeLike = exports.isBun = exports.isBrowser = exports.randomUUID = exports.computeSha256Hmac = exports.computeSha256Hash = exports.isError = exports.isObject = exports.getRandomIntegerInclusive = exports.calculateRetryDelay = void 0;
  var delay_js_1 = require_delay();
  Object.defineProperty(exports, "calculateRetryDelay", { enumerable: !0, get: function() {
    return delay_js_1.calculateRetryDelay;
  } });
  var random_js_1 = require_random();
  Object.defineProperty(exports, "getRandomIntegerInclusive", { enumerable: !0, get: function() {
    return random_js_1.getRandomIntegerInclusive;
  } });
  var object_js_1 = require_object();
  Object.defineProperty(exports, "isObject", { enumerable: !0, get: function() {
    return object_js_1.isObject;
  } });
  var error_js_1 = require_error();
  Object.defineProperty(exports, "isError", { enumerable: !0, get: function() {
    return error_js_1.isError;
  } });
  var sha256_js_1 = require_sha256();
  Object.defineProperty(exports, "computeSha256Hash", { enumerable: !0, get: function() {
    return sha256_js_1.computeSha256Hash;
  } });
  Object.defineProperty(exports, "computeSha256Hmac", { enumerable: !0, get: function() {
    return sha256_js_1.computeSha256Hmac;
  } });
  var uuidUtils_js_1 = require_uuidUtils();
  Object.defineProperty(exports, "randomUUID", { enumerable: !0, get: function() {
    return uuidUtils_js_1.randomUUID;
  } });
  var checkEnvironment_js_1 = require_checkEnvironment();
  Object.defineProperty(exports, "isBrowser", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isBrowser;
  } });
  Object.defineProperty(exports, "isBun", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isBun;
  } });
  Object.defineProperty(exports, "isNodeLike", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isNodeLike;
  } });
  Object.defineProperty(exports, "isNodeRuntime", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isNodeRuntime;
  } });
  Object.defineProperty(exports, "isDeno", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isDeno;
  } });
  Object.defineProperty(exports, "isReactNative", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isReactNative;
  } });
  Object.defineProperty(exports, "isWebWorker", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isWebWorker;
  } });
  var bytesEncoding_js_1 = require_bytesEncoding();
  Object.defineProperty(exports, "stringToUint8Array", { enumerable: !0, get: function() {
    return bytesEncoding_js_1.stringToUint8Array;
  } });
  Object.defineProperty(exports, "uint8ArrayToString", { enumerable: !0, get: function() {
    return bytesEncoding_js_1.uint8ArrayToString;
  } });
  var sanitizer_js_1 = require_sanitizer();
  Object.defineProperty(exports, "Sanitizer", { enumerable: !0, get: function() {
    return sanitizer_js_1.Sanitizer;
  } });
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.cancelablePromiseRace = cancelablePromiseRace;
  async function cancelablePromiseRace(abortablePromiseBuilders, options) {
    let aborter = new AbortController;
    function abortHandler() {
      aborter.abort();
    }
    options?.abortSignal?.addEventListener("abort", abortHandler);
    try {
      return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
    } finally {
      aborter.abort(), options?.abortSignal?.removeEventListener("abort", abortHandler);
    }
  }
});

// node_modules/@azure/abort-controller/dist/commonjs/AbortError.js
var require_AbortError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AbortError = void 0;

  class AbortError extends Error {
    constructor(message) {
      super(message);
      this.name = "AbortError";
    }
  }
  exports.AbortError = AbortError;
});

// node_modules/@azure/abort-controller/dist/commonjs/index.js
var require_commonjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AbortError = void 0;
  var AbortError_js_1 = require_AbortError2();
  Object.defineProperty(exports, "AbortError", { enumerable: !0, get: function() {
    return AbortError_js_1.AbortError;
  } });
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createAbortablePromise = createAbortablePromise;
  var abort_controller_1 = require_commonjs5();
  function createAbortablePromise(buildPromise, options) {
    let { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options ?? {};
    return new Promise((resolve, reject) => {
      function rejectOnAbort() {
        reject(new abort_controller_1.AbortError(abortErrorMsg ?? "The operation was aborted."));
      }
      function removeListeners() {
        abortSignal?.removeEventListener("abort", onAbort);
      }
      function onAbort() {
        cleanupBeforeAbort?.(), removeListeners(), rejectOnAbort();
      }
      if (abortSignal?.aborted)
        return rejectOnAbort();
      try {
        buildPromise((x) => {
          removeListeners(), resolve(x);
        }, (x) => {
          removeListeners(), reject(x);
        });
      } catch (err) {
        reject(err);
      }
      abortSignal?.addEventListener("abort", onAbort);
    });
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.delay = delay;
  exports.calculateRetryDelay = calculateRetryDelay;
  var createAbortablePromise_js_1 = require_createAbortablePromise(), util_1 = require_internal3(), StandardAbortMessage = "The delay was aborted.";
  function delay(timeInMs, options) {
    let token, { abortSignal, abortErrorMsg } = options ?? {};
    return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
      token = setTimeout(resolve, timeInMs);
    }, {
      cleanupBeforeAbort: () => clearTimeout(token),
      abortSignal,
      abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
    });
  }
  function calculateRetryDelay(retryAttempt, config) {
    let exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt), clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    return { retryAfterInMs: clampedDelay / 2 + (0, util_1.getRandomIntegerInclusive)(0, clampedDelay / 2) };
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-util/dist/commonjs/error.js
var require_error2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getErrorMessage = getErrorMessage;
  var util_1 = require_internal3();
  function getErrorMessage(e) {
    if ((0, util_1.isError)(e))
      return e.message;
    else {
      let stringified;
      try {
        if (typeof e === "object" && e)
          stringified = JSON.stringify(e);
        else
          stringified = String(e);
      } catch (err) {
        stringified = "[unable to stringify input]";
      }
      return `Unknown error ${stringified}`;
    }
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isDefined = isDefined;
  exports.isObjectWithProperties = isObjectWithProperties;
  exports.objectHasProperty = objectHasProperty;
  function isDefined(thing) {
    return typeof thing < "u" && thing !== null;
  }
  function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object")
      return !1;
    for (let property of properties)
      if (!objectHasProperty(thing, property))
        return !1;
    return !0;
  }
  function objectHasProperty(thing, property) {
    return isDefined(thing) && typeof thing === "object" && property in thing;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isWebWorker = exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isDeno = exports.isBun = exports.isBrowser = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.getErrorMessage = exports.delay = exports.createAbortablePromise = exports.cancelablePromiseRace = void 0;
  exports.calculateRetryDelay = calculateRetryDelay;
  exports.computeSha256Hash = computeSha256Hash;
  exports.computeSha256Hmac = computeSha256Hmac;
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
  exports.isError = isError;
  exports.isObject = isObject;
  exports.randomUUID = randomUUID;
  exports.uint8ArrayToString = uint8ArrayToString;
  exports.stringToUint8Array = stringToUint8Array;
  var tslib_1 = require_tslib(), tspRuntime = tslib_1.__importStar(require_internal3()), aborterUtils_js_1 = require_aborterUtils();
  Object.defineProperty(exports, "cancelablePromiseRace", { enumerable: !0, get: function() {
    return aborterUtils_js_1.cancelablePromiseRace;
  } });
  var createAbortablePromise_js_1 = require_createAbortablePromise();
  Object.defineProperty(exports, "createAbortablePromise", { enumerable: !0, get: function() {
    return createAbortablePromise_js_1.createAbortablePromise;
  } });
  var delay_js_1 = require_delay2();
  Object.defineProperty(exports, "delay", { enumerable: !0, get: function() {
    return delay_js_1.delay;
  } });
  var error_js_1 = require_error2();
  Object.defineProperty(exports, "getErrorMessage", { enumerable: !0, get: function() {
    return error_js_1.getErrorMessage;
  } });
  var typeGuards_js_1 = require_typeGuards2();
  Object.defineProperty(exports, "isDefined", { enumerable: !0, get: function() {
    return typeGuards_js_1.isDefined;
  } });
  Object.defineProperty(exports, "isObjectWithProperties", { enumerable: !0, get: function() {
    return typeGuards_js_1.isObjectWithProperties;
  } });
  Object.defineProperty(exports, "objectHasProperty", { enumerable: !0, get: function() {
    return typeGuards_js_1.objectHasProperty;
  } });
  function calculateRetryDelay(retryAttempt, config) {
    return tspRuntime.calculateRetryDelay(retryAttempt, config);
  }
  function computeSha256Hash(content, encoding) {
    return tspRuntime.computeSha256Hash(content, encoding);
  }
  function computeSha256Hmac(key, stringToSign, encoding) {
    return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
  }
  function getRandomIntegerInclusive(min, max) {
    return tspRuntime.getRandomIntegerInclusive(min, max);
  }
  function isError(e) {
    return tspRuntime.isError(e);
  }
  function isObject(input) {
    return tspRuntime.isObject(input);
  }
  function randomUUID() {
    return tspRuntime.randomUUID();
  }
  exports.isBrowser = tspRuntime.isBrowser;
  exports.isBun = tspRuntime.isBun;
  exports.isDeno = tspRuntime.isDeno;
  exports.isNode = tspRuntime.isNodeLike;
  exports.isNodeLike = tspRuntime.isNodeLike;
  exports.isNodeRuntime = tspRuntime.isNodeRuntime;
  exports.isReactNative = tspRuntime.isReactNative;
  exports.isWebWorker = tspRuntime.isWebWorker;
  function uint8ArrayToString(bytes, format) {
    return tspRuntime.uint8ArrayToString(bytes, format);
  }
  function stringToUint8Array(value, format) {
    return tspRuntime.stringToUint8Array(value, format);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/file.js
var require_file2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.hasRawContent = hasRawContent;
  exports.getRawContent = getRawContent;
  exports.createFileFromStream = createFileFromStream;
  exports.createFile = createFile;
  var core_util_1 = require_commonjs6();
  function isNodeReadableStream(x) {
    return Boolean(x && typeof x.pipe === "function");
  }
  var unimplementedMethods = {
    arrayBuffer: () => {
      throw Error("Not implemented");
    },
    bytes: () => {
      throw Error("Not implemented");
    },
    slice: () => {
      throw Error("Not implemented");
    },
    text: () => {
      throw Error("Not implemented");
    }
  }, rawContent = Symbol("rawContent");
  function hasRawContent(x) {
    return typeof x[rawContent] === "function";
  }
  function getRawContent(blob) {
    if (hasRawContent(blob))
      return blob[rawContent]();
    else
      return blob;
  }
  function createFileFromStream(stream, name, options = {}) {
    return {
      ...unimplementedMethods,
      type: options.type ?? "",
      lastModified: options.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
      webkitRelativePath: options.webkitRelativePath ?? "",
      size: options.size ?? -1,
      name,
      stream: () => {
        let s = stream();
        if (isNodeReadableStream(s))
          throw Error("Not supported: a Node stream was provided as input to createFileFromStream.");
        return s;
      },
      [rawContent]: stream
    };
  }
  function createFile(content, name, options = {}) {
    if (core_util_1.isNodeLike)
      return {
        ...unimplementedMethods,
        type: options.type ?? "",
        lastModified: options.lastModified ?? (/* @__PURE__ */ new Date()).getTime(),
        webkitRelativePath: options.webkitRelativePath ?? "",
        size: content.byteLength,
        name,
        arrayBuffer: async () => content.buffer,
        stream: () => new Blob([toArrayBuffer(content)]).stream(),
        [rawContent]: () => content
      };
    else
      return new File([toArrayBuffer(content)], name, options);
  }
  function toArrayBuffer(source) {
    if ("resize" in source.buffer)
      return source;
    return source.map((x) => x);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/multipartPolicy.js
var require_multipartPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.multipartPolicyName = void 0;
  exports.multipartPolicy = multipartPolicy;
  var policies_1 = require_internal2(), file_js_1 = require_file2();
  exports.multipartPolicyName = policies_1.multipartPolicyName;
  function multipartPolicy() {
    let tspPolicy = (0, policies_1.multipartPolicy)();
    return {
      name: exports.multipartPolicyName,
      sendRequest: async (request, next) => {
        if (request.multipartBody) {
          for (let part of request.multipartBody.parts)
            if ((0, file_js_1.hasRawContent)(part.body))
              part.body = (0, file_js_1.getRawContent)(part.body);
        }
        return tspPolicy.sendRequest(request, next);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/decompressResponsePolicy.js
var require_decompressResponsePolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.decompressResponsePolicyName = void 0;
  exports.decompressResponsePolicy = decompressResponsePolicy;
  var policies_1 = require_internal2();
  exports.decompressResponsePolicyName = policies_1.decompressResponsePolicyName;
  function decompressResponsePolicy() {
    return (0, policies_1.decompressResponsePolicy)();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/defaultRetryPolicy.js
var require_defaultRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.defaultRetryPolicyName = void 0;
  exports.defaultRetryPolicy = defaultRetryPolicy;
  var policies_1 = require_internal2();
  exports.defaultRetryPolicyName = policies_1.defaultRetryPolicyName;
  function defaultRetryPolicy(options = {}) {
    return (0, policies_1.defaultRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/formDataPolicy.js
var require_formDataPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.formDataPolicyName = void 0;
  exports.formDataPolicy = formDataPolicy;
  var policies_1 = require_internal2();
  exports.formDataPolicyName = policies_1.formDataPolicyName;
  function formDataPolicy() {
    return (0, policies_1.formDataPolicy)();
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/proxyPolicy.js
var require_proxyPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.proxyPolicyName = void 0;
  exports.getDefaultProxySettings = getDefaultProxySettings;
  exports.proxyPolicy = proxyPolicy;
  var policies_1 = require_internal2();
  exports.proxyPolicyName = policies_1.proxyPolicyName;
  function getDefaultProxySettings(proxyUrl) {
    return (0, policies_1.getDefaultProxySettings)(proxyUrl);
  }
  function proxyPolicy(proxySettings, options) {
    return (0, policies_1.proxyPolicy)(proxySettings, options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/setClientRequestIdPolicy.js
var require_setClientRequestIdPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.setClientRequestIdPolicyName = void 0;
  exports.setClientRequestIdPolicy = setClientRequestIdPolicy;
  exports.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
    return {
      name: exports.setClientRequestIdPolicyName,
      async sendRequest(request, next) {
        if (!request.headers.has(requestIdHeaderName))
          request.headers.set(requestIdHeaderName, request.requestId);
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/agentPolicy.js
var require_agentPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.agentPolicyName = void 0;
  exports.agentPolicy = agentPolicy;
  var policies_1 = require_internal2();
  exports.agentPolicyName = policies_1.agentPolicyName;
  function agentPolicy(agent) {
    return (0, policies_1.agentPolicy)(agent);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tlsPolicy.js
var require_tlsPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.tlsPolicyName = void 0;
  exports.tlsPolicy = tlsPolicy;
  var policies_1 = require_internal2();
  exports.tlsPolicyName = policies_1.tlsPolicyName;
  function tlsPolicy(tlsSettings) {
    return (0, policies_1.tlsPolicy)(tlsSettings);
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js
var require_tracingContext = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.TracingContextImpl = exports.knownContextKeys = void 0;
  exports.createTracingContext = createTracingContext;
  exports.knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace")
  };
  function createTracingContext(options = {}) {
    let context = new TracingContextImpl(options.parentContext);
    if (options.span)
      context = context.setValue(exports.knownContextKeys.span, options.span);
    if (options.namespace)
      context = context.setValue(exports.knownContextKeys.namespace, options.namespace);
    return context;
  }

  class TracingContextImpl {
    _contextMap;
    constructor(initialContext) {
      this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map;
    }
    setValue(key, value) {
      let newContext = new TracingContextImpl(this);
      return newContext._contextMap.set(key, value), newContext;
    }
    getValue(key) {
      return this._contextMap.get(key);
    }
    deleteValue(key) {
      let newContext = new TracingContextImpl(this);
      return newContext._contextMap.delete(key), newContext;
    }
  }
  exports.TracingContextImpl = TracingContextImpl;
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist/commonjs/state.js
var require_state = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.state = void 0;
  exports.state = {
    instrumenterImplementation: void 0
  };
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js
var require_instrumenter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createDefaultTracingSpan = createDefaultTracingSpan;
  exports.createDefaultInstrumenter = createDefaultInstrumenter;
  exports.useInstrumenter = useInstrumenter;
  exports.getInstrumenter = getInstrumenter;
  var tracingContext_js_1 = require_tracingContext(), state_js_1 = require_state();
  function createDefaultTracingSpan() {
    return {
      end: () => {},
      isRecording: () => !1,
      recordException: () => {},
      setAttribute: () => {},
      setStatus: () => {},
      addEvent: () => {}
    };
  }
  function createDefaultInstrumenter() {
    return {
      createRequestHeaders: () => {
        return {};
      },
      parseTraceparentHeader: () => {
        return;
      },
      startSpan: (_name, spanOptions) => {
        return {
          span: createDefaultTracingSpan(),
          tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
        };
      },
      withContext(_context, callback, ...callbackArgs) {
        return callback(...callbackArgs);
      }
    };
  }
  function useInstrumenter(instrumenter) {
    state_js_1.state.instrumenterImplementation = instrumenter;
  }
  function getInstrumenter() {
    if (!state_js_1.state.instrumenterImplementation)
      state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
    return state_js_1.state.instrumenterImplementation;
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js
var require_tracingClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createTracingClient = createTracingClient;
  var instrumenter_js_1 = require_instrumenter(), tracingContext_js_1 = require_tracingContext();
  function createTracingClient(options) {
    let { namespace, packageName, packageVersion } = options;
    function startSpan(name, operationOptions, spanOptions) {
      let startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, {
        ...spanOptions,
        packageName,
        packageVersion,
        tracingContext: operationOptions?.tracingOptions?.tracingContext
      }), tracingContext = startSpanResult.tracingContext, span = startSpanResult.span;
      if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace))
        tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
      span.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
      let updatedOptions = Object.assign({}, operationOptions, {
        tracingOptions: { ...operationOptions?.tracingOptions, tracingContext }
      });
      return {
        span,
        updatedOptions
      };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
      let { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
      try {
        let result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
        return span.setStatus({ status: "success" }), result;
      } catch (err) {
        throw span.setStatus({ status: "error", error: err }), err;
      } finally {
        span.end();
      }
    }
    function withContext(context, callback, ...callbackArgs) {
      return (0, instrumenter_js_1.getInstrumenter)().withContext(context, callback, ...callbackArgs);
    }
    function parseTraceparentHeader(traceparentHeader) {
      return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
    }
    function createRequestHeaders(tracingContext) {
      return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
    }
    return {
      startSpan,
      withSpan,
      withContext,
      parseTraceparentHeader,
      createRequestHeaders
    };
  }
});

// node_modules/@azure/core-rest-pipeline/node_modules/@azure/core-tracing/dist/commonjs/index.js
var require_commonjs7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createTracingClient = exports.useInstrumenter = void 0;
  var instrumenter_js_1 = require_instrumenter();
  Object.defineProperty(exports, "useInstrumenter", { enumerable: !0, get: function() {
    return instrumenter_js_1.useInstrumenter;
  } });
  var tracingClient_js_1 = require_tracingClient();
  Object.defineProperty(exports, "createTracingClient", { enumerable: !0, get: function() {
    return tracingClient_js_1.createTracingClient;
  } });
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/restError.js
var require_restError3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.RestError = void 0;
  exports.isRestError = isRestError;
  var ts_http_runtime_1 = require_commonjs3();
  exports.RestError = ts_http_runtime_1.RestError;
  function isRestError(e) {
    return (0, ts_http_runtime_1.isRestError)(e);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/tracingPolicy.js
var require_tracingPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.tracingPolicyName = void 0;
  exports.tracingPolicy = tracingPolicy;
  var core_tracing_1 = require_commonjs7(), constants_js_1 = require_constants7(), userAgent_js_1 = require_userAgent2(), log_js_1 = require_log3(), core_util_1 = require_commonjs6(), restError_js_1 = require_restError3(), util_1 = require_internal3();
  exports.tracingPolicyName = "tracingPolicy";
  function tracingPolicy(options = {}) {
    let userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix), sanitizer = new util_1.Sanitizer({
      additionalAllowedQueryParameters: options.additionalAllowedQueryParameters
    }), tracingClient = tryCreateTracingClient();
    return {
      name: exports.tracingPolicyName,
      async sendRequest(request, next) {
        if (!tracingClient)
          return next(request);
        let userAgent = await userAgentPromise, spanAttributes = {
          "http.url": sanitizer.sanitizeUrl(request.url),
          "http.method": request.method,
          "http.user_agent": userAgent,
          requestId: request.requestId
        };
        if (userAgent)
          spanAttributes["http.user_agent"] = userAgent;
        let { span, tracingContext } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};
        if (!span || !tracingContext)
          return next(request);
        try {
          let response = await tracingClient.withContext(tracingContext, next, request);
          return tryProcessResponse(span, response), response;
        } catch (err) {
          throw tryProcessError(span, err), err;
        }
      }
    };
  }
  function tryCreateTracingClient() {
    try {
      return (0, core_tracing_1.createTracingClient)({
        namespace: "",
        packageName: "@azure/core-rest-pipeline",
        packageVersion: constants_js_1.SDK_VERSION
      });
    } catch (e) {
      log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e)}`);
      return;
    }
  }
  function tryCreateSpan(tracingClient, request, spanAttributes) {
    try {
      let { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
        spanKind: "client",
        spanAttributes
      });
      if (!span.isRecording()) {
        span.end();
        return;
      }
      let headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
      for (let [key, value] of Object.entries(headers))
        request.headers.set(key, value);
      return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
    } catch (e) {
      log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
      return;
    }
  }
  function tryProcessError(span, error) {
    try {
      if (span.setStatus({
        status: "error",
        error: (0, core_util_1.isError)(error) ? error : void 0
      }), (0, restError_js_1.isRestError)(error) && error.statusCode)
        span.setAttribute("http.status_code", error.statusCode);
      span.end();
    } catch (e) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
    }
  }
  function tryProcessResponse(span, response) {
    try {
      span.setAttribute("http.status_code", response.status);
      let serviceRequestId = response.headers.get("x-ms-request-id");
      if (serviceRequestId)
        span.setAttribute("serviceRequestId", serviceRequestId);
      if (response.status >= 400)
        span.setStatus({
          status: "error"
        });
      span.end();
    } catch (e) {
      log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
    }
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/wrapAbortSignal.js
var require_wrapAbortSignal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.wrapAbortSignalLike = wrapAbortSignalLike;
  function wrapAbortSignalLike(abortSignalLike) {
    if (abortSignalLike instanceof AbortSignal)
      return { abortSignal: abortSignalLike };
    if (abortSignalLike.aborted)
      return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
    let controller = new AbortController, needsCleanup = !0;
    function cleanup() {
      if (needsCleanup)
        abortSignalLike.removeEventListener("abort", listener), needsCleanup = !1;
    }
    function listener() {
      controller.abort(abortSignalLike.reason), cleanup();
    }
    return abortSignalLike.addEventListener("abort", listener), { abortSignal: controller.signal, cleanup };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/wrapAbortSignalLikePolicy.js
var require_wrapAbortSignalLikePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.wrapAbortSignalLikePolicyName = void 0;
  exports.wrapAbortSignalLikePolicy = wrapAbortSignalLikePolicy;
  var wrapAbortSignal_js_1 = require_wrapAbortSignal();
  exports.wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
  function wrapAbortSignalLikePolicy() {
    return {
      name: exports.wrapAbortSignalLikePolicyName,
      sendRequest: async (request, next) => {
        if (!request.abortSignal)
          return next(request);
        let { abortSignal, cleanup } = (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal);
        request.abortSignal = abortSignal;
        try {
          return await next(request);
        } finally {
          cleanup?.();
        }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/createPipelineFromOptions.js
var require_createPipelineFromOptions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createPipelineFromOptions = createPipelineFromOptions;
  var logPolicy_js_1 = require_logPolicy2(), pipeline_js_1 = require_pipeline2(), redirectPolicy_js_1 = require_redirectPolicy2(), userAgentPolicy_js_1 = require_userAgentPolicy2(), multipartPolicy_js_1 = require_multipartPolicy2(), decompressResponsePolicy_js_1 = require_decompressResponsePolicy2(), defaultRetryPolicy_js_1 = require_defaultRetryPolicy2(), formDataPolicy_js_1 = require_formDataPolicy2(), core_util_1 = require_commonjs6(), proxyPolicy_js_1 = require_proxyPolicy2(), setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy(), agentPolicy_js_1 = require_agentPolicy2(), tlsPolicy_js_1 = require_tlsPolicy2(), tracingPolicy_js_1 = require_tracingPolicy(), wrapAbortSignalLikePolicy_js_1 = require_wrapAbortSignalLikePolicy();
  function createPipelineFromOptions(options) {
    let pipeline = (0, pipeline_js_1.createEmptyPipeline)();
    if (core_util_1.isNodeLike) {
      if (options.agent)
        pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
      if (options.tlsOptions)
        pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
      pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions)), pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
    }
    if (pipeline.addPolicy((0, wrapAbortSignalLikePolicy_js_1.wrapAbortSignalLikePolicy)()), pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] }), pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions)), pipeline.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)(options.telemetryOptions?.clientRequestIdHeaderName)), pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" }), pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" }), pipeline.addPolicy((0, tracingPolicy_js_1.tracingPolicy)({ ...options.userAgentOptions, ...options.loggingOptions }), {
      afterPhase: "Retry"
    }), core_util_1.isNodeLike)
      pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
    return pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" }), pipeline;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/defaultHttpClient.js
var require_defaultHttpClient2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createDefaultHttpClient = createDefaultHttpClient;
  var ts_http_runtime_1 = require_commonjs3(), wrapAbortSignal_js_1 = require_wrapAbortSignal();
  function createDefaultHttpClient() {
    let client = (0, ts_http_runtime_1.createDefaultHttpClient)();
    return {
      async sendRequest(request) {
        let { abortSignal, cleanup } = request.abortSignal ? (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal) : {};
        try {
          return request.abortSignal = abortSignal, await client.sendRequest(request);
        } finally {
          cleanup?.();
        }
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/httpHeaders.js
var require_httpHeaders2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createHttpHeaders = createHttpHeaders;
  var ts_http_runtime_1 = require_commonjs3();
  function createHttpHeaders(rawHeaders) {
    return (0, ts_http_runtime_1.createHttpHeaders)(rawHeaders);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/pipelineRequest.js
var require_pipelineRequest2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createPipelineRequest = createPipelineRequest;
  var ts_http_runtime_1 = require_commonjs3();
  function createPipelineRequest(options) {
    return (0, ts_http_runtime_1.createPipelineRequest)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/exponentialRetryPolicy.js
var require_exponentialRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.exponentialRetryPolicyName = void 0;
  exports.exponentialRetryPolicy = exponentialRetryPolicy;
  var policies_1 = require_internal2();
  exports.exponentialRetryPolicyName = policies_1.exponentialRetryPolicyName;
  function exponentialRetryPolicy(options = {}) {
    return (0, policies_1.exponentialRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/systemErrorRetryPolicy.js
var require_systemErrorRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.systemErrorRetryPolicyName = void 0;
  exports.systemErrorRetryPolicy = systemErrorRetryPolicy;
  var policies_1 = require_internal2();
  exports.systemErrorRetryPolicyName = policies_1.systemErrorRetryPolicyName;
  function systemErrorRetryPolicy(options = {}) {
    return (0, policies_1.systemErrorRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/throttlingRetryPolicy.js
var require_throttlingRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.throttlingRetryPolicyName = void 0;
  exports.throttlingRetryPolicy = throttlingRetryPolicy;
  var policies_1 = require_internal2();
  exports.throttlingRetryPolicyName = policies_1.throttlingRetryPolicyName;
  function throttlingRetryPolicy(options = {}) {
    return (0, policies_1.throttlingRetryPolicy)(options);
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/retryPolicy.js
var require_retryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.retryPolicy = retryPolicy;
  var logger_1 = require_commonjs4(), constants_js_1 = require_constants7(), policies_1 = require_internal2(), retryPolicyLogger = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
  function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
    return (0, policies_1.retryPolicy)(strategies, {
      logger: retryPolicyLogger,
      ...options
    });
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/util/tokenCycler.js
var require_tokenCycler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.DEFAULT_CYCLER_OPTIONS = void 0;
  exports.createTokenCycler = createTokenCycler;
  var core_util_1 = require_commonjs6();
  exports.DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 120000
  };
  async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    async function tryGetAccessToken() {
      if (Date.now() < refreshTimeout)
        try {
          return await getAccessToken();
        } catch {
          return null;
        }
      else {
        let finalToken = await getAccessToken();
        if (finalToken === null)
          throw Error("Failed to refresh access token.");
        return finalToken;
      }
    }
    let token = await tryGetAccessToken();
    while (token === null)
      await (0, core_util_1.delay)(retryIntervalInMs), token = await tryGetAccessToken();
    return token;
  }
  function createTokenCycler(credential, tokenCyclerOptions) {
    let refreshWorker = null, token = null, tenantId, options = {
      ...exports.DEFAULT_CYCLER_OPTIONS,
      ...tokenCyclerOptions
    }, cycler = {
      get isRefreshing() {
        return refreshWorker !== null;
      },
      get shouldRefresh() {
        if (cycler.isRefreshing)
          return !1;
        if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now())
          return !0;
        return (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now();
      },
      get mustRefresh() {
        return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
      }
    };
    function refresh(scopes, getTokenOptions) {
      if (!cycler.isRefreshing)
        refreshWorker = beginRefresh(() => credential.getToken(scopes, getTokenOptions), options.retryIntervalInMs, token?.expiresOnTimestamp ?? Date.now()).then((_token) => {
          return refreshWorker = null, token = _token, tenantId = getTokenOptions.tenantId, token;
        }).catch((reason) => {
          throw refreshWorker = null, token = null, tenantId = void 0, reason;
        });
      return refreshWorker;
    }
    return async (scopes, tokenOptions) => {
      let hasClaimChallenge = Boolean(tokenOptions.claims), tenantIdChanged = tenantId !== tokenOptions.tenantId;
      if (hasClaimChallenge)
        token = null;
      if (tenantIdChanged || hasClaimChallenge || cycler.mustRefresh)
        return refresh(scopes, tokenOptions);
      if (cycler.shouldRefresh)
        refresh(scopes, tokenOptions);
      return token;
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/bearerTokenAuthenticationPolicy.js
var require_bearerTokenAuthenticationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.bearerTokenAuthenticationPolicyName = void 0;
  exports.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
  exports.parseChallenges = parseChallenges;
  var tokenCycler_js_1 = require_tokenCycler(), log_js_1 = require_log3(), restError_js_1 = require_restError3();
  exports.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  async function trySendRequest(request, next) {
    try {
      return [await next(request), void 0];
    } catch (e) {
      if ((0, restError_js_1.isRestError)(e) && e.response)
        return [e.response, e];
      else
        throw e;
    }
  }
  async function defaultAuthorizeRequest(options) {
    let { scopes, getAccessToken, request } = options, getTokenOptions = {
      abortSignal: request.abortSignal,
      tracingOptions: request.tracingOptions,
      enableCae: !0
    }, accessToken = await getAccessToken(scopes, getTokenOptions);
    if (accessToken)
      options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
  }
  function isChallengeResponse(response) {
    return response.status === 401 && response.headers.has("WWW-Authenticate");
  }
  async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
    let { scopes } = onChallengeOptions, accessToken = await onChallengeOptions.getAccessToken(scopes, {
      enableCae: !0,
      claims: caeClaims
    });
    if (!accessToken)
      return !1;
    return onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`), !0;
  }
  function bearerTokenAuthenticationPolicy(options) {
    let { credential, scopes, challengeCallbacks } = options, logger = options.logger || log_js_1.logger, callbacks = {
      authorizeRequest: challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,
      authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks)
    }, getAccessToken = credential ? (0, tokenCycler_js_1.createTokenCycler)(credential) : () => Promise.resolve(null);
    return {
      name: exports.bearerTokenAuthenticationPolicyName,
      async sendRequest(request, next) {
        if (!request.url.toLowerCase().startsWith("https://"))
          throw Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
        await callbacks.authorizeRequest({
          scopes: Array.isArray(scopes) ? scopes : [scopes],
          request,
          getAccessToken,
          logger
        });
        let response, error, shouldSendRequest;
        if ([response, error] = await trySendRequest(request, next), isChallengeResponse(response)) {
          let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
          if (claims) {
            let parsedClaim;
            try {
              parsedClaim = atob(claims);
            } catch (e) {
              return logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`), response;
            }
            if (shouldSendRequest = await authorizeRequestOnCaeChallenge({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              response,
              request,
              getAccessToken,
              logger
            }, parsedClaim), shouldSendRequest)
              [response, error] = await trySendRequest(request, next);
          } else if (callbacks.authorizeRequestOnChallenge) {
            if (shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
              scopes: Array.isArray(scopes) ? scopes : [scopes],
              request,
              response,
              getAccessToken,
              logger
            }), shouldSendRequest)
              [response, error] = await trySendRequest(request, next);
            if (isChallengeResponse(response)) {
              if (claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate")), claims) {
                let parsedClaim;
                try {
                  parsedClaim = atob(claims);
                } catch (e) {
                  return logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`), response;
                }
                if (shouldSendRequest = await authorizeRequestOnCaeChallenge({
                  scopes: Array.isArray(scopes) ? scopes : [scopes],
                  response,
                  request,
                  getAccessToken,
                  logger
                }, parsedClaim), shouldSendRequest)
                  [response, error] = await trySendRequest(request, next);
              }
            }
          }
        }
        if (error)
          throw error;
        else
          return response;
      }
    };
  }
  function parseChallenges(challenges) {
    let challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g, paramRegex = /(\w+)="([^"]*)"/g, parsedChallenges = [], match;
    while ((match = challengeRegex.exec(challenges)) !== null) {
      let scheme = match[1], paramsString = match[2], params = {}, paramMatch;
      while ((paramMatch = paramRegex.exec(paramsString)) !== null)
        params[paramMatch[1]] = paramMatch[2];
      parsedChallenges.push({ scheme, params });
    }
    return parsedChallenges;
  }
  function getCaeChallengeClaims(challenges) {
    if (!challenges)
      return;
    return parseChallenges(challenges).find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")?.params.claims;
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/ndJsonPolicy.js
var require_ndJsonPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ndJsonPolicyName = void 0;
  exports.ndJsonPolicy = ndJsonPolicy;
  exports.ndJsonPolicyName = "ndJsonPolicy";
  function ndJsonPolicy() {
    return {
      name: exports.ndJsonPolicyName,
      async sendRequest(request, next) {
        if (typeof request.body === "string" && request.body.startsWith("[")) {
          let body = JSON.parse(request.body);
          if (Array.isArray(body))
            request.body = body.map((item) => JSON.stringify(item) + `
`).join("");
        }
        return next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/policies/auxiliaryAuthenticationHeaderPolicy.js
var require_auxiliaryAuthenticationHeaderPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.auxiliaryAuthenticationHeaderPolicyName = void 0;
  exports.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
  var tokenCycler_js_1 = require_tokenCycler(), log_js_1 = require_log3();
  exports.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
  var AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
  async function sendAuthorizeRequest(options) {
    let { scopes, getAccessToken, request } = options, getTokenOptions = {
      abortSignal: request.abortSignal,
      tracingOptions: request.tracingOptions
    };
    return (await getAccessToken(scopes, getTokenOptions))?.token ?? "";
  }
  function auxiliaryAuthenticationHeaderPolicy(options) {
    let { credentials, scopes } = options, logger = options.logger || log_js_1.logger, tokenCyclerMap = /* @__PURE__ */ new WeakMap;
    return {
      name: exports.auxiliaryAuthenticationHeaderPolicyName,
      async sendRequest(request, next) {
        if (!request.url.toLowerCase().startsWith("https://"))
          throw Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
        if (!credentials || credentials.length === 0)
          return logger.info(`${exports.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`), next(request);
        let tokenPromises = [];
        for (let credential of credentials) {
          let getAccessToken = tokenCyclerMap.get(credential);
          if (!getAccessToken)
            getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential), tokenCyclerMap.set(credential, getAccessToken);
          tokenPromises.push(sendAuthorizeRequest({
            scopes: Array.isArray(scopes) ? scopes : [scopes],
            request,
            getAccessToken,
            logger
          }));
        }
        let auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
        if (auxiliaryTokens.length === 0)
          return logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`), next(request);
        return request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", ")), next(request);
      }
    };
  }
});

// node_modules/@azure/core-rest-pipeline/dist/commonjs/index.js
var require_commonjs8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createFileFromStream = exports.createFile = exports.agentPolicyName = exports.agentPolicy = exports.auxiliaryAuthenticationHeaderPolicyName = exports.auxiliaryAuthenticationHeaderPolicy = exports.ndJsonPolicyName = exports.ndJsonPolicy = exports.bearerTokenAuthenticationPolicyName = exports.bearerTokenAuthenticationPolicy = exports.formDataPolicyName = exports.formDataPolicy = exports.tlsPolicyName = exports.tlsPolicy = exports.userAgentPolicyName = exports.userAgentPolicy = exports.defaultRetryPolicy = exports.tracingPolicyName = exports.tracingPolicy = exports.retryPolicy = exports.throttlingRetryPolicyName = exports.throttlingRetryPolicy = exports.systemErrorRetryPolicyName = exports.systemErrorRetryPolicy = exports.redirectPolicyName = exports.redirectPolicy = exports.getDefaultProxySettings = exports.proxyPolicyName = exports.proxyPolicy = exports.multipartPolicyName = exports.multipartPolicy = exports.logPolicyName = exports.logPolicy = exports.setClientRequestIdPolicyName = exports.setClientRequestIdPolicy = exports.exponentialRetryPolicyName = exports.exponentialRetryPolicy = exports.decompressResponsePolicyName = exports.decompressResponsePolicy = exports.isRestError = exports.RestError = exports.createPipelineRequest = exports.createHttpHeaders = exports.createDefaultHttpClient = exports.createPipelineFromOptions = exports.createEmptyPipeline = void 0;
  var pipeline_js_1 = require_pipeline2();
  Object.defineProperty(exports, "createEmptyPipeline", { enumerable: !0, get: function() {
    return pipeline_js_1.createEmptyPipeline;
  } });
  var createPipelineFromOptions_js_1 = require_createPipelineFromOptions2();
  Object.defineProperty(exports, "createPipelineFromOptions", { enumerable: !0, get: function() {
    return createPipelineFromOptions_js_1.createPipelineFromOptions;
  } });
  var defaultHttpClient_js_1 = require_defaultHttpClient2();
  Object.defineProperty(exports, "createDefaultHttpClient", { enumerable: !0, get: function() {
    return defaultHttpClient_js_1.createDefaultHttpClient;
  } });
  var httpHeaders_js_1 = require_httpHeaders2();
  Object.defineProperty(exports, "createHttpHeaders", { enumerable: !0, get: function() {
    return httpHeaders_js_1.createHttpHeaders;
  } });
  var pipelineRequest_js_1 = require_pipelineRequest2();
  Object.defineProperty(exports, "createPipelineRequest", { enumerable: !0, get: function() {
    return pipelineRequest_js_1.createPipelineRequest;
  } });
  var restError_js_1 = require_restError3();
  Object.defineProperty(exports, "RestError", { enumerable: !0, get: function() {
    return restError_js_1.RestError;
  } });
  Object.defineProperty(exports, "isRestError", { enumerable: !0, get: function() {
    return restError_js_1.isRestError;
  } });
  var decompressResponsePolicy_js_1 = require_decompressResponsePolicy2();
  Object.defineProperty(exports, "decompressResponsePolicy", { enumerable: !0, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicy;
  } });
  Object.defineProperty(exports, "decompressResponsePolicyName", { enumerable: !0, get: function() {
    return decompressResponsePolicy_js_1.decompressResponsePolicyName;
  } });
  var exponentialRetryPolicy_js_1 = require_exponentialRetryPolicy2();
  Object.defineProperty(exports, "exponentialRetryPolicy", { enumerable: !0, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicy;
  } });
  Object.defineProperty(exports, "exponentialRetryPolicyName", { enumerable: !0, get: function() {
    return exponentialRetryPolicy_js_1.exponentialRetryPolicyName;
  } });
  var setClientRequestIdPolicy_js_1 = require_setClientRequestIdPolicy();
  Object.defineProperty(exports, "setClientRequestIdPolicy", { enumerable: !0, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy;
  } });
  Object.defineProperty(exports, "setClientRequestIdPolicyName", { enumerable: !0, get: function() {
    return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName;
  } });
  var logPolicy_js_1 = require_logPolicy2();
  Object.defineProperty(exports, "logPolicy", { enumerable: !0, get: function() {
    return logPolicy_js_1.logPolicy;
  } });
  Object.defineProperty(exports, "logPolicyName", { enumerable: !0, get: function() {
    return logPolicy_js_1.logPolicyName;
  } });
  var multipartPolicy_js_1 = require_multipartPolicy2();
  Object.defineProperty(exports, "multipartPolicy", { enumerable: !0, get: function() {
    return multipartPolicy_js_1.multipartPolicy;
  } });
  Object.defineProperty(exports, "multipartPolicyName", { enumerable: !0, get: function() {
    return multipartPolicy_js_1.multipartPolicyName;
  } });
  var proxyPolicy_js_1 = require_proxyPolicy2();
  Object.defineProperty(exports, "proxyPolicy", { enumerable: !0, get: function() {
    return proxyPolicy_js_1.proxyPolicy;
  } });
  Object.defineProperty(exports, "proxyPolicyName", { enumerable: !0, get: function() {
    return proxyPolicy_js_1.proxyPolicyName;
  } });
  Object.defineProperty(exports, "getDefaultProxySettings", { enumerable: !0, get: function() {
    return proxyPolicy_js_1.getDefaultProxySettings;
  } });
  var redirectPolicy_js_1 = require_redirectPolicy2();
  Object.defineProperty(exports, "redirectPolicy", { enumerable: !0, get: function() {
    return redirectPolicy_js_1.redirectPolicy;
  } });
  Object.defineProperty(exports, "redirectPolicyName", { enumerable: !0, get: function() {
    return redirectPolicy_js_1.redirectPolicyName;
  } });
  var systemErrorRetryPolicy_js_1 = require_systemErrorRetryPolicy2();
  Object.defineProperty(exports, "systemErrorRetryPolicy", { enumerable: !0, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy;
  } });
  Object.defineProperty(exports, "systemErrorRetryPolicyName", { enumerable: !0, get: function() {
    return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName;
  } });
  var throttlingRetryPolicy_js_1 = require_throttlingRetryPolicy2();
  Object.defineProperty(exports, "throttlingRetryPolicy", { enumerable: !0, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicy;
  } });
  Object.defineProperty(exports, "throttlingRetryPolicyName", { enumerable: !0, get: function() {
    return throttlingRetryPolicy_js_1.throttlingRetryPolicyName;
  } });
  var retryPolicy_js_1 = require_retryPolicy2();
  Object.defineProperty(exports, "retryPolicy", { enumerable: !0, get: function() {
    return retryPolicy_js_1.retryPolicy;
  } });
  var tracingPolicy_js_1 = require_tracingPolicy();
  Object.defineProperty(exports, "tracingPolicy", { enumerable: !0, get: function() {
    return tracingPolicy_js_1.tracingPolicy;
  } });
  Object.defineProperty(exports, "tracingPolicyName", { enumerable: !0, get: function() {
    return tracingPolicy_js_1.tracingPolicyName;
  } });
  var defaultRetryPolicy_js_1 = require_defaultRetryPolicy2();
  Object.defineProperty(exports, "defaultRetryPolicy", { enumerable: !0, get: function() {
    return defaultRetryPolicy_js_1.defaultRetryPolicy;
  } });
  var userAgentPolicy_js_1 = require_userAgentPolicy2();
  Object.defineProperty(exports, "userAgentPolicy", { enumerable: !0, get: function() {
    return userAgentPolicy_js_1.userAgentPolicy;
  } });
  Object.defineProperty(exports, "userAgentPolicyName", { enumerable: !0, get: function() {
    return userAgentPolicy_js_1.userAgentPolicyName;
  } });
  var tlsPolicy_js_1 = require_tlsPolicy2();
  Object.defineProperty(exports, "tlsPolicy", { enumerable: !0, get: function() {
    return tlsPolicy_js_1.tlsPolicy;
  } });
  Object.defineProperty(exports, "tlsPolicyName", { enumerable: !0, get: function() {
    return tlsPolicy_js_1.tlsPolicyName;
  } });
  var formDataPolicy_js_1 = require_formDataPolicy2();
  Object.defineProperty(exports, "formDataPolicy", { enumerable: !0, get: function() {
    return formDataPolicy_js_1.formDataPolicy;
  } });
  Object.defineProperty(exports, "formDataPolicyName", { enumerable: !0, get: function() {
    return formDataPolicy_js_1.formDataPolicyName;
  } });
  var bearerTokenAuthenticationPolicy_js_1 = require_bearerTokenAuthenticationPolicy();
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicy", { enumerable: !0, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy;
  } });
  Object.defineProperty(exports, "bearerTokenAuthenticationPolicyName", { enumerable: !0, get: function() {
    return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName;
  } });
  var ndJsonPolicy_js_1 = require_ndJsonPolicy();
  Object.defineProperty(exports, "ndJsonPolicy", { enumerable: !0, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicy;
  } });
  Object.defineProperty(exports, "ndJsonPolicyName", { enumerable: !0, get: function() {
    return ndJsonPolicy_js_1.ndJsonPolicyName;
  } });
  var auxiliaryAuthenticationHeaderPolicy_js_1 = require_auxiliaryAuthenticationHeaderPolicy();
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicy", { enumerable: !0, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy;
  } });
  Object.defineProperty(exports, "auxiliaryAuthenticationHeaderPolicyName", { enumerable: !0, get: function() {
    return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName;
  } });
  var agentPolicy_js_1 = require_agentPolicy2();
  Object.defineProperty(exports, "agentPolicy", { enumerable: !0, get: function() {
    return agentPolicy_js_1.agentPolicy;
  } });
  Object.defineProperty(exports, "agentPolicyName", { enumerable: !0, get: function() {
    return agentPolicy_js_1.agentPolicyName;
  } });
  var file_js_1 = require_file2();
  Object.defineProperty(exports, "createFile", { enumerable: !0, get: function() {
    return file_js_1.createFile;
  } });
  Object.defineProperty(exports, "createFileFromStream", { enumerable: !0, get: function() {
    return file_js_1.createFileFromStream;
  } });
});

// node_modules/@azure/core-auth/dist/commonjs/azureKeyCredential.js
var require_azureKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AzureKeyCredential = void 0;

  class AzureKeyCredential {
    get key() {
      return this._key;
    }
    constructor(key) {
      if (!key)
        throw Error("key must be a non-empty string");
      this._key = key;
    }
    update(newKey) {
      this._key = newKey;
    }
  }
  exports.AzureKeyCredential = AzureKeyCredential;
});

// node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createAbortablePromise = createAbortablePromise;
  var abort_controller_1 = require_commonjs5();
  function createAbortablePromise(buildPromise, options) {
    let { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
    return new Promise((resolve, reject) => {
      function rejectOnAbort() {
        reject(new abort_controller_1.AbortError(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : "The operation was aborted."));
      }
      function removeListeners() {
        abortSignal === null || abortSignal === void 0 || abortSignal.removeEventListener("abort", onAbort);
      }
      function onAbort() {
        cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 || cleanupBeforeAbort(), removeListeners(), rejectOnAbort();
      }
      if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted)
        return rejectOnAbort();
      try {
        buildPromise((x) => {
          removeListeners(), resolve(x);
        }, (x) => {
          removeListeners(), reject(x);
        });
      } catch (err) {
        reject(err);
      }
      abortSignal === null || abortSignal === void 0 || abortSignal.addEventListener("abort", onAbort);
    });
  }
});

// node_modules/@azure/core-util/dist/commonjs/random.js
var require_random2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
  function getRandomIntegerInclusive(min, max) {
    return min = Math.ceil(min), max = Math.floor(max), Math.floor(Math.random() * (max - min + 1)) + min;
  }
});

// node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.delay = delay;
  exports.calculateRetryDelay = calculateRetryDelay;
  var createAbortablePromise_js_1 = require_createAbortablePromise2(), random_js_1 = require_random2(), StandardAbortMessage = "The delay was aborted.";
  function delay(timeInMs, options) {
    let token, { abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
    return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
      token = setTimeout(resolve, timeInMs);
    }, {
      cleanupBeforeAbort: () => clearTimeout(token),
      abortSignal,
      abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage
    });
  }
  function calculateRetryDelay(retryAttempt, config) {
    let exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt), clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    return { retryAfterInMs: clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2) };
  }
});

// node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.cancelablePromiseRace = cancelablePromiseRace;
  async function cancelablePromiseRace(abortablePromiseBuilders, options) {
    var _a, _b;
    let aborter = new AbortController;
    function abortHandler() {
      aborter.abort();
    }
    (_a = options === null || options === void 0 ? void 0 : options.abortSignal) === null || _a === void 0 || _a.addEventListener("abort", abortHandler);
    try {
      return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
    } finally {
      aborter.abort(), (_b = options === null || options === void 0 ? void 0 : options.abortSignal) === null || _b === void 0 || _b.removeEventListener("abort", abortHandler);
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/object.js
var require_object2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isObject = isObject;
  function isObject(input) {
    return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
  }
});

// node_modules/@azure/core-util/dist/commonjs/error.js
var require_error3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isError = isError;
  exports.getErrorMessage = getErrorMessage;
  var object_js_1 = require_object2();
  function isError(e) {
    if ((0, object_js_1.isObject)(e)) {
      let hasName = typeof e.name === "string", hasMessage = typeof e.message === "string";
      return hasName && hasMessage;
    }
    return !1;
  }
  function getErrorMessage(e) {
    if (isError(e))
      return e.message;
    else {
      let stringified;
      try {
        if (typeof e === "object" && e)
          stringified = JSON.stringify(e);
        else
          stringified = String(e);
      } catch (err) {
        stringified = "[unable to stringify input]";
      }
      return `Unknown error ${stringified}`;
    }
  }
});

// node_modules/@azure/core-util/dist/commonjs/sha256.js
var require_sha2562 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.computeSha256Hmac = computeSha256Hmac;
  exports.computeSha256Hash = computeSha256Hash;
  var crypto_1 = __require("crypto");
  async function computeSha256Hmac(key, stringToSign, encoding) {
    let decodedKey = Buffer.from(key, "base64");
    return (0, crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
  }
  async function computeSha256Hash(content, encoding) {
    return (0, crypto_1.createHash)("sha256").update(content).digest(encoding);
  }
});

// node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isDefined = isDefined;
  exports.isObjectWithProperties = isObjectWithProperties;
  exports.objectHasProperty = objectHasProperty;
  function isDefined(thing) {
    return typeof thing < "u" && thing !== null;
  }
  function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object")
      return !1;
    for (let property of properties)
      if (!objectHasProperty(thing, property))
        return !1;
    return !0;
  }
  function objectHasProperty(thing, property) {
    return isDefined(thing) && typeof thing === "object" && property in thing;
  }
});

// node_modules/@azure/core-util/dist/commonjs/uuidUtils.js
var require_uuidUtils2 = __commonJS((exports) => {
  var _a;
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.randomUUID = randomUUID;
  var crypto_1 = __require("crypto"), uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : crypto_1.randomUUID;
  function randomUUID() {
    return uuidFunction();
  }
});

// node_modules/@azure/core-util/dist/commonjs/checkEnvironment.js
var require_checkEnvironment2 = __commonJS((exports) => {
  var _a, _b, _c, _d;
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isReactNative = exports.isNodeRuntime = exports.isNode = exports.isNodeLike = exports.isBun = exports.isDeno = exports.isWebWorker = exports.isBrowser = void 0;
  exports.isBrowser = typeof window < "u" && typeof window.document < "u";
  exports.isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_a = self.constructor) === null || _a === void 0 ? void 0 : _a.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "SharedWorkerGlobalScope");
  exports.isDeno = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u";
  exports.isBun = typeof Bun < "u" && typeof Bun.version < "u";
  exports.isNodeLike = typeof globalThis.process < "u" && Boolean(globalThis.process.version) && Boolean((_d = globalThis.process.versions) === null || _d === void 0 ? void 0 : _d.node);
  exports.isNode = exports.isNodeLike;
  exports.isNodeRuntime = exports.isNodeLike && !exports.isBun && !exports.isDeno;
  exports.isReactNative = typeof navigator < "u" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
});

// node_modules/@azure/core-util/dist/commonjs/bytesEncoding.js
var require_bytesEncoding2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.uint8ArrayToString = uint8ArrayToString;
  exports.stringToUint8Array = stringToUint8Array;
  function uint8ArrayToString(bytes, format) {
    return Buffer.from(bytes).toString(format);
  }
  function stringToUint8Array(value, format) {
    return Buffer.from(value, format);
  }
});

// node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.stringToUint8Array = exports.uint8ArrayToString = exports.isWebWorker = exports.isReactNative = exports.isDeno = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isBun = exports.isBrowser = exports.randomUUID = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.computeSha256Hmac = exports.computeSha256Hash = exports.getErrorMessage = exports.isError = exports.isObject = exports.getRandomIntegerInclusive = exports.createAbortablePromise = exports.cancelablePromiseRace = exports.calculateRetryDelay = exports.delay = void 0;
  var delay_js_1 = require_delay3();
  Object.defineProperty(exports, "delay", { enumerable: !0, get: function() {
    return delay_js_1.delay;
  } });
  Object.defineProperty(exports, "calculateRetryDelay", { enumerable: !0, get: function() {
    return delay_js_1.calculateRetryDelay;
  } });
  var aborterUtils_js_1 = require_aborterUtils2();
  Object.defineProperty(exports, "cancelablePromiseRace", { enumerable: !0, get: function() {
    return aborterUtils_js_1.cancelablePromiseRace;
  } });
  var createAbortablePromise_js_1 = require_createAbortablePromise2();
  Object.defineProperty(exports, "createAbortablePromise", { enumerable: !0, get: function() {
    return createAbortablePromise_js_1.createAbortablePromise;
  } });
  var random_js_1 = require_random2();
  Object.defineProperty(exports, "getRandomIntegerInclusive", { enumerable: !0, get: function() {
    return random_js_1.getRandomIntegerInclusive;
  } });
  var object_js_1 = require_object2();
  Object.defineProperty(exports, "isObject", { enumerable: !0, get: function() {
    return object_js_1.isObject;
  } });
  var error_js_1 = require_error3();
  Object.defineProperty(exports, "isError", { enumerable: !0, get: function() {
    return error_js_1.isError;
  } });
  Object.defineProperty(exports, "getErrorMessage", { enumerable: !0, get: function() {
    return error_js_1.getErrorMessage;
  } });
  var sha256_js_1 = require_sha2562();
  Object.defineProperty(exports, "computeSha256Hash", { enumerable: !0, get: function() {
    return sha256_js_1.computeSha256Hash;
  } });
  Object.defineProperty(exports, "computeSha256Hmac", { enumerable: !0, get: function() {
    return sha256_js_1.computeSha256Hmac;
  } });
  var typeGuards_js_1 = require_typeGuards3();
  Object.defineProperty(exports, "isDefined", { enumerable: !0, get: function() {
    return typeGuards_js_1.isDefined;
  } });
  Object.defineProperty(exports, "isObjectWithProperties", { enumerable: !0, get: function() {
    return typeGuards_js_1.isObjectWithProperties;
  } });
  Object.defineProperty(exports, "objectHasProperty", { enumerable: !0, get: function() {
    return typeGuards_js_1.objectHasProperty;
  } });
  var uuidUtils_js_1 = require_uuidUtils2();
  Object.defineProperty(exports, "randomUUID", { enumerable: !0, get: function() {
    return uuidUtils_js_1.randomUUID;
  } });
  var checkEnvironment_js_1 = require_checkEnvironment2();
  Object.defineProperty(exports, "isBrowser", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isBrowser;
  } });
  Object.defineProperty(exports, "isBun", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isBun;
  } });
  Object.defineProperty(exports, "isNode", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isNode;
  } });
  Object.defineProperty(exports, "isNodeLike", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isNodeLike;
  } });
  Object.defineProperty(exports, "isNodeRuntime", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isNodeRuntime;
  } });
  Object.defineProperty(exports, "isDeno", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isDeno;
  } });
  Object.defineProperty(exports, "isReactNative", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isReactNative;
  } });
  Object.defineProperty(exports, "isWebWorker", { enumerable: !0, get: function() {
    return checkEnvironment_js_1.isWebWorker;
  } });
  var bytesEncoding_js_1 = require_bytesEncoding2();
  Object.defineProperty(exports, "uint8ArrayToString", { enumerable: !0, get: function() {
    return bytesEncoding_js_1.uint8ArrayToString;
  } });
  Object.defineProperty(exports, "stringToUint8Array", { enumerable: !0, get: function() {
    return bytesEncoding_js_1.stringToUint8Array;
  } });
});

// node_modules/@azure/core-auth/dist/commonjs/keyCredential.js
var require_keyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isKeyCredential = isKeyCredential;
  var core_util_1 = require_commonjs9();
  function isKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureNamedKeyCredential.js
var require_azureNamedKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AzureNamedKeyCredential = void 0;
  exports.isNamedKeyCredential = isNamedKeyCredential;
  var core_util_1 = require_commonjs9();

  class AzureNamedKeyCredential {
    get key() {
      return this._key;
    }
    get name() {
      return this._name;
    }
    constructor(name, key) {
      if (!name || !key)
        throw TypeError("name and key must be non-empty strings");
      this._name = name, this._key = key;
    }
    update(newName, newKey) {
      if (!newName || !newKey)
        throw TypeError("newName and newKey must be non-empty strings");
      this._name = newName, this._key = newKey;
    }
  }
  exports.AzureNamedKeyCredential = AzureNamedKeyCredential;
  function isNamedKeyCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) && typeof credential.key === "string" && typeof credential.name === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/azureSASCredential.js
var require_azureSASCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AzureSASCredential = void 0;
  exports.isSASCredential = isSASCredential;
  var core_util_1 = require_commonjs9();

  class AzureSASCredential {
    get signature() {
      return this._signature;
    }
    constructor(signature) {
      if (!signature)
        throw Error("shared access signature must be a non-empty string");
      this._signature = signature;
    }
    update(newSignature) {
      if (!newSignature)
        throw Error("shared access signature must be a non-empty string");
      this._signature = newSignature;
    }
  }
  exports.AzureSASCredential = AzureSASCredential;
  function isSASCredential(credential) {
    return (0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string";
  }
});

// node_modules/@azure/core-auth/dist/commonjs/tokenCredential.js
var require_tokenCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isBearerToken = isBearerToken;
  exports.isPopToken = isPopToken;
  exports.isTokenCredential = isTokenCredential;
  function isBearerToken(accessToken) {
    return !accessToken.tokenType || accessToken.tokenType === "Bearer";
  }
  function isPopToken(accessToken) {
    return accessToken.tokenType === "pop";
  }
  function isTokenCredential(credential) {
    let castCredential = credential;
    return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
  }
});

// node_modules/@azure/core-auth/dist/commonjs/index.js
var require_commonjs10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isTokenCredential = exports.isSASCredential = exports.AzureSASCredential = exports.isNamedKeyCredential = exports.AzureNamedKeyCredential = exports.isKeyCredential = exports.AzureKeyCredential = void 0;
  var azureKeyCredential_js_1 = require_azureKeyCredential();
  Object.defineProperty(exports, "AzureKeyCredential", { enumerable: !0, get: function() {
    return azureKeyCredential_js_1.AzureKeyCredential;
  } });
  var keyCredential_js_1 = require_keyCredential();
  Object.defineProperty(exports, "isKeyCredential", { enumerable: !0, get: function() {
    return keyCredential_js_1.isKeyCredential;
  } });
  var azureNamedKeyCredential_js_1 = require_azureNamedKeyCredential();
  Object.defineProperty(exports, "AzureNamedKeyCredential", { enumerable: !0, get: function() {
    return azureNamedKeyCredential_js_1.AzureNamedKeyCredential;
  } });
  Object.defineProperty(exports, "isNamedKeyCredential", { enumerable: !0, get: function() {
    return azureNamedKeyCredential_js_1.isNamedKeyCredential;
  } });
  var azureSASCredential_js_1 = require_azureSASCredential();
  Object.defineProperty(exports, "AzureSASCredential", { enumerable: !0, get: function() {
    return azureSASCredential_js_1.AzureSASCredential;
  } });
  Object.defineProperty(exports, "isSASCredential", { enumerable: !0, get: function() {
    return azureSASCredential_js_1.isSASCredential;
  } });
  var tokenCredential_js_1 = require_tokenCredential();
  Object.defineProperty(exports, "isTokenCredential", { enumerable: !0, get: function() {
    return tokenCredential_js_1.isTokenCredential;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/disableKeepAlivePolicy.js
var require_disableKeepAlivePolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.disableKeepAlivePolicyName = void 0;
  exports.createDisableKeepAlivePolicy = createDisableKeepAlivePolicy;
  exports.pipelineContainsDisableKeepAlivePolicy = pipelineContainsDisableKeepAlivePolicy;
  exports.disableKeepAlivePolicyName = "DisableKeepAlivePolicy";
  function createDisableKeepAlivePolicy() {
    return {
      name: exports.disableKeepAlivePolicyName,
      async sendRequest(request, next) {
        return request.disableKeepAlive = !0, next(request);
      }
    };
  }
  function pipelineContainsDisableKeepAlivePolicy(pipeline) {
    return pipeline.getOrderedPolicies().some((policy) => policy.name === exports.disableKeepAlivePolicyName);
  }
});

// node_modules/@azure/core-client/dist/commonjs/base64.js
var require_base642 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.encodeString = encodeString;
  exports.encodeByteArray = encodeByteArray;
  exports.decodeString = decodeString;
  exports.decodeStringToString = decodeStringToString;
  function encodeString(value) {
    return Buffer.from(value).toString("base64");
  }
  function encodeByteArray(value) {
    return (value instanceof Buffer ? value : Buffer.from(value.buffer)).toString("base64");
  }
  function decodeString(value) {
    return Buffer.from(value, "base64");
  }
  function decodeStringToString(value) {
    return Buffer.from(value, "base64").toString();
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaces.js
var require_interfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = void 0;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-client/dist/commonjs/utils.js
var require_utils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isPrimitiveBody = isPrimitiveBody;
  exports.isDuration = isDuration;
  exports.isValidUuid = isValidUuid;
  exports.flattenResponse = flattenResponse;
  function isPrimitiveBody(value, mapperTypeName) {
    return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !== null || value === void 0 || value === null);
  }
  var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function isDuration(value) {
    return validateISODuration.test(value);
  }
  var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
  function isValidUuid(uuid) {
    return validUuidRegex.test(uuid);
  }
  function handleNullableResponseAndWrappableBody(responseObject) {
    let combinedHeadersAndBody = {
      ...responseObject.headers,
      ...responseObject.body
    };
    if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0)
      return responseObject.shouldWrapBody ? { body: null } : null;
    else
      return responseObject.shouldWrapBody ? {
        ...responseObject.headers,
        body: responseObject.body
      } : combinedHeadersAndBody;
  }
  function flattenResponse(fullResponse, responseSpec) {
    let parsedHeaders = fullResponse.parsedHeaders;
    if (fullResponse.request.method === "HEAD")
      return {
        ...parsedHeaders,
        body: fullResponse.parsedBody
      };
    let bodyMapper = responseSpec && responseSpec.bodyMapper, isNullable = Boolean(bodyMapper?.nullable), expectedBodyTypeName = bodyMapper?.type.name;
    if (expectedBodyTypeName === "Stream")
      return {
        ...parsedHeaders,
        blobBody: fullResponse.blobBody,
        readableStreamBody: fullResponse.readableStreamBody
      };
    let modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {}, isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
      let arrayResponse = fullResponse.parsedBody ?? [];
      for (let key of Object.keys(modelProperties))
        if (modelProperties[key].serializedName)
          arrayResponse[key] = fullResponse.parsedBody?.[key];
      if (parsedHeaders)
        for (let key of Object.keys(parsedHeaders))
          arrayResponse[key] = parsedHeaders[key];
      return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
    }
    return handleNullableResponseAndWrappableBody({
      body: fullResponse.parsedBody,
      headers: parsedHeaders,
      hasNullableType: isNullable,
      shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
    });
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.MapperTypeNames = void 0;
  exports.createSerializer = createSerializer;
  var tslib_1 = require_tslib(), base64 = tslib_1.__importStar(require_base642()), interfaces_js_1 = require_interfaces(), utils_js_1 = require_utils3();

  class SerializerImpl {
    modelMappers;
    isXML;
    constructor(modelMappers = {}, isXML = !1) {
      this.modelMappers = modelMappers, this.isXML = isXML;
    }
    validateConstraints(mapper, value, objectName) {
      let failValidation = (constraintName, constraintValue) => {
        throw Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
      };
      if (mapper.constraints && value !== void 0 && value !== null) {
        let { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
        if (ExclusiveMaximum !== void 0 && value >= ExclusiveMaximum)
          failValidation("ExclusiveMaximum", ExclusiveMaximum);
        if (ExclusiveMinimum !== void 0 && value <= ExclusiveMinimum)
          failValidation("ExclusiveMinimum", ExclusiveMinimum);
        if (InclusiveMaximum !== void 0 && value > InclusiveMaximum)
          failValidation("InclusiveMaximum", InclusiveMaximum);
        if (InclusiveMinimum !== void 0 && value < InclusiveMinimum)
          failValidation("InclusiveMinimum", InclusiveMinimum);
        if (MaxItems !== void 0 && value.length > MaxItems)
          failValidation("MaxItems", MaxItems);
        if (MaxLength !== void 0 && value.length > MaxLength)
          failValidation("MaxLength", MaxLength);
        if (MinItems !== void 0 && value.length < MinItems)
          failValidation("MinItems", MinItems);
        if (MinLength !== void 0 && value.length < MinLength)
          failValidation("MinLength", MinLength);
        if (MultipleOf !== void 0 && value % MultipleOf !== 0)
          failValidation("MultipleOf", MultipleOf);
        if (Pattern) {
          let pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
          if (typeof value !== "string" || value.match(pattern) === null)
            failValidation("Pattern", Pattern);
        }
        if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i))
          failValidation("UniqueItems", UniqueItems);
      }
    }
    serialize(mapper, object, objectName, options = { xml: {} }) {
      let updatedOptions = {
        xml: {
          rootName: options.xml.rootName ?? "",
          includeRoot: options.xml.includeRoot ?? !1,
          xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        }
      }, payload = {}, mapperType = mapper.type.name;
      if (!objectName)
        objectName = mapper.serializedName;
      if (mapperType.match(/^Sequence$/i) !== null)
        payload = [];
      if (mapper.isConstant)
        object = mapper.defaultValue;
      let { required, nullable } = mapper;
      if (required && nullable && object === void 0)
        throw Error(`${objectName} cannot be undefined.`);
      if (required && !nullable && (object === void 0 || object === null))
        throw Error(`${objectName} cannot be null or undefined.`);
      if (!required && nullable === !1 && object === null)
        throw Error(`${objectName} cannot be null.`);
      if (object === void 0 || object === null)
        payload = object;
      else if (mapperType.match(/^any$/i) !== null)
        payload = object;
      else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null)
        payload = serializeBasicTypes(mapperType, objectName, object);
      else if (mapperType.match(/^Enum$/i) !== null)
        payload = serializeEnumType(objectName, mapper.type.allowedValues, object);
      else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null)
        payload = serializeDateTypes(mapperType, object, objectName);
      else if (mapperType.match(/^ByteArray$/i) !== null)
        payload = serializeByteArrayType(objectName, object);
      else if (mapperType.match(/^Base64Url$/i) !== null)
        payload = serializeBase64UrlType(objectName, object);
      else if (mapperType.match(/^Sequence$/i) !== null)
        payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      else if (mapperType.match(/^Dictionary$/i) !== null)
        payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      else if (mapperType.match(/^Composite$/i) !== null)
        payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      return payload;
    }
    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
      let updatedOptions = {
        xml: {
          rootName: options.xml.rootName ?? "",
          includeRoot: options.xml.includeRoot ?? !1,
          xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
        },
        ignoreUnknownProperties: options.ignoreUnknownProperties ?? !1
      };
      if (responseBody === void 0 || responseBody === null) {
        if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped)
          responseBody = [];
        if (mapper.defaultValue !== void 0)
          responseBody = mapper.defaultValue;
        return responseBody;
      }
      let payload, mapperType = mapper.type.name;
      if (!objectName)
        objectName = mapper.serializedName;
      if (mapperType.match(/^Composite$/i) !== null)
        payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
      else {
        if (this.isXML) {
          let xmlCharKey = updatedOptions.xml.xmlCharKey;
          if (responseBody[interfaces_js_1.XML_ATTRKEY] !== void 0 && responseBody[xmlCharKey] !== void 0)
            responseBody = responseBody[xmlCharKey];
        }
        if (mapperType.match(/^Number$/i) !== null) {
          if (payload = parseFloat(responseBody), isNaN(payload))
            payload = responseBody;
        } else if (mapperType.match(/^Boolean$/i) !== null)
          if (responseBody === "true")
            payload = !0;
          else if (responseBody === "false")
            payload = !1;
          else
            payload = responseBody;
        else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null)
          payload = responseBody;
        else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null)
          payload = new Date(responseBody);
        else if (mapperType.match(/^UnixTime$/i) !== null)
          payload = unixTimeToDate(responseBody);
        else if (mapperType.match(/^ByteArray$/i) !== null)
          payload = base64.decodeString(responseBody);
        else if (mapperType.match(/^Base64Url$/i) !== null)
          payload = base64UrlToByteArray(responseBody);
        else if (mapperType.match(/^Sequence$/i) !== null)
          payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
        else if (mapperType.match(/^Dictionary$/i) !== null)
          payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
      }
      if (mapper.isConstant)
        payload = mapper.defaultValue;
      return payload;
    }
  }
  function createSerializer(modelMappers = {}, isXML = !1) {
    return new SerializerImpl(modelMappers, isXML);
  }
  function trimEnd(str, ch) {
    let len = str.length;
    while (len - 1 >= 0 && str[len - 1] === ch)
      --len;
    return str.substr(0, len);
  }
  function bufferToBase64Url(buffer) {
    if (!buffer)
      return;
    if (!(buffer instanceof Uint8Array))
      throw Error("Please provide an input of type Uint8Array for converting to Base64Url.");
    let str = base64.encodeByteArray(buffer);
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function base64UrlToByteArray(str) {
    if (!str)
      return;
    if (str && typeof str.valueOf() !== "string")
      throw Error("Please provide an input of type string for converting to Uint8Array");
    return str = str.replace(/-/g, "+").replace(/_/g, "/"), base64.decodeString(str);
  }
  function splitSerializeName(prop) {
    let classes = [], partialclass = "";
    if (prop) {
      let subwords = prop.split(".");
      for (let item of subwords)
        if (item.charAt(item.length - 1) === "\\")
          partialclass += item.substr(0, item.length - 1) + ".";
        else
          partialclass += item, classes.push(partialclass), partialclass = "";
    }
    return classes;
  }
  function dateToUnixTime(d) {
    if (!d)
      return;
    if (typeof d.valueOf() === "string")
      d = new Date(d);
    return Math.floor(d.getTime() / 1000);
  }
  function unixTimeToDate(n) {
    if (!n)
      return;
    return new Date(n * 1000);
  }
  function serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== void 0) {
      if (typeName.match(/^Number$/i) !== null) {
        if (typeof value !== "number")
          throw Error(`${objectName} with value ${value} must be of type number.`);
      } else if (typeName.match(/^String$/i) !== null) {
        if (typeof value.valueOf() !== "string")
          throw Error(`${objectName} with value "${value}" must be of type string.`);
      } else if (typeName.match(/^Uuid$/i) !== null) {
        if (!(typeof value.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value)))
          throw Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
      } else if (typeName.match(/^Boolean$/i) !== null) {
        if (typeof value !== "boolean")
          throw Error(`${objectName} with value ${value} must be of type boolean.`);
      } else if (typeName.match(/^Stream$/i) !== null) {
        let objectType = typeof value;
        if (objectType !== "string" && typeof value.pipe !== "function" && typeof value.tee !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function")
          throw Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
      }
    }
    return value;
  }
  function serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues)
      throw Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
    if (!allowedValues.some((item) => {
      if (typeof item.valueOf() === "string")
        return item.toLowerCase() === value.toLowerCase();
      return item === value;
    }))
      throw Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
    return value;
  }
  function serializeByteArrayType(objectName, value) {
    if (value !== void 0 && value !== null) {
      if (!(value instanceof Uint8Array))
        throw Error(`${objectName} must be of type Uint8Array.`);
      value = base64.encodeByteArray(value);
    }
    return value;
  }
  function serializeBase64UrlType(objectName, value) {
    if (value !== void 0 && value !== null) {
      if (!(value instanceof Uint8Array))
        throw Error(`${objectName} must be of type Uint8Array.`);
      value = bufferToBase64Url(value);
    }
    return value;
  }
  function serializeDateTypes(typeName, value, objectName) {
    if (value !== void 0 && value !== null) {
      if (typeName.match(/^Date$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))
          throw Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
      } else if (typeName.match(/^DateTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))
          throw Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
        value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
      } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))
          throw Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
        value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
      } else if (typeName.match(/^UnixTime$/i) !== null) {
        if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))
          throw Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
        value = dateToUnixTime(value);
      } else if (typeName.match(/^TimeSpan$/i) !== null) {
        if (!(0, utils_js_1.isDuration)(value))
          throw Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
      }
    }
    return value;
  }
  function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
    if (!Array.isArray(object))
      throw Error(`${objectName} must be of type Array.`);
    let elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object")
      throw Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
    if (elementType.type.name === "Composite" && elementType.type.className)
      elementType = serializer.modelMappers[elementType.type.className] ?? elementType;
    let tempArray = [];
    for (let i = 0;i < object.length; i++) {
      let serializedValue = serializer.serialize(elementType, object[i], objectName, options);
      if (isXml && elementType.xmlNamespace) {
        let xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
        if (elementType.type.name === "Composite")
          tempArray[i] = { ...serializedValue }, tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
        else
          tempArray[i] = {}, tempArray[i][options.xml.xmlCharKey] = serializedValue, tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
      } else
        tempArray[i] = serializedValue;
    }
    return tempArray;
  }
  function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
    if (typeof object !== "object")
      throw Error(`${objectName} must be of type object.`);
    let valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object")
      throw Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
    let tempDictionary = {};
    for (let key of Object.keys(object)) {
      let serializedValue = serializer.serialize(valueType, object[key], objectName, options);
      tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
    }
    if (isXml && mapper.xmlNamespace) {
      let xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns", result = tempDictionary;
      return result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace }, result;
    }
    return tempDictionary;
  }
  function resolveAdditionalProperties(serializer, mapper, objectName) {
    let additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className)
      return resolveReferencedMapper(serializer, mapper, objectName)?.type.additionalProperties;
    return additionalProperties;
  }
  function resolveReferencedMapper(serializer, mapper, objectName) {
    let className = mapper.type.className;
    if (!className)
      throw Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
    return serializer.modelMappers[className];
  }
  function resolveModelProperties(serializer, mapper, objectName) {
    let modelProps = mapper.type.modelProperties;
    if (!modelProps) {
      let modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
      if (!modelMapper)
        throw Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
      if (modelProps = modelMapper?.type.modelProperties, !modelProps)
        throw Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
    }
    return modelProps;
  }
  function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper))
      mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
    if (object !== void 0 && object !== null) {
      let payload = {}, modelProps = resolveModelProperties(serializer, mapper, objectName);
      for (let key of Object.keys(modelProps)) {
        let propertyMapper = modelProps[key];
        if (propertyMapper.readOnly)
          continue;
        let propName, parentObject = payload;
        if (serializer.isXML)
          if (propertyMapper.xmlIsWrapped)
            propName = propertyMapper.xmlName;
          else
            propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        else {
          let paths = splitSerializeName(propertyMapper.serializedName);
          propName = paths.pop();
          for (let pathName of paths) {
            let childObject = parentObject[pathName];
            if ((childObject === void 0 || childObject === null) && (object[key] !== void 0 && object[key] !== null || propertyMapper.defaultValue !== void 0))
              parentObject[pathName] = {};
            parentObject = parentObject[pathName];
          }
        }
        if (parentObject !== void 0 && parentObject !== null) {
          if (isXml && mapper.xmlNamespace) {
            let xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
            parentObject[interfaces_js_1.XML_ATTRKEY] = {
              ...parentObject[interfaces_js_1.XML_ATTRKEY],
              [xmlnsKey]: mapper.xmlNamespace
            };
          }
          let propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName, toSerialize = object[key], polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
          if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === void 0 || toSerialize === null))
            toSerialize = mapper.serializedName;
          let serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
          if (serializedValue !== void 0 && propName !== void 0 && propName !== null) {
            let value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
            if (isXml && propertyMapper.xmlIsAttribute)
              parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {}, parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
            else if (isXml && propertyMapper.xmlIsWrapped)
              parentObject[propName] = { [propertyMapper.xmlElementName]: value };
            else
              parentObject[propName] = value;
          }
        }
      }
      let additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
      if (additionalPropertiesMapper) {
        let propNames = Object.keys(modelProps);
        for (let clientPropName in object)
          if (propNames.every((pn) => pn !== clientPropName))
            payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
      }
      return payload;
    }
    return object;
  }
  function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
    if (!isXml || !propertyMapper.xmlNamespace)
      return serializedValue;
    let xmlNamespace = { [propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns"]: propertyMapper.xmlNamespace };
    if (["Composite"].includes(propertyMapper.type.name))
      if (serializedValue[interfaces_js_1.XML_ATTRKEY])
        return serializedValue;
      else {
        let result2 = { ...serializedValue };
        return result2[interfaces_js_1.XML_ATTRKEY] = xmlNamespace, result2;
      }
    let result = {};
    return result[options.xml.xmlCharKey] = serializedValue, result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace, result;
  }
  function isSpecialXmlProperty(propertyName, options) {
    return [interfaces_js_1.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
  }
  function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
    let xmlCharKey = options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY;
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper))
      mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
    let modelProps = resolveModelProperties(serializer, mapper, objectName), instance = {}, handledPropertyNames = [];
    for (let key of Object.keys(modelProps)) {
      let propertyMapper = modelProps[key], paths = splitSerializeName(modelProps[key].serializedName);
      handledPropertyNames.push(paths[0]);
      let { serializedName, xmlName, xmlElementName } = propertyMapper, propertyObjectName = objectName;
      if (serializedName !== "" && serializedName !== void 0)
        propertyObjectName = objectName + "." + serializedName;
      let headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
      if (headerCollectionPrefix) {
        let dictionary = {};
        for (let headerKey of Object.keys(responseBody)) {
          if (headerKey.startsWith(headerCollectionPrefix))
            dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
          handledPropertyNames.push(headerKey);
        }
        instance[key] = dictionary;
      } else if (serializer.isXML)
        if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY])
          instance[key] = serializer.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options);
        else if (propertyMapper.xmlIsMsText) {
          if (responseBody[xmlCharKey] !== void 0)
            instance[key] = responseBody[xmlCharKey];
          else if (typeof responseBody === "string")
            instance[key] = responseBody;
        } else {
          let propertyName = xmlElementName || xmlName || serializedName;
          if (propertyMapper.xmlIsWrapped) {
            let elementList = responseBody[xmlName]?.[xmlElementName] ?? [];
            instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options), handledPropertyNames.push(xmlName);
          } else {
            let property = responseBody[propertyName];
            instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options), handledPropertyNames.push(propertyName);
          }
        }
      else {
        let propertyInstance, res = responseBody, steps = 0;
        for (let item of paths) {
          if (!res)
            break;
          steps++, res = res[item];
        }
        if (res === null && steps < paths.length)
          res = void 0;
        propertyInstance = res;
        let polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
        if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === void 0 || propertyInstance === null))
          propertyInstance = mapper.serializedName;
        let serializedValue;
        if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
          propertyInstance = responseBody[key];
          let arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
          for (let [k, v] of Object.entries(instance))
            if (!Object.prototype.hasOwnProperty.call(arrayInstance, k))
              arrayInstance[k] = v;
          instance = arrayInstance;
        } else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0)
          serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options), instance[key] = serializedValue;
      }
    }
    let additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
      let isAdditionalProperty = (responsePropName) => {
        for (let clientPropName in modelProps)
          if (splitSerializeName(modelProps[clientPropName].serializedName)[0] === responsePropName)
            return !1;
        return !0;
      };
      for (let responsePropName in responseBody)
        if (isAdditionalProperty(responsePropName))
          instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
    } else if (responseBody && !options.ignoreUnknownProperties) {
      for (let key of Object.keys(responseBody))
        if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options))
          instance[key] = responseBody[key];
    }
    return instance;
  }
  function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
    let value = mapper.type.value;
    if (!value || typeof value !== "object")
      throw Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
    if (responseBody) {
      let tempDictionary = {};
      for (let key of Object.keys(responseBody))
        tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
      return tempDictionary;
    }
    return responseBody;
  }
  function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
    let element = mapper.type.element;
    if (!element || typeof element !== "object")
      throw Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
    if (responseBody) {
      if (!Array.isArray(responseBody))
        responseBody = [responseBody];
      if (element.type.name === "Composite" && element.type.className)
        element = serializer.modelMappers[element.type.className] ?? element;
      let tempArray = [];
      for (let i = 0;i < responseBody.length; i++)
        tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
      return tempArray;
    }
    return responseBody;
  }
  function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
    let typeNamesToCheck = [typeName];
    while (typeNamesToCheck.length) {
      let currentName = typeNamesToCheck.shift(), indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
      if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator))
        return discriminators[indexDiscriminator];
      else
        for (let [name, mapper] of Object.entries(discriminators))
          if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className)
            typeNamesToCheck.push(mapper.type.className);
    }
    return;
  }
  function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
    let polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
    if (polymorphicDiscriminator) {
      let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
      if (discriminatorName) {
        if (polymorphicPropertyName === "serializedName")
          discriminatorName = discriminatorName.replace(/\\/gi, "");
        let discriminatorValue = object[discriminatorName], typeName = mapper.type.uberParent ?? mapper.type.className;
        if (typeof discriminatorValue === "string" && typeName) {
          let polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
          if (polymorphicMapper)
            mapper = polymorphicMapper;
        }
      }
    }
    return mapper;
  }
  function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
    return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
  }
  function getPolymorphicDiscriminatorSafely(serializer, typeName) {
    return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
  }
  exports.MapperTypeNames = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime"
  };
});

// node_modules/@azure/core-client/dist/commonjs/state.js
var require_state2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.state = void 0;
  exports.state = {
    operationRequestMap: /* @__PURE__ */ new WeakMap
  };
});

// node_modules/@azure/core-client/dist/commonjs/operationHelpers.js
var require_operationHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
  exports.getOperationRequestInfo = getOperationRequestInfo;
  var state_js_1 = require_state2();
  function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
    let { parameterPath, mapper: parameterMapper } = parameter, value;
    if (typeof parameterPath === "string")
      parameterPath = [parameterPath];
    if (Array.isArray(parameterPath)) {
      if (parameterPath.length > 0)
        if (parameterMapper.isConstant)
          value = parameterMapper.defaultValue;
        else {
          let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
          if (!propertySearchResult.propertyFound && fallbackObject)
            propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
          let useDefaultValue = !1;
          if (!propertySearchResult.propertyFound)
            useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
          value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
        }
    } else {
      if (parameterMapper.required)
        value = {};
      for (let propertyName in parameterPath) {
        let propertyMapper = parameterMapper.type.modelProperties[propertyName], propertyPath = parameterPath[propertyName], propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
          parameterPath: propertyPath,
          mapper: propertyMapper
        }, fallbackObject);
        if (propertyValue !== void 0) {
          if (!value)
            value = {};
          value[propertyName] = propertyValue;
        }
      }
    }
    return value;
  }
  function getPropertyFromParameterPath(parent, parameterPath) {
    let result = { propertyFound: !1 }, i = 0;
    for (;i < parameterPath.length; ++i) {
      let parameterPathPart = parameterPath[i];
      if (parent && parameterPathPart in parent)
        parent = parent[parameterPathPart];
      else
        break;
    }
    if (i === parameterPath.length)
      result.propertyValue = parent, result.propertyFound = !0;
    return result;
  }
  var originalRequestSymbol = Symbol.for("@azure/core-client original request");
  function hasOriginalRequest(request) {
    return originalRequestSymbol in request;
  }
  function getOperationRequestInfo(request) {
    if (hasOriginalRequest(request))
      return getOperationRequestInfo(request[originalRequestSymbol]);
    let info = state_js_1.state.operationRequestMap.get(request);
    if (!info)
      info = {}, state_js_1.state.operationRequestMap.set(request, info);
    return info;
  }
});

// node_modules/@azure/core-client/dist/commonjs/deserializationPolicy.js
var require_deserializationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.deserializationPolicyName = void 0;
  exports.deserializationPolicy = deserializationPolicy;
  var interfaces_js_1 = require_interfaces(), core_rest_pipeline_1 = require_commonjs8(), serializer_js_1 = require_serializer(), operationHelpers_js_1 = require_operationHelpers(), defaultJsonContentTypes = ["application/json", "text/json"], defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
  exports.deserializationPolicyName = "deserializationPolicy";
  function deserializationPolicy(options = {}) {
    let jsonContentTypes = options.expectedContentTypes?.json ?? defaultJsonContentTypes, xmlContentTypes = options.expectedContentTypes?.xml ?? defaultXmlContentTypes, parseXML = options.parseXML, serializerOptions = options.serializerOptions, updatedOptions = {
      xml: {
        rootName: serializerOptions?.xml.rootName ?? "",
        includeRoot: serializerOptions?.xml.includeRoot ?? !1,
        xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
      }
    };
    return {
      name: exports.deserializationPolicyName,
      async sendRequest(request, next) {
        let response = await next(request);
        return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
      }
    };
  }
  function getOperationResponseMap(parsedResponse) {
    let result, request = parsedResponse.request, operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request), operationSpec = operationInfo?.operationSpec;
    if (operationSpec)
      if (!operationInfo?.operationResponseGetter)
        result = operationSpec.responses[parsedResponse.status];
      else
        result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);
    return result;
  }
  function shouldDeserializeResponse(parsedResponse) {
    let request = parsedResponse.request, shouldDeserialize = (0, operationHelpers_js_1.getOperationRequestInfo)(request)?.shouldDeserialize, result;
    if (shouldDeserialize === void 0)
      result = !0;
    else if (typeof shouldDeserialize === "boolean")
      result = shouldDeserialize;
    else
      result = shouldDeserialize(parsedResponse);
    return result;
  }
  async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
    let parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
    if (!shouldDeserializeResponse(parsedResponse))
      return parsedResponse;
    let operationSpec = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request)?.operationSpec;
    if (!operationSpec || !operationSpec.responses)
      return parsedResponse;
    let responseSpec = getOperationResponseMap(parsedResponse), { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
    if (error)
      throw error;
    else if (shouldReturnResponse)
      return parsedResponse;
    if (responseSpec) {
      if (responseSpec.bodyMapper) {
        let valueToDeserialize = parsedResponse.parsedBody;
        if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence)
          valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
        try {
          parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
        } catch (deserializeError) {
          throw new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
            statusCode: parsedResponse.status,
            request: parsedResponse.request,
            response: parsedResponse
          });
        }
      } else if (operationSpec.httpMethod === "HEAD")
        parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
      if (responseSpec.headersMapper)
        parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: !0 });
    }
    return parsedResponse;
  }
  function isOperationSpecEmpty(operationSpec) {
    let expectedStatusCodes = Object.keys(operationSpec.responses);
    return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
  }
  function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
    let isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
    if (isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec)
      if (responseSpec) {
        if (!responseSpec.isError)
          return { error: null, shouldReturnResponse: !1 };
      } else
        return { error: null, shouldReturnResponse: !1 };
    let errorResponseSpec = responseSpec ?? operationSpec.responses.default, initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(parsedResponse.status) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText, error = new core_rest_pipeline_1.RestError(initialErrorMessage, {
      statusCode: parsedResponse.status,
      request: parsedResponse.request,
      response: parsedResponse
    });
    if (!errorResponseSpec && !(parsedResponse.parsedBody?.error?.code && parsedResponse.parsedBody?.error?.message))
      throw error;
    let defaultBodyMapper = errorResponseSpec?.bodyMapper, defaultHeadersMapper = errorResponseSpec?.headersMapper;
    try {
      if (parsedResponse.parsedBody) {
        let parsedBody = parsedResponse.parsedBody, deserializedError;
        if (defaultBodyMapper) {
          let valueToDeserialize = parsedBody;
          if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
            valueToDeserialize = [];
            let elementName = defaultBodyMapper.xmlElementName;
            if (typeof parsedBody === "object" && elementName)
              valueToDeserialize = parsedBody[elementName];
          }
          deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
        }
        let internalError = parsedBody.error || deserializedError || parsedBody;
        if (error.code = internalError.code, internalError.message)
          error.message = internalError.message;
        if (defaultBodyMapper)
          error.response.parsedBody = deserializedError;
      }
      if (parsedResponse.headers && defaultHeadersMapper)
        error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    } catch (defaultError) {
      error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
    }
    return { error, shouldReturnResponse: !1 };
  }
  async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
    if (!operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) && operationResponse.bodyAsText) {
      let text = operationResponse.bodyAsText, contentType = operationResponse.headers.get("Content-Type") || "", contentComponents = !contentType ? [] : contentType.split(";").map((component) => component.toLowerCase());
      try {
        if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1))
          return operationResponse.parsedBody = JSON.parse(text), operationResponse;
        else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
          if (!parseXML)
            throw Error("Parsing XML not supported.");
          let body = await parseXML(text, opts.xml);
          return operationResponse.parsedBody = body, operationResponse;
        }
      } catch (err) {
        let msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`, errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
        throw new core_rest_pipeline_1.RestError(msg, {
          code: errCode,
          statusCode: operationResponse.status,
          request: operationResponse.request,
          response: operationResponse
        });
      }
    }
    return operationResponse;
  }
});

// node_modules/@azure/core-client/dist/commonjs/interfaceHelpers.js
var require_interfaceHelpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
  exports.getPathStringFromParameter = getPathStringFromParameter;
  var serializer_js_1 = require_serializer();
  function getStreamingResponseStatusCodes(operationSpec) {
    let result = /* @__PURE__ */ new Set;
    for (let statusCode in operationSpec.responses) {
      let operationResponse = operationSpec.responses[statusCode];
      if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream)
        result.add(Number(statusCode));
    }
    return result;
  }
  function getPathStringFromParameter(parameter) {
    let { parameterPath, mapper } = parameter, result;
    if (typeof parameterPath === "string")
      result = parameterPath;
    else if (Array.isArray(parameterPath))
      result = parameterPath.join(".");
    else
      result = mapper.serializedName;
    return result;
  }
});

// node_modules/@azure/core-client/dist/commonjs/serializationPolicy.js
var require_serializationPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.serializationPolicyName = void 0;
  exports.serializationPolicy = serializationPolicy;
  exports.serializeHeaders = serializeHeaders;
  exports.serializeRequestBody = serializeRequestBody;
  var interfaces_js_1 = require_interfaces(), operationHelpers_js_1 = require_operationHelpers(), serializer_js_1 = require_serializer(), interfaceHelpers_js_1 = require_interfaceHelpers();
  exports.serializationPolicyName = "serializationPolicy";
  function serializationPolicy(options = {}) {
    let stringifyXML = options.stringifyXML;
    return {
      name: exports.serializationPolicyName,
      async sendRequest(request, next) {
        let operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request), operationSpec = operationInfo?.operationSpec, operationArguments = operationInfo?.operationArguments;
        if (operationSpec && operationArguments)
          serializeHeaders(request, operationArguments, operationSpec), serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
        return next(request);
      }
    };
  }
  function serializeHeaders(request, operationArguments, operationSpec) {
    if (operationSpec.headerParameters)
      for (let headerParameter of operationSpec.headerParameters) {
        let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
        if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
          headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
          let headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
          if (headerCollectionPrefix)
            for (let key of Object.keys(headerValue))
              request.headers.set(headerCollectionPrefix + key, headerValue[key]);
          else
            request.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
        }
      }
    let customHeaders = operationArguments.options?.requestOptions?.customHeaders;
    if (customHeaders)
      for (let customHeaderName of Object.keys(customHeaders))
        request.headers.set(customHeaderName, customHeaders[customHeaderName]);
  }
  function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function() {
    throw Error("XML serialization unsupported!");
  }) {
    let serializerOptions = operationArguments.options?.serializerOptions, updatedOptions = {
      xml: {
        rootName: serializerOptions?.xml.rootName ?? "",
        includeRoot: serializerOptions?.xml.includeRoot ?? !1,
        xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY
      }
    }, xmlCharKey = updatedOptions.xml.xmlCharKey;
    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
      request.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
      let bodyMapper = operationSpec.requestBody.mapper, { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper, typeName = bodyMapper.type.name;
      try {
        if (request.body !== void 0 && request.body !== null || nullable && request.body === null || required) {
          let requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
          request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
          let isStream = typeName === serializer_js_1.MapperTypeNames.Stream;
          if (operationSpec.isXML) {
            let xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns", value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
            if (typeName === serializer_js_1.MapperTypeNames.Sequence)
              request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
            else if (!isStream)
              request.body = stringifyXML(value, {
                rootName: xmlName || serializedName,
                xmlCharKey
              });
          } else if (typeName === serializer_js_1.MapperTypeNames.String && (operationSpec.contentType?.match("text/plain") || operationSpec.mediaType === "text"))
            return;
          else if (!isStream)
            request.body = JSON.stringify(request.body);
        }
      } catch (error) {
        throw Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
      }
    } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
      request.formData = {};
      for (let formDataParameter of operationSpec.formDataParameters) {
        let formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
        if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
          let formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
          request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
        }
      }
    }
  }
  function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
    if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
      let result = {};
      return result[options.xml.xmlCharKey] = serializedValue, result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace }, result;
    }
    return serializedValue;
  }
  function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
    if (!Array.isArray(obj))
      obj = [obj];
    if (!xmlNamespaceKey || !xmlNamespace)
      return { [elementName]: obj };
    let result = { [elementName]: obj };
    return result[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace }, result;
  }
});

// node_modules/@azure/core-client/dist/commonjs/pipeline.js
var require_pipeline3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createClientPipeline = createClientPipeline;
  var deserializationPolicy_js_1 = require_deserializationPolicy(), core_rest_pipeline_1 = require_commonjs8(), serializationPolicy_js_1 = require_serializationPolicy();
  function createClientPipeline(options = {}) {
    let pipeline = (0, core_rest_pipeline_1.createPipelineFromOptions)(options ?? {});
    if (options.credentialOptions)
      pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
        credential: options.credentialOptions.credential,
        scopes: options.credentialOptions.credentialScopes
      }));
    return pipeline.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options.serializationOptions), { phase: "Serialize" }), pipeline.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options.deserializationOptions), {
      phase: "Deserialize"
    }), pipeline;
  }
});

// node_modules/@azure/core-client/dist/commonjs/httpClientCache.js
var require_httpClientCache = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
  var core_rest_pipeline_1 = require_commonjs8(), cachedHttpClient;
  function getCachedDefaultHttpClient() {
    if (!cachedHttpClient)
      cachedHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
    return cachedHttpClient;
  }
});

// node_modules/@azure/core-client/dist/commonjs/urlHelpers.js
var require_urlHelpers2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getRequestUrl = getRequestUrl;
  exports.appendQueryParams = appendQueryParams;
  var operationHelpers_js_1 = require_operationHelpers(), interfaceHelpers_js_1 = require_interfaceHelpers(), CollectionFormatToDelimiterMap = {
    CSV: ",",
    SSV: " ",
    Multi: "Multi",
    TSV: "\t",
    Pipes: "|"
  };
  function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
    let urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject), isAbsolutePath = !1, requestUrl = replaceAll(baseUri, urlReplacements);
    if (operationSpec.path) {
      let path = replaceAll(operationSpec.path, urlReplacements);
      if (operationSpec.path === "/{nextLink}" && path.startsWith("/"))
        path = path.substring(1);
      if (isAbsoluteUrl(path))
        requestUrl = path, isAbsolutePath = !0;
      else
        requestUrl = appendPath(requestUrl, path);
    }
    let { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
    return requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath), requestUrl;
  }
  function replaceAll(input, replacements) {
    let result = input;
    for (let [searchValue, replaceValue] of replacements)
      result = result.split(searchValue).join(replaceValue);
    return result;
  }
  function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
    let result = /* @__PURE__ */ new Map;
    if (operationSpec.urlParameters?.length)
      for (let urlParameter of operationSpec.urlParameters) {
        let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject), parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
        if (urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString), !urlParameter.skipEncoding)
          urlParameterValue = encodeURIComponent(urlParameterValue);
        result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
      }
    return result;
  }
  function isAbsoluteUrl(url) {
    return url.includes("://");
  }
  function appendPath(url, pathToAppend) {
    if (!pathToAppend)
      return url;
    let parsedUrl = new URL(url), newPath = parsedUrl.pathname;
    if (!newPath.endsWith("/"))
      newPath = `${newPath}/`;
    if (pathToAppend.startsWith("/"))
      pathToAppend = pathToAppend.substring(1);
    let searchStart = pathToAppend.indexOf("?");
    if (searchStart !== -1) {
      let path = pathToAppend.substring(0, searchStart), search = pathToAppend.substring(searchStart + 1);
      if (newPath = newPath + path, search)
        parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    } else
      newPath = newPath + pathToAppend;
    return parsedUrl.pathname = newPath, parsedUrl.toString();
  }
  function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
    let result = /* @__PURE__ */ new Map, sequenceParams = /* @__PURE__ */ new Set;
    if (operationSpec.queryParameters?.length)
      for (let queryParameter of operationSpec.queryParameters) {
        if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName)
          sequenceParams.add(queryParameter.mapper.serializedName);
        let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
        if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
          queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
          let delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
          if (Array.isArray(queryParameterValue))
            queryParameterValue = queryParameterValue.map((item) => {
              if (item === null || item === void 0)
                return "";
              return item;
            });
          if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0)
            continue;
          else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV"))
            queryParameterValue = queryParameterValue.join(delimiter);
          if (!queryParameter.skipEncoding)
            if (Array.isArray(queryParameterValue))
              queryParameterValue = queryParameterValue.map((item) => {
                return encodeURIComponent(item);
              });
            else
              queryParameterValue = encodeURIComponent(queryParameterValue);
          if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes"))
            queryParameterValue = queryParameterValue.join(delimiter);
          result.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
        }
      }
    return {
      queryParams: result,
      sequenceParams
    };
  }
  function simpleParseQueryParams(queryString) {
    let result = /* @__PURE__ */ new Map;
    if (!queryString || queryString[0] !== "?")
      return result;
    queryString = queryString.slice(1);
    let pairs = queryString.split("&");
    for (let pair of pairs) {
      let [name, value] = pair.split("=", 2), existingValue = result.get(name);
      if (existingValue)
        if (Array.isArray(existingValue))
          existingValue.push(value);
        else
          result.set(name, [existingValue, value]);
      else
        result.set(name, value);
    }
    return result;
  }
  function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = !1) {
    if (queryParams.size === 0)
      return url;
    let parsedUrl = new URL(url), combinedParams = simpleParseQueryParams(parsedUrl.search);
    for (let [name, value] of queryParams) {
      let existingValue = combinedParams.get(name);
      if (Array.isArray(existingValue))
        if (Array.isArray(value)) {
          existingValue.push(...value);
          let valueSet = new Set(existingValue);
          combinedParams.set(name, Array.from(valueSet));
        } else
          existingValue.push(value);
      else if (existingValue) {
        if (Array.isArray(value))
          value.unshift(existingValue);
        else if (sequenceParams.has(name))
          combinedParams.set(name, [existingValue, value]);
        if (!noOverwrite)
          combinedParams.set(name, value);
      } else
        combinedParams.set(name, value);
    }
    let searchPieces = [];
    for (let [name, value] of combinedParams)
      if (typeof value === "string")
        searchPieces.push(`${name}=${value}`);
      else if (Array.isArray(value))
        for (let subValue of value)
          searchPieces.push(`${name}=${subValue}`);
      else
        searchPieces.push(`${name}=${value}`);
    return parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "", parsedUrl.toString();
  }
});

// node_modules/@azure/core-client/node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs11 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AzureLogger = void 0;
  exports.setLogLevel = setLogLevel;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger;
  var logger_1 = require_internal(), context = (0, logger_1.createLoggerContext)({
    logLevelEnvVarName: "AZURE_LOG_LEVEL",
    namespace: "azure"
  });
  exports.AzureLogger = context.logger;
  function setLogLevel(level) {
    context.setLogLevel(level);
  }
  function getLogLevel() {
    return context.getLogLevel();
  }
  function createClientLogger(namespace) {
    return context.createClientLogger(namespace);
  }
});

// node_modules/@azure/core-client/dist/commonjs/log.js
var require_log4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.logger = void 0;
  var logger_1 = require_commonjs11();
  exports.logger = (0, logger_1.createClientLogger)("core-client");
});

// node_modules/@azure/core-client/dist/commonjs/serviceClient.js
var require_serviceClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ServiceClient = void 0;
  var core_rest_pipeline_1 = require_commonjs8(), pipeline_js_1 = require_pipeline3(), utils_js_1 = require_utils3(), httpClientCache_js_1 = require_httpClientCache(), operationHelpers_js_1 = require_operationHelpers(), urlHelpers_js_1 = require_urlHelpers2(), interfaceHelpers_js_1 = require_interfaceHelpers(), log_js_1 = require_log4();

  class ServiceClient {
    _endpoint;
    _requestContentType;
    _allowInsecureConnection;
    _httpClient;
    pipeline;
    constructor(options = {}) {
      if (this._requestContentType = options.requestContentType, this._endpoint = options.endpoint ?? options.baseUri, options.baseUri)
        log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
      if (this._allowInsecureConnection = options.allowInsecureConnection, this._httpClient = options.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)(), this.pipeline = options.pipeline || createDefaultPipeline(options), options.additionalPolicies?.length)
        for (let { policy, position } of options.additionalPolicies) {
          let afterPhase = position === "perRetry" ? "Sign" : void 0;
          this.pipeline.addPolicy(policy, {
            afterPhase
          });
        }
    }
    async sendRequest(request) {
      return this.pipeline.sendRequest(this._httpClient, request);
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      let endpoint = operationSpec.baseUrl || this._endpoint;
      if (!endpoint)
        throw Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
      let url = (0, urlHelpers_js_1.getRequestUrl)(endpoint, operationSpec, operationArguments, this), request = (0, core_rest_pipeline_1.createPipelineRequest)({
        url
      });
      request.method = operationSpec.httpMethod;
      let operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
      operationInfo.operationSpec = operationSpec, operationInfo.operationArguments = operationArguments;
      let contentType = operationSpec.contentType || this._requestContentType;
      if (contentType && operationSpec.requestBody)
        request.headers.set("Content-Type", contentType);
      let options = operationArguments.options;
      if (options) {
        let requestOptions = options.requestOptions;
        if (requestOptions) {
          if (requestOptions.timeout)
            request.timeout = requestOptions.timeout;
          if (requestOptions.onUploadProgress)
            request.onUploadProgress = requestOptions.onUploadProgress;
          if (requestOptions.onDownloadProgress)
            request.onDownloadProgress = requestOptions.onDownloadProgress;
          if (requestOptions.shouldDeserialize !== void 0)
            operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
          if (requestOptions.allowInsecureConnection)
            request.allowInsecureConnection = !0;
        }
        if (options.abortSignal)
          request.abortSignal = options.abortSignal;
        if (options.tracingOptions)
          request.tracingOptions = options.tracingOptions;
      }
      if (this._allowInsecureConnection)
        request.allowInsecureConnection = !0;
      if (request.streamResponseStatusCodes === void 0)
        request.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
      try {
        let rawResponse = await this.sendRequest(request), flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
        if (options?.onResponse)
          options.onResponse(rawResponse, flatResponse);
        return flatResponse;
      } catch (error) {
        if (typeof error === "object" && error?.response) {
          let rawResponse = error.response, flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses.default);
          if (error.details = flatResponse, options?.onResponse)
            options.onResponse(rawResponse, flatResponse, error);
        }
        throw error;
      }
    }
  }
  exports.ServiceClient = ServiceClient;
  function createDefaultPipeline(options) {
    let credentialScopes = getCredentialScopes(options), credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
    return (0, pipeline_js_1.createClientPipeline)({
      ...options,
      credentialOptions
    });
  }
  function getCredentialScopes(options) {
    if (options.credentialScopes)
      return options.credentialScopes;
    if (options.endpoint)
      return `${options.endpoint}/.default`;
    if (options.baseUri)
      return `${options.baseUri}/.default`;
    if (options.credential && !options.credentialScopes)
      throw Error("When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy");
    return;
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnClaimChallenge.js
var require_authorizeRequestOnClaimChallenge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.parseCAEChallenge = parseCAEChallenge;
  exports.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge;
  var log_js_1 = require_log4(), base64_js_1 = require_base642();
  function parseCAEChallenge(challenges) {
    return `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x).map((challenge) => {
      return `${challenge.trim()}, `.split('", ').filter((x) => x).map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="'))).reduce((a, b) => ({ ...a, ...b }), {});
    });
  }
  async function authorizeRequestOnClaimChallenge(onChallengeOptions) {
    let { scopes, response } = onChallengeOptions, logger = onChallengeOptions.logger || log_js_1.logger, challenge = response.headers.get("WWW-Authenticate");
    if (!challenge)
      return logger.info("The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow."), !1;
    let parsedChallenge = (parseCAEChallenge(challenge) || []).find((x) => x.claims);
    if (!parsedChallenge)
      return logger.info('The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.'), !1;
    let accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
      claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims)
    });
    if (!accessToken)
      return !1;
    return onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`), !0;
  }
});

// node_modules/@azure/core-client/dist/commonjs/authorizeRequestOnTenantChallenge.js
var require_authorizeRequestOnTenantChallenge = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.authorizeRequestOnTenantChallenge = void 0;
  var Constants = {
    DefaultScope: "/.default",
    HeaderConstants: {
      AUTHORIZATION: "authorization"
    }
  };
  function isUuid(text) {
    return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
  }
  var authorizeRequestOnTenantChallenge = async (challengeOptions) => {
    let requestOptions = requestToOptions(challengeOptions.request), challenge = getChallenge(challengeOptions.response);
    if (challenge) {
      let challengeInfo = parseChallenge(challenge), challengeScopes = buildScopes(challengeOptions, challengeInfo), tenantId = extractTenantId(challengeInfo);
      if (!tenantId)
        return !1;
      let accessToken = await challengeOptions.getAccessToken(challengeScopes, {
        ...requestOptions,
        tenantId
      });
      if (!accessToken)
        return !1;
      return challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`), !0;
    }
    return !1;
  };
  exports.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge;
  function extractTenantId(challengeInfo) {
    let tenantId = new URL(challengeInfo.authorization_uri).pathname.split("/")[1];
    if (tenantId && isUuid(tenantId))
      return tenantId;
    return;
  }
  function buildScopes(challengeOptions, challengeInfo) {
    if (!challengeInfo.resource_id)
      return challengeOptions.scopes;
    let challengeScopes = new URL(challengeInfo.resource_id);
    challengeScopes.pathname = Constants.DefaultScope;
    let scope = challengeScopes.toString();
    if (scope === "https://disk.azure.com/.default")
      scope = "https://disk.azure.com//.default";
    return [scope];
  }
  function getChallenge(response) {
    let challenge = response.headers.get("WWW-Authenticate");
    if (response.status === 401 && challenge)
      return challenge;
    return;
  }
  function parseChallenge(challenge) {
    return `${challenge.slice(7).trim()} `.split(" ").filter((x) => x).map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("="))).reduce((a, b) => ({ ...a, ...b }), {});
  }
  function requestToOptions(request) {
    return {
      abortSignal: request.abortSignal,
      requestOptions: {
        timeout: request.timeout
      },
      tracingOptions: request.tracingOptions
    };
  }
});

// node_modules/@azure/core-client/dist/commonjs/index.js
var require_commonjs12 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.authorizeRequestOnTenantChallenge = exports.authorizeRequestOnClaimChallenge = exports.serializationPolicyName = exports.serializationPolicy = exports.deserializationPolicyName = exports.deserializationPolicy = exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.createClientPipeline = exports.ServiceClient = exports.MapperTypeNames = exports.createSerializer = void 0;
  var serializer_js_1 = require_serializer();
  Object.defineProperty(exports, "createSerializer", { enumerable: !0, get: function() {
    return serializer_js_1.createSerializer;
  } });
  Object.defineProperty(exports, "MapperTypeNames", { enumerable: !0, get: function() {
    return serializer_js_1.MapperTypeNames;
  } });
  var serviceClient_js_1 = require_serviceClient();
  Object.defineProperty(exports, "ServiceClient", { enumerable: !0, get: function() {
    return serviceClient_js_1.ServiceClient;
  } });
  var pipeline_js_1 = require_pipeline3();
  Object.defineProperty(exports, "createClientPipeline", { enumerable: !0, get: function() {
    return pipeline_js_1.createClientPipeline;
  } });
  var interfaces_js_1 = require_interfaces();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: !0, get: function() {
    return interfaces_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: !0, get: function() {
    return interfaces_js_1.XML_CHARKEY;
  } });
  var deserializationPolicy_js_1 = require_deserializationPolicy();
  Object.defineProperty(exports, "deserializationPolicy", { enumerable: !0, get: function() {
    return deserializationPolicy_js_1.deserializationPolicy;
  } });
  Object.defineProperty(exports, "deserializationPolicyName", { enumerable: !0, get: function() {
    return deserializationPolicy_js_1.deserializationPolicyName;
  } });
  var serializationPolicy_js_1 = require_serializationPolicy();
  Object.defineProperty(exports, "serializationPolicy", { enumerable: !0, get: function() {
    return serializationPolicy_js_1.serializationPolicy;
  } });
  Object.defineProperty(exports, "serializationPolicyName", { enumerable: !0, get: function() {
    return serializationPolicy_js_1.serializationPolicyName;
  } });
  var authorizeRequestOnClaimChallenge_js_1 = require_authorizeRequestOnClaimChallenge();
  Object.defineProperty(exports, "authorizeRequestOnClaimChallenge", { enumerable: !0, get: function() {
    return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge;
  } });
  var authorizeRequestOnTenantChallenge_js_1 = require_authorizeRequestOnTenantChallenge();
  Object.defineProperty(exports, "authorizeRequestOnTenantChallenge", { enumerable: !0, get: function() {
    return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge;
  } });
});

// node_modules/@azure/core-http-compat/dist/commonjs/util.js
var require_util9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.HttpHeaders = void 0;
  exports.toPipelineRequest = toPipelineRequest;
  exports.toWebResourceLike = toWebResourceLike;
  exports.toHttpHeadersLike = toHttpHeadersLike;
  var core_rest_pipeline_1 = require_commonjs8(), originalRequestSymbol = Symbol("Original PipelineRequest"), originalClientRequestSymbol = Symbol.for("@azure/core-client original request");
  function toPipelineRequest(webResource, options = {}) {
    let request = webResource[originalRequestSymbol], headers = (0, core_rest_pipeline_1.createHttpHeaders)(webResource.headers.toJson({ preserveCase: !0 }));
    if (request)
      return request.headers = headers, request;
    else {
      let newRequest = (0, core_rest_pipeline_1.createPipelineRequest)({
        url: webResource.url,
        method: webResource.method,
        headers,
        withCredentials: webResource.withCredentials,
        timeout: webResource.timeout,
        requestId: webResource.requestId,
        abortSignal: webResource.abortSignal,
        body: webResource.body,
        formData: webResource.formData,
        disableKeepAlive: !!webResource.keepAlive,
        onDownloadProgress: webResource.onDownloadProgress,
        onUploadProgress: webResource.onUploadProgress,
        proxySettings: webResource.proxySettings,
        streamResponseStatusCodes: webResource.streamResponseStatusCodes,
        agent: webResource.agent,
        requestOverrides: webResource.requestOverrides
      });
      if (options.originalRequest)
        newRequest[originalClientRequestSymbol] = options.originalRequest;
      return newRequest;
    }
  }
  function toWebResourceLike(request, options) {
    let originalRequest = options?.originalRequest ?? request, webResource = {
      url: request.url,
      method: request.method,
      headers: toHttpHeadersLike(request.headers),
      withCredentials: request.withCredentials,
      timeout: request.timeout,
      requestId: request.headers.get("x-ms-client-request-id") || request.requestId,
      abortSignal: request.abortSignal,
      body: request.body,
      formData: request.formData,
      keepAlive: !!request.disableKeepAlive,
      onDownloadProgress: request.onDownloadProgress,
      onUploadProgress: request.onUploadProgress,
      proxySettings: request.proxySettings,
      streamResponseStatusCodes: request.streamResponseStatusCodes,
      agent: request.agent,
      requestOverrides: request.requestOverrides,
      clone() {
        throw Error("Cannot clone a non-proxied WebResourceLike");
      },
      prepare() {
        throw Error("WebResourceLike.prepare() is not supported by @azure/core-http-compat");
      },
      validateRequestProperties() {}
    };
    if (options?.createProxy)
      return new Proxy(webResource, {
        get(target, prop, receiver) {
          if (prop === originalRequestSymbol)
            return request;
          else if (prop === "clone")
            return () => {
              return toWebResourceLike(toPipelineRequest(webResource, { originalRequest }), {
                createProxy: !0,
                originalRequest
              });
            };
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "keepAlive")
            request.disableKeepAlive = !value;
          if (typeof prop === "string" && [
            "url",
            "method",
            "withCredentials",
            "timeout",
            "requestId",
            "abortSignal",
            "body",
            "formData",
            "onDownloadProgress",
            "onUploadProgress",
            "proxySettings",
            "streamResponseStatusCodes",
            "agent",
            "requestOverrides"
          ].includes(prop))
            request[prop] = value;
          return Reflect.set(target, prop, value, receiver);
        }
      });
    else
      return webResource;
  }
  function toHttpHeadersLike(headers) {
    return new HttpHeaders(headers.toJSON({ preserveCase: !0 }));
  }
  function getHeaderKey(headerName) {
    return headerName.toLowerCase();
  }

  class HttpHeaders {
    _headersMap;
    constructor(rawHeaders) {
      if (this._headersMap = {}, rawHeaders)
        for (let headerName in rawHeaders)
          this.set(headerName, rawHeaders[headerName]);
    }
    set(headerName, headerValue) {
      this._headersMap[getHeaderKey(headerName)] = {
        name: headerName,
        value: headerValue.toString()
      };
    }
    get(headerName) {
      let header = this._headersMap[getHeaderKey(headerName)];
      return !header ? void 0 : header.value;
    }
    contains(headerName) {
      return !!this._headersMap[getHeaderKey(headerName)];
    }
    remove(headerName) {
      let result = this.contains(headerName);
      return delete this._headersMap[getHeaderKey(headerName)], result;
    }
    rawHeaders() {
      return this.toJson({ preserveCase: !0 });
    }
    headersArray() {
      let headers = [];
      for (let headerKey in this._headersMap)
        headers.push(this._headersMap[headerKey]);
      return headers;
    }
    headerNames() {
      let headerNames = [], headers = this.headersArray();
      for (let i = 0;i < headers.length; ++i)
        headerNames.push(headers[i].name);
      return headerNames;
    }
    headerValues() {
      let headerValues = [], headers = this.headersArray();
      for (let i = 0;i < headers.length; ++i)
        headerValues.push(headers[i].value);
      return headerValues;
    }
    toJson(options = {}) {
      let result = {};
      if (options.preserveCase)
        for (let headerKey in this._headersMap) {
          let header = this._headersMap[headerKey];
          result[header.name] = header.value;
        }
      else
        for (let headerKey in this._headersMap) {
          let header = this._headersMap[headerKey];
          result[getHeaderKey(header.name)] = header.value;
        }
      return result;
    }
    toString() {
      return JSON.stringify(this.toJson({ preserveCase: !0 }));
    }
    clone() {
      let resultPreservingCasing = {};
      for (let headerKey in this._headersMap) {
        let header = this._headersMap[headerKey];
        resultPreservingCasing[header.name] = header.value;
      }
      return new HttpHeaders(resultPreservingCasing);
    }
  }
  exports.HttpHeaders = HttpHeaders;
});

// node_modules/@azure/core-http-compat/dist/commonjs/response.js
var require_response2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.toCompatResponse = toCompatResponse;
  exports.toPipelineResponse = toPipelineResponse;
  var core_rest_pipeline_1 = require_commonjs8(), util_js_1 = require_util9(), originalResponse = Symbol("Original FullOperationResponse");
  function toCompatResponse(response, options) {
    let request = (0, util_js_1.toWebResourceLike)(response.request), headers = (0, util_js_1.toHttpHeadersLike)(response.headers);
    if (options?.createProxy)
      return new Proxy(response, {
        get(target, prop, receiver) {
          if (prop === "headers")
            return headers;
          else if (prop === "request")
            return request;
          else if (prop === originalResponse)
            return response;
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver) {
          if (prop === "headers")
            headers = value;
          else if (prop === "request")
            request = value;
          return Reflect.set(target, prop, value, receiver);
        }
      });
    else
      return {
        ...response,
        request,
        headers
      };
  }
  function toPipelineResponse(compatResponse) {
    let response = compatResponse[originalResponse], headers = (0, core_rest_pipeline_1.createHttpHeaders)(compatResponse.headers.toJson({ preserveCase: !0 }));
    if (response)
      return response.headers = headers, response;
    else
      return {
        ...compatResponse,
        headers,
        request: (0, util_js_1.toPipelineRequest)(compatResponse.request)
      };
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/extendedClient.js
var require_extendedClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ExtendedServiceClient = void 0;
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy(), core_rest_pipeline_1 = require_commonjs8(), core_client_1 = require_commonjs12(), response_js_1 = require_response2();

  class ExtendedServiceClient extends core_client_1.ServiceClient {
    constructor(options) {
      super(options);
      if (options.keepAliveOptions?.enable === !1 && !(0, disableKeepAlivePolicy_js_1.pipelineContainsDisableKeepAlivePolicy)(this.pipeline))
        this.pipeline.addPolicy((0, disableKeepAlivePolicy_js_1.createDisableKeepAlivePolicy)());
      if (options.redirectOptions?.handleRedirects === !1)
        this.pipeline.removePolicy({
          name: core_rest_pipeline_1.redirectPolicyName
        });
    }
    async sendOperationRequest(operationArguments, operationSpec) {
      let userProvidedCallBack = operationArguments?.options?.onResponse, lastResponse;
      function onResponse(rawResponse, flatResponse, error) {
        if (lastResponse = rawResponse, userProvidedCallBack)
          userProvidedCallBack(rawResponse, flatResponse, error);
      }
      operationArguments.options = {
        ...operationArguments.options,
        onResponse
      };
      let result = await super.sendOperationRequest(operationArguments, operationSpec);
      if (lastResponse)
        Object.defineProperty(result, "_response", {
          value: (0, response_js_1.toCompatResponse)(lastResponse)
        });
      return result;
    }
  }
  exports.ExtendedServiceClient = ExtendedServiceClient;
});

// node_modules/@azure/core-http-compat/dist/commonjs/policies/requestPolicyFactoryPolicy.js
var require_requestPolicyFactoryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.requestPolicyFactoryPolicyName = exports.HttpPipelineLogLevel = void 0;
  exports.createRequestPolicyFactoryPolicy = createRequestPolicyFactoryPolicy;
  var util_js_1 = require_util9(), response_js_1 = require_response2(), HttpPipelineLogLevel;
  (function(HttpPipelineLogLevel2) {
    HttpPipelineLogLevel2[HttpPipelineLogLevel2.ERROR = 1] = "ERROR", HttpPipelineLogLevel2[HttpPipelineLogLevel2.INFO = 3] = "INFO", HttpPipelineLogLevel2[HttpPipelineLogLevel2.OFF = 0] = "OFF", HttpPipelineLogLevel2[HttpPipelineLogLevel2.WARNING = 2] = "WARNING";
  })(HttpPipelineLogLevel || (exports.HttpPipelineLogLevel = HttpPipelineLogLevel = {}));
  var mockRequestPolicyOptions = {
    log(_logLevel, _message) {},
    shouldLog(_logLevel) {
      return !1;
    }
  };
  exports.requestPolicyFactoryPolicyName = "RequestPolicyFactoryPolicy";
  function createRequestPolicyFactoryPolicy(factories) {
    let orderedFactories = factories.slice().reverse();
    return {
      name: exports.requestPolicyFactoryPolicyName,
      async sendRequest(request, next) {
        let httpPipeline = {
          async sendRequest(httpRequest) {
            let response2 = await next((0, util_js_1.toPipelineRequest)(httpRequest));
            return (0, response_js_1.toCompatResponse)(response2, { createProxy: !0 });
          }
        };
        for (let factory of orderedFactories)
          httpPipeline = factory.create(httpPipeline, mockRequestPolicyOptions);
        let webResourceLike = (0, util_js_1.toWebResourceLike)(request, { createProxy: !0 }), response = await httpPipeline.sendRequest(webResourceLike);
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/httpClientAdapter.js
var require_httpClientAdapter = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.convertHttpClient = convertHttpClient;
  var response_js_1 = require_response2(), util_js_1 = require_util9();
  function convertHttpClient(requestPolicyClient) {
    return {
      sendRequest: async (request) => {
        let response = await requestPolicyClient.sendRequest((0, util_js_1.toWebResourceLike)(request, { createProxy: !0 }));
        return (0, response_js_1.toPipelineResponse)(response);
      }
    };
  }
});

// node_modules/@azure/core-http-compat/dist/commonjs/index.js
var require_commonjs13 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.toHttpHeadersLike = exports.convertHttpClient = exports.disableKeepAlivePolicyName = exports.HttpPipelineLogLevel = exports.createRequestPolicyFactoryPolicy = exports.requestPolicyFactoryPolicyName = exports.ExtendedServiceClient = void 0;
  var extendedClient_js_1 = require_extendedClient();
  Object.defineProperty(exports, "ExtendedServiceClient", { enumerable: !0, get: function() {
    return extendedClient_js_1.ExtendedServiceClient;
  } });
  var requestPolicyFactoryPolicy_js_1 = require_requestPolicyFactoryPolicy();
  Object.defineProperty(exports, "requestPolicyFactoryPolicyName", { enumerable: !0, get: function() {
    return requestPolicyFactoryPolicy_js_1.requestPolicyFactoryPolicyName;
  } });
  Object.defineProperty(exports, "createRequestPolicyFactoryPolicy", { enumerable: !0, get: function() {
    return requestPolicyFactoryPolicy_js_1.createRequestPolicyFactoryPolicy;
  } });
  Object.defineProperty(exports, "HttpPipelineLogLevel", { enumerable: !0, get: function() {
    return requestPolicyFactoryPolicy_js_1.HttpPipelineLogLevel;
  } });
  var disableKeepAlivePolicy_js_1 = require_disableKeepAlivePolicy();
  Object.defineProperty(exports, "disableKeepAlivePolicyName", { enumerable: !0, get: function() {
    return disableKeepAlivePolicy_js_1.disableKeepAlivePolicyName;
  } });
  var httpClientAdapter_js_1 = require_httpClientAdapter();
  Object.defineProperty(exports, "convertHttpClient", { enumerable: !0, get: function() {
    return httpClientAdapter_js_1.convertHttpClient;
  } });
  var util_js_1 = require_util9();
  Object.defineProperty(exports, "toHttpHeadersLike", { enumerable: !0, get: function() {
    return util_js_1.toHttpHeadersLike;
  } });
});

// node_modules/fast-xml-parser/lib/fxp.cjs
var require_fxp = __commonJS((exports, module) => {
  (() => {
    var t = { d: (e2, i2) => {
      for (var n2 in i2)
        t.o(i2, n2) && !t.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: !0, get: i2[n2] });
    }, o: (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r: (t2) => {
      typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: !0 });
    } }, e = {};
    t.r(e), t.d(e, { XMLBuilder: () => lt, XMLParser: () => tt, XMLValidator: () => pt });
    let i = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", n = new RegExp("^[" + i + "][" + i + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
    function s(t2, e2) {
      let i2 = [], n2 = e2.exec(t2);
      for (;n2; ) {
        let s2 = [];
        s2.startIndex = e2.lastIndex - n2[0].length;
        let r2 = n2.length;
        for (let t3 = 0;t3 < r2; t3++)
          s2.push(n2[t3]);
        i2.push(s2), n2 = e2.exec(t2);
      }
      return i2;
    }
    let r = function(t2) {
      return n.exec(t2) != null;
    }, o = { allowBooleanAttributes: !1, unpairedTags: [] };
    function a(t2, e2) {
      e2 = Object.assign({}, o, e2);
      let i2 = [], n2 = !1, s2 = !1;
      t2[0] === "\uFEFF" && (t2 = t2.substr(1));
      for (let o2 = 0;o2 < t2.length; o2++)
        if (t2[o2] === "<" && t2[o2 + 1] === "?") {
          if (o2 += 2, o2 = u(t2, o2), o2.err)
            return o2;
        } else {
          if (t2[o2] !== "<") {
            if (l(t2[o2]))
              continue;
            return x("InvalidChar", "char '" + t2[o2] + "' is not expected.", b(t2, o2));
          }
          {
            let a2 = o2;
            if (o2++, t2[o2] === "!") {
              o2 = h(t2, o2);
              continue;
            }
            {
              let d2 = !1;
              t2[o2] === "/" && (d2 = !0, o2++);
              let p2 = "";
              for (;o2 < t2.length && t2[o2] !== ">" && t2[o2] !== " " && t2[o2] !== "\t" && t2[o2] !== `
` && t2[o2] !== "\r"; o2++)
                p2 += t2[o2];
              if (p2 = p2.trim(), p2[p2.length - 1] === "/" && (p2 = p2.substring(0, p2.length - 1), o2--), !r(p2)) {
                let e3;
                return e3 = p2.trim().length === 0 ? "Invalid space after '<'." : "Tag '" + p2 + "' is an invalid name.", x("InvalidTag", e3, b(t2, o2));
              }
              let c2 = f(t2, o2);
              if (c2 === !1)
                return x("InvalidAttr", "Attributes for '" + p2 + "' have open quote.", b(t2, o2));
              let N2 = c2.value;
              if (o2 = c2.index, N2[N2.length - 1] === "/") {
                let i3 = o2 - N2.length;
                N2 = N2.substring(0, N2.length - 1);
                let s3 = g(N2, e2);
                if (s3 !== !0)
                  return x(s3.err.code, s3.err.msg, b(t2, i3 + s3.err.line));
                n2 = !0;
              } else if (d2) {
                if (!c2.tagClosed)
                  return x("InvalidTag", "Closing tag '" + p2 + "' doesn't have proper closing.", b(t2, o2));
                if (N2.trim().length > 0)
                  return x("InvalidTag", "Closing tag '" + p2 + "' can't have attributes or invalid starting.", b(t2, a2));
                if (i2.length === 0)
                  return x("InvalidTag", "Closing tag '" + p2 + "' has not been opened.", b(t2, a2));
                {
                  let e3 = i2.pop();
                  if (p2 !== e3.tagName) {
                    let i3 = b(t2, e3.tagStartPos);
                    return x("InvalidTag", "Expected closing tag '" + e3.tagName + "' (opened in line " + i3.line + ", col " + i3.col + ") instead of closing tag '" + p2 + "'.", b(t2, a2));
                  }
                  i2.length == 0 && (s2 = !0);
                }
              } else {
                let r2 = g(N2, e2);
                if (r2 !== !0)
                  return x(r2.err.code, r2.err.msg, b(t2, o2 - N2.length + r2.err.line));
                if (s2 === !0)
                  return x("InvalidXml", "Multiple possible root nodes found.", b(t2, o2));
                e2.unpairedTags.indexOf(p2) !== -1 || i2.push({ tagName: p2, tagStartPos: a2 }), n2 = !0;
              }
              for (o2++;o2 < t2.length; o2++)
                if (t2[o2] === "<") {
                  if (t2[o2 + 1] === "!") {
                    o2++, o2 = h(t2, o2);
                    continue;
                  }
                  if (t2[o2 + 1] !== "?")
                    break;
                  if (o2 = u(t2, ++o2), o2.err)
                    return o2;
                } else if (t2[o2] === "&") {
                  let e3 = m(t2, o2);
                  if (e3 == -1)
                    return x("InvalidChar", "char '&' is not expected.", b(t2, o2));
                  o2 = e3;
                } else if (s2 === !0 && !l(t2[o2]))
                  return x("InvalidXml", "Extra text at the end", b(t2, o2));
              t2[o2] === "<" && o2--;
            }
          }
        }
      return n2 ? i2.length == 1 ? x("InvalidTag", "Unclosed tag '" + i2[0].tagName + "'.", b(t2, i2[0].tagStartPos)) : !(i2.length > 0) || x("InvalidXml", "Invalid '" + JSON.stringify(i2.map((t3) => t3.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : x("InvalidXml", "Start tag expected.", 1);
    }
    function l(t2) {
      return t2 === " " || t2 === "\t" || t2 === `
` || t2 === "\r";
    }
    function u(t2, e2) {
      let i2 = e2;
      for (;e2 < t2.length; e2++)
        if (t2[e2] != "?" && t2[e2] != " ")
          ;
        else {
          let n2 = t2.substr(i2, e2 - i2);
          if (e2 > 5 && n2 === "xml")
            return x("InvalidXml", "XML declaration allowed only at the start of the document.", b(t2, e2));
          if (t2[e2] == "?" && t2[e2 + 1] == ">") {
            e2++;
            break;
          }
        }
      return e2;
    }
    function h(t2, e2) {
      if (t2.length > e2 + 5 && t2[e2 + 1] === "-" && t2[e2 + 2] === "-") {
        for (e2 += 3;e2 < t2.length; e2++)
          if (t2[e2] === "-" && t2[e2 + 1] === "-" && t2[e2 + 2] === ">") {
            e2 += 2;
            break;
          }
      } else if (t2.length > e2 + 8 && t2[e2 + 1] === "D" && t2[e2 + 2] === "O" && t2[e2 + 3] === "C" && t2[e2 + 4] === "T" && t2[e2 + 5] === "Y" && t2[e2 + 6] === "P" && t2[e2 + 7] === "E") {
        let i2 = 1;
        for (e2 += 8;e2 < t2.length; e2++)
          if (t2[e2] === "<")
            i2++;
          else if (t2[e2] === ">" && (i2--, i2 === 0))
            break;
      } else if (t2.length > e2 + 9 && t2[e2 + 1] === "[" && t2[e2 + 2] === "C" && t2[e2 + 3] === "D" && t2[e2 + 4] === "A" && t2[e2 + 5] === "T" && t2[e2 + 6] === "A" && t2[e2 + 7] === "[") {
        for (e2 += 8;e2 < t2.length; e2++)
          if (t2[e2] === "]" && t2[e2 + 1] === "]" && t2[e2 + 2] === ">") {
            e2 += 2;
            break;
          }
      }
      return e2;
    }
    let d = '"', p = "'";
    function f(t2, e2) {
      let i2 = "", n2 = "", s2 = !1;
      for (;e2 < t2.length; e2++) {
        if (t2[e2] === d || t2[e2] === p)
          n2 === "" ? n2 = t2[e2] : n2 !== t2[e2] || (n2 = "");
        else if (t2[e2] === ">" && n2 === "") {
          s2 = !0;
          break;
        }
        i2 += t2[e2];
      }
      return n2 === "" && { value: i2, index: e2, tagClosed: s2 };
    }
    let c = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function g(t2, e2) {
      let i2 = s(t2, c), n2 = {};
      for (let t3 = 0;t3 < i2.length; t3++) {
        if (i2[t3][1].length === 0)
          return x("InvalidAttr", "Attribute '" + i2[t3][2] + "' has no space in starting.", E(i2[t3]));
        if (i2[t3][3] !== void 0 && i2[t3][4] === void 0)
          return x("InvalidAttr", "Attribute '" + i2[t3][2] + "' is without value.", E(i2[t3]));
        if (i2[t3][3] === void 0 && !e2.allowBooleanAttributes)
          return x("InvalidAttr", "boolean attribute '" + i2[t3][2] + "' is not allowed.", E(i2[t3]));
        let s2 = i2[t3][2];
        if (!N(s2))
          return x("InvalidAttr", "Attribute '" + s2 + "' is an invalid name.", E(i2[t3]));
        if (n2.hasOwnProperty(s2))
          return x("InvalidAttr", "Attribute '" + s2 + "' is repeated.", E(i2[t3]));
        n2[s2] = 1;
      }
      return !0;
    }
    function m(t2, e2) {
      if (t2[++e2] === ";")
        return -1;
      if (t2[e2] === "#")
        return function(t3, e3) {
          let i3 = /\d/;
          for (t3[e3] === "x" && (e3++, i3 = /[\da-fA-F]/);e3 < t3.length; e3++) {
            if (t3[e3] === ";")
              return e3;
            if (!t3[e3].match(i3))
              break;
          }
          return -1;
        }(t2, ++e2);
      let i2 = 0;
      for (;e2 < t2.length; e2++, i2++)
        if (!(t2[e2].match(/\w/) && i2 < 20)) {
          if (t2[e2] === ";")
            break;
          return -1;
        }
      return e2;
    }
    function x(t2, e2, i2) {
      return { err: { code: t2, msg: e2, line: i2.line || i2, col: i2.col } };
    }
    function N(t2) {
      return r(t2);
    }
    function b(t2, e2) {
      let i2 = t2.substring(0, e2).split(/\r?\n/);
      return { line: i2.length, col: i2[i2.length - 1].length + 1 };
    }
    function E(t2) {
      return t2.startIndex + t2[1].length;
    }
    let v = { preserveOrder: !1, attributeNamePrefix: "@_", attributesGroupName: !1, textNodeName: "#text", ignoreAttributes: !0, removeNSPrefix: !1, allowBooleanAttributes: !1, parseTagValue: !0, parseAttributeValue: !1, trimValues: !0, cdataPropName: !1, numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 }, tagValueProcessor: function(t2, e2) {
      return e2;
    }, attributeValueProcessor: function(t2, e2) {
      return e2;
    }, stopNodes: [], alwaysCreateTextNode: !1, isArray: () => !1, commentPropName: !1, unpairedTags: [], processEntities: !0, htmlEntities: !1, ignoreDeclaration: !1, ignorePiTags: !1, transformTagName: !1, transformAttributeName: !1, updateTag: function(t2, e2, i2) {
      return t2;
    }, captureMetaData: !1 }, T;
    T = typeof Symbol != "function" ? "@@xmlMetadata" : Symbol("XML Node Metadata");

    class y {
      constructor(t2) {
        this.tagname = t2, this.child = [], this[":@"] = {};
      }
      add(t2, e2) {
        t2 === "__proto__" && (t2 = "#__proto__"), this.child.push({ [t2]: e2 });
      }
      addChild(t2, e2) {
        t2.tagname === "__proto__" && (t2.tagname = "#__proto__"), t2[":@"] && Object.keys(t2[":@"]).length > 0 ? this.child.push({ [t2.tagname]: t2.child, ":@": t2[":@"] }) : this.child.push({ [t2.tagname]: t2.child }), e2 !== void 0 && (this.child[this.child.length - 1][T] = { startIndex: e2 });
      }
      static getMetaDataSymbol() {
        return T;
      }
    }

    class w {
      constructor(t2) {
        this.suppressValidationErr = !t2;
      }
      readDocType(t2, e2) {
        let i2 = {};
        if (t2[e2 + 3] !== "O" || t2[e2 + 4] !== "C" || t2[e2 + 5] !== "T" || t2[e2 + 6] !== "Y" || t2[e2 + 7] !== "P" || t2[e2 + 8] !== "E")
          throw Error("Invalid Tag instead of DOCTYPE");
        {
          e2 += 9;
          let n2 = 1, s2 = !1, r2 = !1, o2 = "";
          for (;e2 < t2.length; e2++)
            if (t2[e2] !== "<" || r2)
              if (t2[e2] === ">") {
                if (r2 ? t2[e2 - 1] === "-" && t2[e2 - 2] === "-" && (r2 = !1, n2--) : n2--, n2 === 0)
                  break;
              } else
                t2[e2] === "[" ? s2 = !0 : o2 += t2[e2];
            else {
              if (s2 && P(t2, "!ENTITY", e2)) {
                let n3, s3;
                e2 += 7, [n3, s3, e2] = this.readEntityExp(t2, e2 + 1, this.suppressValidationErr), s3.indexOf("&") === -1 && (i2[n3] = { regx: RegExp(`&${n3};`, "g"), val: s3 });
              } else if (s2 && P(t2, "!ELEMENT", e2)) {
                e2 += 8;
                let { index: i3 } = this.readElementExp(t2, e2 + 1);
                e2 = i3;
              } else if (s2 && P(t2, "!ATTLIST", e2))
                e2 += 8;
              else if (s2 && P(t2, "!NOTATION", e2)) {
                e2 += 9;
                let { index: i3 } = this.readNotationExp(t2, e2 + 1, this.suppressValidationErr);
                e2 = i3;
              } else {
                if (!P(t2, "!--", e2))
                  throw Error("Invalid DOCTYPE");
                r2 = !0;
              }
              n2++, o2 = "";
            }
          if (n2 !== 0)
            throw Error("Unclosed DOCTYPE");
        }
        return { entities: i2, i: e2 };
      }
      readEntityExp(t2, e2) {
        e2 = I(t2, e2);
        let i2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]) && t2[e2] !== '"' && t2[e2] !== "'"; )
          i2 += t2[e2], e2++;
        if (O(i2), e2 = I(t2, e2), !this.suppressValidationErr) {
          if (t2.substring(e2, e2 + 6).toUpperCase() === "SYSTEM")
            throw Error("External entities are not supported");
          if (t2[e2] === "%")
            throw Error("Parameter entities are not supported");
        }
        let n2 = "";
        return [e2, n2] = this.readIdentifierVal(t2, e2, "entity"), [i2, n2, --e2];
      }
      readNotationExp(t2, e2) {
        e2 = I(t2, e2);
        let i2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          i2 += t2[e2], e2++;
        !this.suppressValidationErr && O(i2), e2 = I(t2, e2);
        let n2 = t2.substring(e2, e2 + 6).toUpperCase();
        if (!this.suppressValidationErr && n2 !== "SYSTEM" && n2 !== "PUBLIC")
          throw Error(`Expected SYSTEM or PUBLIC, found "${n2}"`);
        e2 += n2.length, e2 = I(t2, e2);
        let s2 = null, r2 = null;
        if (n2 === "PUBLIC")
          [e2, s2] = this.readIdentifierVal(t2, e2, "publicIdentifier"), t2[e2 = I(t2, e2)] !== '"' && t2[e2] !== "'" || ([e2, r2] = this.readIdentifierVal(t2, e2, "systemIdentifier"));
        else if (n2 === "SYSTEM" && ([e2, r2] = this.readIdentifierVal(t2, e2, "systemIdentifier"), !this.suppressValidationErr && !r2))
          throw Error("Missing mandatory system identifier for SYSTEM notation");
        return { notationName: i2, publicIdentifier: s2, systemIdentifier: r2, index: --e2 };
      }
      readIdentifierVal(t2, e2, i2) {
        let n2 = "", s2 = t2[e2];
        if (s2 !== '"' && s2 !== "'")
          throw Error(`Expected quoted string, found "${s2}"`);
        for (e2++;e2 < t2.length && t2[e2] !== s2; )
          n2 += t2[e2], e2++;
        if (t2[e2] !== s2)
          throw Error(`Unterminated ${i2} value`);
        return [++e2, n2];
      }
      readElementExp(t2, e2) {
        e2 = I(t2, e2);
        let i2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          i2 += t2[e2], e2++;
        if (!this.suppressValidationErr && !r(i2))
          throw Error(`Invalid element name: "${i2}"`);
        let n2 = "";
        if (t2[e2 = I(t2, e2)] === "E" && P(t2, "MPTY", e2))
          e2 += 4;
        else if (t2[e2] === "A" && P(t2, "NY", e2))
          e2 += 2;
        else if (t2[e2] === "(") {
          for (e2++;e2 < t2.length && t2[e2] !== ")"; )
            n2 += t2[e2], e2++;
          if (t2[e2] !== ")")
            throw Error("Unterminated content model");
        } else if (!this.suppressValidationErr)
          throw Error(`Invalid Element Expression, found "${t2[e2]}"`);
        return { elementName: i2, contentModel: n2.trim(), index: e2 };
      }
      readAttlistExp(t2, e2) {
        e2 = I(t2, e2);
        let i2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          i2 += t2[e2], e2++;
        O(i2), e2 = I(t2, e2);
        let n2 = "";
        for (;e2 < t2.length && !/\s/.test(t2[e2]); )
          n2 += t2[e2], e2++;
        if (!O(n2))
          throw Error(`Invalid attribute name: "${n2}"`);
        e2 = I(t2, e2);
        let s2 = "";
        if (t2.substring(e2, e2 + 8).toUpperCase() === "NOTATION") {
          if (s2 = "NOTATION", t2[e2 = I(t2, e2 += 8)] !== "(")
            throw Error(`Expected '(', found "${t2[e2]}"`);
          e2++;
          let i3 = [];
          for (;e2 < t2.length && t2[e2] !== ")"; ) {
            let n3 = "";
            for (;e2 < t2.length && t2[e2] !== "|" && t2[e2] !== ")"; )
              n3 += t2[e2], e2++;
            if (n3 = n3.trim(), !O(n3))
              throw Error(`Invalid notation name: "${n3}"`);
            i3.push(n3), t2[e2] === "|" && (e2++, e2 = I(t2, e2));
          }
          if (t2[e2] !== ")")
            throw Error("Unterminated list of notations");
          e2++, s2 += " (" + i3.join("|") + ")";
        } else {
          for (;e2 < t2.length && !/\s/.test(t2[e2]); )
            s2 += t2[e2], e2++;
          let i3 = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
          if (!this.suppressValidationErr && !i3.includes(s2.toUpperCase()))
            throw Error(`Invalid attribute type: "${s2}"`);
        }
        e2 = I(t2, e2);
        let r2 = "";
        return t2.substring(e2, e2 + 8).toUpperCase() === "#REQUIRED" ? (r2 = "#REQUIRED", e2 += 8) : t2.substring(e2, e2 + 7).toUpperCase() === "#IMPLIED" ? (r2 = "#IMPLIED", e2 += 7) : [e2, r2] = this.readIdentifierVal(t2, e2, "ATTLIST"), { elementName: i2, attributeName: n2, attributeType: s2, defaultValue: r2, index: e2 };
      }
    }
    let I = (t2, e2) => {
      for (;e2 < t2.length && /\s/.test(t2[e2]); )
        e2++;
      return e2;
    };
    function P(t2, e2, i2) {
      for (let n2 = 0;n2 < e2.length; n2++)
        if (e2[n2] !== t2[i2 + n2 + 1])
          return !1;
      return !0;
    }
    function O(t2) {
      if (r(t2))
        return t2;
      throw Error(`Invalid entity name ${t2}`);
    }
    let A = /^[-+]?0x[a-fA-F0-9]+$/, S = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, C = { hex: !0, leadingZeros: !0, decimalPoint: ".", eNotation: !0 }, V = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
    function $(t2) {
      return typeof t2 == "function" ? t2 : Array.isArray(t2) ? (e2) => {
        for (let i2 of t2) {
          if (typeof i2 == "string" && e2 === i2)
            return !0;
          if (i2 instanceof RegExp && i2.test(e2))
            return !0;
        }
      } : () => !1;
    }

    class D {
      constructor(t2) {
        if (this.options = t2, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "" }, pound: { regex: /&(pound|#163);/g, val: "" }, yen: { regex: /&(yen|#165);/g, val: "" }, euro: { regex: /&(euro|#8364);/g, val: "" }, copyright: { regex: /&(copy|#169);/g, val: "" }, reg: { regex: /&(reg|#174);/g, val: "" }, inr: { regex: /&(inr|#8377);/g, val: "" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (t3, e2) => String.fromCodePoint(Number.parseInt(e2, 10)) }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t3, e2) => String.fromCodePoint(Number.parseInt(e2, 16)) } }, this.addExternalEntities = j, this.parseXml = L, this.parseTextData = M, this.resolveNameSpace = F, this.buildAttributesMap = k, this.isItStopNode = Y, this.replaceEntitiesValue = B, this.readStopNodeData = W, this.saveTextToParentTag = R, this.addChild = U, this.ignoreAttributesFn = $(this.options.ignoreAttributes), this.options.stopNodes && this.options.stopNodes.length > 0) {
          this.stopNodesExact = /* @__PURE__ */ new Set, this.stopNodesWildcard = /* @__PURE__ */ new Set;
          for (let t3 = 0;t3 < this.options.stopNodes.length; t3++) {
            let e2 = this.options.stopNodes[t3];
            typeof e2 == "string" && (e2.startsWith("*.") ? this.stopNodesWildcard.add(e2.substring(2)) : this.stopNodesExact.add(e2));
          }
        }
      }
    }
    function j(t2) {
      let e2 = Object.keys(t2);
      for (let i2 = 0;i2 < e2.length; i2++) {
        let n2 = e2[i2];
        this.lastEntities[n2] = { regex: new RegExp("&" + n2 + ";", "g"), val: t2[n2] };
      }
    }
    function M(t2, e2, i2, n2, s2, r2, o2) {
      if (t2 !== void 0 && (this.options.trimValues && !n2 && (t2 = t2.trim()), t2.length > 0)) {
        o2 || (t2 = this.replaceEntitiesValue(t2));
        let n3 = this.options.tagValueProcessor(e2, t2, i2, s2, r2);
        return n3 == null ? t2 : typeof n3 != typeof t2 || n3 !== t2 ? n3 : this.options.trimValues || t2.trim() === t2 ? q(t2, this.options.parseTagValue, this.options.numberParseOptions) : t2;
      }
    }
    function F(t2) {
      if (this.options.removeNSPrefix) {
        let e2 = t2.split(":"), i2 = t2.charAt(0) === "/" ? "/" : "";
        if (e2[0] === "xmlns")
          return "";
        e2.length === 2 && (t2 = i2 + e2[1]);
      }
      return t2;
    }
    let _2 = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function k(t2, e2) {
      if (this.options.ignoreAttributes !== !0 && typeof t2 == "string") {
        let i2 = s(t2, _2), n2 = i2.length, r2 = {};
        for (let t3 = 0;t3 < n2; t3++) {
          let n3 = this.resolveNameSpace(i2[t3][1]);
          if (this.ignoreAttributesFn(n3, e2))
            continue;
          let s2 = i2[t3][4], o2 = this.options.attributeNamePrefix + n3;
          if (n3.length)
            if (this.options.transformAttributeName && (o2 = this.options.transformAttributeName(o2)), o2 === "__proto__" && (o2 = "#__proto__"), s2 !== void 0) {
              this.options.trimValues && (s2 = s2.trim()), s2 = this.replaceEntitiesValue(s2);
              let t4 = this.options.attributeValueProcessor(n3, s2, e2);
              r2[o2] = t4 == null ? s2 : typeof t4 != typeof s2 || t4 !== s2 ? t4 : q(s2, this.options.parseAttributeValue, this.options.numberParseOptions);
            } else
              this.options.allowBooleanAttributes && (r2[o2] = !0);
        }
        if (!Object.keys(r2).length)
          return;
        if (this.options.attributesGroupName) {
          let t3 = {};
          return t3[this.options.attributesGroupName] = r2, t3;
        }
        return r2;
      }
    }
    let L = function(t2) {
      t2 = t2.replace(/\r\n?/g, `
`);
      let e2 = new y("!xml"), i2 = e2, n2 = "", s2 = "", r2 = new w(this.options.processEntities);
      for (let o2 = 0;o2 < t2.length; o2++)
        if (t2[o2] === "<")
          if (t2[o2 + 1] === "/") {
            let e3 = G(t2, ">", o2, "Closing Tag is not closed."), r3 = t2.substring(o2 + 2, e3).trim();
            if (this.options.removeNSPrefix) {
              let t3 = r3.indexOf(":");
              t3 !== -1 && (r3 = r3.substr(t3 + 1));
            }
            this.options.transformTagName && (r3 = this.options.transformTagName(r3)), i2 && (n2 = this.saveTextToParentTag(n2, i2, s2));
            let a2 = s2.substring(s2.lastIndexOf(".") + 1);
            if (r3 && this.options.unpairedTags.indexOf(r3) !== -1)
              throw Error(`Unpaired tag can not be used as closing tag: </${r3}>`);
            let l2 = 0;
            a2 && this.options.unpairedTags.indexOf(a2) !== -1 ? (l2 = s2.lastIndexOf(".", s2.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l2 = s2.lastIndexOf("."), s2 = s2.substring(0, l2), i2 = this.tagsNodeStack.pop(), n2 = "", o2 = e3;
          } else if (t2[o2 + 1] === "?") {
            let e3 = X(t2, o2, !1, "?>");
            if (!e3)
              throw Error("Pi Tag is not closed.");
            if (n2 = this.saveTextToParentTag(n2, i2, s2), this.options.ignoreDeclaration && e3.tagName === "?xml" || this.options.ignorePiTags)
              ;
            else {
              let t3 = new y(e3.tagName);
              t3.add(this.options.textNodeName, ""), e3.tagName !== e3.tagExp && e3.attrExpPresent && (t3[":@"] = this.buildAttributesMap(e3.tagExp, s2)), this.addChild(i2, t3, s2, o2);
            }
            o2 = e3.closeIndex + 1;
          } else if (t2.substr(o2 + 1, 3) === "!--") {
            let e3 = G(t2, "-->", o2 + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              let r3 = t2.substring(o2 + 4, e3 - 2);
              n2 = this.saveTextToParentTag(n2, i2, s2), i2.add(this.options.commentPropName, [{ [this.options.textNodeName]: r3 }]);
            }
            o2 = e3;
          } else if (t2.substr(o2 + 1, 2) === "!D") {
            let e3 = r2.readDocType(t2, o2);
            this.docTypeEntities = e3.entities, o2 = e3.i;
          } else if (t2.substr(o2 + 1, 2) === "![") {
            let e3 = G(t2, "]]>", o2, "CDATA is not closed.") - 2, r3 = t2.substring(o2 + 9, e3);
            n2 = this.saveTextToParentTag(n2, i2, s2);
            let a2 = this.parseTextData(r3, i2.tagname, s2, !0, !1, !0, !0);
            a2 == null && (a2 = ""), this.options.cdataPropName ? i2.add(this.options.cdataPropName, [{ [this.options.textNodeName]: r3 }]) : i2.add(this.options.textNodeName, a2), o2 = e3 + 2;
          } else {
            let r3 = X(t2, o2, this.options.removeNSPrefix), a2 = r3.tagName, l2 = r3.rawTagName, u2 = r3.tagExp, h2 = r3.attrExpPresent, d2 = r3.closeIndex;
            if (this.options.transformTagName) {
              let t3 = this.options.transformTagName(a2);
              u2 === a2 && (u2 = t3), a2 = t3;
            }
            i2 && n2 && i2.tagname !== "!xml" && (n2 = this.saveTextToParentTag(n2, i2, s2, !1));
            let p2 = i2;
            p2 && this.options.unpairedTags.indexOf(p2.tagname) !== -1 && (i2 = this.tagsNodeStack.pop(), s2 = s2.substring(0, s2.lastIndexOf("."))), a2 !== e2.tagname && (s2 += s2 ? "." + a2 : a2);
            let f2 = o2;
            if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, s2, a2)) {
              let e3 = "";
              if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1)
                a2[a2.length - 1] === "/" ? (a2 = a2.substr(0, a2.length - 1), s2 = s2.substr(0, s2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), o2 = r3.closeIndex;
              else if (this.options.unpairedTags.indexOf(a2) !== -1)
                o2 = r3.closeIndex;
              else {
                let i3 = this.readStopNodeData(t2, l2, d2 + 1);
                if (!i3)
                  throw Error(`Unexpected end of ${l2}`);
                o2 = i3.i, e3 = i3.tagContent;
              }
              let n3 = new y(a2);
              a2 !== u2 && h2 && (n3[":@"] = this.buildAttributesMap(u2, s2)), e3 && (e3 = this.parseTextData(e3, a2, s2, !0, h2, !0, !0)), s2 = s2.substr(0, s2.lastIndexOf(".")), n3.add(this.options.textNodeName, e3), this.addChild(i2, n3, s2, f2);
            } else {
              if (u2.length > 0 && u2.lastIndexOf("/") === u2.length - 1) {
                if (a2[a2.length - 1] === "/" ? (a2 = a2.substr(0, a2.length - 1), s2 = s2.substr(0, s2.length - 1), u2 = a2) : u2 = u2.substr(0, u2.length - 1), this.options.transformTagName) {
                  let t4 = this.options.transformTagName(a2);
                  u2 === a2 && (u2 = t4), a2 = t4;
                }
                let t3 = new y(a2);
                a2 !== u2 && h2 && (t3[":@"] = this.buildAttributesMap(u2, s2)), this.addChild(i2, t3, s2, f2), s2 = s2.substr(0, s2.lastIndexOf("."));
              } else {
                let t3 = new y(a2);
                this.tagsNodeStack.push(i2), a2 !== u2 && h2 && (t3[":@"] = this.buildAttributesMap(u2, s2)), this.addChild(i2, t3, s2, f2), i2 = t3;
              }
              n2 = "", o2 = d2;
            }
          }
        else
          n2 += t2[o2];
      return e2.child;
    };
    function U(t2, e2, i2, n2) {
      this.options.captureMetaData || (n2 = void 0);
      let s2 = this.options.updateTag(e2.tagname, i2, e2[":@"]);
      s2 === !1 || (typeof s2 == "string" ? (e2.tagname = s2, t2.addChild(e2, n2)) : t2.addChild(e2, n2));
    }
    let B = function(t2) {
      if (this.options.processEntities) {
        for (let e2 in this.docTypeEntities) {
          let i2 = this.docTypeEntities[e2];
          t2 = t2.replace(i2.regx, i2.val);
        }
        for (let e2 in this.lastEntities) {
          let i2 = this.lastEntities[e2];
          t2 = t2.replace(i2.regex, i2.val);
        }
        if (this.options.htmlEntities)
          for (let e2 in this.htmlEntities) {
            let i2 = this.htmlEntities[e2];
            t2 = t2.replace(i2.regex, i2.val);
          }
        t2 = t2.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return t2;
    };
    function R(t2, e2, i2, n2) {
      return t2 && (n2 === void 0 && (n2 = e2.child.length === 0), (t2 = this.parseTextData(t2, e2.tagname, i2, !1, !!e2[":@"] && Object.keys(e2[":@"]).length !== 0, n2)) !== void 0 && t2 !== "" && e2.add(this.options.textNodeName, t2), t2 = ""), t2;
    }
    function Y(t2, e2, i2, n2) {
      return !(!e2 || !e2.has(n2)) || !(!t2 || !t2.has(i2));
    }
    function G(t2, e2, i2, n2) {
      let s2 = t2.indexOf(e2, i2);
      if (s2 === -1)
        throw Error(n2);
      return s2 + e2.length - 1;
    }
    function X(t2, e2, i2, n2 = ">") {
      let s2 = function(t3, e3, i3 = ">") {
        let n3, s3 = "";
        for (let r3 = e3;r3 < t3.length; r3++) {
          let e4 = t3[r3];
          if (n3)
            e4 === n3 && (n3 = "");
          else if (e4 === '"' || e4 === "'")
            n3 = e4;
          else if (e4 === i3[0]) {
            if (!i3[1])
              return { data: s3, index: r3 };
            if (t3[r3 + 1] === i3[1])
              return { data: s3, index: r3 };
          } else
            e4 === "\t" && (e4 = " ");
          s3 += e4;
        }
      }(t2, e2 + 1, n2);
      if (!s2)
        return;
      let { data: r2, index: o2 } = s2, a2 = r2.search(/\s/), l2 = r2, u2 = !0;
      a2 !== -1 && (l2 = r2.substring(0, a2), r2 = r2.substring(a2 + 1).trimStart());
      let h2 = l2;
      if (i2) {
        let t3 = l2.indexOf(":");
        t3 !== -1 && (l2 = l2.substr(t3 + 1), u2 = l2 !== s2.data.substr(t3 + 1));
      }
      return { tagName: l2, tagExp: r2, closeIndex: o2, attrExpPresent: u2, rawTagName: h2 };
    }
    function W(t2, e2, i2) {
      let n2 = i2, s2 = 1;
      for (;i2 < t2.length; i2++)
        if (t2[i2] === "<")
          if (t2[i2 + 1] === "/") {
            let r2 = G(t2, ">", i2, `${e2} is not closed`);
            if (t2.substring(i2 + 2, r2).trim() === e2 && (s2--, s2 === 0))
              return { tagContent: t2.substring(n2, i2), i: r2 };
            i2 = r2;
          } else if (t2[i2 + 1] === "?")
            i2 = G(t2, "?>", i2 + 1, "StopNode is not closed.");
          else if (t2.substr(i2 + 1, 3) === "!--")
            i2 = G(t2, "-->", i2 + 3, "StopNode is not closed.");
          else if (t2.substr(i2 + 1, 2) === "![")
            i2 = G(t2, "]]>", i2, "StopNode is not closed.") - 2;
          else {
            let n3 = X(t2, i2, ">");
            n3 && ((n3 && n3.tagName) === e2 && n3.tagExp[n3.tagExp.length - 1] !== "/" && s2++, i2 = n3.closeIndex);
          }
    }
    function q(t2, e2, i2) {
      if (e2 && typeof t2 == "string") {
        let e3 = t2.trim();
        return e3 === "true" || e3 !== "false" && function(t3, e4 = {}) {
          if (e4 = Object.assign({}, C, e4), !t3 || typeof t3 != "string")
            return t3;
          let i3 = t3.trim();
          if (e4.skipLike !== void 0 && e4.skipLike.test(i3))
            return t3;
          if (t3 === "0")
            return 0;
          if (e4.hex && A.test(i3))
            return function(t4) {
              if (parseInt)
                return parseInt(t4, 16);
              if (Number.parseInt)
                return Number.parseInt(t4, 16);
              if (window && window.parseInt)
                return window.parseInt(t4, 16);
              throw Error("parseInt, Number.parseInt, window.parseInt are not supported");
            }(i3);
          if (i3.search(/.+[eE].+/) !== -1)
            return function(t4, e5, i4) {
              if (!i4.eNotation)
                return t4;
              let n3 = e5.match(V);
              if (n3) {
                let s2 = n3[1] || "", r2 = n3[3].indexOf("e") === -1 ? "E" : "e", o2 = n3[2], a2 = s2 ? t4[o2.length + 1] === r2 : t4[o2.length] === r2;
                return o2.length > 1 && a2 ? t4 : o2.length !== 1 || !n3[3].startsWith(`.${r2}`) && n3[3][0] !== r2 ? i4.leadingZeros && !a2 ? (e5 = (n3[1] || "") + n3[3], Number(e5)) : t4 : Number(e5);
              }
              return t4;
            }(t3, i3, e4);
          {
            let s2 = S.exec(i3);
            if (s2) {
              let r2 = s2[1] || "", o2 = s2[2], a2 = (n2 = s2[3]) && n2.indexOf(".") !== -1 ? ((n2 = n2.replace(/0+$/, "")) === "." ? n2 = "0" : n2[0] === "." ? n2 = "0" + n2 : n2[n2.length - 1] === "." && (n2 = n2.substring(0, n2.length - 1)), n2) : n2, l2 = r2 ? t3[o2.length + 1] === "." : t3[o2.length] === ".";
              if (!e4.leadingZeros && (o2.length > 1 || o2.length === 1 && !l2))
                return t3;
              {
                let n3 = Number(i3), s3 = String(n3);
                if (n3 === 0 || n3 === -0)
                  return n3;
                if (s3.search(/[eE]/) !== -1)
                  return e4.eNotation ? n3 : t3;
                if (i3.indexOf(".") !== -1)
                  return s3 === "0" || s3 === a2 || s3 === `${r2}${a2}` ? n3 : t3;
                let l3 = o2 ? a2 : i3;
                return o2 ? l3 === s3 || r2 + l3 === s3 ? n3 : t3 : l3 === s3 || l3 === r2 + s3 ? n3 : t3;
              }
            }
            return t3;
          }
          var n2;
        }(t2, i2);
      }
      return t2 !== void 0 ? t2 : "";
    }
    let Z = y.getMetaDataSymbol();
    function K(t2, e2) {
      return Q(t2, e2);
    }
    function Q(t2, e2, i2) {
      let n2, s2 = {};
      for (let r2 = 0;r2 < t2.length; r2++) {
        let o2 = t2[r2], a2 = z(o2), l2 = "";
        if (l2 = i2 === void 0 ? a2 : i2 + "." + a2, a2 === e2.textNodeName)
          n2 === void 0 ? n2 = o2[a2] : n2 += "" + o2[a2];
        else {
          if (a2 === void 0)
            continue;
          if (o2[a2]) {
            let t3 = Q(o2[a2], e2, l2), i3 = H(t3, e2);
            o2[Z] !== void 0 && (t3[Z] = o2[Z]), o2[":@"] ? J(t3, o2[":@"], l2, e2) : Object.keys(t3).length !== 1 || t3[e2.textNodeName] === void 0 || e2.alwaysCreateTextNode ? Object.keys(t3).length === 0 && (e2.alwaysCreateTextNode ? t3[e2.textNodeName] = "" : t3 = "") : t3 = t3[e2.textNodeName], s2[a2] !== void 0 && s2.hasOwnProperty(a2) ? (Array.isArray(s2[a2]) || (s2[a2] = [s2[a2]]), s2[a2].push(t3)) : e2.isArray(a2, l2, i3) ? s2[a2] = [t3] : s2[a2] = t3;
          }
        }
      }
      return typeof n2 == "string" ? n2.length > 0 && (s2[e2.textNodeName] = n2) : n2 !== void 0 && (s2[e2.textNodeName] = n2), s2;
    }
    function z(t2) {
      let e2 = Object.keys(t2);
      for (let t3 = 0;t3 < e2.length; t3++) {
        let i2 = e2[t3];
        if (i2 !== ":@")
          return i2;
      }
    }
    function J(t2, e2, i2, n2) {
      if (e2) {
        let s2 = Object.keys(e2), r2 = s2.length;
        for (let o2 = 0;o2 < r2; o2++) {
          let r3 = s2[o2];
          n2.isArray(r3, i2 + "." + r3, !0, !0) ? t2[r3] = [e2[r3]] : t2[r3] = e2[r3];
        }
      }
    }
    function H(t2, e2) {
      let { textNodeName: i2 } = e2, n2 = Object.keys(t2).length;
      return n2 === 0 || !(n2 !== 1 || !t2[i2] && typeof t2[i2] != "boolean" && t2[i2] !== 0);
    }

    class tt {
      constructor(t2) {
        this.externalEntities = {}, this.options = function(t3) {
          return Object.assign({}, v, t3);
        }(t2);
      }
      parse(t2, e2) {
        if (typeof t2 != "string" && t2.toString)
          t2 = t2.toString();
        else if (typeof t2 != "string")
          throw Error("XML data is accepted in String or Bytes[] form.");
        if (e2) {
          e2 === !0 && (e2 = {});
          let i3 = a(t2, e2);
          if (i3 !== !0)
            throw Error(`${i3.err.msg}:${i3.err.line}:${i3.err.col}`);
        }
        let i2 = new D(this.options);
        i2.addExternalEntities(this.externalEntities);
        let n2 = i2.parseXml(t2);
        return this.options.preserveOrder || n2 === void 0 ? n2 : K(n2, this.options);
      }
      addEntity(t2, e2) {
        if (e2.indexOf("&") !== -1)
          throw Error("Entity value can't have '&'");
        if (t2.indexOf("&") !== -1 || t2.indexOf(";") !== -1)
          throw Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        if (e2 === "&")
          throw Error("An entity with value '&' is not permitted");
        this.externalEntities[t2] = e2;
      }
      static getMetaDataSymbol() {
        return y.getMetaDataSymbol();
      }
    }
    function et(t2, e2) {
      let i2 = "";
      return e2.format && e2.indentBy.length > 0 && (i2 = `
`), it(t2, e2, "", i2);
    }
    function it(t2, e2, i2, n2) {
      let s2 = "", r2 = !1;
      for (let o2 = 0;o2 < t2.length; o2++) {
        let a2 = t2[o2], l2 = nt(a2);
        if (l2 === void 0)
          continue;
        let u2 = "";
        if (u2 = i2.length === 0 ? l2 : `${i2}.${l2}`, l2 === e2.textNodeName) {
          let t3 = a2[l2];
          rt(u2, e2) || (t3 = e2.tagValueProcessor(l2, t3), t3 = ot(t3, e2)), r2 && (s2 += n2), s2 += t3, r2 = !1;
          continue;
        }
        if (l2 === e2.cdataPropName) {
          r2 && (s2 += n2), s2 += `<![CDATA[${a2[l2][0][e2.textNodeName]}]]>`, r2 = !1;
          continue;
        }
        if (l2 === e2.commentPropName) {
          s2 += n2 + `<!--${a2[l2][0][e2.textNodeName]}-->`, r2 = !0;
          continue;
        }
        if (l2[0] === "?") {
          let t3 = st(a2[":@"], e2), i3 = l2 === "?xml" ? "" : n2, o3 = a2[l2][0][e2.textNodeName];
          o3 = o3.length !== 0 ? " " + o3 : "", s2 += i3 + `<${l2}${o3}${t3}?>`, r2 = !0;
          continue;
        }
        let h2 = n2;
        h2 !== "" && (h2 += e2.indentBy);
        let d2 = n2 + `<${l2}${st(a2[":@"], e2)}`, p2 = it(a2[l2], e2, u2, h2);
        e2.unpairedTags.indexOf(l2) !== -1 ? e2.suppressUnpairedNode ? s2 += d2 + ">" : s2 += d2 + "/>" : p2 && p2.length !== 0 || !e2.suppressEmptyNode ? p2 && p2.endsWith(">") ? s2 += d2 + `>${p2}${n2}</${l2}>` : (s2 += d2 + ">", p2 && n2 !== "" && (p2.includes("/>") || p2.includes("</")) ? s2 += n2 + e2.indentBy + p2 + n2 : s2 += p2, s2 += `</${l2}>`) : s2 += d2 + "/>", r2 = !0;
      }
      return s2;
    }
    function nt(t2) {
      let e2 = Object.keys(t2);
      for (let i2 = 0;i2 < e2.length; i2++) {
        let n2 = e2[i2];
        if (t2.hasOwnProperty(n2) && n2 !== ":@")
          return n2;
      }
    }
    function st(t2, e2) {
      let i2 = "";
      if (t2 && !e2.ignoreAttributes)
        for (let n2 in t2) {
          if (!t2.hasOwnProperty(n2))
            continue;
          let s2 = e2.attributeValueProcessor(n2, t2[n2]);
          s2 = ot(s2, e2), s2 === !0 && e2.suppressBooleanAttributes ? i2 += ` ${n2.substr(e2.attributeNamePrefix.length)}` : i2 += ` ${n2.substr(e2.attributeNamePrefix.length)}="${s2}"`;
        }
      return i2;
    }
    function rt(t2, e2) {
      let i2 = (t2 = t2.substr(0, t2.length - e2.textNodeName.length - 1)).substr(t2.lastIndexOf(".") + 1);
      for (let n2 in e2.stopNodes)
        if (e2.stopNodes[n2] === t2 || e2.stopNodes[n2] === "*." + i2)
          return !0;
      return !1;
    }
    function ot(t2, e2) {
      if (t2 && t2.length > 0 && e2.processEntities)
        for (let i2 = 0;i2 < e2.entities.length; i2++) {
          let n2 = e2.entities[i2];
          t2 = t2.replace(n2.regex, n2.val);
        }
      return t2;
    }
    let at = { attributeNamePrefix: "@_", attributesGroupName: !1, textNodeName: "#text", ignoreAttributes: !0, cdataPropName: !1, format: !1, indentBy: "  ", suppressEmptyNode: !1, suppressUnpairedNode: !0, suppressBooleanAttributes: !0, tagValueProcessor: function(t2, e2) {
      return e2;
    }, attributeValueProcessor: function(t2, e2) {
      return e2;
    }, preserveOrder: !1, commentPropName: !1, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: !0, stopNodes: [], oneListGroup: !1 };
    function lt(t2) {
      this.options = Object.assign({}, at, t2), this.options.ignoreAttributes === !0 || this.options.attributesGroupName ? this.isAttribute = function() {
        return !1;
      } : (this.ignoreAttributesFn = $(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = dt), this.processTextOrObjNode = ut, this.options.format ? (this.indentate = ht, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
        return "";
      }, this.tagEndChar = ">", this.newLine = "");
    }
    function ut(t2, e2, i2, n2) {
      let s2 = this.j2x(t2, i2 + 1, n2.concat(e2));
      return t2[this.options.textNodeName] !== void 0 && Object.keys(t2).length === 1 ? this.buildTextValNode(t2[this.options.textNodeName], e2, s2.attrStr, i2) : this.buildObjectNode(s2.val, e2, s2.attrStr, i2);
    }
    function ht(t2) {
      return this.options.indentBy.repeat(t2);
    }
    function dt(t2) {
      return !(!t2.startsWith(this.options.attributeNamePrefix) || t2 === this.options.textNodeName) && t2.substr(this.attrPrefixLen);
    }
    lt.prototype.build = function(t2) {
      return this.options.preserveOrder ? et(t2, this.options) : (Array.isArray(t2) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t2 = { [this.options.arrayNodeName]: t2 }), this.j2x(t2, 0, []).val);
    }, lt.prototype.j2x = function(t2, e2, i2) {
      let n2 = "", s2 = "", r2 = i2.join(".");
      for (let o2 in t2)
        if (Object.prototype.hasOwnProperty.call(t2, o2))
          if (t2[o2] === void 0)
            this.isAttribute(o2) && (s2 += "");
          else if (t2[o2] === null)
            this.isAttribute(o2) || o2 === this.options.cdataPropName ? s2 += "" : o2[0] === "?" ? s2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
          else if (t2[o2] instanceof Date)
            s2 += this.buildTextValNode(t2[o2], o2, "", e2);
          else if (typeof t2[o2] != "object") {
            let i3 = this.isAttribute(o2);
            if (i3 && !this.ignoreAttributesFn(i3, r2))
              n2 += this.buildAttrPairStr(i3, "" + t2[o2]);
            else if (!i3)
              if (o2 === this.options.textNodeName) {
                let e3 = this.options.tagValueProcessor(o2, "" + t2[o2]);
                s2 += this.replaceEntitiesValue(e3);
              } else
                s2 += this.buildTextValNode(t2[o2], o2, "", e2);
          } else if (Array.isArray(t2[o2])) {
            let n3 = t2[o2].length, r3 = "", a2 = "";
            for (let l2 = 0;l2 < n3; l2++) {
              let n4 = t2[o2][l2];
              if (n4 === void 0)
                ;
              else if (n4 === null)
                o2[0] === "?" ? s2 += this.indentate(e2) + "<" + o2 + "?" + this.tagEndChar : s2 += this.indentate(e2) + "<" + o2 + "/" + this.tagEndChar;
              else if (typeof n4 == "object")
                if (this.options.oneListGroup) {
                  let t3 = this.j2x(n4, e2 + 1, i2.concat(o2));
                  r3 += t3.val, this.options.attributesGroupName && n4.hasOwnProperty(this.options.attributesGroupName) && (a2 += t3.attrStr);
                } else
                  r3 += this.processTextOrObjNode(n4, o2, e2, i2);
              else if (this.options.oneListGroup) {
                let t3 = this.options.tagValueProcessor(o2, n4);
                t3 = this.replaceEntitiesValue(t3), r3 += t3;
              } else
                r3 += this.buildTextValNode(n4, o2, "", e2);
            }
            this.options.oneListGroup && (r3 = this.buildObjectNode(r3, o2, a2, e2)), s2 += r3;
          } else if (this.options.attributesGroupName && o2 === this.options.attributesGroupName) {
            let e3 = Object.keys(t2[o2]), i3 = e3.length;
            for (let s3 = 0;s3 < i3; s3++)
              n2 += this.buildAttrPairStr(e3[s3], "" + t2[o2][e3[s3]]);
          } else
            s2 += this.processTextOrObjNode(t2[o2], o2, e2, i2);
      return { attrStr: n2, val: s2 };
    }, lt.prototype.buildAttrPairStr = function(t2, e2) {
      return e2 = this.options.attributeValueProcessor(t2, "" + e2), e2 = this.replaceEntitiesValue(e2), this.options.suppressBooleanAttributes && e2 === "true" ? " " + t2 : " " + t2 + '="' + e2 + '"';
    }, lt.prototype.buildObjectNode = function(t2, e2, i2, n2) {
      if (t2 === "")
        return e2[0] === "?" ? this.indentate(n2) + "<" + e2 + i2 + "?" + this.tagEndChar : this.indentate(n2) + "<" + e2 + i2 + this.closeTag(e2) + this.tagEndChar;
      {
        let s2 = "</" + e2 + this.tagEndChar, r2 = "";
        return e2[0] === "?" && (r2 = "?", s2 = ""), !i2 && i2 !== "" || t2.indexOf("<") !== -1 ? this.options.commentPropName !== !1 && e2 === this.options.commentPropName && r2.length === 0 ? this.indentate(n2) + `<!--${t2}-->` + this.newLine : this.indentate(n2) + "<" + e2 + i2 + r2 + this.tagEndChar + t2 + this.indentate(n2) + s2 : this.indentate(n2) + "<" + e2 + i2 + r2 + ">" + t2 + s2;
      }
    }, lt.prototype.closeTag = function(t2) {
      let e2 = "";
      return this.options.unpairedTags.indexOf(t2) !== -1 ? this.options.suppressUnpairedNode || (e2 = "/") : e2 = this.options.suppressEmptyNode ? "/" : `></${t2}`, e2;
    }, lt.prototype.buildTextValNode = function(t2, e2, i2, n2) {
      if (this.options.cdataPropName !== !1 && e2 === this.options.cdataPropName)
        return this.indentate(n2) + `<![CDATA[${t2}]]>` + this.newLine;
      if (this.options.commentPropName !== !1 && e2 === this.options.commentPropName)
        return this.indentate(n2) + `<!--${t2}-->` + this.newLine;
      if (e2[0] === "?")
        return this.indentate(n2) + "<" + e2 + i2 + "?" + this.tagEndChar;
      {
        let s2 = this.options.tagValueProcessor(e2, t2);
        return s2 = this.replaceEntitiesValue(s2), s2 === "" ? this.indentate(n2) + "<" + e2 + i2 + this.closeTag(e2) + this.tagEndChar : this.indentate(n2) + "<" + e2 + i2 + ">" + s2 + "</" + e2 + this.tagEndChar;
      }
    }, lt.prototype.replaceEntitiesValue = function(t2) {
      if (t2 && t2.length > 0 && this.options.processEntities)
        for (let e2 = 0;e2 < this.options.entities.length; e2++) {
          let i2 = this.options.entities[e2];
          t2 = t2.replace(i2.regex, i2.val);
        }
      return t2;
    };
    let pt = { validate: a };
    module.exports = e;
  })();
});

// node_modules/@azure/core-xml/dist/commonjs/xml.common.js
var require_xml_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = void 0;
  exports.XML_ATTRKEY = "$";
  exports.XML_CHARKEY = "_";
});

// node_modules/@azure/core-xml/dist/commonjs/xml.js
var require_xml = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.stringifyXML = stringifyXML;
  exports.parseXML = parseXML;
  var fast_xml_parser_1 = require_fxp(), xml_common_js_1 = require_xml_common();
  function getCommonOptions(options) {
    var _a;
    return {
      attributesGroupName: xml_common_js_1.XML_ATTRKEY,
      textNodeName: (_a = options.xmlCharKey) !== null && _a !== void 0 ? _a : xml_common_js_1.XML_CHARKEY,
      ignoreAttributes: !1,
      suppressBooleanAttributes: !1
    };
  }
  function getSerializerOptions(options = {}) {
    var _a, _b;
    return Object.assign(Object.assign({}, getCommonOptions(options)), { attributeNamePrefix: "@_", format: !0, suppressEmptyNode: !0, indentBy: "", rootNodeName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "root", cdataPropName: (_b = options.cdataPropName) !== null && _b !== void 0 ? _b : "__cdata" });
  }
  function getParserOptions(options = {}) {
    return Object.assign(Object.assign({}, getCommonOptions(options)), { parseAttributeValue: !1, parseTagValue: !1, attributeNamePrefix: "", stopNodes: options.stopNodes, processEntities: !0, trimValues: !1 });
  }
  function stringifyXML(obj, opts = {}) {
    let parserOptions = getSerializerOptions(opts), j2x = new fast_xml_parser_1.XMLBuilder(parserOptions), node = { [parserOptions.rootNodeName]: obj };
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${j2x.build(node)}`.replace(/\n/g, "");
  }
  async function parseXML(str, opts = {}) {
    if (!str)
      throw Error("Document is empty");
    let validation = fast_xml_parser_1.XMLValidator.validate(str);
    if (validation !== !0)
      throw validation;
    let parsedXml = new fast_xml_parser_1.XMLParser(getParserOptions(opts)).parse(str);
    if (parsedXml["?xml"])
      delete parsedXml["?xml"];
    if (!opts.includeRoot)
      for (let key of Object.keys(parsedXml)) {
        let value = parsedXml[key];
        return typeof value === "object" ? Object.assign({}, value) : value;
      }
    return parsedXml;
  }
});

// node_modules/@azure/core-xml/dist/commonjs/index.js
var require_commonjs14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.XML_CHARKEY = exports.XML_ATTRKEY = exports.parseXML = exports.stringifyXML = void 0;
  var xml_js_1 = require_xml();
  Object.defineProperty(exports, "stringifyXML", { enumerable: !0, get: function() {
    return xml_js_1.stringifyXML;
  } });
  Object.defineProperty(exports, "parseXML", { enumerable: !0, get: function() {
    return xml_js_1.parseXML;
  } });
  var xml_common_js_1 = require_xml_common();
  Object.defineProperty(exports, "XML_ATTRKEY", { enumerable: !0, get: function() {
    return xml_common_js_1.XML_ATTRKEY;
  } });
  Object.defineProperty(exports, "XML_CHARKEY", { enumerable: !0, get: function() {
    return xml_common_js_1.XML_CHARKEY;
  } });
});

// node_modules/@azure/logger/node_modules/tslib/tslib.js
var require_tslib2 = __commonJS((exports, module) => {
  var __extends, __assign, __rest, __decorate, __param, __esDecorate, __runInitializers, __propKey, __setFunctionName, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet, __classPrivateFieldIn, __createBinding, __addDisposableResource, __disposeResources, __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd)
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    else if (typeof module === "object" && typeof exports === "object")
      factory(createExporter(root, createExporter(exports)));
    else
      factory(createExporter(root));
    function createExporter(exports2, previous) {
      if (exports2 !== root)
        if (typeof Object.create === "function")
          Object.defineProperty(exports2, "__esModule", { value: !0 });
        else
          exports2.__esModule = !0;
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    }, __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    }, __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++)
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
      }
      return t;
    }, __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }, __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    }, __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value", target = !descriptorIn && ctor ? contextIn.static ? ctor : ctor.prototype : null, descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {}), _2, done = !1;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw TypeError("Object expected");
          if (_2 = accept(result.get))
            descriptor.get = _2;
          if (_2 = accept(result.set))
            descriptor.set = _2;
          if (_2 = accept(result.init))
            initializers.unshift(_2);
        } else if (_2 = accept(result))
          if (kind === "field")
            initializers.unshift(_2);
          else
            descriptor[key] = _2;
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = !0;
    }, __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++)
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      return useValue ? value : void 0;
    }, __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    }, __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: !0, value: prefix ? "".concat(prefix, " ", name) : name });
    }, __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    }, __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __generator = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g.throw = verb(1), g.return = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _2.label++, { value: op[1], done: !1 };
              case 5:
                _2.label++, y = op[1], op = [0];
                continue;
              case 7:
                op = _2.ops.pop(), _2.trys.pop();
                continue;
              default:
                if ((t = _2.trys, !(t = t.length > 0 && t[t.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1], t = op;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2], _2.ops.push(op);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e) {
            op = [6, e], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: !0 };
      }
    }, __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    }, __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
        desc = { enumerable: !0, get: function() {
          return m[k];
        } };
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    }, __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i.return))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    }, __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    }, __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    }, __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) {
        for (var i = 0, l = from.length, ar;i < l; i++)
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }, __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }, __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          if (i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          }, f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    }, __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: !1 } : f ? f(v) : v;
        } : f;
      }
    }, __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    }, __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty)
        Object.defineProperty(cooked, "raw", { value: raw });
      else
        cooked.raw = raw;
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      return __setModuleDefault(result, mod), result;
    }, __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    }, __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }, __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    }, __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw TypeError("Symbol.dispose is not defined.");
          if (dispose = value[Symbol.dispose], async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async)
        env.stack.push({ async: !0 });
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e, env.hasError = !0;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop())
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  return fail(e), next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    }, __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path))
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      return path;
    }, exporter("__extends", __extends), exporter("__assign", __assign), exporter("__rest", __rest), exporter("__decorate", __decorate), exporter("__param", __param), exporter("__esDecorate", __esDecorate), exporter("__runInitializers", __runInitializers), exporter("__propKey", __propKey), exporter("__setFunctionName", __setFunctionName), exporter("__metadata", __metadata), exporter("__awaiter", __awaiter), exporter("__generator", __generator), exporter("__exportStar", __exportStar), exporter("__createBinding", __createBinding), exporter("__values", __values), exporter("__read", __read), exporter("__spread", __spread), exporter("__spreadArrays", __spreadArrays), exporter("__spreadArray", __spreadArray), exporter("__await", __await), exporter("__asyncGenerator", __asyncGenerator), exporter("__asyncDelegator", __asyncDelegator), exporter("__asyncValues", __asyncValues), exporter("__makeTemplateObject", __makeTemplateObject), exporter("__importStar", __importStar), exporter("__importDefault", __importDefault), exporter("__classPrivateFieldGet", __classPrivateFieldGet), exporter("__classPrivateFieldSet", __classPrivateFieldSet), exporter("__classPrivateFieldIn", __classPrivateFieldIn), exporter("__addDisposableResource", __addDisposableResource), exporter("__disposeResources", __disposeResources), exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/@azure/logger/dist/commonjs/log.js
var require_log5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.log = log;
  var tslib_1 = require_tslib2(), node_os_1 = __require("node:os"), node_util_1 = tslib_1.__importDefault(__require("node:util")), process2 = tslib_1.__importStar(__require("node:process"));
  function log(message, ...args) {
    process2.stderr.write(`${node_util_1.default.format(message, ...args)}${node_os_1.EOL}`);
  }
});

// node_modules/@azure/logger/dist/commonjs/debug.js
var require_debug2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var log_js_1 = require_log5(), debugEnvVariable = typeof process < "u" && process.env && process.env.DEBUG || void 0, enabledString, enabledNamespaces = [], skippedNamespaces = [], debuggers = [];
  if (debugEnvVariable)
    enable(debugEnvVariable);
  var debugObj = Object.assign((namespace) => {
    return createDebugger(namespace);
  }, {
    enable,
    enabled,
    disable,
    log: log_js_1.log
  });
  function enable(namespaces) {
    enabledString = namespaces, enabledNamespaces = [], skippedNamespaces = [];
    let wildcard = /\*/g, namespaceList = namespaces.split(",").map((ns) => ns.trim().replace(wildcard, ".*?"));
    for (let ns of namespaceList)
      if (ns.startsWith("-"))
        skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));
      else
        enabledNamespaces.push(new RegExp(`^${ns}$`));
    for (let instance of debuggers)
      instance.enabled = enabled(instance.namespace);
  }
  function enabled(namespace) {
    if (namespace.endsWith("*"))
      return !0;
    for (let skipped of skippedNamespaces)
      if (skipped.test(namespace))
        return !1;
    for (let enabledNamespace of enabledNamespaces)
      if (enabledNamespace.test(namespace))
        return !0;
    return !1;
  }
  function disable() {
    let result = enabledString || "";
    return enable(""), result;
  }
  function createDebugger(namespace) {
    let newDebugger = Object.assign(debug, {
      enabled: enabled(namespace),
      destroy,
      log: debugObj.log,
      namespace,
      extend
    });
    function debug(...args) {
      if (!newDebugger.enabled)
        return;
      if (args.length > 0)
        args[0] = `${namespace} ${args[0]}`;
      newDebugger.log(...args);
    }
    return debuggers.push(newDebugger), newDebugger;
  }
  function destroy() {
    let index = debuggers.indexOf(this);
    if (index >= 0)
      return debuggers.splice(index, 1), !0;
    return !1;
  }
  function extend(namespace) {
    let newDebugger = createDebugger(`${this.namespace}:${namespace}`);
    return newDebugger.log = this.log, newDebugger;
  }
  exports.default = debugObj;
});

// node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AzureLogger = void 0;
  exports.setLogLevel = setLogLevel;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger;
  var tslib_1 = require_tslib2(), debug_js_1 = tslib_1.__importDefault(require_debug2()), registeredLoggers = /* @__PURE__ */ new Set, logLevelFromEnv = typeof process < "u" && process.env && process.env.AZURE_LOG_LEVEL || void 0, azureLogLevel;
  exports.AzureLogger = (0, debug_js_1.default)("azure");
  exports.AzureLogger.log = (...args) => {
    debug_js_1.default.log(...args);
  };
  var AZURE_LOG_LEVELS = ["verbose", "info", "warning", "error"];
  if (logLevelFromEnv)
    if (isAzureLogLevel(logLevelFromEnv))
      setLogLevel(logLevelFromEnv);
    else
      console.error(`AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(", ")}.`);
  function setLogLevel(level) {
    if (level && !isAzureLogLevel(level))
      throw Error(`Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(",")}`);
    azureLogLevel = level;
    let enabledNamespaces = [];
    for (let logger of registeredLoggers)
      if (shouldEnable(logger))
        enabledNamespaces.push(logger.namespace);
    debug_js_1.default.enable(enabledNamespaces.join(","));
  }
  function getLogLevel() {
    return azureLogLevel;
  }
  var levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
  };
  function createClientLogger(namespace) {
    let clientRootLogger = exports.AzureLogger.extend(namespace);
    return patchLogMethod(exports.AzureLogger, clientRootLogger), {
      error: createLogger(clientRootLogger, "error"),
      warning: createLogger(clientRootLogger, "warning"),
      info: createLogger(clientRootLogger, "info"),
      verbose: createLogger(clientRootLogger, "verbose")
    };
  }
  function patchLogMethod(parent, child) {
    child.log = (...args) => {
      parent.log(...args);
    };
  }
  function createLogger(parent, level) {
    let logger = Object.assign(parent.extend(level), {
      level
    });
    if (patchLogMethod(parent, logger), shouldEnable(logger)) {
      let enabledNamespaces = debug_js_1.default.disable();
      debug_js_1.default.enable(enabledNamespaces + "," + logger.namespace);
    }
    return registeredLoggers.add(logger), logger;
  }
  function shouldEnable(logger) {
    return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);
  }
  function isAzureLogLevel(logLevel) {
    return AZURE_LOG_LEVELS.includes(logLevel);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/log.js
var require_log6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.logger = void 0;
  var logger_1 = require_commonjs15();
  exports.logger = (0, logger_1.createClientLogger)("storage-blob");
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/RequestPolicy.js
var require_RequestPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BaseRequestPolicy = void 0;

  class BaseRequestPolicy {
    _nextPolicy;
    _options;
    constructor(_nextPolicy, _options) {
      this._nextPolicy = _nextPolicy, this._options = _options;
    }
    shouldLog(logLevel) {
      return this._options.shouldLog(logLevel);
    }
    log(logLevel, message) {
      this._options.log(logLevel, message);
    }
  }
  exports.BaseRequestPolicy = BaseRequestPolicy;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/constants.js
var require_constants8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.PathStylePorts = exports.BlobDoesNotUseCustomerSpecifiedEncryption = exports.BlobUsesCustomerSpecifiedEncryptionMsg = exports.StorageBlobLoggingAllowedQueryParameters = exports.StorageBlobLoggingAllowedHeaderNames = exports.DevelopmentConnectionString = exports.EncryptionAlgorithmAES25 = exports.HTTP_VERSION_1_1 = exports.HTTP_LINE_ENDING = exports.BATCH_MAX_PAYLOAD_IN_BYTES = exports.BATCH_MAX_REQUEST = exports.SIZE_1_MB = exports.ETagAny = exports.ETagNone = exports.HeaderConstants = exports.HTTPURLConnection = exports.URLConstants = exports.StorageOAuthScopes = exports.REQUEST_TIMEOUT = exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = exports.BLOCK_BLOB_MAX_BLOCKS = exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = exports.SERVICE_VERSION = exports.SDK_VERSION = void 0;
  exports.SDK_VERSION = "12.29.1";
  exports.SERVICE_VERSION = "2025-11-05";
  exports.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 268435456;
  exports.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4194304000;
  exports.BLOCK_BLOB_MAX_BLOCKS = 50000;
  exports.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8388608;
  exports.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4194304;
  exports.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
  exports.REQUEST_TIMEOUT = 1e5;
  exports.StorageOAuthScopes = "https://storage.azure.com/.default";
  exports.URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SIGNATURE: "sig",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout"
    }
  };
  exports.HTTPURLConnection = {
    HTTP_ACCEPTED: 202,
    HTTP_CONFLICT: 409,
    HTTP_NOT_FOUND: 404,
    HTTP_PRECON_FAILED: 412,
    HTTP_RANGE_NOT_SATISFIABLE: 416
  };
  exports.HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
  };
  exports.ETagNone = "";
  exports.ETagAny = "*";
  exports.SIZE_1_MB = 1048576;
  exports.BATCH_MAX_REQUEST = 256;
  exports.BATCH_MAX_PAYLOAD_IN_BYTES = 4 * exports.SIZE_1_MB;
  exports.HTTP_LINE_ENDING = `\r
`;
  exports.HTTP_VERSION_1_1 = "HTTP/1.1";
  exports.EncryptionAlgorithmAES25 = "AES256";
  exports.DevelopmentConnectionString = "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;";
  exports.StorageBlobLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "x-ms-access-tier",
    "x-ms-access-tier-change-time",
    "x-ms-access-tier-inferred",
    "x-ms-account-kind",
    "x-ms-archive-status",
    "x-ms-blob-append-offset",
    "x-ms-blob-cache-control",
    "x-ms-blob-committed-block-count",
    "x-ms-blob-condition-appendpos",
    "x-ms-blob-condition-maxsize",
    "x-ms-blob-content-disposition",
    "x-ms-blob-content-encoding",
    "x-ms-blob-content-language",
    "x-ms-blob-content-length",
    "x-ms-blob-content-md5",
    "x-ms-blob-content-type",
    "x-ms-blob-public-access",
    "x-ms-blob-sequence-number",
    "x-ms-blob-type",
    "x-ms-copy-destination-snapshot",
    "x-ms-creation-time",
    "x-ms-default-encryption-scope",
    "x-ms-delete-snapshots",
    "x-ms-delete-type-permanent",
    "x-ms-deny-encryption-scope-override",
    "x-ms-encryption-algorithm",
    "x-ms-if-sequence-number-eq",
    "x-ms-if-sequence-number-le",
    "x-ms-if-sequence-number-lt",
    "x-ms-incremental-copy",
    "x-ms-lease-action",
    "x-ms-lease-break-period",
    "x-ms-lease-duration",
    "x-ms-lease-id",
    "x-ms-lease-time",
    "x-ms-page-write",
    "x-ms-proposed-lease-id",
    "x-ms-range-get-content-md5",
    "x-ms-rehydrate-priority",
    "x-ms-sequence-number-action",
    "x-ms-sku-name",
    "x-ms-source-content-md5",
    "x-ms-source-if-match",
    "x-ms-source-if-modified-since",
    "x-ms-source-if-none-match",
    "x-ms-source-if-unmodified-since",
    "x-ms-tag-count",
    "x-ms-encryption-key-sha256",
    "x-ms-copy-source-error-code",
    "x-ms-copy-source-status-code",
    "x-ms-if-tags",
    "x-ms-source-if-tags"
  ];
  exports.StorageBlobLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "include",
    "marker",
    "prefix",
    "copyid",
    "restype",
    "blockid",
    "blocklisttype",
    "delimiter",
    "prevsnapshot",
    "ske",
    "skoid",
    "sks",
    "skt",
    "sktid",
    "skv",
    "snapshot"
  ];
  exports.BlobUsesCustomerSpecifiedEncryptionMsg = "BlobUsesCustomerSpecifiedEncryption";
  exports.BlobDoesNotUseCustomerSpecifiedEncryption = "BlobDoesNotUseCustomerSpecifiedEncryption";
  exports.PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104"
  ];
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/utils.common.js
var require_utils_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.escapeURLPath = escapeURLPath;
  exports.getValueInConnString = getValueInConnString;
  exports.extractConnectionStringParts = extractConnectionStringParts;
  exports.appendToURLPath = appendToURLPath;
  exports.setURLParameter = setURLParameter;
  exports.getURLParameter = getURLParameter;
  exports.setURLHost = setURLHost;
  exports.getURLPath = getURLPath;
  exports.getURLScheme = getURLScheme;
  exports.getURLPathAndQuery = getURLPathAndQuery;
  exports.getURLQueries = getURLQueries;
  exports.appendToURLQuery = appendToURLQuery;
  exports.truncatedISO8061Date = truncatedISO8061Date;
  exports.base64encode = base64encode;
  exports.base64decode = base64decode;
  exports.generateBlockID = generateBlockID;
  exports.delay = delay;
  exports.padStart = padStart;
  exports.sanitizeURL = sanitizeURL;
  exports.sanitizeHeaders = sanitizeHeaders;
  exports.iEqual = iEqual;
  exports.getAccountNameFromUrl = getAccountNameFromUrl;
  exports.isIpEndpointStyle = isIpEndpointStyle;
  exports.toBlobTagsString = toBlobTagsString;
  exports.toBlobTags = toBlobTags;
  exports.toTags = toTags;
  exports.toQuerySerialization = toQuerySerialization;
  exports.parseObjectReplicationRecord = parseObjectReplicationRecord;
  exports.attachCredential = attachCredential;
  exports.httpAuthorizationToString = httpAuthorizationToString;
  exports.BlobNameToString = BlobNameToString;
  exports.ConvertInternalResponseOfListBlobFlat = ConvertInternalResponseOfListBlobFlat;
  exports.ConvertInternalResponseOfListBlobHierarchy = ConvertInternalResponseOfListBlobHierarchy;
  exports.ExtractPageRangeInfoItems = ExtractPageRangeInfoItems;
  exports.EscapePath = EscapePath;
  exports.assertResponse = assertResponse;
  var core_rest_pipeline_1 = require_commonjs8(), core_util_1 = require_commonjs9(), constants_js_1 = require_constants8();
  function escapeURLPath(url) {
    let urlParsed = new URL(url), path = urlParsed.pathname;
    return path = path || "/", path = escape(path), urlParsed.pathname = path, urlParsed.toString();
  }
  function getProxyUriFromDevConnString(connectionString) {
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
      let matchCredentials = connectionString.split(";");
      for (let element of matchCredentials)
        if (element.trim().startsWith("DevelopmentStorageProxyUri="))
          proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
    }
    return proxyUri;
  }
  function getValueInConnString(connectionString, argument) {
    let elements = connectionString.split(";");
    for (let element of elements)
      if (element.trim().startsWith(argument))
        return element.trim().match(argument + "=(.*)")[1];
    return "";
  }
  function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true"))
      proxyUri = getProxyUriFromDevConnString(connectionString), connectionString = constants_js_1.DevelopmentConnectionString;
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    if (blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint, connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
      let defaultEndpointsProtocol = "", accountName = "", accountKey = Buffer.from("accountKey", "base64"), endpointSuffix = "";
      if (accountName = getValueInConnString(connectionString, "AccountName"), accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64"), !blobEndpoint) {
        defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
        let protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http")
          throw Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        if (endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix"), !endpointSuffix)
          throw Error("Invalid EndpointSuffix in the provided Connection String");
        blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
      }
      if (!accountName)
        throw Error("Invalid AccountName in the provided Connection String");
      else if (accountKey.length === 0)
        throw Error("Invalid AccountKey in the provided Connection String");
      return {
        kind: "AccountConnString",
        url: blobEndpoint,
        accountName,
        accountKey,
        proxyUri
      };
    } else {
      let accountSas = getValueInConnString(connectionString, "SharedAccessSignature"), accountName = getValueInConnString(connectionString, "AccountName");
      if (!accountName)
        accountName = getAccountNameFromUrl(blobEndpoint);
      if (!blobEndpoint)
        throw Error("Invalid BlobEndpoint in the provided SAS Connection String");
      else if (!accountSas)
        throw Error("Invalid SharedAccessSignature in the provided SAS Connection String");
      if (accountSas.startsWith("?"))
        accountSas = accountSas.substring(1);
      return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
    }
  }
  function escape(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
  }
  function appendToURLPath(url, name) {
    let urlParsed = new URL(url), path = urlParsed.pathname;
    return path = path ? path.endsWith("/") ? `${path}${name}` : `${path}/${name}` : name, urlParsed.pathname = path, urlParsed.toString();
  }
  function setURLParameter(url, name, value) {
    let urlParsed = new URL(url), encodedName = encodeURIComponent(name), encodedValue = value ? encodeURIComponent(value) : void 0, searchString = urlParsed.search === "" ? "?" : urlParsed.search, searchPieces = [];
    for (let pair of searchString.slice(1).split("&"))
      if (pair) {
        let [key] = pair.split("=", 2);
        if (key !== encodedName)
          searchPieces.push(pair);
      }
    if (encodedValue)
      searchPieces.push(`${encodedName}=${encodedValue}`);
    return urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "", urlParsed.toString();
  }
  function getURLParameter(url, name) {
    return new URL(url).searchParams.get(name) ?? void 0;
  }
  function setURLHost(url, host) {
    let urlParsed = new URL(url);
    return urlParsed.hostname = host, urlParsed.toString();
  }
  function getURLPath(url) {
    try {
      return new URL(url).pathname;
    } catch (e) {
      return;
    }
  }
  function getURLScheme(url) {
    try {
      let urlParsed = new URL(url);
      return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e) {
      return;
    }
  }
  function getURLPathAndQuery(url) {
    let urlParsed = new URL(url), pathString = urlParsed.pathname;
    if (!pathString)
      throw RangeError("Invalid url without valid path.");
    let queryString = urlParsed.search || "";
    if (queryString = queryString.trim(), queryString !== "")
      queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
    return `${pathString}${queryString}`;
  }
  function getURLQueries(url) {
    let queryString = new URL(url).search;
    if (!queryString)
      return {};
    queryString = queryString.trim(), queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
      let indexOfEqual = value.indexOf("="), lastIndexOfEqual = value.lastIndexOf("=");
      return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    let queries = {};
    for (let querySubString of querySubStrings) {
      let splitResults = querySubString.split("="), key = splitResults[0], value = splitResults[1];
      queries[key] = value;
    }
    return queries;
  }
  function appendToURLQuery(url, queryParts) {
    let urlParsed = new URL(url), query = urlParsed.search;
    if (query)
      query += "&" + queryParts;
    else
      query = queryParts;
    return urlParsed.search = query, urlParsed.toString();
  }
  function truncatedISO8061Date(date, withMilliseconds = !0) {
    let dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
  }
  function base64encode(content) {
    return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
  }
  function base64decode(encodedString) {
    return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
  }
  function generateBlockID(blockIDPrefix, blockIndex) {
    if (blockIDPrefix.length > 42)
      blockIDPrefix = blockIDPrefix.slice(0, 42);
    let res = blockIDPrefix + padStart(blockIndex.toString(), 48 - blockIDPrefix.length, "0");
    return base64encode(res);
  }
  async function delay(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject) => {
      let timeout, abortHandler = () => {
        if (timeout !== void 0)
          clearTimeout(timeout);
        reject(abortError);
      };
      if (timeout = setTimeout(() => {
        if (aborter !== void 0)
          aborter.removeEventListener("abort", abortHandler);
        resolve();
      }, timeInMs), aborter !== void 0)
        aborter.addEventListener("abort", abortHandler);
    });
  }
  function padStart(currentString, targetLength, padString = " ") {
    if (String.prototype.padStart)
      return currentString.padStart(targetLength, padString);
    if (padString = padString || " ", currentString.length > targetLength)
      return currentString;
    else {
      if (targetLength = targetLength - currentString.length, targetLength > padString.length)
        padString += padString.repeat(targetLength / padString.length);
      return padString.slice(0, targetLength) + currentString;
    }
  }
  function sanitizeURL(url) {
    let safeURL = url;
    if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE))
      safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
    return safeURL;
  }
  function sanitizeHeaders(originalHeader) {
    let headers = (0, core_rest_pipeline_1.createHttpHeaders)();
    for (let [name, value] of originalHeader)
      if (name.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase())
        headers.set(name, "*****");
      else if (name.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE)
        headers.set(name, sanitizeURL(value));
      else
        headers.set(name, value);
    return headers;
  }
  function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
  }
  function getAccountNameFromUrl(url) {
    let parsedUrl = new URL(url), accountName;
    try {
      if (parsedUrl.hostname.split(".")[1] === "blob")
        accountName = parsedUrl.hostname.split(".")[0];
      else if (isIpEndpointStyle(parsedUrl))
        accountName = parsedUrl.pathname.split("/")[1];
      else
        accountName = "";
      return accountName;
    } catch (error) {
      throw Error("Unable to extract accountName with provided information.");
    }
  }
  function isIpEndpointStyle(parsedUrl) {
    let host = parsedUrl.host;
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
  }
  function toBlobTagsString(tags) {
    if (tags === void 0)
      return;
    let tagPairs = [];
    for (let key in tags)
      if (Object.prototype.hasOwnProperty.call(tags, key)) {
        let value = tags[key];
        tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);
      }
    return tagPairs.join("&");
  }
  function toBlobTags(tags) {
    if (tags === void 0)
      return;
    let res = {
      blobTagSet: []
    };
    for (let key in tags)
      if (Object.prototype.hasOwnProperty.call(tags, key)) {
        let value = tags[key];
        res.blobTagSet.push({
          key,
          value
        });
      }
    return res;
  }
  function toTags(tags) {
    if (tags === void 0)
      return;
    let res = {};
    for (let blobTag of tags.blobTagSet)
      res[blobTag.key] = blobTag.value;
    return res;
  }
  function toQuerySerialization(textConfiguration) {
    if (textConfiguration === void 0)
      return;
    switch (textConfiguration.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: textConfiguration.columnSeparator || ",",
              fieldQuote: textConfiguration.fieldQuote || "",
              recordSeparator: textConfiguration.recordSeparator,
              escapeChar: textConfiguration.escapeCharacter || "",
              headersPresent: textConfiguration.hasHeaders || !1
            }
          }
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: {
              recordSeparator: textConfiguration.recordSeparator
            }
          }
        };
      case "arrow":
        return {
          format: {
            type: "arrow",
            arrowConfiguration: {
              schema: textConfiguration.schema
            }
          }
        };
      case "parquet":
        return {
          format: {
            type: "parquet"
          }
        };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
  }
  function parseObjectReplicationRecord(objectReplicationRecord) {
    if (!objectReplicationRecord)
      return;
    if ("policy-id" in objectReplicationRecord)
      return;
    let orProperties = [];
    for (let key in objectReplicationRecord) {
      let ids = key.split("_"), policyPrefix = "or-";
      if (ids[0].startsWith("or-"))
        ids[0] = ids[0].substring(3);
      let rule = {
        ruleId: ids[1],
        replicationStatus: objectReplicationRecord[key]
      }, policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);
      if (policyIndex > -1)
        orProperties[policyIndex].rules.push(rule);
      else
        orProperties.push({
          policyId: ids[0],
          rules: [rule]
        });
    }
    return orProperties;
  }
  function attachCredential(thing, credential) {
    return thing.credential = credential, thing;
  }
  function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : void 0;
  }
  function BlobNameToString(name) {
    if (name.encoded)
      return decodeURIComponent(name.content);
    else
      return name.content;
  }
  function ConvertInternalResponseOfListBlobFlat(internalResponse) {
    return {
      ...internalResponse,
      segment: {
        blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
          return {
            ...blobItemInteral,
            name: BlobNameToString(blobItemInteral.name)
          };
        })
      }
    };
  }
  function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {
    return {
      ...internalResponse,
      segment: {
        blobPrefixes: internalResponse.segment.blobPrefixes?.map((blobPrefixInternal) => {
          return {
            ...blobPrefixInternal,
            name: BlobNameToString(blobPrefixInternal.name)
          };
        }),
        blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {
          return {
            ...blobItemInteral,
            name: BlobNameToString(blobItemInteral.name)
          };
        })
      }
    };
  }
  function* ExtractPageRangeInfoItems(getPageRangesSegment) {
    let pageRange = [], clearRange = [];
    if (getPageRangesSegment.pageRange)
      pageRange = getPageRangesSegment.pageRange;
    if (getPageRangesSegment.clearRange)
      clearRange = getPageRangesSegment.clearRange;
    let pageRangeIndex = 0, clearRangeIndex = 0;
    while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length)
      if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start)
        yield {
          start: pageRange[pageRangeIndex].start,
          end: pageRange[pageRangeIndex].end,
          isClear: !1
        }, ++pageRangeIndex;
      else
        yield {
          start: clearRange[clearRangeIndex].start,
          end: clearRange[clearRangeIndex].end,
          isClear: !0
        }, ++clearRangeIndex;
    for (;pageRangeIndex < pageRange.length; ++pageRangeIndex)
      yield {
        start: pageRange[pageRangeIndex].start,
        end: pageRange[pageRangeIndex].end,
        isClear: !1
      };
    for (;clearRangeIndex < clearRange.length; ++clearRangeIndex)
      yield {
        start: clearRange[clearRangeIndex].start,
        end: clearRange[clearRangeIndex].end,
        isClear: !0
      };
  }
  function EscapePath(blobName) {
    let split = blobName.split("/");
    for (let i = 0;i < split.length; i++)
      split[i] = encodeURIComponent(split[i]);
    return split.join("/");
  }
  function assertResponse(response) {
    if ("_response" in response)
      return response;
    throw TypeError(`Unexpected response object ${response}`);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageRetryPolicyType.js
var require_StorageRetryPolicyType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageRetryPolicyType = void 0;
  var StorageRetryPolicyType;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2.EXPONENTIAL = 0] = "EXPONENTIAL", StorageRetryPolicyType2[StorageRetryPolicyType2.FIXED = 1] = "FIXED";
  })(StorageRetryPolicyType || (exports.StorageRetryPolicyType = StorageRetryPolicyType = {}));
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageRetryPolicy.js
var require_StorageRetryPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageRetryPolicy = void 0;
  exports.NewRetryPolicyFactory = NewRetryPolicyFactory;
  var abort_controller_1 = require_commonjs5(), RequestPolicy_js_1 = require_RequestPolicy(), constants_js_1 = require_constants8(), utils_common_js_1 = require_utils_common(), log_js_1 = require_log6(), StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType();
  function NewRetryPolicyFactory(retryOptions) {
    return {
      create: (nextPolicy, options) => {
        return new StorageRetryPolicy(nextPolicy, options, retryOptions);
      }
    };
  }
  var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120000,
    maxTries: 4,
    retryDelayInMs: 4000,
    retryPolicyType: StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: void 0
  }, RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");

  class StorageRetryPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    retryOptions;
    constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS) {
      super(nextPolicy, options);
      this.retryOptions = {
        retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
        maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
        tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
        retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
        maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
        secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
      };
    }
    async sendRequest(request) {
      return this.attemptSendRequest(request, !1, 1);
    }
    async attemptSendRequest(request, secondaryHas404, attempt) {
      let newRequest = request.clone(), isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") || attempt % 2 === 1;
      if (!isPrimaryRetry)
        newRequest.url = (0, utils_common_js_1.setURLHost)(newRequest.url, this.retryOptions.secondaryHost);
      if (this.retryOptions.tryTimeoutInMs)
        newRequest.url = (0, utils_common_js_1.setURLParameter)(newRequest.url, constants_js_1.URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
      let response;
      try {
        if (log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`), response = await this._nextPolicy.sendRequest(newRequest), !this.shouldRetry(isPrimaryRetry, attempt, response))
          return response;
        secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
      } catch (err) {
        if (log_js_1.logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`), !this.shouldRetry(isPrimaryRetry, attempt, response, err))
          throw err;
      }
      return await this.delay(isPrimaryRetry, attempt, request.abortSignal), this.attemptSendRequest(request, secondaryHas404, ++attempt);
    }
    shouldRetry(isPrimaryRetry, attempt, response, err) {
      if (attempt >= this.retryOptions.maxTries)
        return log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`), !1;
      let retriableErrors = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR"
      ];
      if (err) {
        for (let retriableError of retriableErrors)
          if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError)
            return log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`), !0;
      }
      if (response || err) {
        let statusCode = response ? response.status : err ? err.statusCode : 0;
        if (!isPrimaryRetry && statusCode === 404)
          return log_js_1.logger.info("RetryPolicy: Secondary access with 404, will retry."), !0;
        if (statusCode === 503 || statusCode === 500)
          return log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`), !0;
      }
      if (response) {
        if (response?.status >= 400) {
          let copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
          if (copySourceError !== void 0)
            switch (copySourceError) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return !0;
            }
        }
      }
      if (err?.code === "PARSE_ERROR" && err?.message.startsWith('Error "Error: Unclosed root tag'))
        return log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry."), !0;
      return !1;
    }
    async delay(isPrimaryRetry, attempt, abortSignal) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry)
        switch (this.retryOptions.retryPolicyType) {
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
            break;
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.FIXED:
            delayTimeInMs = this.retryOptions.retryDelayInMs;
            break;
        }
      else
        delayTimeInMs = Math.random() * 1000;
      return log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`), (0, utils_common_js_1.delay)(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR);
    }
  }
  exports.StorageRetryPolicy = StorageRetryPolicy;
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageRetryPolicyFactory.js
var require_StorageRetryPolicyFactory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = void 0;
  var StorageRetryPolicy_js_1 = require_StorageRetryPolicy();
  Object.defineProperty(exports, "StorageRetryPolicy", { enumerable: !0, get: function() {
    return StorageRetryPolicy_js_1.StorageRetryPolicy;
  } });
  var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType();
  Object.defineProperty(exports, "StorageRetryPolicyType", { enumerable: !0, get: function() {
    return StorageRetryPolicyType_js_1.StorageRetryPolicyType;
  } });

  class StorageRetryPolicyFactory {
    retryOptions;
    constructor(retryOptions) {
      this.retryOptions = retryOptions;
    }
    create(nextPolicy, options) {
      return new StorageRetryPolicy_js_1.StorageRetryPolicy(nextPolicy, options, this.retryOptions);
    }
  }
  exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/CredentialPolicy.js
var require_CredentialPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.CredentialPolicy = void 0;
  var RequestPolicy_js_1 = require_RequestPolicy();

  class CredentialPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    sendRequest(request) {
      return this._nextPolicy.sendRequest(this.signRequest(request));
    }
    signRequest(request) {
      return request;
    }
  }
  exports.CredentialPolicy = CredentialPolicy;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/SharedKeyComparator.js
var require_SharedKeyComparator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.compareHeader = compareHeader;
  var table_lv0 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1820,
    0,
    1823,
    1825,
    1827,
    1829,
    0,
    0,
    0,
    1837,
    2051,
    0,
    0,
    1843,
    0,
    3331,
    3354,
    3356,
    3358,
    3360,
    3362,
    3364,
    3366,
    3368,
    3370,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    0,
    0,
    1859,
    1860,
    1864,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    1868,
    0,
    1872,
    0
  ]), table_lv2 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]), table_lv4 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    32786,
    0,
    0,
    0,
    0,
    0,
    33298,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  function compareHeader(lhs, rhs) {
    if (isLessThan(lhs, rhs))
      return -1;
    return 1;
  }
  function isLessThan(lhs, rhs) {
    let tables = [table_lv0, table_lv2, table_lv4], curr_level = 0, i = 0, j = 0;
    while (curr_level < tables.length) {
      if (curr_level === tables.length - 1 && i !== j)
        return i > j;
      let weight1 = i < lhs.length ? tables[curr_level][lhs[i].charCodeAt(0)] : 1, weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
      if (weight1 === 1 && weight2 === 1)
        i = 0, j = 0, ++curr_level;
      else if (weight1 === weight2)
        ++i, ++j;
      else if (weight1 === 0)
        ++i;
      else if (weight2 === 0)
        ++j;
      else
        return weight1 < weight2;
    }
    return !1;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageSharedKeyCredentialPolicy.js
var require_StorageSharedKeyCredentialPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageSharedKeyCredentialPolicy = void 0;
  var constants_js_1 = require_constants8(), utils_common_js_1 = require_utils_common(), CredentialPolicy_js_1 = require_CredentialPolicy(), SharedKeyComparator_js_1 = require_SharedKeyComparator();

  class StorageSharedKeyCredentialPolicy extends CredentialPolicy_js_1.CredentialPolicy {
    factory;
    constructor(nextPolicy, options, factory) {
      super(nextPolicy, options);
      this.factory = factory;
    }
    signRequest(request) {
      if (request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString()), request.body && (typeof request.body === "string" || request.body !== void 0) && request.body.length > 0)
        request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      let stringToSign = [
        request.method.toUpperCase(),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
      ].join(`
`) + `
` + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request), signature = this.factory.computeHMACSHA256(stringToSign);
      return request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`), request;
    }
    getHeaderValueToSign(request, headerName) {
      let value = request.headers.get(headerName);
      if (!value)
        return "";
      if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0")
        return "";
      return value;
    }
    getCanonicalizedHeadersString(request) {
      let headersArray = request.headers.headersArray().filter((value) => {
        return value.name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE);
      });
      headersArray.sort((a, b) => {
        return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
      }), headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase())
          return !1;
        return !0;
      });
      let canonicalizedHeadersStringToSign = "";
      return headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      }), canonicalizedHeadersStringToSign;
    }
    getCanonicalizedResourceString(request) {
      let path = (0, utils_common_js_1.getURLPath)(request.url) || "/", canonicalizedResourceString = "";
      canonicalizedResourceString += `/${this.factory.accountName}${path}`;
      let queries = (0, utils_common_js_1.getURLQueries)(request.url), lowercaseQueries = {};
      if (queries) {
        let queryKeys = [];
        for (let key in queries)
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            let lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key], queryKeys.push(lowercaseKey);
          }
        queryKeys.sort();
        for (let key of queryKeys)
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
      }
      return canonicalizedResourceString;
    }
  }
  exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
});

// node_modules/@azure/storage-blob/dist/commonjs/credentials/Credential.js
var require_Credential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Credential = void 0;

  class Credential {
    create(_nextPolicy, _options) {
      throw Error("Method should be implemented in children classes.");
    }
  }
  exports.Credential = Credential;
});

// node_modules/@azure/storage-blob/dist/commonjs/credentials/StorageSharedKeyCredential.js
var require_StorageSharedKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageSharedKeyCredential = void 0;
  var node_crypto_1 = __require("node:crypto"), StorageSharedKeyCredentialPolicy_js_1 = require_StorageSharedKeyCredentialPolicy(), Credential_js_1 = require_Credential();

  class StorageSharedKeyCredential extends Credential_js_1.Credential {
    accountName;
    accountKey;
    constructor(accountName, accountKey) {
      super();
      this.accountName = accountName, this.accountKey = Buffer.from(accountKey, "base64");
    }
    create(nextPolicy, options) {
      return new StorageSharedKeyCredentialPolicy_js_1.StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
    }
    computeHMACSHA256(stringToSign) {
      return (0, node_crypto_1.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
    }
  }
  exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/AnonymousCredentialPolicy.js
var require_AnonymousCredentialPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AnonymousCredentialPolicy = void 0;
  var CredentialPolicy_js_1 = require_CredentialPolicy();

  class AnonymousCredentialPolicy extends CredentialPolicy_js_1.CredentialPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
  }
  exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
});

// node_modules/@azure/storage-blob/dist/commonjs/credentials/AnonymousCredential.js
var require_AnonymousCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AnonymousCredential = void 0;
  var AnonymousCredentialPolicy_js_1 = require_AnonymousCredentialPolicy(), Credential_js_1 = require_Credential();

  class AnonymousCredential extends Credential_js_1.Credential {
    create(nextPolicy, options) {
      return new AnonymousCredentialPolicy_js_1.AnonymousCredentialPolicy(nextPolicy, options);
    }
  }
  exports.AnonymousCredential = AnonymousCredential;
});

// node_modules/@azure/storage-common/dist/commonjs/BuffersStream.js
var require_BuffersStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BuffersStream = void 0;
  var node_stream_1 = __require("node:stream");

  class BuffersStream extends node_stream_1.Readable {
    buffers;
    byteLength;
    byteOffsetInCurrentBuffer;
    bufferIndex;
    pushedBytesLength;
    constructor(buffers, byteLength, options) {
      super(options);
      this.buffers = buffers, this.byteLength = byteLength, this.byteOffsetInCurrentBuffer = 0, this.bufferIndex = 0, this.pushedBytesLength = 0;
      let buffersLength = 0;
      for (let buf of this.buffers)
        buffersLength += buf.byteLength;
      if (buffersLength < this.byteLength)
        throw Error("Data size shouldn't be larger than the total length of buffers.");
    }
    _read(size) {
      if (this.pushedBytesLength >= this.byteLength)
        this.push(null);
      if (!size)
        size = this.readableHighWaterMark;
      let outBuffers = [], i = 0;
      while (i < size && this.pushedBytesLength < this.byteLength) {
        let remainingDataInAllBuffers = this.byteLength - this.pushedBytesLength, remainingCapacityInThisBuffer = this.buffers[this.bufferIndex].byteLength - this.byteOffsetInCurrentBuffer, remaining = Math.min(remainingCapacityInThisBuffer, remainingDataInAllBuffers);
        if (remaining > size - i) {
          let end = this.byteOffsetInCurrentBuffer + size - i;
          outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end)), this.pushedBytesLength += size - i, this.byteOffsetInCurrentBuffer = end, i = size;
          break;
        } else {
          let end = this.byteOffsetInCurrentBuffer + remaining;
          if (outBuffers.push(this.buffers[this.bufferIndex].slice(this.byteOffsetInCurrentBuffer, end)), remaining === remainingCapacityInThisBuffer)
            this.byteOffsetInCurrentBuffer = 0, this.bufferIndex++;
          else
            this.byteOffsetInCurrentBuffer = end;
          this.pushedBytesLength += remaining, i += remaining;
        }
      }
      if (outBuffers.length > 1)
        this.push(Buffer.concat(outBuffers));
      else if (outBuffers.length === 1)
        this.push(outBuffers[0]);
    }
  }
  exports.BuffersStream = BuffersStream;
});

// node_modules/@azure/storage-common/dist/commonjs/PooledBuffer.js
var require_PooledBuffer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.PooledBuffer = void 0;
  var tslib_1 = require_tslib(), BuffersStream_js_1 = require_BuffersStream(), node_buffer_1 = tslib_1.__importDefault(__require("node:buffer")), maxBufferLength = node_buffer_1.default.constants.MAX_LENGTH;

  class PooledBuffer {
    buffers = [];
    capacity;
    _size;
    get size() {
      return this._size;
    }
    constructor(capacity, buffers, totalLength) {
      this.capacity = capacity, this._size = 0;
      let bufferNum = Math.ceil(capacity / maxBufferLength);
      for (let i = 0;i < bufferNum; i++) {
        let len = i === bufferNum - 1 ? capacity % maxBufferLength : maxBufferLength;
        if (len === 0)
          len = maxBufferLength;
        this.buffers.push(Buffer.allocUnsafe(len));
      }
      if (buffers)
        this.fill(buffers, totalLength);
    }
    fill(buffers, totalLength) {
      this._size = Math.min(this.capacity, totalLength);
      let i = 0, j = 0, targetOffset = 0, sourceOffset = 0, totalCopiedNum = 0;
      while (totalCopiedNum < this._size) {
        let source = buffers[i], target = this.buffers[j], copiedNum = source.copy(target, targetOffset, sourceOffset);
        if (totalCopiedNum += copiedNum, sourceOffset += copiedNum, targetOffset += copiedNum, sourceOffset === source.length)
          i++, sourceOffset = 0;
        if (targetOffset === target.length)
          j++, targetOffset = 0;
      }
      if (buffers.splice(0, i), buffers.length > 0)
        buffers[0] = buffers[0].slice(sourceOffset);
    }
    getReadableStream() {
      return new BuffersStream_js_1.BuffersStream(this.buffers, this.size);
    }
  }
  exports.PooledBuffer = PooledBuffer;
});

// node_modules/@azure/storage-common/dist/commonjs/BufferScheduler.js
var require_BufferScheduler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BufferScheduler = void 0;
  var events_1 = __require("events"), PooledBuffer_js_1 = require_PooledBuffer();

  class BufferScheduler {
    bufferSize;
    maxBuffers;
    readable;
    outgoingHandler;
    emitter = new events_1.EventEmitter;
    concurrency;
    offset = 0;
    isStreamEnd = !1;
    isError = !1;
    executingOutgoingHandlers = 0;
    encoding;
    numBuffers = 0;
    unresolvedDataArray = [];
    unresolvedLength = 0;
    incoming = [];
    outgoing = [];
    constructor(readable, bufferSize, maxBuffers, outgoingHandler, concurrency, encoding) {
      if (bufferSize <= 0)
        throw RangeError(`bufferSize must be larger than 0, current is ${bufferSize}`);
      if (maxBuffers <= 0)
        throw RangeError(`maxBuffers must be larger than 0, current is ${maxBuffers}`);
      if (concurrency <= 0)
        throw RangeError(`concurrency must be larger than 0, current is ${concurrency}`);
      this.bufferSize = bufferSize, this.maxBuffers = maxBuffers, this.readable = readable, this.outgoingHandler = outgoingHandler, this.concurrency = concurrency, this.encoding = encoding;
    }
    async do() {
      return new Promise((resolve, reject) => {
        this.readable.on("data", (data) => {
          if (data = typeof data === "string" ? Buffer.from(data, this.encoding) : data, this.appendUnresolvedData(data), !this.resolveData())
            this.readable.pause();
        }), this.readable.on("error", (err) => {
          this.emitter.emit("error", err);
        }), this.readable.on("end", () => {
          this.isStreamEnd = !0, this.emitter.emit("checkEnd");
        }), this.emitter.on("error", (err) => {
          this.isError = !0, this.readable.pause(), reject(err);
        }), this.emitter.on("checkEnd", () => {
          if (this.outgoing.length > 0) {
            this.triggerOutgoingHandlers();
            return;
          }
          if (this.isStreamEnd && this.executingOutgoingHandlers === 0)
            if (this.unresolvedLength > 0 && this.unresolvedLength < this.bufferSize) {
              let buffer = this.shiftBufferFromUnresolvedDataArray();
              this.outgoingHandler(() => buffer.getReadableStream(), buffer.size, this.offset).then(resolve).catch(reject);
            } else if (this.unresolvedLength >= this.bufferSize)
              return;
            else
              resolve();
        });
      });
    }
    appendUnresolvedData(data) {
      this.unresolvedDataArray.push(data), this.unresolvedLength += data.length;
    }
    shiftBufferFromUnresolvedDataArray(buffer) {
      if (!buffer)
        buffer = new PooledBuffer_js_1.PooledBuffer(this.bufferSize, this.unresolvedDataArray, this.unresolvedLength);
      else
        buffer.fill(this.unresolvedDataArray, this.unresolvedLength);
      return this.unresolvedLength -= buffer.size, buffer;
    }
    resolveData() {
      while (this.unresolvedLength >= this.bufferSize) {
        let buffer;
        if (this.incoming.length > 0)
          buffer = this.incoming.shift(), this.shiftBufferFromUnresolvedDataArray(buffer);
        else if (this.numBuffers < this.maxBuffers)
          buffer = this.shiftBufferFromUnresolvedDataArray(), this.numBuffers++;
        else
          return !1;
        this.outgoing.push(buffer), this.triggerOutgoingHandlers();
      }
      return !0;
    }
    async triggerOutgoingHandlers() {
      let buffer;
      do {
        if (this.executingOutgoingHandlers >= this.concurrency)
          return;
        if (buffer = this.outgoing.shift(), buffer)
          this.triggerOutgoingHandler(buffer);
      } while (buffer);
    }
    async triggerOutgoingHandler(buffer) {
      let bufferLength = buffer.size;
      this.executingOutgoingHandlers++, this.offset += bufferLength;
      try {
        await this.outgoingHandler(() => buffer.getReadableStream(), bufferLength, this.offset - bufferLength);
      } catch (err) {
        this.emitter.emit("error", err);
        return;
      }
      this.executingOutgoingHandlers--, this.reuseBuffer(buffer), this.emitter.emit("checkEnd");
    }
    reuseBuffer(buffer) {
      if (this.incoming.push(buffer), !this.isError && this.resolveData() && !this.isStreamEnd)
        this.readable.resume();
    }
  }
  exports.BufferScheduler = BufferScheduler;
});

// node_modules/@azure/storage-common/dist/commonjs/cache.js
var require_cache2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
  var core_rest_pipeline_1 = require_commonjs8(), _defaultHttpClient;
  function getCachedDefaultHttpClient() {
    if (!_defaultHttpClient)
      _defaultHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
    return _defaultHttpClient;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/RequestPolicy.js
var require_RequestPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BaseRequestPolicy = void 0;

  class BaseRequestPolicy {
    _nextPolicy;
    _options;
    constructor(_nextPolicy, _options) {
      this._nextPolicy = _nextPolicy, this._options = _options;
    }
    shouldLog(logLevel) {
      return this._options.shouldLog(logLevel);
    }
    log(logLevel, message) {
      this._options.log(logLevel, message);
    }
  }
  exports.BaseRequestPolicy = BaseRequestPolicy;
});

// node_modules/@azure/storage-common/node_modules/@azure/core-util/dist/commonjs/aborterUtils.js
var require_aborterUtils3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.cancelablePromiseRace = cancelablePromiseRace;
  async function cancelablePromiseRace(abortablePromiseBuilders, options) {
    let aborter = new AbortController;
    function abortHandler() {
      aborter.abort();
    }
    options?.abortSignal?.addEventListener("abort", abortHandler);
    try {
      return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
    } finally {
      aborter.abort(), options?.abortSignal?.removeEventListener("abort", abortHandler);
    }
  }
});

// node_modules/@azure/storage-common/node_modules/@azure/core-util/dist/commonjs/createAbortablePromise.js
var require_createAbortablePromise3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createAbortablePromise = createAbortablePromise;
  var abort_controller_1 = require_commonjs5();
  function createAbortablePromise(buildPromise, options) {
    let { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options ?? {};
    return new Promise((resolve, reject) => {
      function rejectOnAbort() {
        reject(new abort_controller_1.AbortError(abortErrorMsg ?? "The operation was aborted."));
      }
      function removeListeners() {
        abortSignal?.removeEventListener("abort", onAbort);
      }
      function onAbort() {
        cleanupBeforeAbort?.(), removeListeners(), rejectOnAbort();
      }
      if (abortSignal?.aborted)
        return rejectOnAbort();
      try {
        buildPromise((x) => {
          removeListeners(), resolve(x);
        }, (x) => {
          removeListeners(), reject(x);
        });
      } catch (err) {
        reject(err);
      }
      abortSignal?.addEventListener("abort", onAbort);
    });
  }
});

// node_modules/@azure/storage-common/node_modules/@azure/core-util/dist/commonjs/delay.js
var require_delay4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.delay = delay;
  exports.calculateRetryDelay = calculateRetryDelay;
  var createAbortablePromise_js_1 = require_createAbortablePromise3(), util_1 = require_internal3(), StandardAbortMessage = "The delay was aborted.";
  function delay(timeInMs, options) {
    let token, { abortSignal, abortErrorMsg } = options ?? {};
    return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
      token = setTimeout(resolve, timeInMs);
    }, {
      cleanupBeforeAbort: () => clearTimeout(token),
      abortSignal,
      abortErrorMsg: abortErrorMsg ?? StandardAbortMessage
    });
  }
  function calculateRetryDelay(retryAttempt, config) {
    let exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt), clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    return { retryAfterInMs: clampedDelay / 2 + (0, util_1.getRandomIntegerInclusive)(0, clampedDelay / 2) };
  }
});

// node_modules/@azure/storage-common/node_modules/@azure/core-util/dist/commonjs/error.js
var require_error4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getErrorMessage = getErrorMessage;
  var util_1 = require_internal3();
  function getErrorMessage(e) {
    if ((0, util_1.isError)(e))
      return e.message;
    else {
      let stringified;
      try {
        if (typeof e === "object" && e)
          stringified = JSON.stringify(e);
        else
          stringified = String(e);
      } catch (err) {
        stringified = "[unable to stringify input]";
      }
      return `Unknown error ${stringified}`;
    }
  }
});

// node_modules/@azure/storage-common/node_modules/@azure/core-util/dist/commonjs/typeGuards.js
var require_typeGuards4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isDefined = isDefined;
  exports.isObjectWithProperties = isObjectWithProperties;
  exports.objectHasProperty = objectHasProperty;
  function isDefined(thing) {
    return typeof thing < "u" && thing !== null;
  }
  function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object")
      return !1;
    for (let property of properties)
      if (!objectHasProperty(thing, property))
        return !1;
    return !0;
  }
  function objectHasProperty(thing, property) {
    return isDefined(thing) && typeof thing === "object" && property in thing;
  }
});

// node_modules/@azure/storage-common/node_modules/@azure/core-util/dist/commonjs/index.js
var require_commonjs16 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.isWebWorker = exports.isReactNative = exports.isNodeRuntime = exports.isNodeLike = exports.isNode = exports.isDeno = exports.isBun = exports.isBrowser = exports.objectHasProperty = exports.isObjectWithProperties = exports.isDefined = exports.getErrorMessage = exports.delay = exports.createAbortablePromise = exports.cancelablePromiseRace = void 0;
  exports.calculateRetryDelay = calculateRetryDelay;
  exports.computeSha256Hash = computeSha256Hash;
  exports.computeSha256Hmac = computeSha256Hmac;
  exports.getRandomIntegerInclusive = getRandomIntegerInclusive;
  exports.isError = isError;
  exports.isObject = isObject;
  exports.randomUUID = randomUUID;
  exports.uint8ArrayToString = uint8ArrayToString;
  exports.stringToUint8Array = stringToUint8Array;
  var tslib_1 = require_tslib(), tspRuntime = tslib_1.__importStar(require_internal3()), aborterUtils_js_1 = require_aborterUtils3();
  Object.defineProperty(exports, "cancelablePromiseRace", { enumerable: !0, get: function() {
    return aborterUtils_js_1.cancelablePromiseRace;
  } });
  var createAbortablePromise_js_1 = require_createAbortablePromise3();
  Object.defineProperty(exports, "createAbortablePromise", { enumerable: !0, get: function() {
    return createAbortablePromise_js_1.createAbortablePromise;
  } });
  var delay_js_1 = require_delay4();
  Object.defineProperty(exports, "delay", { enumerable: !0, get: function() {
    return delay_js_1.delay;
  } });
  var error_js_1 = require_error4();
  Object.defineProperty(exports, "getErrorMessage", { enumerable: !0, get: function() {
    return error_js_1.getErrorMessage;
  } });
  var typeGuards_js_1 = require_typeGuards4();
  Object.defineProperty(exports, "isDefined", { enumerable: !0, get: function() {
    return typeGuards_js_1.isDefined;
  } });
  Object.defineProperty(exports, "isObjectWithProperties", { enumerable: !0, get: function() {
    return typeGuards_js_1.isObjectWithProperties;
  } });
  Object.defineProperty(exports, "objectHasProperty", { enumerable: !0, get: function() {
    return typeGuards_js_1.objectHasProperty;
  } });
  function calculateRetryDelay(retryAttempt, config) {
    return tspRuntime.calculateRetryDelay(retryAttempt, config);
  }
  function computeSha256Hash(content, encoding) {
    return tspRuntime.computeSha256Hash(content, encoding);
  }
  function computeSha256Hmac(key, stringToSign, encoding) {
    return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
  }
  function getRandomIntegerInclusive(min, max) {
    return tspRuntime.getRandomIntegerInclusive(min, max);
  }
  function isError(e) {
    return tspRuntime.isError(e);
  }
  function isObject(input) {
    return tspRuntime.isObject(input);
  }
  function randomUUID() {
    return tspRuntime.randomUUID();
  }
  exports.isBrowser = tspRuntime.isBrowser;
  exports.isBun = tspRuntime.isBun;
  exports.isDeno = tspRuntime.isDeno;
  exports.isNode = tspRuntime.isNodeLike;
  exports.isNodeLike = tspRuntime.isNodeLike;
  exports.isNodeRuntime = tspRuntime.isNodeRuntime;
  exports.isReactNative = tspRuntime.isReactNative;
  exports.isWebWorker = tspRuntime.isWebWorker;
  function uint8ArrayToString(bytes, format) {
    return tspRuntime.uint8ArrayToString(bytes, format);
  }
  function stringToUint8Array(value, format) {
    return tspRuntime.stringToUint8Array(value, format);
  }
});

// node_modules/@azure/storage-common/dist/commonjs/utils/constants.js
var require_constants9 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.PathStylePorts = exports.DevelopmentConnectionString = exports.HeaderConstants = exports.URLConstants = exports.SDK_VERSION = void 0;
  exports.SDK_VERSION = "1.0.0";
  exports.URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SIGNATURE: "sig",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout"
    }
  };
  exports.HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code"
  };
  exports.DevelopmentConnectionString = "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;";
  exports.PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104"
  ];
});

// node_modules/@azure/storage-common/dist/commonjs/utils/utils.common.js
var require_utils_common2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.escapeURLPath = escapeURLPath;
  exports.getValueInConnString = getValueInConnString;
  exports.extractConnectionStringParts = extractConnectionStringParts;
  exports.appendToURLPath = appendToURLPath;
  exports.setURLParameter = setURLParameter;
  exports.getURLParameter = getURLParameter;
  exports.setURLHost = setURLHost;
  exports.getURLPath = getURLPath;
  exports.getURLScheme = getURLScheme;
  exports.getURLPathAndQuery = getURLPathAndQuery;
  exports.getURLQueries = getURLQueries;
  exports.appendToURLQuery = appendToURLQuery;
  exports.truncatedISO8061Date = truncatedISO8061Date;
  exports.base64encode = base64encode;
  exports.base64decode = base64decode;
  exports.generateBlockID = generateBlockID;
  exports.delay = delay;
  exports.padStart = padStart;
  exports.sanitizeURL = sanitizeURL;
  exports.sanitizeHeaders = sanitizeHeaders;
  exports.iEqual = iEqual;
  exports.getAccountNameFromUrl = getAccountNameFromUrl;
  exports.isIpEndpointStyle = isIpEndpointStyle;
  exports.attachCredential = attachCredential;
  exports.httpAuthorizationToString = httpAuthorizationToString;
  exports.EscapePath = EscapePath;
  exports.assertResponse = assertResponse;
  var core_rest_pipeline_1 = require_commonjs8(), core_util_1 = require_commonjs16(), constants_js_1 = require_constants9();
  function escapeURLPath(url) {
    let urlParsed = new URL(url), path = urlParsed.pathname;
    return path = path || "/", path = escape(path), urlParsed.pathname = path, urlParsed.toString();
  }
  function getProxyUriFromDevConnString(connectionString) {
    let proxyUri = "";
    if (connectionString.search("DevelopmentStorageProxyUri=") !== -1) {
      let matchCredentials = connectionString.split(";");
      for (let element of matchCredentials)
        if (element.trim().startsWith("DevelopmentStorageProxyUri="))
          proxyUri = element.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
    }
    return proxyUri;
  }
  function getValueInConnString(connectionString, argument) {
    let elements = connectionString.split(";");
    for (let element of elements)
      if (element.trim().startsWith(argument))
        return element.trim().match(argument + "=(.*)")[1];
    return "";
  }
  function extractConnectionStringParts(connectionString) {
    let proxyUri = "";
    if (connectionString.startsWith("UseDevelopmentStorage=true"))
      proxyUri = getProxyUriFromDevConnString(connectionString), connectionString = constants_js_1.DevelopmentConnectionString;
    let blobEndpoint = getValueInConnString(connectionString, "BlobEndpoint");
    if (blobEndpoint = blobEndpoint.endsWith("/") ? blobEndpoint.slice(0, -1) : blobEndpoint, connectionString.search("DefaultEndpointsProtocol=") !== -1 && connectionString.search("AccountKey=") !== -1) {
      let defaultEndpointsProtocol = "", accountName = "", accountKey = Buffer.from("accountKey", "base64"), endpointSuffix = "";
      if (accountName = getValueInConnString(connectionString, "AccountName"), accountKey = Buffer.from(getValueInConnString(connectionString, "AccountKey"), "base64"), !blobEndpoint) {
        defaultEndpointsProtocol = getValueInConnString(connectionString, "DefaultEndpointsProtocol");
        let protocol = defaultEndpointsProtocol.toLowerCase();
        if (protocol !== "https" && protocol !== "http")
          throw Error("Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'");
        if (endpointSuffix = getValueInConnString(connectionString, "EndpointSuffix"), !endpointSuffix)
          throw Error("Invalid EndpointSuffix in the provided Connection String");
        blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;
      }
      if (!accountName)
        throw Error("Invalid AccountName in the provided Connection String");
      else if (accountKey.length === 0)
        throw Error("Invalid AccountKey in the provided Connection String");
      return {
        kind: "AccountConnString",
        url: blobEndpoint,
        accountName,
        accountKey,
        proxyUri
      };
    } else {
      let accountSas = getValueInConnString(connectionString, "SharedAccessSignature"), accountName = getValueInConnString(connectionString, "AccountName");
      if (!accountName)
        accountName = getAccountNameFromUrl(blobEndpoint);
      if (!blobEndpoint)
        throw Error("Invalid BlobEndpoint in the provided SAS Connection String");
      else if (!accountSas)
        throw Error("Invalid SharedAccessSignature in the provided SAS Connection String");
      if (accountSas.startsWith("?"))
        accountSas = accountSas.substring(1);
      return { kind: "SASConnString", url: blobEndpoint, accountName, accountSas };
    }
  }
  function escape(text) {
    return encodeURIComponent(text).replace(/%2F/g, "/").replace(/'/g, "%27").replace(/\+/g, "%20").replace(/%25/g, "%");
  }
  function appendToURLPath(url, name) {
    let urlParsed = new URL(url), path = urlParsed.pathname;
    return path = path ? path.endsWith("/") ? `${path}${name}` : `${path}/${name}` : name, urlParsed.pathname = path, urlParsed.toString();
  }
  function setURLParameter(url, name, value) {
    let urlParsed = new URL(url), encodedName = encodeURIComponent(name), encodedValue = value ? encodeURIComponent(value) : void 0, searchString = urlParsed.search === "" ? "?" : urlParsed.search, searchPieces = [];
    for (let pair of searchString.slice(1).split("&"))
      if (pair) {
        let [key] = pair.split("=", 2);
        if (key !== encodedName)
          searchPieces.push(pair);
      }
    if (encodedValue)
      searchPieces.push(`${encodedName}=${encodedValue}`);
    return urlParsed.search = searchPieces.length ? `?${searchPieces.join("&")}` : "", urlParsed.toString();
  }
  function getURLParameter(url, name) {
    return new URL(url).searchParams.get(name) ?? void 0;
  }
  function setURLHost(url, host) {
    let urlParsed = new URL(url);
    return urlParsed.hostname = host, urlParsed.toString();
  }
  function getURLPath(url) {
    try {
      return new URL(url).pathname;
    } catch (e) {
      return;
    }
  }
  function getURLScheme(url) {
    try {
      let urlParsed = new URL(url);
      return urlParsed.protocol.endsWith(":") ? urlParsed.protocol.slice(0, -1) : urlParsed.protocol;
    } catch (e) {
      return;
    }
  }
  function getURLPathAndQuery(url) {
    let urlParsed = new URL(url), pathString = urlParsed.pathname;
    if (!pathString)
      throw RangeError("Invalid url without valid path.");
    let queryString = urlParsed.search || "";
    if (queryString = queryString.trim(), queryString !== "")
      queryString = queryString.startsWith("?") ? queryString : `?${queryString}`;
    return `${pathString}${queryString}`;
  }
  function getURLQueries(url) {
    let queryString = new URL(url).search;
    if (!queryString)
      return {};
    queryString = queryString.trim(), queryString = queryString.startsWith("?") ? queryString.substring(1) : queryString;
    let querySubStrings = queryString.split("&");
    querySubStrings = querySubStrings.filter((value) => {
      let indexOfEqual = value.indexOf("="), lastIndexOfEqual = value.lastIndexOf("=");
      return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;
    });
    let queries = {};
    for (let querySubString of querySubStrings) {
      let splitResults = querySubString.split("="), key = splitResults[0], value = splitResults[1];
      queries[key] = value;
    }
    return queries;
  }
  function appendToURLQuery(url, queryParts) {
    let urlParsed = new URL(url), query = urlParsed.search;
    if (query)
      query += "&" + queryParts;
    else
      query = queryParts;
    return urlParsed.search = query, urlParsed.toString();
  }
  function truncatedISO8061Date(date, withMilliseconds = !0) {
    let dateString = date.toISOString();
    return withMilliseconds ? dateString.substring(0, dateString.length - 1) + "0000Z" : dateString.substring(0, dateString.length - 5) + "Z";
  }
  function base64encode(content) {
    return !core_util_1.isNodeLike ? btoa(content) : Buffer.from(content).toString("base64");
  }
  function base64decode(encodedString) {
    return !core_util_1.isNodeLike ? atob(encodedString) : Buffer.from(encodedString, "base64").toString();
  }
  function generateBlockID(blockIDPrefix, blockIndex) {
    if (blockIDPrefix.length > 42)
      blockIDPrefix = blockIDPrefix.slice(0, 42);
    let res = blockIDPrefix + padStart(blockIndex.toString(), 48 - blockIDPrefix.length, "0");
    return base64encode(res);
  }
  async function delay(timeInMs, aborter, abortError) {
    return new Promise((resolve, reject) => {
      let timeout, abortHandler = () => {
        if (timeout !== void 0)
          clearTimeout(timeout);
        reject(abortError);
      };
      if (timeout = setTimeout(() => {
        if (aborter !== void 0)
          aborter.removeEventListener("abort", abortHandler);
        resolve();
      }, timeInMs), aborter !== void 0)
        aborter.addEventListener("abort", abortHandler);
    });
  }
  function padStart(currentString, targetLength, padString = " ") {
    if (String.prototype.padStart)
      return currentString.padStart(targetLength, padString);
    if (padString = padString || " ", currentString.length > targetLength)
      return currentString;
    else {
      if (targetLength = targetLength - currentString.length, targetLength > padString.length)
        padString += padString.repeat(targetLength / padString.length);
      return padString.slice(0, targetLength) + currentString;
    }
  }
  function sanitizeURL(url) {
    let safeURL = url;
    if (getURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE))
      safeURL = setURLParameter(safeURL, constants_js_1.URLConstants.Parameters.SIGNATURE, "*****");
    return safeURL;
  }
  function sanitizeHeaders(originalHeader) {
    let headers = (0, core_rest_pipeline_1.createHttpHeaders)();
    for (let [name, value] of originalHeader)
      if (name.toLowerCase() === constants_js_1.HeaderConstants.AUTHORIZATION.toLowerCase())
        headers.set(name, "*****");
      else if (name.toLowerCase() === constants_js_1.HeaderConstants.X_MS_COPY_SOURCE)
        headers.set(name, sanitizeURL(value));
      else
        headers.set(name, value);
    return headers;
  }
  function iEqual(str1, str2) {
    return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();
  }
  function getAccountNameFromUrl(url) {
    let parsedUrl = new URL(url), accountName;
    try {
      if (parsedUrl.hostname.split(".")[1] === "blob")
        accountName = parsedUrl.hostname.split(".")[0];
      else if (isIpEndpointStyle(parsedUrl))
        accountName = parsedUrl.pathname.split("/")[1];
      else
        accountName = "";
      return accountName;
    } catch (error) {
      throw Error("Unable to extract accountName with provided information.");
    }
  }
  function isIpEndpointStyle(parsedUrl) {
    let host = parsedUrl.host;
    return /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || Boolean(parsedUrl.port) && constants_js_1.PathStylePorts.includes(parsedUrl.port);
  }
  function attachCredential(thing, credential) {
    return thing.credential = credential, thing;
  }
  function httpAuthorizationToString(httpAuthorization) {
    return httpAuthorization ? httpAuthorization.scheme + " " + httpAuthorization.value : void 0;
  }
  function EscapePath(blobName) {
    let split = blobName.split("/");
    for (let i = 0;i < split.length; i++)
      split[i] = encodeURIComponent(split[i]);
    return split.join("/");
  }
  function assertResponse(response) {
    if ("_response" in response)
      return response;
    throw TypeError(`Unexpected response object ${response}`);
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageBrowserPolicy.js
var require_StorageBrowserPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageBrowserPolicy = void 0;
  var RequestPolicy_js_1 = require_RequestPolicy2(), core_util_1 = require_commonjs16(), constants_js_1 = require_constants9(), utils_common_js_1 = require_utils_common2();

  class StorageBrowserPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
    async sendRequest(request) {
      if (core_util_1.isNodeLike)
        return this._nextPolicy.sendRequest(request);
      if (request.method.toUpperCase() === "GET" || request.method.toUpperCase() === "HEAD")
        request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
      return request.headers.remove(constants_js_1.HeaderConstants.COOKIE), request.headers.remove(constants_js_1.HeaderConstants.CONTENT_LENGTH), this._nextPolicy.sendRequest(request);
    }
  }
  exports.StorageBrowserPolicy = StorageBrowserPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/StorageBrowserPolicyFactory.js
var require_StorageBrowserPolicyFactory = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = void 0;
  var StorageBrowserPolicy_js_1 = require_StorageBrowserPolicy();
  Object.defineProperty(exports, "StorageBrowserPolicy", { enumerable: !0, get: function() {
    return StorageBrowserPolicy_js_1.StorageBrowserPolicy;
  } });

  class StorageBrowserPolicyFactory {
    create(nextPolicy, options) {
      return new StorageBrowserPolicy_js_1.StorageBrowserPolicy(nextPolicy, options);
    }
  }
  exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
});

// node_modules/@azure/storage-common/dist/commonjs/policies/CredentialPolicy.js
var require_CredentialPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.CredentialPolicy = void 0;
  var RequestPolicy_js_1 = require_RequestPolicy2();

  class CredentialPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    sendRequest(request) {
      return this._nextPolicy.sendRequest(this.signRequest(request));
    }
    signRequest(request) {
      return request;
    }
  }
  exports.CredentialPolicy = CredentialPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/policies/AnonymousCredentialPolicy.js
var require_AnonymousCredentialPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AnonymousCredentialPolicy = void 0;
  var CredentialPolicy_js_1 = require_CredentialPolicy2();

  class AnonymousCredentialPolicy extends CredentialPolicy_js_1.CredentialPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
  }
  exports.AnonymousCredentialPolicy = AnonymousCredentialPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/Credential.js
var require_Credential2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Credential = void 0;

  class Credential {
    create(_nextPolicy, _options) {
      throw Error("Method should be implemented in children classes.");
    }
  }
  exports.Credential = Credential;
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/AnonymousCredential.js
var require_AnonymousCredential2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AnonymousCredential = void 0;
  var AnonymousCredentialPolicy_js_1 = require_AnonymousCredentialPolicy2(), Credential_js_1 = require_Credential2();

  class AnonymousCredential extends Credential_js_1.Credential {
    create(nextPolicy, options) {
      return new AnonymousCredentialPolicy_js_1.AnonymousCredentialPolicy(nextPolicy, options);
    }
  }
  exports.AnonymousCredential = AnonymousCredential;
});

// node_modules/@azure/storage-common/dist/commonjs/utils/SharedKeyComparator.js
var require_SharedKeyComparator2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.compareHeader = compareHeader;
  var table_lv0 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1820,
    0,
    1823,
    1825,
    1827,
    1829,
    0,
    0,
    0,
    1837,
    2051,
    0,
    0,
    1843,
    0,
    3331,
    3354,
    3356,
    3358,
    3360,
    3362,
    3364,
    3366,
    3368,
    3370,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    0,
    0,
    1859,
    1860,
    1864,
    3586,
    3593,
    3594,
    3610,
    3617,
    3619,
    3621,
    3628,
    3634,
    3637,
    3638,
    3656,
    3665,
    3696,
    3708,
    3710,
    3721,
    3722,
    3729,
    3737,
    3743,
    3746,
    3748,
    3750,
    3751,
    3753,
    0,
    1868,
    0,
    1872,
    0
  ]), table_lv2 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]), table_lv4 = new Uint32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    32786,
    0,
    0,
    0,
    0,
    0,
    33298,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ]);
  function compareHeader(lhs, rhs) {
    if (isLessThan(lhs, rhs))
      return -1;
    return 1;
  }
  function isLessThan(lhs, rhs) {
    let tables = [table_lv0, table_lv2, table_lv4], curr_level = 0, i = 0, j = 0;
    while (curr_level < tables.length) {
      if (curr_level === tables.length - 1 && i !== j)
        return i > j;
      let weight1 = i < lhs.length ? tables[curr_level][lhs[i].charCodeAt(0)] : 1, weight2 = j < rhs.length ? tables[curr_level][rhs[j].charCodeAt(0)] : 1;
      if (weight1 === 1 && weight2 === 1)
        i = 0, j = 0, ++curr_level;
      else if (weight1 === weight2)
        ++i, ++j;
      else if (weight1 === 0)
        ++i;
      else if (weight2 === 0)
        ++j;
      else
        return weight1 < weight2;
    }
    return !1;
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageSharedKeyCredentialPolicy.js
var require_StorageSharedKeyCredentialPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageSharedKeyCredentialPolicy = void 0;
  var constants_js_1 = require_constants9(), utils_common_js_1 = require_utils_common2(), CredentialPolicy_js_1 = require_CredentialPolicy2(), SharedKeyComparator_js_1 = require_SharedKeyComparator2();

  class StorageSharedKeyCredentialPolicy extends CredentialPolicy_js_1.CredentialPolicy {
    factory;
    constructor(nextPolicy, options, factory) {
      super(nextPolicy, options);
      this.factory = factory;
    }
    signRequest(request) {
      if (request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString()), request.body && (typeof request.body === "string" || request.body !== void 0) && request.body.length > 0)
        request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      let stringToSign = [
        request.method.toUpperCase(),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
        this.getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
      ].join(`
`) + `
` + this.getCanonicalizedHeadersString(request) + this.getCanonicalizedResourceString(request), signature = this.factory.computeHMACSHA256(stringToSign);
      return request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${this.factory.accountName}:${signature}`), request;
    }
    getHeaderValueToSign(request, headerName) {
      let value = request.headers.get(headerName);
      if (!value)
        return "";
      if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0")
        return "";
      return value;
    }
    getCanonicalizedHeadersString(request) {
      let headersArray = request.headers.headersArray().filter((value) => {
        return value.name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE);
      });
      headersArray.sort((a, b) => {
        return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
      }), headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase())
          return !1;
        return !0;
      });
      let canonicalizedHeadersStringToSign = "";
      return headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      }), canonicalizedHeadersStringToSign;
    }
    getCanonicalizedResourceString(request) {
      let path = (0, utils_common_js_1.getURLPath)(request.url) || "/", canonicalizedResourceString = "";
      canonicalizedResourceString += `/${this.factory.accountName}${path}`;
      let queries = (0, utils_common_js_1.getURLQueries)(request.url), lowercaseQueries = {};
      if (queries) {
        let queryKeys = [];
        for (let key in queries)
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            let lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key], queryKeys.push(lowercaseKey);
          }
        queryKeys.sort();
        for (let key of queryKeys)
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
      }
      return canonicalizedResourceString;
    }
  }
  exports.StorageSharedKeyCredentialPolicy = StorageSharedKeyCredentialPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/credentials/StorageSharedKeyCredential.js
var require_StorageSharedKeyCredential2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageSharedKeyCredential = void 0;
  var node_crypto_1 = __require("node:crypto"), StorageSharedKeyCredentialPolicy_js_1 = require_StorageSharedKeyCredentialPolicy2(), Credential_js_1 = require_Credential2();

  class StorageSharedKeyCredential extends Credential_js_1.Credential {
    accountName;
    accountKey;
    constructor(accountName, accountKey) {
      super();
      this.accountName = accountName, this.accountKey = Buffer.from(accountKey, "base64");
    }
    create(nextPolicy, options) {
      return new StorageSharedKeyCredentialPolicy_js_1.StorageSharedKeyCredentialPolicy(nextPolicy, options, this);
    }
    computeHMACSHA256(stringToSign) {
      return (0, node_crypto_1.createHmac)("sha256", this.accountKey).update(stringToSign, "utf8").digest("base64");
    }
  }
  exports.StorageSharedKeyCredential = StorageSharedKeyCredential;
});

// node_modules/@azure/storage-common/node_modules/@azure/logger/dist/commonjs/index.js
var require_commonjs17 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AzureLogger = void 0;
  exports.setLogLevel = setLogLevel;
  exports.getLogLevel = getLogLevel;
  exports.createClientLogger = createClientLogger;
  var logger_1 = require_internal(), context = (0, logger_1.createLoggerContext)({
    logLevelEnvVarName: "AZURE_LOG_LEVEL",
    namespace: "azure"
  });
  exports.AzureLogger = context.logger;
  function setLogLevel(level) {
    context.setLogLevel(level);
  }
  function getLogLevel() {
    return context.getLogLevel();
  }
  function createClientLogger(namespace) {
    return context.createClientLogger(namespace);
  }
});

// node_modules/@azure/storage-common/dist/commonjs/log.js
var require_log7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.logger = void 0;
  var logger_1 = require_commonjs17();
  exports.logger = (0, logger_1.createClientLogger)("storage-common");
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicyType.js
var require_StorageRetryPolicyType2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageRetryPolicyType = void 0;
  var StorageRetryPolicyType;
  (function(StorageRetryPolicyType2) {
    StorageRetryPolicyType2[StorageRetryPolicyType2.EXPONENTIAL = 0] = "EXPONENTIAL", StorageRetryPolicyType2[StorageRetryPolicyType2.FIXED = 1] = "FIXED";
  })(StorageRetryPolicyType || (exports.StorageRetryPolicyType = StorageRetryPolicyType = {}));
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicy.js
var require_StorageRetryPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageRetryPolicy = void 0;
  exports.NewRetryPolicyFactory = NewRetryPolicyFactory;
  var abort_controller_1 = require_commonjs5(), RequestPolicy_js_1 = require_RequestPolicy2(), constants_js_1 = require_constants9(), utils_common_js_1 = require_utils_common2(), log_js_1 = require_log7(), StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType2();
  function NewRetryPolicyFactory(retryOptions) {
    return {
      create: (nextPolicy, options) => {
        return new StorageRetryPolicy(nextPolicy, options, retryOptions);
      }
    };
  }
  var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120000,
    maxTries: 4,
    retryDelayInMs: 4000,
    retryPolicyType: StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: void 0
  }, RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");

  class StorageRetryPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    retryOptions;
    constructor(nextPolicy, options, retryOptions = DEFAULT_RETRY_OPTIONS) {
      super(nextPolicy, options);
      this.retryOptions = {
        retryPolicyType: retryOptions.retryPolicyType ? retryOptions.retryPolicyType : DEFAULT_RETRY_OPTIONS.retryPolicyType,
        maxTries: retryOptions.maxTries && retryOptions.maxTries >= 1 ? Math.floor(retryOptions.maxTries) : DEFAULT_RETRY_OPTIONS.maxTries,
        tryTimeoutInMs: retryOptions.tryTimeoutInMs && retryOptions.tryTimeoutInMs >= 0 ? retryOptions.tryTimeoutInMs : DEFAULT_RETRY_OPTIONS.tryTimeoutInMs,
        retryDelayInMs: retryOptions.retryDelayInMs && retryOptions.retryDelayInMs >= 0 ? Math.min(retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs) : DEFAULT_RETRY_OPTIONS.retryDelayInMs,
        maxRetryDelayInMs: retryOptions.maxRetryDelayInMs && retryOptions.maxRetryDelayInMs >= 0 ? retryOptions.maxRetryDelayInMs : DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs,
        secondaryHost: retryOptions.secondaryHost ? retryOptions.secondaryHost : DEFAULT_RETRY_OPTIONS.secondaryHost
      };
    }
    async sendRequest(request) {
      return this.attemptSendRequest(request, !1, 1);
    }
    async attemptSendRequest(request, secondaryHas404, attempt) {
      let newRequest = request.clone(), isPrimaryRetry = secondaryHas404 || !this.retryOptions.secondaryHost || !(request.method === "GET" || request.method === "HEAD" || request.method === "OPTIONS") || attempt % 2 === 1;
      if (!isPrimaryRetry)
        newRequest.url = (0, utils_common_js_1.setURLHost)(newRequest.url, this.retryOptions.secondaryHost);
      if (this.retryOptions.tryTimeoutInMs)
        newRequest.url = (0, utils_common_js_1.setURLParameter)(newRequest.url, constants_js_1.URLConstants.Parameters.TIMEOUT, Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString());
      let response;
      try {
        if (log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`), response = await this._nextPolicy.sendRequest(newRequest), !this.shouldRetry(isPrimaryRetry, attempt, response))
          return response;
        secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
      } catch (err) {
        if (log_js_1.logger.error(`RetryPolicy: Caught error, message: ${err.message}, code: ${err.code}`), !this.shouldRetry(isPrimaryRetry, attempt, response, err))
          throw err;
      }
      return await this.delay(isPrimaryRetry, attempt, request.abortSignal), this.attemptSendRequest(request, secondaryHas404, ++attempt);
    }
    shouldRetry(isPrimaryRetry, attempt, response, err) {
      if (attempt >= this.retryOptions.maxTries)
        return log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${this.retryOptions.maxTries}, no further try.`), !1;
      let retriableErrors = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR"
      ];
      if (err) {
        for (let retriableError of retriableErrors)
          if (err.name.toUpperCase().includes(retriableError) || err.message.toUpperCase().includes(retriableError) || err.code && err.code.toString().toUpperCase() === retriableError)
            return log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`), !0;
      }
      if (response || err) {
        let statusCode = response ? response.status : err ? err.statusCode : 0;
        if (!isPrimaryRetry && statusCode === 404)
          return log_js_1.logger.info("RetryPolicy: Secondary access with 404, will retry."), !0;
        if (statusCode === 503 || statusCode === 500)
          return log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`), !0;
      }
      if (response) {
        if (response?.status >= 400) {
          let copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
          if (copySourceError !== void 0)
            switch (copySourceError) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return !0;
            }
        }
      }
      if (err?.code === "PARSE_ERROR" && err?.message.startsWith('Error "Error: Unclosed root tag'))
        return log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry."), !0;
      return !1;
    }
    async delay(isPrimaryRetry, attempt, abortSignal) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry)
        switch (this.retryOptions.retryPolicyType) {
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * this.retryOptions.retryDelayInMs, this.retryOptions.maxRetryDelayInMs);
            break;
          case StorageRetryPolicyType_js_1.StorageRetryPolicyType.FIXED:
            delayTimeInMs = this.retryOptions.retryDelayInMs;
            break;
        }
      else
        delayTimeInMs = Math.random() * 1000;
      return log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`), (0, utils_common_js_1.delay)(delayTimeInMs, abortSignal, RETRY_ABORT_ERROR);
    }
  }
  exports.StorageRetryPolicy = StorageRetryPolicy;
});

// node_modules/@azure/storage-common/dist/commonjs/StorageRetryPolicyFactory.js
var require_StorageRetryPolicyFactory2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageRetryPolicyFactory = exports.StorageRetryPolicy = exports.StorageRetryPolicyType = void 0;
  var StorageRetryPolicy_js_1 = require_StorageRetryPolicy2();
  Object.defineProperty(exports, "StorageRetryPolicy", { enumerable: !0, get: function() {
    return StorageRetryPolicy_js_1.StorageRetryPolicy;
  } });
  var StorageRetryPolicyType_js_1 = require_StorageRetryPolicyType2();
  Object.defineProperty(exports, "StorageRetryPolicyType", { enumerable: !0, get: function() {
    return StorageRetryPolicyType_js_1.StorageRetryPolicyType;
  } });

  class StorageRetryPolicyFactory {
    retryOptions;
    constructor(retryOptions) {
      this.retryOptions = retryOptions;
    }
    create(nextPolicy, options) {
      return new StorageRetryPolicy_js_1.StorageRetryPolicy(nextPolicy, options, this.retryOptions);
    }
  }
  exports.StorageRetryPolicyFactory = StorageRetryPolicyFactory;
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageBrowserPolicyV2.js
var require_StorageBrowserPolicyV2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.storageBrowserPolicyName = void 0;
  exports.storageBrowserPolicy = storageBrowserPolicy;
  var core_util_1 = require_commonjs16(), constants_js_1 = require_constants9(), utils_common_js_1 = require_utils_common2();
  exports.storageBrowserPolicyName = "storageBrowserPolicy";
  function storageBrowserPolicy() {
    return {
      name: exports.storageBrowserPolicyName,
      async sendRequest(request, next) {
        if (core_util_1.isNodeLike)
          return next(request);
        if (request.method === "GET" || request.method === "HEAD")
          request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
        return request.headers.delete(constants_js_1.HeaderConstants.COOKIE), request.headers.delete(constants_js_1.HeaderConstants.CONTENT_LENGTH), next(request);
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageCorrectContentLengthPolicy.js
var require_StorageCorrectContentLengthPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.storageCorrectContentLengthPolicyName = void 0;
  exports.storageCorrectContentLengthPolicy = storageCorrectContentLengthPolicy;
  var constants_js_1 = require_constants9();
  exports.storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
  function storageCorrectContentLengthPolicy() {
    function correctContentLength(request) {
      if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0)
        request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
    }
    return {
      name: exports.storageCorrectContentLengthPolicyName,
      async sendRequest(request, next) {
        return correctContentLength(request), next(request);
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRetryPolicyV2.js
var require_StorageRetryPolicyV2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.storageRetryPolicyName = void 0;
  exports.storageRetryPolicy = storageRetryPolicy;
  var abort_controller_1 = require_commonjs5(), core_rest_pipeline_1 = require_commonjs8(), core_util_1 = require_commonjs16(), StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory2(), constants_js_1 = require_constants9(), utils_common_js_1 = require_utils_common2(), log_js_1 = require_log7();
  exports.storageRetryPolicyName = "storageRetryPolicy";
  var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120000,
    maxTries: 4,
    retryDelayInMs: 4000,
    retryPolicyType: StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: void 0
  }, retriableErrors = [
    "ETIMEDOUT",
    "ESOCKETTIMEDOUT",
    "ECONNREFUSED",
    "ECONNRESET",
    "ENOENT",
    "ENOTFOUND",
    "TIMEOUT",
    "EPIPE",
    "REQUEST_SEND_ERROR"
  ], RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
  function storageRetryPolicy(options = {}) {
    let retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType, maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries, retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs, maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs, secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost, tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
    function shouldRetry({ isPrimaryRetry, attempt, response, error }) {
      if (attempt >= maxTries)
        return log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`), !1;
      if (error) {
        for (let retriableError of retriableErrors)
          if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError)
            return log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`), !0;
        if (error?.code === "PARSE_ERROR" && error?.message.startsWith('Error "Error: Unclosed root tag'))
          return log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry."), !0;
      }
      if (response || error) {
        let statusCode = response?.status ?? error?.statusCode ?? 0;
        if (!isPrimaryRetry && statusCode === 404)
          return log_js_1.logger.info("RetryPolicy: Secondary access with 404, will retry."), !0;
        if (statusCode === 503 || statusCode === 500)
          return log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`), !0;
      }
      if (response) {
        if (response?.status >= 400) {
          let copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
          if (copySourceError !== void 0)
            switch (copySourceError) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return !0;
            }
        }
      }
      return !1;
    }
    function calculateDelay(isPrimaryRetry, attempt) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry)
        switch (retryPolicyType) {
          case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
            break;
          case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.FIXED:
            delayTimeInMs = retryDelayInMs;
            break;
        }
      else
        delayTimeInMs = Math.random() * 1000;
      return log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`), delayTimeInMs;
    }
    return {
      name: exports.storageRetryPolicyName,
      async sendRequest(request, next) {
        if (tryTimeoutInMs)
          request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1000)));
        let primaryUrl = request.url, secondaryUrl = secondaryHost ? (0, utils_common_js_1.setURLHost)(request.url, secondaryHost) : void 0, secondaryHas404 = !1, attempt = 1, retryAgain = !0, response, error;
        while (retryAgain) {
          let isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request.method) || attempt % 2 === 1;
          request.url = isPrimaryRetry ? primaryUrl : secondaryUrl, response = void 0, error = void 0;
          try {
            log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`), response = await next(request), secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
          } catch (e) {
            if ((0, core_rest_pipeline_1.isRestError)(e))
              log_js_1.logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`), error = e;
            else
              throw log_js_1.logger.error(`RetryPolicy: Caught error, message: ${(0, core_util_1.getErrorMessage)(e)}`), e;
          }
          if (retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error }), retryAgain)
            await (0, utils_common_js_1.delay)(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);
          attempt++;
        }
        if (response)
          return response;
        throw error ?? new core_rest_pipeline_1.RestError("RetryPolicy failed without known error.");
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageSharedKeyCredentialPolicyV2.js
var require_StorageSharedKeyCredentialPolicyV2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.storageSharedKeyCredentialPolicyName = void 0;
  exports.storageSharedKeyCredentialPolicy = storageSharedKeyCredentialPolicy;
  var node_crypto_1 = __require("node:crypto"), constants_js_1 = require_constants9(), utils_common_js_1 = require_utils_common2(), SharedKeyComparator_js_1 = require_SharedKeyComparator2();
  exports.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
  function storageSharedKeyCredentialPolicy(options) {
    function signRequest(request) {
      if (request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString()), request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0)
        request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      let stringToSign = [
        request.method.toUpperCase(),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
      ].join(`
`) + `
` + getCanonicalizedHeadersString(request) + getCanonicalizedResourceString(request), signature = (0, node_crypto_1.createHmac)("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
      request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
    }
    function getHeaderValueToSign(request, headerName) {
      let value = request.headers.get(headerName);
      if (!value)
        return "";
      if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0")
        return "";
      return value;
    }
    function getCanonicalizedHeadersString(request) {
      let headersArray = [];
      for (let [name, value] of request.headers)
        if (name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE))
          headersArray.push({ name, value });
      headersArray.sort((a, b) => {
        return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
      }), headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase())
          return !1;
        return !0;
      });
      let canonicalizedHeadersStringToSign = "";
      return headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      }), canonicalizedHeadersStringToSign;
    }
    function getCanonicalizedResourceString(request) {
      let path = (0, utils_common_js_1.getURLPath)(request.url) || "/", canonicalizedResourceString = "";
      canonicalizedResourceString += `/${options.accountName}${path}`;
      let queries = (0, utils_common_js_1.getURLQueries)(request.url), lowercaseQueries = {};
      if (queries) {
        let queryKeys = [];
        for (let key in queries)
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            let lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key], queryKeys.push(lowercaseKey);
          }
        queryKeys.sort();
        for (let key of queryKeys)
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
      }
      return canonicalizedResourceString;
    }
    return {
      name: exports.storageSharedKeyCredentialPolicyName,
      async sendRequest(request, next) {
        return signRequest(request), next(request);
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/policies/StorageRequestFailureDetailsParserPolicy.js
var require_StorageRequestFailureDetailsParserPolicy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.storageRequestFailureDetailsParserPolicyName = void 0;
  exports.storageRequestFailureDetailsParserPolicy = storageRequestFailureDetailsParserPolicy;
  exports.storageRequestFailureDetailsParserPolicyName = "storageRequestFailureDetailsParserPolicy";
  function storageRequestFailureDetailsParserPolicy() {
    return {
      name: exports.storageRequestFailureDetailsParserPolicyName,
      async sendRequest(request, next) {
        try {
          return await next(request);
        } catch (err) {
          if (typeof err === "object" && err !== null && err.response && err.response.parsedBody) {
            if (err.response.parsedBody.code === "InvalidHeaderValue" && err.response.parsedBody.HeaderName === "x-ms-version")
              err.message = `The provided service version is not enabled on this storage account. Please see https://learn.microsoft.com/rest/api/storageservices/versioning-for-the-azure-storage-services for additional information.
`;
          }
          throw err;
        }
      }
    };
  }
});

// node_modules/@azure/storage-common/dist/commonjs/index.js
var require_commonjs18 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BaseRequestPolicy = exports.getCachedDefaultHttpClient = void 0;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_BufferScheduler(), exports);
  var cache_js_1 = require_cache2();
  Object.defineProperty(exports, "getCachedDefaultHttpClient", { enumerable: !0, get: function() {
    return cache_js_1.getCachedDefaultHttpClient;
  } });
  tslib_1.__exportStar(require_StorageBrowserPolicyFactory(), exports);
  tslib_1.__exportStar(require_AnonymousCredential2(), exports);
  tslib_1.__exportStar(require_Credential2(), exports);
  tslib_1.__exportStar(require_StorageSharedKeyCredential2(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicyFactory2(), exports);
  var RequestPolicy_js_1 = require_RequestPolicy2();
  Object.defineProperty(exports, "BaseRequestPolicy", { enumerable: !0, get: function() {
    return RequestPolicy_js_1.BaseRequestPolicy;
  } });
  tslib_1.__exportStar(require_AnonymousCredentialPolicy2(), exports);
  tslib_1.__exportStar(require_CredentialPolicy2(), exports);
  tslib_1.__exportStar(require_StorageBrowserPolicy(), exports);
  tslib_1.__exportStar(require_StorageBrowserPolicyV2(), exports);
  tslib_1.__exportStar(require_StorageCorrectContentLengthPolicy(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicyType2(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicy2(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicyV2(), exports);
  tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicy2(), exports);
  tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicyV2(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicyFactory2(), exports);
  tslib_1.__exportStar(require_StorageRequestFailureDetailsParserPolicy(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageBrowserPolicyV2.js
var require_StorageBrowserPolicyV22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.storageBrowserPolicyName = void 0;
  exports.storageBrowserPolicy = storageBrowserPolicy;
  var core_util_1 = require_commonjs9(), constants_js_1 = require_constants8(), utils_common_js_1 = require_utils_common();
  exports.storageBrowserPolicyName = "storageBrowserPolicy";
  function storageBrowserPolicy() {
    return {
      name: exports.storageBrowserPolicyName,
      async sendRequest(request, next) {
        if (core_util_1.isNodeLike)
          return next(request);
        if (request.method === "GET" || request.method === "HEAD")
          request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
        return request.headers.delete(constants_js_1.HeaderConstants.COOKIE), request.headers.delete(constants_js_1.HeaderConstants.CONTENT_LENGTH), next(request);
      }
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageRetryPolicyV2.js
var require_StorageRetryPolicyV22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.storageRetryPolicyName = void 0;
  exports.storageRetryPolicy = storageRetryPolicy;
  var abort_controller_1 = require_commonjs5(), core_rest_pipeline_1 = require_commonjs8(), core_util_1 = require_commonjs9(), StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory(), constants_js_1 = require_constants8(), utils_common_js_1 = require_utils_common(), log_js_1 = require_log6();
  exports.storageRetryPolicyName = "storageRetryPolicy";
  var DEFAULT_RETRY_OPTIONS = {
    maxRetryDelayInMs: 120000,
    maxTries: 4,
    retryDelayInMs: 4000,
    retryPolicyType: StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL,
    secondaryHost: "",
    tryTimeoutInMs: void 0
  }, retriableErrors = [
    "ETIMEDOUT",
    "ESOCKETTIMEDOUT",
    "ECONNREFUSED",
    "ECONNRESET",
    "ENOENT",
    "ENOTFOUND",
    "TIMEOUT",
    "EPIPE",
    "REQUEST_SEND_ERROR"
  ], RETRY_ABORT_ERROR = new abort_controller_1.AbortError("The operation was aborted.");
  function storageRetryPolicy(options = {}) {
    let retryPolicyType = options.retryPolicyType ?? DEFAULT_RETRY_OPTIONS.retryPolicyType, maxTries = options.maxTries ?? DEFAULT_RETRY_OPTIONS.maxTries, retryDelayInMs = options.retryDelayInMs ?? DEFAULT_RETRY_OPTIONS.retryDelayInMs, maxRetryDelayInMs = options.maxRetryDelayInMs ?? DEFAULT_RETRY_OPTIONS.maxRetryDelayInMs, secondaryHost = options.secondaryHost ?? DEFAULT_RETRY_OPTIONS.secondaryHost, tryTimeoutInMs = options.tryTimeoutInMs ?? DEFAULT_RETRY_OPTIONS.tryTimeoutInMs;
    function shouldRetry({ isPrimaryRetry, attempt, response, error }) {
      if (attempt >= maxTries)
        return log_js_1.logger.info(`RetryPolicy: Attempt(s) ${attempt} >= maxTries ${maxTries}, no further try.`), !1;
      if (error) {
        for (let retriableError of retriableErrors)
          if (error.name.toUpperCase().includes(retriableError) || error.message.toUpperCase().includes(retriableError) || error.code && error.code.toString().toUpperCase() === retriableError)
            return log_js_1.logger.info(`RetryPolicy: Network error ${retriableError} found, will retry.`), !0;
        if (error?.code === "PARSE_ERROR" && error?.message.startsWith('Error "Error: Unclosed root tag'))
          return log_js_1.logger.info("RetryPolicy: Incomplete XML response likely due to service timeout, will retry."), !0;
      }
      if (response || error) {
        let statusCode = response?.status ?? error?.statusCode ?? 0;
        if (!isPrimaryRetry && statusCode === 404)
          return log_js_1.logger.info("RetryPolicy: Secondary access with 404, will retry."), !0;
        if (statusCode === 503 || statusCode === 500)
          return log_js_1.logger.info(`RetryPolicy: Will retry for status code ${statusCode}.`), !0;
      }
      if (response) {
        if (response?.status >= 400) {
          let copySourceError = response.headers.get(constants_js_1.HeaderConstants.X_MS_CopySourceErrorCode);
          if (copySourceError !== void 0)
            switch (copySourceError) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return !0;
            }
        }
      }
      return !1;
    }
    function calculateDelay(isPrimaryRetry, attempt) {
      let delayTimeInMs = 0;
      if (isPrimaryRetry)
        switch (retryPolicyType) {
          case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.EXPONENTIAL:
            delayTimeInMs = Math.min((Math.pow(2, attempt - 1) - 1) * retryDelayInMs, maxRetryDelayInMs);
            break;
          case StorageRetryPolicyFactory_js_1.StorageRetryPolicyType.FIXED:
            delayTimeInMs = retryDelayInMs;
            break;
        }
      else
        delayTimeInMs = Math.random() * 1000;
      return log_js_1.logger.info(`RetryPolicy: Delay for ${delayTimeInMs}ms`), delayTimeInMs;
    }
    return {
      name: exports.storageRetryPolicyName,
      async sendRequest(request, next) {
        if (tryTimeoutInMs)
          request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.TIMEOUT, String(Math.floor(tryTimeoutInMs / 1000)));
        let primaryUrl = request.url, secondaryUrl = secondaryHost ? (0, utils_common_js_1.setURLHost)(request.url, secondaryHost) : void 0, secondaryHas404 = !1, attempt = 1, retryAgain = !0, response, error;
        while (retryAgain) {
          let isPrimaryRetry = secondaryHas404 || !secondaryUrl || !["GET", "HEAD", "OPTIONS"].includes(request.method) || attempt % 2 === 1;
          request.url = isPrimaryRetry ? primaryUrl : secondaryUrl, response = void 0, error = void 0;
          try {
            log_js_1.logger.info(`RetryPolicy: =====> Try=${attempt} ${isPrimaryRetry ? "Primary" : "Secondary"}`), response = await next(request), secondaryHas404 = secondaryHas404 || !isPrimaryRetry && response.status === 404;
          } catch (e) {
            if ((0, core_rest_pipeline_1.isRestError)(e))
              log_js_1.logger.error(`RetryPolicy: Caught error, message: ${e.message}, code: ${e.code}`), error = e;
            else
              throw log_js_1.logger.error(`RetryPolicy: Caught error, message: ${(0, core_util_1.getErrorMessage)(e)}`), e;
          }
          if (retryAgain = shouldRetry({ isPrimaryRetry, attempt, response, error }), retryAgain)
            await (0, utils_common_js_1.delay)(calculateDelay(isPrimaryRetry, attempt), request.abortSignal, RETRY_ABORT_ERROR);
          attempt++;
        }
        if (response)
          return response;
        throw error ?? new core_rest_pipeline_1.RestError("RetryPolicy failed without known error.");
      }
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageSharedKeyCredentialPolicyV2.js
var require_StorageSharedKeyCredentialPolicyV22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.storageSharedKeyCredentialPolicyName = void 0;
  exports.storageSharedKeyCredentialPolicy = storageSharedKeyCredentialPolicy;
  var node_crypto_1 = __require("node:crypto"), constants_js_1 = require_constants8(), utils_common_js_1 = require_utils_common(), SharedKeyComparator_js_1 = require_SharedKeyComparator();
  exports.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
  function storageSharedKeyCredentialPolicy(options) {
    function signRequest(request) {
      if (request.headers.set(constants_js_1.HeaderConstants.X_MS_DATE, (/* @__PURE__ */ new Date()).toUTCString()), request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0)
        request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
      let stringToSign = [
        request.method.toUpperCase(),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LANGUAGE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_ENCODING),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_LENGTH),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_MD5),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.CONTENT_TYPE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.DATE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MODIFIED_SINCE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_MATCH),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_NONE_MATCH),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.IF_UNMODIFIED_SINCE),
        getHeaderValueToSign(request, constants_js_1.HeaderConstants.RANGE)
      ].join(`
`) + `
` + getCanonicalizedHeadersString(request) + getCanonicalizedResourceString(request), signature = (0, node_crypto_1.createHmac)("sha256", options.accountKey).update(stringToSign, "utf8").digest("base64");
      request.headers.set(constants_js_1.HeaderConstants.AUTHORIZATION, `SharedKey ${options.accountName}:${signature}`);
    }
    function getHeaderValueToSign(request, headerName) {
      let value = request.headers.get(headerName);
      if (!value)
        return "";
      if (headerName === constants_js_1.HeaderConstants.CONTENT_LENGTH && value === "0")
        return "";
      return value;
    }
    function getCanonicalizedHeadersString(request) {
      let headersArray = [];
      for (let [name, value] of request.headers)
        if (name.toLowerCase().startsWith(constants_js_1.HeaderConstants.PREFIX_FOR_STORAGE))
          headersArray.push({ name, value });
      headersArray.sort((a, b) => {
        return (0, SharedKeyComparator_js_1.compareHeader)(a.name.toLowerCase(), b.name.toLowerCase());
      }), headersArray = headersArray.filter((value, index, array) => {
        if (index > 0 && value.name.toLowerCase() === array[index - 1].name.toLowerCase())
          return !1;
        return !0;
      });
      let canonicalizedHeadersStringToSign = "";
      return headersArray.forEach((header) => {
        canonicalizedHeadersStringToSign += `${header.name.toLowerCase().trimRight()}:${header.value.trimLeft()}
`;
      }), canonicalizedHeadersStringToSign;
    }
    function getCanonicalizedResourceString(request) {
      let path = (0, utils_common_js_1.getURLPath)(request.url) || "/", canonicalizedResourceString = "";
      canonicalizedResourceString += `/${options.accountName}${path}`;
      let queries = (0, utils_common_js_1.getURLQueries)(request.url), lowercaseQueries = {};
      if (queries) {
        let queryKeys = [];
        for (let key in queries)
          if (Object.prototype.hasOwnProperty.call(queries, key)) {
            let lowercaseKey = key.toLowerCase();
            lowercaseQueries[lowercaseKey] = queries[key], queryKeys.push(lowercaseKey);
          }
        queryKeys.sort();
        for (let key of queryKeys)
          canonicalizedResourceString += `
${key}:${decodeURIComponent(lowercaseQueries[key])}`;
      }
      return canonicalizedResourceString;
    }
    return {
      name: exports.storageSharedKeyCredentialPolicyName,
      async sendRequest(request, next) {
        return signRequest(request), next(request);
      }
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageBrowserPolicy.js
var require_StorageBrowserPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageBrowserPolicy = void 0;
  var RequestPolicy_js_1 = require_RequestPolicy(), core_util_1 = require_commonjs9(), constants_js_1 = require_constants8(), utils_common_js_1 = require_utils_common();

  class StorageBrowserPolicy extends RequestPolicy_js_1.BaseRequestPolicy {
    constructor(nextPolicy, options) {
      super(nextPolicy, options);
    }
    async sendRequest(request) {
      if (core_util_1.isNodeLike)
        return this._nextPolicy.sendRequest(request);
      if (request.method.toUpperCase() === "GET" || request.method.toUpperCase() === "HEAD")
        request.url = (0, utils_common_js_1.setURLParameter)(request.url, constants_js_1.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE, (/* @__PURE__ */ new Date()).getTime().toString());
      return request.headers.remove(constants_js_1.HeaderConstants.COOKIE), request.headers.remove(constants_js_1.HeaderConstants.CONTENT_LENGTH), this._nextPolicy.sendRequest(request);
    }
  }
  exports.StorageBrowserPolicy = StorageBrowserPolicy;
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageBrowserPolicyFactory.js
var require_StorageBrowserPolicyFactory2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageBrowserPolicyFactory = exports.StorageBrowserPolicy = void 0;
  var StorageBrowserPolicy_js_1 = require_StorageBrowserPolicy2();
  Object.defineProperty(exports, "StorageBrowserPolicy", { enumerable: !0, get: function() {
    return StorageBrowserPolicy_js_1.StorageBrowserPolicy;
  } });

  class StorageBrowserPolicyFactory {
    create(nextPolicy, options) {
      return new StorageBrowserPolicy_js_1.StorageBrowserPolicy(nextPolicy, options);
    }
  }
  exports.StorageBrowserPolicyFactory = StorageBrowserPolicyFactory;
});

// node_modules/@azure/storage-blob/dist/commonjs/policies/StorageCorrectContentLengthPolicy.js
var require_StorageCorrectContentLengthPolicy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.storageCorrectContentLengthPolicyName = void 0;
  exports.storageCorrectContentLengthPolicy = storageCorrectContentLengthPolicy;
  var constants_js_1 = require_constants8();
  exports.storageCorrectContentLengthPolicyName = "StorageCorrectContentLengthPolicy";
  function storageCorrectContentLengthPolicy() {
    function correctContentLength(request) {
      if (request.body && (typeof request.body === "string" || Buffer.isBuffer(request.body)) && request.body.length > 0)
        request.headers.set(constants_js_1.HeaderConstants.CONTENT_LENGTH, Buffer.byteLength(request.body));
    }
    return {
      name: exports.storageCorrectContentLengthPolicyName,
      async sendRequest(request, next) {
        return correctContentLength(request), next(request);
      }
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/Pipeline.js
var require_Pipeline = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Pipeline = exports.StorageOAuthScopes = void 0;
  exports.isPipelineLike = isPipelineLike;
  exports.newPipeline = newPipeline;
  exports.getCoreClientOptions = getCoreClientOptions;
  exports.getCredentialFromPipeline = getCredentialFromPipeline;
  var core_http_compat_1 = require_commonjs13(), core_rest_pipeline_1 = require_commonjs8(), core_client_1 = require_commonjs12(), core_xml_1 = require_commonjs14(), core_auth_1 = require_commonjs10(), log_js_1 = require_log6(), StorageRetryPolicyFactory_js_1 = require_StorageRetryPolicyFactory(), StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential(), AnonymousCredential_js_1 = require_AnonymousCredential(), constants_js_1 = require_constants8();
  Object.defineProperty(exports, "StorageOAuthScopes", { enumerable: !0, get: function() {
    return constants_js_1.StorageOAuthScopes;
  } });
  var storage_common_1 = require_commonjs18(), StorageBrowserPolicyV2_js_1 = require_StorageBrowserPolicyV22(), StorageRetryPolicyV2_js_1 = require_StorageRetryPolicyV22(), StorageSharedKeyCredentialPolicyV2_js_1 = require_StorageSharedKeyCredentialPolicyV22(), StorageBrowserPolicyFactory_js_1 = require_StorageBrowserPolicyFactory2(), StorageCorrectContentLengthPolicy_js_1 = require_StorageCorrectContentLengthPolicy2();
  function isPipelineLike(pipeline) {
    if (!pipeline || typeof pipeline !== "object")
      return !1;
    let castPipeline = pipeline;
    return Array.isArray(castPipeline.factories) && typeof castPipeline.options === "object" && typeof castPipeline.toServiceClientOptions === "function";
  }

  class Pipeline {
    factories;
    options;
    constructor(factories, options = {}) {
      this.factories = factories, this.options = options;
    }
    toServiceClientOptions() {
      return {
        httpClient: this.options.httpClient,
        requestPolicyFactories: this.factories
      };
    }
  }
  exports.Pipeline = Pipeline;
  function newPipeline(credential, pipelineOptions = {}) {
    if (!credential)
      credential = new AnonymousCredential_js_1.AnonymousCredential;
    let pipeline = new Pipeline([], pipelineOptions);
    return pipeline._credential = credential, pipeline;
  }
  function processDownlevelPipeline(pipeline) {
    let knownFactoryFunctions = [
      isAnonymousCredential,
      isStorageSharedKeyCredential,
      isCoreHttpBearerTokenFactory,
      isStorageBrowserPolicyFactory,
      isStorageRetryPolicyFactory,
      isStorageTelemetryPolicyFactory,
      isCoreHttpPolicyFactory
    ];
    if (pipeline.factories.length) {
      let novelFactories = pipeline.factories.filter((factory) => {
        return !knownFactoryFunctions.some((knownFactory) => knownFactory(factory));
      });
      if (novelFactories.length) {
        let hasInjector = novelFactories.some((factory) => isInjectorPolicyFactory(factory));
        return {
          wrappedPolicies: (0, core_http_compat_1.createRequestPolicyFactoryPolicy)(novelFactories),
          afterRetry: hasInjector
        };
      }
    }
    return;
  }
  function getCoreClientOptions(pipeline) {
    let { httpClient: v1Client, ...restOptions } = pipeline.options, httpClient = pipeline._coreHttpClient;
    if (!httpClient)
      httpClient = v1Client ? (0, core_http_compat_1.convertHttpClient)(v1Client) : (0, storage_common_1.getCachedDefaultHttpClient)(), pipeline._coreHttpClient = httpClient;
    let corePipeline = pipeline._corePipeline;
    if (!corePipeline) {
      let packageDetails = `azsdk-js-azure-storage-blob/${constants_js_1.SDK_VERSION}`, userAgentPrefix = restOptions.userAgentOptions && restOptions.userAgentOptions.userAgentPrefix ? `${restOptions.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
      corePipeline = (0, core_client_1.createClientPipeline)({
        ...restOptions,
        loggingOptions: {
          additionalAllowedHeaderNames: constants_js_1.StorageBlobLoggingAllowedHeaderNames,
          additionalAllowedQueryParameters: constants_js_1.StorageBlobLoggingAllowedQueryParameters,
          logger: log_js_1.logger.info
        },
        userAgentOptions: {
          userAgentPrefix
        },
        serializationOptions: {
          stringifyXML: core_xml_1.stringifyXML,
          serializerOptions: {
            xml: {
              xmlCharKey: "#"
            }
          }
        },
        deserializationOptions: {
          parseXML: core_xml_1.parseXML,
          serializerOptions: {
            xml: {
              xmlCharKey: "#"
            }
          }
        }
      }), corePipeline.removePolicy({ phase: "Retry" }), corePipeline.removePolicy({ name: core_rest_pipeline_1.decompressResponsePolicyName }), corePipeline.addPolicy((0, StorageCorrectContentLengthPolicy_js_1.storageCorrectContentLengthPolicy)()), corePipeline.addPolicy((0, StorageRetryPolicyV2_js_1.storageRetryPolicy)(restOptions.retryOptions), { phase: "Retry" }), corePipeline.addPolicy((0, storage_common_1.storageRequestFailureDetailsParserPolicy)()), corePipeline.addPolicy((0, StorageBrowserPolicyV2_js_1.storageBrowserPolicy)());
      let downlevelResults = processDownlevelPipeline(pipeline);
      if (downlevelResults)
        corePipeline.addPolicy(downlevelResults.wrappedPolicies, downlevelResults.afterRetry ? { afterPhase: "Retry" } : void 0);
      let credential = getCredentialFromPipeline(pipeline);
      if ((0, core_auth_1.isTokenCredential)(credential))
        corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
          credential,
          scopes: restOptions.audience ?? constants_js_1.StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      else if (credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)
        corePipeline.addPolicy((0, StorageSharedKeyCredentialPolicyV2_js_1.storageSharedKeyCredentialPolicy)({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      pipeline._corePipeline = corePipeline;
    }
    return {
      ...restOptions,
      allowInsecureConnection: !0,
      httpClient,
      pipeline: corePipeline
    };
  }
  function getCredentialFromPipeline(pipeline) {
    if (pipeline._credential)
      return pipeline._credential;
    let credential = new AnonymousCredential_js_1.AnonymousCredential;
    for (let factory of pipeline.factories)
      if ((0, core_auth_1.isTokenCredential)(factory.credential))
        credential = factory.credential;
      else if (isStorageSharedKeyCredential(factory))
        return factory;
    return credential;
  }
  function isStorageSharedKeyCredential(factory) {
    if (factory instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)
      return !0;
    return factory.constructor.name === "StorageSharedKeyCredential";
  }
  function isAnonymousCredential(factory) {
    if (factory instanceof AnonymousCredential_js_1.AnonymousCredential)
      return !0;
    return factory.constructor.name === "AnonymousCredential";
  }
  function isCoreHttpBearerTokenFactory(factory) {
    return (0, core_auth_1.isTokenCredential)(factory.credential);
  }
  function isStorageBrowserPolicyFactory(factory) {
    if (factory instanceof StorageBrowserPolicyFactory_js_1.StorageBrowserPolicyFactory)
      return !0;
    return factory.constructor.name === "StorageBrowserPolicyFactory";
  }
  function isStorageRetryPolicyFactory(factory) {
    if (factory instanceof StorageRetryPolicyFactory_js_1.StorageRetryPolicyFactory)
      return !0;
    return factory.constructor.name === "StorageRetryPolicyFactory";
  }
  function isStorageTelemetryPolicyFactory(factory) {
    return factory.constructor.name === "TelemetryPolicyFactory";
  }
  function isInjectorPolicyFactory(factory) {
    return factory.constructor.name === "InjectorPolicyFactory";
  }
  function isCoreHttpPolicyFactory(factory) {
    let knownPolicies = [
      "GenerateClientRequestIdPolicy",
      "TracingPolicy",
      "LogPolicy",
      "ProxyPolicy",
      "DisableResponseDecompressionPolicy",
      "KeepAlivePolicy",
      "DeserializationPolicy"
    ], mockHttpClient = {
      sendRequest: async (request) => {
        return {
          request,
          headers: request.headers.clone(),
          status: 500
        };
      }
    }, mockRequestPolicyOptions = {
      log(_logLevel, _message) {},
      shouldLog(_logLevel) {
        return !1;
      }
    }, policyName = factory.create(mockHttpClient, mockRequestPolicyOptions).constructor.name;
    return knownPolicies.some((knownPolicyName) => {
      return policyName.startsWith(knownPolicyName);
    });
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/index.js
var require_models = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.KnownStorageErrorCode = exports.KnownBlobExpiryOptions = exports.KnownFileShareTokenIntent = exports.KnownEncryptionAlgorithmType = void 0;
  var KnownEncryptionAlgorithmType;
  (function(KnownEncryptionAlgorithmType2) {
    KnownEncryptionAlgorithmType2.AES256 = "AES256";
  })(KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
  var KnownFileShareTokenIntent;
  (function(KnownFileShareTokenIntent2) {
    KnownFileShareTokenIntent2.Backup = "backup";
  })(KnownFileShareTokenIntent || (exports.KnownFileShareTokenIntent = KnownFileShareTokenIntent = {}));
  var KnownBlobExpiryOptions;
  (function(KnownBlobExpiryOptions2) {
    KnownBlobExpiryOptions2.NeverExpire = "NeverExpire", KnownBlobExpiryOptions2.RelativeToCreation = "RelativeToCreation", KnownBlobExpiryOptions2.RelativeToNow = "RelativeToNow", KnownBlobExpiryOptions2.Absolute = "Absolute";
  })(KnownBlobExpiryOptions || (exports.KnownBlobExpiryOptions = KnownBlobExpiryOptions = {}));
  var KnownStorageErrorCode;
  (function(KnownStorageErrorCode2) {
    KnownStorageErrorCode2.AccountAlreadyExists = "AccountAlreadyExists", KnownStorageErrorCode2.AccountBeingCreated = "AccountBeingCreated", KnownStorageErrorCode2.AccountIsDisabled = "AccountIsDisabled", KnownStorageErrorCode2.AuthenticationFailed = "AuthenticationFailed", KnownStorageErrorCode2.AuthorizationFailure = "AuthorizationFailure", KnownStorageErrorCode2.ConditionHeadersNotSupported = "ConditionHeadersNotSupported", KnownStorageErrorCode2.ConditionNotMet = "ConditionNotMet", KnownStorageErrorCode2.EmptyMetadataKey = "EmptyMetadataKey", KnownStorageErrorCode2.InsufficientAccountPermissions = "InsufficientAccountPermissions", KnownStorageErrorCode2.InternalError = "InternalError", KnownStorageErrorCode2.InvalidAuthenticationInfo = "InvalidAuthenticationInfo", KnownStorageErrorCode2.InvalidHeaderValue = "InvalidHeaderValue", KnownStorageErrorCode2.InvalidHttpVerb = "InvalidHttpVerb", KnownStorageErrorCode2.InvalidInput = "InvalidInput", KnownStorageErrorCode2.InvalidMd5 = "InvalidMd5", KnownStorageErrorCode2.InvalidMetadata = "InvalidMetadata", KnownStorageErrorCode2.InvalidQueryParameterValue = "InvalidQueryParameterValue", KnownStorageErrorCode2.InvalidRange = "InvalidRange", KnownStorageErrorCode2.InvalidResourceName = "InvalidResourceName", KnownStorageErrorCode2.InvalidUri = "InvalidUri", KnownStorageErrorCode2.InvalidXmlDocument = "InvalidXmlDocument", KnownStorageErrorCode2.InvalidXmlNodeValue = "InvalidXmlNodeValue", KnownStorageErrorCode2.Md5Mismatch = "Md5Mismatch", KnownStorageErrorCode2.MetadataTooLarge = "MetadataTooLarge", KnownStorageErrorCode2.MissingContentLengthHeader = "MissingContentLengthHeader", KnownStorageErrorCode2.MissingRequiredQueryParameter = "MissingRequiredQueryParameter", KnownStorageErrorCode2.MissingRequiredHeader = "MissingRequiredHeader", KnownStorageErrorCode2.MissingRequiredXmlNode = "MissingRequiredXmlNode", KnownStorageErrorCode2.MultipleConditionHeadersNotSupported = "MultipleConditionHeadersNotSupported", KnownStorageErrorCode2.OperationTimedOut = "OperationTimedOut", KnownStorageErrorCode2.OutOfRangeInput = "OutOfRangeInput", KnownStorageErrorCode2.OutOfRangeQueryParameterValue = "OutOfRangeQueryParameterValue", KnownStorageErrorCode2.RequestBodyTooLarge = "RequestBodyTooLarge", KnownStorageErrorCode2.ResourceTypeMismatch = "ResourceTypeMismatch", KnownStorageErrorCode2.RequestUrlFailedToParse = "RequestUrlFailedToParse", KnownStorageErrorCode2.ResourceAlreadyExists = "ResourceAlreadyExists", KnownStorageErrorCode2.ResourceNotFound = "ResourceNotFound", KnownStorageErrorCode2.ServerBusy = "ServerBusy", KnownStorageErrorCode2.UnsupportedHeader = "UnsupportedHeader", KnownStorageErrorCode2.UnsupportedXmlNode = "UnsupportedXmlNode", KnownStorageErrorCode2.UnsupportedQueryParameter = "UnsupportedQueryParameter", KnownStorageErrorCode2.UnsupportedHttpVerb = "UnsupportedHttpVerb", KnownStorageErrorCode2.AppendPositionConditionNotMet = "AppendPositionConditionNotMet", KnownStorageErrorCode2.BlobAlreadyExists = "BlobAlreadyExists", KnownStorageErrorCode2.BlobImmutableDueToPolicy = "BlobImmutableDueToPolicy", KnownStorageErrorCode2.BlobNotFound = "BlobNotFound", KnownStorageErrorCode2.BlobOverwritten = "BlobOverwritten", KnownStorageErrorCode2.BlobTierInadequateForContentLength = "BlobTierInadequateForContentLength", KnownStorageErrorCode2.BlobUsesCustomerSpecifiedEncryption = "BlobUsesCustomerSpecifiedEncryption", KnownStorageErrorCode2.BlockCountExceedsLimit = "BlockCountExceedsLimit", KnownStorageErrorCode2.BlockListTooLong = "BlockListTooLong", KnownStorageErrorCode2.CannotChangeToLowerTier = "CannotChangeToLowerTier", KnownStorageErrorCode2.CannotVerifyCopySource = "CannotVerifyCopySource", KnownStorageErrorCode2.ContainerAlreadyExists = "ContainerAlreadyExists", KnownStorageErrorCode2.ContainerBeingDeleted = "ContainerBeingDeleted", KnownStorageErrorCode2.ContainerDisabled = "ContainerDisabled", KnownStorageErrorCode2.ContainerNotFound = "ContainerNotFound", KnownStorageErrorCode2.ContentLengthLargerThanTierLimit = "ContentLengthLargerThanTierLimit", KnownStorageErrorCode2.CopyAcrossAccountsNotSupported = "CopyAcrossAccountsNotSupported", KnownStorageErrorCode2.CopyIdMismatch = "CopyIdMismatch", KnownStorageErrorCode2.FeatureVersionMismatch = "FeatureVersionMismatch", KnownStorageErrorCode2.IncrementalCopyBlobMismatch = "IncrementalCopyBlobMismatch", KnownStorageErrorCode2.IncrementalCopyOfEarlierVersionSnapshotNotAllowed = "IncrementalCopyOfEarlierVersionSnapshotNotAllowed", KnownStorageErrorCode2.IncrementalCopySourceMustBeSnapshot = "IncrementalCopySourceMustBeSnapshot", KnownStorageErrorCode2.InfiniteLeaseDurationRequired = "InfiniteLeaseDurationRequired", KnownStorageErrorCode2.InvalidBlobOrBlock = "InvalidBlobOrBlock", KnownStorageErrorCode2.InvalidBlobTier = "InvalidBlobTier", KnownStorageErrorCode2.InvalidBlobType = "InvalidBlobType", KnownStorageErrorCode2.InvalidBlockId = "InvalidBlockId", KnownStorageErrorCode2.InvalidBlockList = "InvalidBlockList", KnownStorageErrorCode2.InvalidOperation = "InvalidOperation", KnownStorageErrorCode2.InvalidPageRange = "InvalidPageRange", KnownStorageErrorCode2.InvalidSourceBlobType = "InvalidSourceBlobType", KnownStorageErrorCode2.InvalidSourceBlobUrl = "InvalidSourceBlobUrl", KnownStorageErrorCode2.InvalidVersionForPageBlobOperation = "InvalidVersionForPageBlobOperation", KnownStorageErrorCode2.LeaseAlreadyPresent = "LeaseAlreadyPresent", KnownStorageErrorCode2.LeaseAlreadyBroken = "LeaseAlreadyBroken", KnownStorageErrorCode2.LeaseIdMismatchWithBlobOperation = "LeaseIdMismatchWithBlobOperation", KnownStorageErrorCode2.LeaseIdMismatchWithContainerOperation = "LeaseIdMismatchWithContainerOperation", KnownStorageErrorCode2.LeaseIdMismatchWithLeaseOperation = "LeaseIdMismatchWithLeaseOperation", KnownStorageErrorCode2.LeaseIdMissing = "LeaseIdMissing", KnownStorageErrorCode2.LeaseIsBreakingAndCannotBeAcquired = "LeaseIsBreakingAndCannotBeAcquired", KnownStorageErrorCode2.LeaseIsBreakingAndCannotBeChanged = "LeaseIsBreakingAndCannotBeChanged", KnownStorageErrorCode2.LeaseIsBrokenAndCannotBeRenewed = "LeaseIsBrokenAndCannotBeRenewed", KnownStorageErrorCode2.LeaseLost = "LeaseLost", KnownStorageErrorCode2.LeaseNotPresentWithBlobOperation = "LeaseNotPresentWithBlobOperation", KnownStorageErrorCode2.LeaseNotPresentWithContainerOperation = "LeaseNotPresentWithContainerOperation", KnownStorageErrorCode2.LeaseNotPresentWithLeaseOperation = "LeaseNotPresentWithLeaseOperation", KnownStorageErrorCode2.MaxBlobSizeConditionNotMet = "MaxBlobSizeConditionNotMet", KnownStorageErrorCode2.NoAuthenticationInformation = "NoAuthenticationInformation", KnownStorageErrorCode2.NoPendingCopyOperation = "NoPendingCopyOperation", KnownStorageErrorCode2.OperationNotAllowedOnIncrementalCopyBlob = "OperationNotAllowedOnIncrementalCopyBlob", KnownStorageErrorCode2.PendingCopyOperation = "PendingCopyOperation", KnownStorageErrorCode2.PreviousSnapshotCannotBeNewer = "PreviousSnapshotCannotBeNewer", KnownStorageErrorCode2.PreviousSnapshotNotFound = "PreviousSnapshotNotFound", KnownStorageErrorCode2.PreviousSnapshotOperationNotSupported = "PreviousSnapshotOperationNotSupported", KnownStorageErrorCode2.SequenceNumberConditionNotMet = "SequenceNumberConditionNotMet", KnownStorageErrorCode2.SequenceNumberIncrementTooLarge = "SequenceNumberIncrementTooLarge", KnownStorageErrorCode2.SnapshotCountExceeded = "SnapshotCountExceeded", KnownStorageErrorCode2.SnapshotOperationRateExceeded = "SnapshotOperationRateExceeded", KnownStorageErrorCode2.SnapshotsPresent = "SnapshotsPresent", KnownStorageErrorCode2.SourceConditionNotMet = "SourceConditionNotMet", KnownStorageErrorCode2.SystemInUse = "SystemInUse", KnownStorageErrorCode2.TargetConditionNotMet = "TargetConditionNotMet", KnownStorageErrorCode2.UnauthorizedBlobOverwrite = "UnauthorizedBlobOverwrite", KnownStorageErrorCode2.BlobBeingRehydrated = "BlobBeingRehydrated", KnownStorageErrorCode2.BlobArchived = "BlobArchived", KnownStorageErrorCode2.BlobNotArchived = "BlobNotArchived", KnownStorageErrorCode2.AuthorizationSourceIPMismatch = "AuthorizationSourceIPMismatch", KnownStorageErrorCode2.AuthorizationProtocolMismatch = "AuthorizationProtocolMismatch", KnownStorageErrorCode2.AuthorizationPermissionMismatch = "AuthorizationPermissionMismatch", KnownStorageErrorCode2.AuthorizationServiceMismatch = "AuthorizationServiceMismatch", KnownStorageErrorCode2.AuthorizationResourceTypeMismatch = "AuthorizationResourceTypeMismatch", KnownStorageErrorCode2.BlobAccessTierNotSupportedForAccountType = "BlobAccessTierNotSupportedForAccountType";
  })(KnownStorageErrorCode || (exports.KnownStorageErrorCode = KnownStorageErrorCode = {}));
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/mappers.js
var require_mappers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ServiceGetUserDelegationKeyHeaders = exports.ServiceListContainersSegmentExceptionHeaders = exports.ServiceListContainersSegmentHeaders = exports.ServiceGetStatisticsExceptionHeaders = exports.ServiceGetStatisticsHeaders = exports.ServiceGetPropertiesExceptionHeaders = exports.ServiceGetPropertiesHeaders = exports.ServiceSetPropertiesExceptionHeaders = exports.ServiceSetPropertiesHeaders = exports.ArrowField = exports.ArrowConfiguration = exports.JsonTextConfiguration = exports.DelimitedTextConfiguration = exports.QueryFormat = exports.QuerySerialization = exports.QueryRequest = exports.ClearRange = exports.PageRange = exports.PageList = exports.Block = exports.BlockList = exports.BlockLookupList = exports.BlobPrefix = exports.BlobHierarchyListSegment = exports.ListBlobsHierarchySegmentResponse = exports.BlobPropertiesInternal = exports.BlobName = exports.BlobItemInternal = exports.BlobFlatListSegment = exports.ListBlobsFlatSegmentResponse = exports.AccessPolicy = exports.SignedIdentifier = exports.BlobTag = exports.BlobTags = exports.FilterBlobItem = exports.FilterBlobSegment = exports.UserDelegationKey = exports.KeyInfo = exports.ContainerProperties = exports.ContainerItem = exports.ListContainersSegmentResponse = exports.GeoReplication = exports.BlobServiceStatistics = exports.StorageError = exports.StaticWebsite = exports.CorsRule = exports.Metrics = exports.RetentionPolicy = exports.Logging = exports.BlobServiceProperties = void 0;
  exports.BlobUndeleteHeaders = exports.BlobDeleteExceptionHeaders = exports.BlobDeleteHeaders = exports.BlobGetPropertiesExceptionHeaders = exports.BlobGetPropertiesHeaders = exports.BlobDownloadExceptionHeaders = exports.BlobDownloadHeaders = exports.ContainerGetAccountInfoExceptionHeaders = exports.ContainerGetAccountInfoHeaders = exports.ContainerListBlobHierarchySegmentExceptionHeaders = exports.ContainerListBlobHierarchySegmentHeaders = exports.ContainerListBlobFlatSegmentExceptionHeaders = exports.ContainerListBlobFlatSegmentHeaders = exports.ContainerChangeLeaseExceptionHeaders = exports.ContainerChangeLeaseHeaders = exports.ContainerBreakLeaseExceptionHeaders = exports.ContainerBreakLeaseHeaders = exports.ContainerRenewLeaseExceptionHeaders = exports.ContainerRenewLeaseHeaders = exports.ContainerReleaseLeaseExceptionHeaders = exports.ContainerReleaseLeaseHeaders = exports.ContainerAcquireLeaseExceptionHeaders = exports.ContainerAcquireLeaseHeaders = exports.ContainerFilterBlobsExceptionHeaders = exports.ContainerFilterBlobsHeaders = exports.ContainerSubmitBatchExceptionHeaders = exports.ContainerSubmitBatchHeaders = exports.ContainerRenameExceptionHeaders = exports.ContainerRenameHeaders = exports.ContainerRestoreExceptionHeaders = exports.ContainerRestoreHeaders = exports.ContainerSetAccessPolicyExceptionHeaders = exports.ContainerSetAccessPolicyHeaders = exports.ContainerGetAccessPolicyExceptionHeaders = exports.ContainerGetAccessPolicyHeaders = exports.ContainerSetMetadataExceptionHeaders = exports.ContainerSetMetadataHeaders = exports.ContainerDeleteExceptionHeaders = exports.ContainerDeleteHeaders = exports.ContainerGetPropertiesExceptionHeaders = exports.ContainerGetPropertiesHeaders = exports.ContainerCreateExceptionHeaders = exports.ContainerCreateHeaders = exports.ServiceFilterBlobsExceptionHeaders = exports.ServiceFilterBlobsHeaders = exports.ServiceSubmitBatchExceptionHeaders = exports.ServiceSubmitBatchHeaders = exports.ServiceGetAccountInfoExceptionHeaders = exports.ServiceGetAccountInfoHeaders = exports.ServiceGetUserDelegationKeyExceptionHeaders = void 0;
  exports.PageBlobGetPageRangesHeaders = exports.PageBlobUploadPagesFromURLExceptionHeaders = exports.PageBlobUploadPagesFromURLHeaders = exports.PageBlobClearPagesExceptionHeaders = exports.PageBlobClearPagesHeaders = exports.PageBlobUploadPagesExceptionHeaders = exports.PageBlobUploadPagesHeaders = exports.PageBlobCreateExceptionHeaders = exports.PageBlobCreateHeaders = exports.BlobSetTagsExceptionHeaders = exports.BlobSetTagsHeaders = exports.BlobGetTagsExceptionHeaders = exports.BlobGetTagsHeaders = exports.BlobQueryExceptionHeaders = exports.BlobQueryHeaders = exports.BlobGetAccountInfoExceptionHeaders = exports.BlobGetAccountInfoHeaders = exports.BlobSetTierExceptionHeaders = exports.BlobSetTierHeaders = exports.BlobAbortCopyFromURLExceptionHeaders = exports.BlobAbortCopyFromURLHeaders = exports.BlobCopyFromURLExceptionHeaders = exports.BlobCopyFromURLHeaders = exports.BlobStartCopyFromURLExceptionHeaders = exports.BlobStartCopyFromURLHeaders = exports.BlobCreateSnapshotExceptionHeaders = exports.BlobCreateSnapshotHeaders = exports.BlobBreakLeaseExceptionHeaders = exports.BlobBreakLeaseHeaders = exports.BlobChangeLeaseExceptionHeaders = exports.BlobChangeLeaseHeaders = exports.BlobRenewLeaseExceptionHeaders = exports.BlobRenewLeaseHeaders = exports.BlobReleaseLeaseExceptionHeaders = exports.BlobReleaseLeaseHeaders = exports.BlobAcquireLeaseExceptionHeaders = exports.BlobAcquireLeaseHeaders = exports.BlobSetMetadataExceptionHeaders = exports.BlobSetMetadataHeaders = exports.BlobSetLegalHoldExceptionHeaders = exports.BlobSetLegalHoldHeaders = exports.BlobDeleteImmutabilityPolicyExceptionHeaders = exports.BlobDeleteImmutabilityPolicyHeaders = exports.BlobSetImmutabilityPolicyExceptionHeaders = exports.BlobSetImmutabilityPolicyHeaders = exports.BlobSetHttpHeadersExceptionHeaders = exports.BlobSetHttpHeadersHeaders = exports.BlobSetExpiryExceptionHeaders = exports.BlobSetExpiryHeaders = exports.BlobUndeleteExceptionHeaders = void 0;
  exports.BlockBlobGetBlockListExceptionHeaders = exports.BlockBlobGetBlockListHeaders = exports.BlockBlobCommitBlockListExceptionHeaders = exports.BlockBlobCommitBlockListHeaders = exports.BlockBlobStageBlockFromURLExceptionHeaders = exports.BlockBlobStageBlockFromURLHeaders = exports.BlockBlobStageBlockExceptionHeaders = exports.BlockBlobStageBlockHeaders = exports.BlockBlobPutBlobFromUrlExceptionHeaders = exports.BlockBlobPutBlobFromUrlHeaders = exports.BlockBlobUploadExceptionHeaders = exports.BlockBlobUploadHeaders = exports.AppendBlobSealExceptionHeaders = exports.AppendBlobSealHeaders = exports.AppendBlobAppendBlockFromUrlExceptionHeaders = exports.AppendBlobAppendBlockFromUrlHeaders = exports.AppendBlobAppendBlockExceptionHeaders = exports.AppendBlobAppendBlockHeaders = exports.AppendBlobCreateExceptionHeaders = exports.AppendBlobCreateHeaders = exports.PageBlobCopyIncrementalExceptionHeaders = exports.PageBlobCopyIncrementalHeaders = exports.PageBlobUpdateSequenceNumberExceptionHeaders = exports.PageBlobUpdateSequenceNumberHeaders = exports.PageBlobResizeExceptionHeaders = exports.PageBlobResizeHeaders = exports.PageBlobGetPageRangesDiffExceptionHeaders = exports.PageBlobGetPageRangesDiffHeaders = exports.PageBlobGetPageRangesExceptionHeaders = void 0;
  exports.BlobServiceProperties = {
    serializedName: "BlobServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
      name: "Composite",
      className: "BlobServiceProperties",
      modelProperties: {
        blobAnalyticsLogging: {
          serializedName: "Logging",
          xmlName: "Logging",
          type: {
            name: "Composite",
            className: "Logging"
          }
        },
        hourMetrics: {
          serializedName: "HourMetrics",
          xmlName: "HourMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        minuteMetrics: {
          serializedName: "MinuteMetrics",
          xmlName: "MinuteMetrics",
          type: {
            name: "Composite",
            className: "Metrics"
          }
        },
        cors: {
          serializedName: "Cors",
          xmlName: "Cors",
          xmlIsWrapped: !0,
          xmlElementName: "CorsRule",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "CorsRule"
              }
            }
          }
        },
        defaultServiceVersion: {
          serializedName: "DefaultServiceVersion",
          xmlName: "DefaultServiceVersion",
          type: {
            name: "String"
          }
        },
        deleteRetentionPolicy: {
          serializedName: "DeleteRetentionPolicy",
          xmlName: "DeleteRetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        },
        staticWebsite: {
          serializedName: "StaticWebsite",
          xmlName: "StaticWebsite",
          type: {
            name: "Composite",
            className: "StaticWebsite"
          }
        }
      }
    }
  };
  exports.Logging = {
    serializedName: "Logging",
    type: {
      name: "Composite",
      className: "Logging",
      modelProperties: {
        version: {
          serializedName: "Version",
          required: !0,
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        deleteProperty: {
          serializedName: "Delete",
          required: !0,
          xmlName: "Delete",
          type: {
            name: "Boolean"
          }
        },
        read: {
          serializedName: "Read",
          required: !0,
          xmlName: "Read",
          type: {
            name: "Boolean"
          }
        },
        write: {
          serializedName: "Write",
          required: !0,
          xmlName: "Write",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  exports.RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
      name: "Composite",
      className: "RetentionPolicy",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: !0,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        days: {
          constraints: {
            InclusiveMinimum: 1
          },
          serializedName: "Days",
          xmlName: "Days",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.Metrics = {
    serializedName: "Metrics",
    type: {
      name: "Composite",
      className: "Metrics",
      modelProperties: {
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        enabled: {
          serializedName: "Enabled",
          required: !0,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        includeAPIs: {
          serializedName: "IncludeAPIs",
          xmlName: "IncludeAPIs",
          type: {
            name: "Boolean"
          }
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: {
            name: "Composite",
            className: "RetentionPolicy"
          }
        }
      }
    }
  };
  exports.CorsRule = {
    serializedName: "CorsRule",
    type: {
      name: "Composite",
      className: "CorsRule",
      modelProperties: {
        allowedOrigins: {
          serializedName: "AllowedOrigins",
          required: !0,
          xmlName: "AllowedOrigins",
          type: {
            name: "String"
          }
        },
        allowedMethods: {
          serializedName: "AllowedMethods",
          required: !0,
          xmlName: "AllowedMethods",
          type: {
            name: "String"
          }
        },
        allowedHeaders: {
          serializedName: "AllowedHeaders",
          required: !0,
          xmlName: "AllowedHeaders",
          type: {
            name: "String"
          }
        },
        exposedHeaders: {
          serializedName: "ExposedHeaders",
          required: !0,
          xmlName: "ExposedHeaders",
          type: {
            name: "String"
          }
        },
        maxAgeInSeconds: {
          constraints: {
            InclusiveMinimum: 0
          },
          serializedName: "MaxAgeInSeconds",
          required: !0,
          xmlName: "MaxAgeInSeconds",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.StaticWebsite = {
    serializedName: "StaticWebsite",
    type: {
      name: "Composite",
      className: "StaticWebsite",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: !0,
          xmlName: "Enabled",
          type: {
            name: "Boolean"
          }
        },
        indexDocument: {
          serializedName: "IndexDocument",
          xmlName: "IndexDocument",
          type: {
            name: "String"
          }
        },
        errorDocument404Path: {
          serializedName: "ErrorDocument404Path",
          xmlName: "ErrorDocument404Path",
          type: {
            name: "String"
          }
        },
        defaultIndexDocumentPath: {
          serializedName: "DefaultIndexDocumentPath",
          xmlName: "DefaultIndexDocumentPath",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.StorageError = {
    serializedName: "StorageError",
    type: {
      name: "Composite",
      className: "StorageError",
      modelProperties: {
        message: {
          serializedName: "Message",
          xmlName: "Message",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "CopySourceStatusCode",
          xmlName: "CopySourceStatusCode",
          type: {
            name: "Number"
          }
        },
        copySourceErrorCode: {
          serializedName: "CopySourceErrorCode",
          xmlName: "CopySourceErrorCode",
          type: {
            name: "String"
          }
        },
        copySourceErrorMessage: {
          serializedName: "CopySourceErrorMessage",
          xmlName: "CopySourceErrorMessage",
          type: {
            name: "String"
          }
        },
        code: {
          serializedName: "Code",
          xmlName: "Code",
          type: {
            name: "String"
          }
        },
        authenticationErrorDetail: {
          serializedName: "AuthenticationErrorDetail",
          xmlName: "AuthenticationErrorDetail",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobServiceStatistics = {
    serializedName: "BlobServiceStatistics",
    xmlName: "StorageServiceStats",
    type: {
      name: "Composite",
      className: "BlobServiceStatistics",
      modelProperties: {
        geoReplication: {
          serializedName: "GeoReplication",
          xmlName: "GeoReplication",
          type: {
            name: "Composite",
            className: "GeoReplication"
          }
        }
      }
    }
  };
  exports.GeoReplication = {
    serializedName: "GeoReplication",
    type: {
      name: "Composite",
      className: "GeoReplication",
      modelProperties: {
        status: {
          serializedName: "Status",
          required: !0,
          xmlName: "Status",
          type: {
            name: "Enum",
            allowedValues: ["live", "bootstrap", "unavailable"]
          }
        },
        lastSyncOn: {
          serializedName: "LastSyncTime",
          required: !0,
          xmlName: "LastSyncTime",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ListContainersSegmentResponse = {
    serializedName: "ListContainersSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListContainersSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: !0,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: !0,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        containerItems: {
          serializedName: "ContainerItems",
          required: !0,
          xmlName: "Containers",
          xmlIsWrapped: !0,
          xmlElementName: "Container",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ContainerItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerItem = {
    serializedName: "ContainerItem",
    xmlName: "Container",
    type: {
      name: "Composite",
      className: "ContainerItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: !0,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        deleted: {
          serializedName: "Deleted",
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: {
            name: "String"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "ContainerProperties"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        }
      }
    }
  };
  exports.ContainerProperties = {
    serializedName: "ContainerProperties",
    type: {
      name: "Composite",
      className: "ContainerProperties",
      modelProperties: {
        lastModified: {
          serializedName: "Last-Modified",
          required: !0,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: !0,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        publicAccess: {
          serializedName: "PublicAccess",
          xmlName: "PublicAccess",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "HasImmutabilityPolicy",
          xmlName: "HasImmutabilityPolicy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "HasLegalHold",
          xmlName: "HasLegalHold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "DefaultEncryptionScope",
          xmlName: "DefaultEncryptionScope",
          type: {
            name: "String"
          }
        },
        preventEncryptionScopeOverride: {
          serializedName: "DenyEncryptionScopeOverride",
          xmlName: "DenyEncryptionScopeOverride",
          type: {
            name: "Boolean"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "ImmutableStorageWithVersioningEnabled",
          xmlName: "ImmutableStorageWithVersioningEnabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.KeyInfo = {
    serializedName: "KeyInfo",
    type: {
      name: "Composite",
      className: "KeyInfo",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          required: !0,
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          required: !0,
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.UserDelegationKey = {
    serializedName: "UserDelegationKey",
    type: {
      name: "Composite",
      className: "UserDelegationKey",
      modelProperties: {
        signedObjectId: {
          serializedName: "SignedOid",
          required: !0,
          xmlName: "SignedOid",
          type: {
            name: "String"
          }
        },
        signedTenantId: {
          serializedName: "SignedTid",
          required: !0,
          xmlName: "SignedTid",
          type: {
            name: "String"
          }
        },
        signedStartsOn: {
          serializedName: "SignedStart",
          required: !0,
          xmlName: "SignedStart",
          type: {
            name: "String"
          }
        },
        signedExpiresOn: {
          serializedName: "SignedExpiry",
          required: !0,
          xmlName: "SignedExpiry",
          type: {
            name: "String"
          }
        },
        signedService: {
          serializedName: "SignedService",
          required: !0,
          xmlName: "SignedService",
          type: {
            name: "String"
          }
        },
        signedVersion: {
          serializedName: "SignedVersion",
          required: !0,
          xmlName: "SignedVersion",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: !0,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.FilterBlobSegment = {
    serializedName: "FilterBlobSegment",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "FilterBlobSegment",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: !0,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: !0,
          type: {
            name: "String"
          }
        },
        where: {
          serializedName: "Where",
          required: !0,
          xmlName: "Where",
          type: {
            name: "String"
          }
        },
        blobs: {
          serializedName: "Blobs",
          required: !0,
          xmlName: "Blobs",
          xmlIsWrapped: !0,
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "FilterBlobItem"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.FilterBlobItem = {
    serializedName: "FilterBlobItem",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "FilterBlobItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: !0,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: !0,
          xmlName: "ContainerName",
          type: {
            name: "String"
          }
        },
        tags: {
          serializedName: "Tags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        }
      }
    }
  };
  exports.BlobTags = {
    serializedName: "BlobTags",
    xmlName: "Tags",
    type: {
      name: "Composite",
      className: "BlobTags",
      modelProperties: {
        blobTagSet: {
          serializedName: "BlobTagSet",
          required: !0,
          xmlName: "TagSet",
          xmlIsWrapped: !0,
          xmlElementName: "Tag",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobTag"
              }
            }
          }
        }
      }
    }
  };
  exports.BlobTag = {
    serializedName: "BlobTag",
    xmlName: "Tag",
    type: {
      name: "Composite",
      className: "BlobTag",
      modelProperties: {
        key: {
          serializedName: "Key",
          required: !0,
          xmlName: "Key",
          type: {
            name: "String"
          }
        },
        value: {
          serializedName: "Value",
          required: !0,
          xmlName: "Value",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.SignedIdentifier = {
    serializedName: "SignedIdentifier",
    xmlName: "SignedIdentifier",
    type: {
      name: "Composite",
      className: "SignedIdentifier",
      modelProperties: {
        id: {
          serializedName: "Id",
          required: !0,
          xmlName: "Id",
          type: {
            name: "String"
          }
        },
        accessPolicy: {
          serializedName: "AccessPolicy",
          xmlName: "AccessPolicy",
          type: {
            name: "Composite",
            className: "AccessPolicy"
          }
        }
      }
    }
  };
  exports.AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
      name: "Composite",
      className: "AccessPolicy",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          xmlName: "Start",
          type: {
            name: "String"
          }
        },
        expiresOn: {
          serializedName: "Expiry",
          xmlName: "Expiry",
          type: {
            name: "String"
          }
        },
        permissions: {
          serializedName: "Permission",
          xmlName: "Permission",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ListBlobsFlatSegmentResponse = {
    serializedName: "ListBlobsFlatSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsFlatSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: !0,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: !0,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: !0,
          xmlName: "ContainerName",
          xmlIsAttribute: !0,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobFlatListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobFlatListSegment = {
    serializedName: "BlobFlatListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobFlatListSegment",
      modelProperties: {
        blobItems: {
          serializedName: "BlobItems",
          required: !0,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  exports.BlobItemInternal = {
    serializedName: "BlobItemInternal",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "BlobItemInternal",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        },
        deleted: {
          serializedName: "Deleted",
          required: !0,
          xmlName: "Deleted",
          type: {
            name: "Boolean"
          }
        },
        snapshot: {
          serializedName: "Snapshot",
          required: !0,
          xmlName: "Snapshot",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "VersionId",
          xmlName: "VersionId",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "IsCurrentVersion",
          xmlName: "IsCurrentVersion",
          type: {
            name: "Boolean"
          }
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: {
            name: "Composite",
            className: "BlobPropertiesInternal"
          }
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobTags: {
          serializedName: "BlobTags",
          xmlName: "Tags",
          type: {
            name: "Composite",
            className: "BlobTags"
          }
        },
        objectReplicationMetadata: {
          serializedName: "ObjectReplicationMetadata",
          xmlName: "OrMetadata",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        hasVersionsOnly: {
          serializedName: "HasVersionsOnly",
          xmlName: "HasVersionsOnly",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.BlobName = {
    serializedName: "BlobName",
    type: {
      name: "Composite",
      className: "BlobName",
      modelProperties: {
        encoded: {
          serializedName: "Encoded",
          xmlName: "Encoded",
          xmlIsAttribute: !0,
          type: {
            name: "Boolean"
          }
        },
        content: {
          serializedName: "content",
          xmlName: "content",
          xmlIsMsText: !0,
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobPropertiesInternal = {
    serializedName: "BlobPropertiesInternal",
    xmlName: "Properties",
    type: {
      name: "Composite",
      className: "BlobPropertiesInternal",
      modelProperties: {
        createdOn: {
          serializedName: "Creation-Time",
          xmlName: "Creation-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        lastModified: {
          serializedName: "Last-Modified",
          required: !0,
          xmlName: "Last-Modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "Etag",
          required: !0,
          xmlName: "Etag",
          type: {
            name: "String"
          }
        },
        contentLength: {
          serializedName: "Content-Length",
          xmlName: "Content-Length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "Content-Type",
          xmlName: "Content-Type",
          type: {
            name: "String"
          }
        },
        contentEncoding: {
          serializedName: "Content-Encoding",
          xmlName: "Content-Encoding",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "Content-Language",
          xmlName: "Content-Language",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "Content-MD5",
          xmlName: "Content-MD5",
          type: {
            name: "ByteArray"
          }
        },
        contentDisposition: {
          serializedName: "Content-Disposition",
          xmlName: "Content-Disposition",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "Cache-Control",
          xmlName: "Cache-Control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "BlobType",
          xmlName: "BlobType",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        copyId: {
          serializedName: "CopyId",
          xmlName: "CopyId",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "CopyStatus",
          xmlName: "CopyStatus",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        copySource: {
          serializedName: "CopySource",
          xmlName: "CopySource",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "CopyProgress",
          xmlName: "CopyProgress",
          type: {
            name: "String"
          }
        },
        copyCompletedOn: {
          serializedName: "CopyCompletionTime",
          xmlName: "CopyCompletionTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "CopyStatusDescription",
          xmlName: "CopyStatusDescription",
          type: {
            name: "String"
          }
        },
        serverEncrypted: {
          serializedName: "ServerEncrypted",
          xmlName: "ServerEncrypted",
          type: {
            name: "Boolean"
          }
        },
        incrementalCopy: {
          serializedName: "IncrementalCopy",
          xmlName: "IncrementalCopy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "DestinationSnapshot",
          xmlName: "DestinationSnapshot",
          type: {
            name: "String"
          }
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: {
            name: "Number"
          }
        },
        accessTier: {
          serializedName: "AccessTier",
          xmlName: "AccessTier",
          type: {
            name: "Enum",
            allowedValues: [
              "P4",
              "P6",
              "P10",
              "P15",
              "P20",
              "P30",
              "P40",
              "P50",
              "P60",
              "P70",
              "P80",
              "Hot",
              "Cool",
              "Archive",
              "Cold"
            ]
          }
        },
        accessTierInferred: {
          serializedName: "AccessTierInferred",
          xmlName: "AccessTierInferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "ArchiveStatus",
          xmlName: "ArchiveStatus",
          type: {
            name: "Enum",
            allowedValues: [
              "rehydrate-pending-to-hot",
              "rehydrate-pending-to-cool",
              "rehydrate-pending-to-cold"
            ]
          }
        },
        customerProvidedKeySha256: {
          serializedName: "CustomerProvidedKeySha256",
          xmlName: "CustomerProvidedKeySha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "EncryptionScope",
          xmlName: "EncryptionScope",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "AccessTierChangeTime",
          xmlName: "AccessTierChangeTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        tagCount: {
          serializedName: "TagCount",
          xmlName: "TagCount",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "Expiry-Time",
          xmlName: "Expiry-Time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "Sealed",
          xmlName: "Sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "RehydratePriority",
          xmlName: "RehydratePriority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessedOn: {
          serializedName: "LastAccessTime",
          xmlName: "LastAccessTime",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "ImmutabilityPolicyUntilDate",
          xmlName: "ImmutabilityPolicyUntilDate",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "ImmutabilityPolicyMode",
          xmlName: "ImmutabilityPolicyMode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "LegalHold",
          xmlName: "LegalHold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.ListBlobsHierarchySegmentResponse = {
    serializedName: "ListBlobsHierarchySegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsHierarchySegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: !0,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: !0,
          type: {
            name: "String"
          }
        },
        containerName: {
          serializedName: "ContainerName",
          required: !0,
          xmlName: "ContainerName",
          xmlIsAttribute: !0,
          type: {
            name: "String"
          }
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: {
            name: "String"
          }
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: {
            name: "String"
          }
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: {
            name: "Number"
          }
        },
        delimiter: {
          serializedName: "Delimiter",
          xmlName: "Delimiter",
          type: {
            name: "String"
          }
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: {
            name: "Composite",
            className: "BlobHierarchyListSegment"
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobHierarchyListSegment = {
    serializedName: "BlobHierarchyListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobHierarchyListSegment",
      modelProperties: {
        blobPrefixes: {
          serializedName: "BlobPrefixes",
          xmlName: "BlobPrefixes",
          xmlElementName: "BlobPrefix",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobPrefix"
              }
            }
          }
        },
        blobItems: {
          serializedName: "BlobItems",
          required: !0,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "BlobItemInternal"
              }
            }
          }
        }
      }
    }
  };
  exports.BlobPrefix = {
    serializedName: "BlobPrefix",
    type: {
      name: "Composite",
      className: "BlobPrefix",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "Composite",
            className: "BlobName"
          }
        }
      }
    }
  };
  exports.BlockLookupList = {
    serializedName: "BlockLookupList",
    xmlName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockLookupList",
      modelProperties: {
        committed: {
          serializedName: "Committed",
          xmlName: "Committed",
          xmlElementName: "Committed",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        uncommitted: {
          serializedName: "Uncommitted",
          xmlName: "Uncommitted",
          xmlElementName: "Uncommitted",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        },
        latest: {
          serializedName: "Latest",
          xmlName: "Latest",
          xmlElementName: "Latest",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "String"
              }
            }
          }
        }
      }
    }
  };
  exports.BlockList = {
    serializedName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockList",
      modelProperties: {
        committedBlocks: {
          serializedName: "CommittedBlocks",
          xmlName: "CommittedBlocks",
          xmlIsWrapped: !0,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        },
        uncommittedBlocks: {
          serializedName: "UncommittedBlocks",
          xmlName: "UncommittedBlocks",
          xmlIsWrapped: !0,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "Block"
              }
            }
          }
        }
      }
    }
  };
  exports.Block = {
    serializedName: "Block",
    type: {
      name: "Composite",
      className: "Block",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: !0,
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        size: {
          serializedName: "Size",
          required: !0,
          xmlName: "Size",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.PageList = {
    serializedName: "PageList",
    type: {
      name: "Composite",
      className: "PageList",
      modelProperties: {
        pageRange: {
          serializedName: "PageRange",
          xmlName: "PageRange",
          xmlElementName: "PageRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "PageRange"
              }
            }
          }
        },
        clearRange: {
          serializedName: "ClearRange",
          xmlName: "ClearRange",
          xmlElementName: "ClearRange",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ClearRange"
              }
            }
          }
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageRange = {
    serializedName: "PageRange",
    xmlName: "PageRange",
    type: {
      name: "Composite",
      className: "PageRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: !0,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: !0,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.ClearRange = {
    serializedName: "ClearRange",
    xmlName: "ClearRange",
    type: {
      name: "Composite",
      className: "ClearRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: !0,
          xmlName: "Start",
          type: {
            name: "Number"
          }
        },
        end: {
          serializedName: "End",
          required: !0,
          xmlName: "End",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.QueryRequest = {
    serializedName: "QueryRequest",
    xmlName: "QueryRequest",
    type: {
      name: "Composite",
      className: "QueryRequest",
      modelProperties: {
        queryType: {
          serializedName: "QueryType",
          required: !0,
          xmlName: "QueryType",
          type: {
            name: "String"
          }
        },
        expression: {
          serializedName: "Expression",
          required: !0,
          xmlName: "Expression",
          type: {
            name: "String"
          }
        },
        inputSerialization: {
          serializedName: "InputSerialization",
          xmlName: "InputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        },
        outputSerialization: {
          serializedName: "OutputSerialization",
          xmlName: "OutputSerialization",
          type: {
            name: "Composite",
            className: "QuerySerialization"
          }
        }
      }
    }
  };
  exports.QuerySerialization = {
    serializedName: "QuerySerialization",
    type: {
      name: "Composite",
      className: "QuerySerialization",
      modelProperties: {
        format: {
          serializedName: "Format",
          xmlName: "Format",
          type: {
            name: "Composite",
            className: "QueryFormat"
          }
        }
      }
    }
  };
  exports.QueryFormat = {
    serializedName: "QueryFormat",
    type: {
      name: "Composite",
      className: "QueryFormat",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: !0,
          xmlName: "Type",
          type: {
            name: "Enum",
            allowedValues: ["delimited", "json", "arrow", "parquet"]
          }
        },
        delimitedTextConfiguration: {
          serializedName: "DelimitedTextConfiguration",
          xmlName: "DelimitedTextConfiguration",
          type: {
            name: "Composite",
            className: "DelimitedTextConfiguration"
          }
        },
        jsonTextConfiguration: {
          serializedName: "JsonTextConfiguration",
          xmlName: "JsonTextConfiguration",
          type: {
            name: "Composite",
            className: "JsonTextConfiguration"
          }
        },
        arrowConfiguration: {
          serializedName: "ArrowConfiguration",
          xmlName: "ArrowConfiguration",
          type: {
            name: "Composite",
            className: "ArrowConfiguration"
          }
        },
        parquetTextConfiguration: {
          serializedName: "ParquetTextConfiguration",
          xmlName: "ParquetTextConfiguration",
          type: {
            name: "Dictionary",
            value: { type: { name: "any" } }
          }
        }
      }
    }
  };
  exports.DelimitedTextConfiguration = {
    serializedName: "DelimitedTextConfiguration",
    xmlName: "DelimitedTextConfiguration",
    type: {
      name: "Composite",
      className: "DelimitedTextConfiguration",
      modelProperties: {
        columnSeparator: {
          serializedName: "ColumnSeparator",
          xmlName: "ColumnSeparator",
          type: {
            name: "String"
          }
        },
        fieldQuote: {
          serializedName: "FieldQuote",
          xmlName: "FieldQuote",
          type: {
            name: "String"
          }
        },
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        },
        escapeChar: {
          serializedName: "EscapeChar",
          xmlName: "EscapeChar",
          type: {
            name: "String"
          }
        },
        headersPresent: {
          serializedName: "HeadersPresent",
          xmlName: "HasHeaders",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.JsonTextConfiguration = {
    serializedName: "JsonTextConfiguration",
    xmlName: "JsonTextConfiguration",
    type: {
      name: "Composite",
      className: "JsonTextConfiguration",
      modelProperties: {
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ArrowConfiguration = {
    serializedName: "ArrowConfiguration",
    xmlName: "ArrowConfiguration",
    type: {
      name: "Composite",
      className: "ArrowConfiguration",
      modelProperties: {
        schema: {
          serializedName: "Schema",
          required: !0,
          xmlName: "Schema",
          xmlIsWrapped: !0,
          xmlElementName: "Field",
          type: {
            name: "Sequence",
            element: {
              type: {
                name: "Composite",
                className: "ArrowField"
              }
            }
          }
        }
      }
    }
  };
  exports.ArrowField = {
    serializedName: "ArrowField",
    xmlName: "Field",
    type: {
      name: "Composite",
      className: "ArrowField",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: !0,
          xmlName: "Type",
          type: {
            name: "String"
          }
        },
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: {
            name: "String"
          }
        },
        precision: {
          serializedName: "Precision",
          xmlName: "Precision",
          type: {
            name: "Number"
          }
        },
        scale: {
          serializedName: "Scale",
          xmlName: "Scale",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetStatisticsHeaders = {
    serializedName: "Service_getStatisticsHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetStatisticsExceptionHeaders = {
    serializedName: "Service_getStatisticsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceListContainersSegmentHeaders = {
    serializedName: "Service_listContainersSegmentHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceListContainersSegmentExceptionHeaders = {
    serializedName: "Service_listContainersSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetUserDelegationKeyHeaders = {
    serializedName: "Service_getUserDelegationKeyHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetUserDelegationKeyExceptionHeaders = {
    serializedName: "Service_getUserDelegationKeyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetAccountInfoHeaders = {
    serializedName: "Service_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceGetAccountInfoExceptionHeaders = {
    serializedName: "Service_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceSubmitBatchHeaders = {
    serializedName: "Service_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceSubmitBatchExceptionHeaders = {
    serializedName: "Service_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceFilterBlobsHeaders = {
    serializedName: "Service_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ServiceFilterBlobsExceptionHeaders = {
    serializedName: "Service_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerCreateHeaders = {
    serializedName: "Container_createHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerCreateExceptionHeaders = {
    serializedName: "Container_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetPropertiesHeaders = {
    serializedName: "Container_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesHeaders",
      modelProperties: {
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        hasImmutabilityPolicy: {
          serializedName: "x-ms-has-immutability-policy",
          xmlName: "x-ms-has-immutability-policy",
          type: {
            name: "Boolean"
          }
        },
        hasLegalHold: {
          serializedName: "x-ms-has-legal-hold",
          xmlName: "x-ms-has-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        defaultEncryptionScope: {
          serializedName: "x-ms-default-encryption-scope",
          xmlName: "x-ms-default-encryption-scope",
          type: {
            name: "String"
          }
        },
        denyEncryptionScopeOverride: {
          serializedName: "x-ms-deny-encryption-scope-override",
          xmlName: "x-ms-deny-encryption-scope-override",
          type: {
            name: "Boolean"
          }
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "x-ms-immutable-storage-with-versioning-enabled",
          xmlName: "x-ms-immutable-storage-with-versioning-enabled",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetPropertiesExceptionHeaders = {
    serializedName: "Container_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerDeleteHeaders = {
    serializedName: "Container_deleteHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerDeleteExceptionHeaders = {
    serializedName: "Container_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSetMetadataHeaders = {
    serializedName: "Container_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSetMetadataExceptionHeaders = {
    serializedName: "Container_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetAccessPolicyHeaders = {
    serializedName: "Container_getAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyHeaders",
      modelProperties: {
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: {
            name: "Enum",
            allowedValues: ["container", "blob"]
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetAccessPolicyExceptionHeaders = {
    serializedName: "Container_getAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSetAccessPolicyHeaders = {
    serializedName: "Container_setAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSetAccessPolicyExceptionHeaders = {
    serializedName: "Container_setAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRestoreHeaders = {
    serializedName: "Container_restoreHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRestoreExceptionHeaders = {
    serializedName: "Container_restoreExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRenameHeaders = {
    serializedName: "Container_renameHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRenameExceptionHeaders = {
    serializedName: "Container_renameExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSubmitBatchHeaders = {
    serializedName: "Container_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerSubmitBatchExceptionHeaders = {
    serializedName: "Container_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerFilterBlobsHeaders = {
    serializedName: "Container_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerFilterBlobsExceptionHeaders = {
    serializedName: "Container_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerAcquireLeaseHeaders = {
    serializedName: "Container_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerAcquireLeaseExceptionHeaders = {
    serializedName: "Container_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerReleaseLeaseHeaders = {
    serializedName: "Container_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerReleaseLeaseExceptionHeaders = {
    serializedName: "Container_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerRenewLeaseHeaders = {
    serializedName: "Container_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerRenewLeaseExceptionHeaders = {
    serializedName: "Container_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerBreakLeaseHeaders = {
    serializedName: "Container_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerBreakLeaseExceptionHeaders = {
    serializedName: "Container_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerChangeLeaseHeaders = {
    serializedName: "Container_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.ContainerChangeLeaseExceptionHeaders = {
    serializedName: "Container_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerListBlobFlatSegmentHeaders = {
    serializedName: "Container_listBlobFlatSegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerListBlobFlatSegmentExceptionHeaders = {
    serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerListBlobHierarchySegmentHeaders = {
    serializedName: "Container_listBlobHierarchySegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerListBlobHierarchySegmentExceptionHeaders = {
    serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.ContainerGetAccountInfoHeaders = {
    serializedName: "Container_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.ContainerGetAccountInfoExceptionHeaders = {
    serializedName: "Container_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobDownloadHeaders = {
    serializedName: "Blob_downloadHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  exports.BlobDownloadExceptionHeaders = {
    serializedName: "Blob_downloadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetPropertiesHeaders = {
    serializedName: "Blob_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: {
            name: "String"
          }
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        isIncrementalCopy: {
          serializedName: "x-ms-incremental-copy",
          xmlName: "x-ms-incremental-copy",
          type: {
            name: "Boolean"
          }
        },
        destinationSnapshot: {
          serializedName: "x-ms-copy-destination-snapshot",
          xmlName: "x-ms-copy-destination-snapshot",
          type: {
            name: "String"
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        accessTier: {
          serializedName: "x-ms-access-tier",
          xmlName: "x-ms-access-tier",
          type: {
            name: "String"
          }
        },
        accessTierInferred: {
          serializedName: "x-ms-access-tier-inferred",
          xmlName: "x-ms-access-tier-inferred",
          type: {
            name: "Boolean"
          }
        },
        archiveStatus: {
          serializedName: "x-ms-archive-status",
          xmlName: "x-ms-archive-status",
          type: {
            name: "String"
          }
        },
        accessTierChangedOn: {
          serializedName: "x-ms-access-tier-change-time",
          xmlName: "x-ms-access-tier-change-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: {
            name: "Boolean"
          }
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: {
            name: "Number"
          }
        },
        expiresOn: {
          serializedName: "x-ms-expiry-time",
          xmlName: "x-ms-expiry-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        },
        rehydratePriority: {
          serializedName: "x-ms-rehydrate-priority",
          xmlName: "x-ms-rehydrate-priority",
          type: {
            name: "Enum",
            allowedValues: ["High", "Standard"]
          }
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetPropertiesExceptionHeaders = {
    serializedName: "Blob_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobDeleteHeaders = {
    serializedName: "Blob_deleteHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobDeleteExceptionHeaders = {
    serializedName: "Blob_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobUndeleteHeaders = {
    serializedName: "Blob_undeleteHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobUndeleteExceptionHeaders = {
    serializedName: "Blob_undeleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetExpiryHeaders = {
    serializedName: "Blob_setExpiryHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobSetExpiryExceptionHeaders = {
    serializedName: "Blob_setExpiryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetHttpHeadersHeaders = {
    serializedName: "Blob_setHttpHeadersHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetHttpHeadersExceptionHeaders = {
    serializedName: "Blob_setHttpHeadersExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetImmutabilityPolicyHeaders = {
    serializedName: "Blob_setImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyExpiry: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"]
          }
        }
      }
    }
  };
  exports.BlobSetImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobDeleteImmutabilityPolicyHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobDeleteImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetLegalHoldHeaders = {
    serializedName: "Blob_setLegalHoldHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.BlobSetLegalHoldExceptionHeaders = {
    serializedName: "Blob_setLegalHoldExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetMetadataHeaders = {
    serializedName: "Blob_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetMetadataExceptionHeaders = {
    serializedName: "Blob_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobAcquireLeaseHeaders = {
    serializedName: "Blob_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobAcquireLeaseExceptionHeaders = {
    serializedName: "Blob_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobReleaseLeaseHeaders = {
    serializedName: "Blob_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobReleaseLeaseExceptionHeaders = {
    serializedName: "Blob_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobRenewLeaseHeaders = {
    serializedName: "Blob_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobRenewLeaseExceptionHeaders = {
    serializedName: "Blob_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobChangeLeaseHeaders = {
    serializedName: "Blob_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobChangeLeaseExceptionHeaders = {
    serializedName: "Blob_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobBreakLeaseHeaders = {
    serializedName: "Blob_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        }
      }
    }
  };
  exports.BlobBreakLeaseExceptionHeaders = {
    serializedName: "Blob_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobCreateSnapshotHeaders = {
    serializedName: "Blob_createSnapshotHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotHeaders",
      modelProperties: {
        snapshot: {
          serializedName: "x-ms-snapshot",
          xmlName: "x-ms-snapshot",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobCreateSnapshotExceptionHeaders = {
    serializedName: "Blob_createSnapshotExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobStartCopyFromURLHeaders = {
    serializedName: "Blob_startCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobStartCopyFromURLExceptionHeaders = {
    serializedName: "Blob_startCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.BlobCopyFromURLHeaders = {
    serializedName: "Blob_copyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          defaultValue: "success",
          isConstant: !0,
          serializedName: "x-ms-copy-status",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobCopyFromURLExceptionHeaders = {
    serializedName: "Blob_copyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.BlobAbortCopyFromURLHeaders = {
    serializedName: "Blob_abortCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobAbortCopyFromURLExceptionHeaders = {
    serializedName: "Blob_abortCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetTierHeaders = {
    serializedName: "Blob_setTierHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetTierExceptionHeaders = {
    serializedName: "Blob_setTierExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetAccountInfoHeaders = {
    serializedName: "Blob_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS"
            ]
          }
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage"
            ]
          }
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.BlobGetAccountInfoExceptionHeaders = {
    serializedName: "Blob_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobQueryHeaders = {
    serializedName: "Blob_queryHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
          }
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: {
            name: "Number"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: {
            name: "String"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: {
            name: "String"
          }
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: {
            name: "String"
          }
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: {
            name: "String"
          }
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: {
            name: "String"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"]
          }
        },
        copyCompletionTime: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: {
            name: "String"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: {
            name: "String"
          }
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: {
            name: "Enum",
            allowedValues: ["infinite", "fixed"]
          }
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken"
            ]
          }
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: {
            name: "Enum",
            allowedValues: ["locked", "unlocked"]
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: {
            name: "ByteArray"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        }
      }
    }
  };
  exports.BlobQueryExceptionHeaders = {
    serializedName: "Blob_queryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetTagsHeaders = {
    serializedName: "Blob_getTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobGetTagsExceptionHeaders = {
    serializedName: "Blob_getTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetTagsHeaders = {
    serializedName: "Blob_setTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlobSetTagsExceptionHeaders = {
    serializedName: "Blob_setTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobCreateHeaders = {
    serializedName: "PageBlob_createHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobCreateExceptionHeaders = {
    serializedName: "PageBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUploadPagesHeaders = {
    serializedName: "PageBlob_uploadPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUploadPagesExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobClearPagesHeaders = {
    serializedName: "PageBlob_clearPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobClearPagesExceptionHeaders = {
    serializedName: "PageBlob_clearPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUploadPagesFromURLHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUploadPagesFromURLExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.PageBlobGetPageRangesHeaders = {
    serializedName: "PageBlob_getPageRangesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobGetPageRangesExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobGetPageRangesDiffHeaders = {
    serializedName: "PageBlob_getPageRangesDiffHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobGetPageRangesDiffExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobResizeHeaders = {
    serializedName: "PageBlob_resizeHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobResizeExceptionHeaders = {
    serializedName: "PageBlob_resizeExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUpdateSequenceNumberHeaders = {
    serializedName: "PageBlob_updateSequenceNumberHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobUpdateSequenceNumberExceptionHeaders = {
    serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobCopyIncrementalHeaders = {
    serializedName: "PageBlob_copyIncrementalHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: {
            name: "String"
          }
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"]
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.PageBlobCopyIncrementalExceptionHeaders = {
    serializedName: "PageBlob_copyIncrementalExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobCreateHeaders = {
    serializedName: "AppendBlob_createHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobCreateExceptionHeaders = {
    serializedName: "AppendBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobAppendBlockHeaders = {
    serializedName: "AppendBlob_appendBlockHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobAppendBlockExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobAppendBlockFromUrlHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: {
            name: "String"
          }
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: {
            name: "Number"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.AppendBlobAppendBlockFromUrlExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.AppendBlobSealHeaders = {
    serializedName: "AppendBlob_sealHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: {
            name: "Boolean"
          }
        }
      }
    }
  };
  exports.AppendBlobSealExceptionHeaders = {
    serializedName: "AppendBlob_sealExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobUploadHeaders = {
    serializedName: "BlockBlob_uploadHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobUploadExceptionHeaders = {
    serializedName: "BlockBlob_uploadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobPutBlobFromUrlHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobPutBlobFromUrlExceptionHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.BlockBlobStageBlockHeaders = {
    serializedName: "BlockBlob_stageBlockHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobStageBlockExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobStageBlockFromURLHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobStageBlockFromURLExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: {
            name: "String"
          }
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: {
            name: "Number"
          }
        }
      }
    }
  };
  exports.BlockBlobCommitBlockListHeaders = {
    serializedName: "BlockBlob_commitBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: {
            name: "ByteArray"
          }
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: {
            name: "ByteArray"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: {
            name: "Boolean"
          }
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: {
            name: "String"
          }
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: {
            name: "String"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobCommitBlockListExceptionHeaders = {
    serializedName: "BlockBlob_commitBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobGetBlockListHeaders = {
    serializedName: "BlockBlob_getBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: {
            name: "String"
          }
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: {
            name: "String"
          }
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: {
            name: "Number"
          }
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: {
            name: "String"
          }
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: {
            name: "String"
          }
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: {
            name: "String"
          }
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: {
            name: "DateTimeRfc1123"
          }
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
  exports.BlockBlobGetBlockListExceptionHeaders = {
    serializedName: "BlockBlob_getBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: {
            name: "String"
          }
        }
      }
    }
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/models/parameters.js
var require_parameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.action3 = exports.action2 = exports.leaseId1 = exports.action1 = exports.proposedLeaseId = exports.duration = exports.action = exports.comp10 = exports.sourceLeaseId = exports.sourceContainerName = exports.comp9 = exports.deletedContainerVersion = exports.deletedContainerName = exports.comp8 = exports.containerAcl = exports.comp7 = exports.comp6 = exports.ifUnmodifiedSince = exports.ifModifiedSince = exports.leaseId = exports.preventEncryptionScopeOverride = exports.defaultEncryptionScope = exports.access = exports.metadata = exports.restype2 = exports.where = exports.comp5 = exports.multipartContentType = exports.contentLength = exports.comp4 = exports.body = exports.restype1 = exports.comp3 = exports.keyInfo = exports.include = exports.maxPageSize = exports.marker = exports.prefix = exports.comp2 = exports.comp1 = exports.accept1 = exports.requestId = exports.version = exports.timeoutInSeconds = exports.comp = exports.restype = exports.url = exports.accept = exports.blobServiceProperties = exports.contentType = void 0;
  exports.fileRequestIntent = exports.copySourceTags = exports.copySourceAuthorization = exports.sourceContentMD5 = exports.xMsRequiresSync = exports.legalHold1 = exports.sealBlob = exports.blobTagsString = exports.copySource = exports.sourceIfTags = exports.sourceIfNoneMatch = exports.sourceIfMatch = exports.sourceIfUnmodifiedSince = exports.sourceIfModifiedSince = exports.rehydratePriority = exports.tier = exports.comp14 = exports.encryptionScope = exports.legalHold = exports.comp13 = exports.immutabilityPolicyMode = exports.immutabilityPolicyExpiry = exports.comp12 = exports.blobContentDisposition = exports.blobContentLanguage = exports.blobContentEncoding = exports.blobContentMD5 = exports.blobContentType = exports.blobCacheControl = exports.expiresOn = exports.expiryOptions = exports.comp11 = exports.blobDeleteType = exports.deleteSnapshots = exports.ifTags = exports.ifNoneMatch = exports.ifMatch = exports.encryptionAlgorithm = exports.encryptionKeySha256 = exports.encryptionKey = exports.rangeGetContentCRC64 = exports.rangeGetContentMD5 = exports.range = exports.versionId = exports.snapshot = exports.delimiter = exports.include1 = exports.proposedLeaseId1 = exports.action4 = exports.breakPeriod = void 0;
  exports.listType = exports.comp25 = exports.blocks = exports.blockId = exports.comp24 = exports.copySourceBlobProperties = exports.blobType2 = exports.comp23 = exports.sourceRange1 = exports.appendPosition = exports.maxSize = exports.comp22 = exports.blobType1 = exports.comp21 = exports.sequenceNumberAction = exports.prevSnapshotUrl = exports.prevsnapshot = exports.comp20 = exports.range1 = exports.sourceContentCrc64 = exports.sourceRange = exports.sourceUrl = exports.pageWrite1 = exports.ifSequenceNumberEqualTo = exports.ifSequenceNumberLessThan = exports.ifSequenceNumberLessThanOrEqualTo = exports.pageWrite = exports.comp19 = exports.accept2 = exports.body1 = exports.contentType1 = exports.blobSequenceNumber = exports.blobContentLength = exports.blobType = exports.transactionalContentCrc64 = exports.transactionalContentMD5 = exports.tags = exports.comp18 = exports.comp17 = exports.queryRequest = exports.tier1 = exports.comp16 = exports.copyId = exports.copyActionAbortConstant = exports.comp15 = void 0;
  var mappers_js_1 = require_mappers();
  exports.contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/xml",
      isConstant: !0,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  exports.blobServiceProperties = {
    parameterPath: "blobServiceProperties",
    mapper: mappers_js_1.BlobServiceProperties
  };
  exports.accept = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: !0,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  exports.url = {
    parameterPath: "url",
    mapper: {
      serializedName: "url",
      required: !0,
      xmlName: "url",
      type: {
        name: "String"
      }
    },
    skipEncoding: !0
  };
  exports.restype = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "service",
      isConstant: !0,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  exports.comp = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "properties",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.timeoutInSeconds = {
    parameterPath: ["options", "timeoutInSeconds"],
    mapper: {
      constraints: {
        InclusiveMinimum: 0
      },
      serializedName: "timeout",
      xmlName: "timeout",
      type: {
        name: "Number"
      }
    }
  };
  exports.version = {
    parameterPath: "version",
    mapper: {
      defaultValue: "2025-11-05",
      isConstant: !0,
      serializedName: "x-ms-version",
      type: {
        name: "String"
      }
    }
  };
  exports.requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
      serializedName: "x-ms-client-request-id",
      xmlName: "x-ms-client-request-id",
      type: {
        name: "String"
      }
    }
  };
  exports.accept1 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: !0,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  exports.comp1 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "stats",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.comp2 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "list",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
      serializedName: "prefix",
      xmlName: "prefix",
      type: {
        name: "String"
      }
    }
  };
  exports.marker = {
    parameterPath: ["options", "marker"],
    mapper: {
      serializedName: "marker",
      xmlName: "marker",
      type: {
        name: "String"
      }
    }
  };
  exports.maxPageSize = {
    parameterPath: ["options", "maxPageSize"],
    mapper: {
      constraints: {
        InclusiveMinimum: 1
      },
      serializedName: "maxresults",
      xmlName: "maxresults",
      type: {
        name: "Number"
      }
    }
  };
  exports.include = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListContainersIncludeType",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: ["metadata", "deleted", "system"]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  exports.keyInfo = {
    parameterPath: "keyInfo",
    mapper: mappers_js_1.KeyInfo
  };
  exports.comp3 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "userdelegationkey",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.restype1 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "account",
      isConstant: !0,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  exports.body = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: !0,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  exports.comp4 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "batch",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.contentLength = {
    parameterPath: "contentLength",
    mapper: {
      serializedName: "Content-Length",
      required: !0,
      xmlName: "Content-Length",
      type: {
        name: "Number"
      }
    }
  };
  exports.multipartContentType = {
    parameterPath: "multipartContentType",
    mapper: {
      serializedName: "Content-Type",
      required: !0,
      xmlName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  exports.comp5 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blobs",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.where = {
    parameterPath: ["options", "where"],
    mapper: {
      serializedName: "where",
      xmlName: "where",
      type: {
        name: "String"
      }
    }
  };
  exports.restype2 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "container",
      isConstant: !0,
      serializedName: "restype",
      type: {
        name: "String"
      }
    }
  };
  exports.metadata = {
    parameterPath: ["options", "metadata"],
    mapper: {
      serializedName: "x-ms-meta",
      xmlName: "x-ms-meta",
      headerCollectionPrefix: "x-ms-meta-",
      type: {
        name: "Dictionary",
        value: { type: { name: "String" } }
      }
    }
  };
  exports.access = {
    parameterPath: ["options", "access"],
    mapper: {
      serializedName: "x-ms-blob-public-access",
      xmlName: "x-ms-blob-public-access",
      type: {
        name: "Enum",
        allowedValues: ["container", "blob"]
      }
    }
  };
  exports.defaultEncryptionScope = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "defaultEncryptionScope"
    ],
    mapper: {
      serializedName: "x-ms-default-encryption-scope",
      xmlName: "x-ms-default-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  exports.preventEncryptionScopeOverride = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "preventEncryptionScopeOverride"
    ],
    mapper: {
      serializedName: "x-ms-deny-encryption-scope-override",
      xmlName: "x-ms-deny-encryption-scope-override",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.leaseId = {
    parameterPath: ["options", "leaseAccessConditions", "leaseId"],
    mapper: {
      serializedName: "x-ms-lease-id",
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.ifModifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
    mapper: {
      serializedName: "If-Modified-Since",
      xmlName: "If-Modified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.ifUnmodifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
    mapper: {
      serializedName: "If-Unmodified-Since",
      xmlName: "If-Unmodified-Since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.comp6 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "metadata",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.comp7 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "acl",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.containerAcl = {
    parameterPath: ["options", "containerAcl"],
    mapper: {
      serializedName: "containerAcl",
      xmlName: "SignedIdentifiers",
      xmlIsWrapped: !0,
      xmlElementName: "SignedIdentifier",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Composite",
            className: "SignedIdentifier"
          }
        }
      }
    }
  };
  exports.comp8 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "undelete",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.deletedContainerName = {
    parameterPath: ["options", "deletedContainerName"],
    mapper: {
      serializedName: "x-ms-deleted-container-name",
      xmlName: "x-ms-deleted-container-name",
      type: {
        name: "String"
      }
    }
  };
  exports.deletedContainerVersion = {
    parameterPath: ["options", "deletedContainerVersion"],
    mapper: {
      serializedName: "x-ms-deleted-container-version",
      xmlName: "x-ms-deleted-container-version",
      type: {
        name: "String"
      }
    }
  };
  exports.comp9 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "rename",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceContainerName = {
    parameterPath: "sourceContainerName",
    mapper: {
      serializedName: "x-ms-source-container-name",
      required: !0,
      xmlName: "x-ms-source-container-name",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceLeaseId = {
    parameterPath: ["options", "sourceLeaseId"],
    mapper: {
      serializedName: "x-ms-source-lease-id",
      xmlName: "x-ms-source-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.comp10 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "lease",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.action = {
    parameterPath: "action",
    mapper: {
      defaultValue: "acquire",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.duration = {
    parameterPath: ["options", "duration"],
    mapper: {
      serializedName: "x-ms-lease-duration",
      xmlName: "x-ms-lease-duration",
      type: {
        name: "Number"
      }
    }
  };
  exports.proposedLeaseId = {
    parameterPath: ["options", "proposedLeaseId"],
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.action1 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "release",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.leaseId1 = {
    parameterPath: "leaseId",
    mapper: {
      serializedName: "x-ms-lease-id",
      required: !0,
      xmlName: "x-ms-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.action2 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "renew",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.action3 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "break",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.breakPeriod = {
    parameterPath: ["options", "breakPeriod"],
    mapper: {
      serializedName: "x-ms-lease-break-period",
      xmlName: "x-ms-lease-break-period",
      type: {
        name: "Number"
      }
    }
  };
  exports.action4 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "change",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: {
        name: "String"
      }
    }
  };
  exports.proposedLeaseId1 = {
    parameterPath: "proposedLeaseId",
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      required: !0,
      xmlName: "x-ms-proposed-lease-id",
      type: {
        name: "String"
      }
    }
  };
  exports.include1 = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListBlobsIncludeItem",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: [
              "copy",
              "deleted",
              "metadata",
              "snapshots",
              "uncommittedblobs",
              "versions",
              "tags",
              "immutabilitypolicy",
              "legalhold",
              "deletedwithversions"
            ]
          }
        }
      }
    },
    collectionFormat: "CSV"
  };
  exports.delimiter = {
    parameterPath: "delimiter",
    mapper: {
      serializedName: "delimiter",
      required: !0,
      xmlName: "delimiter",
      type: {
        name: "String"
      }
    }
  };
  exports.snapshot = {
    parameterPath: ["options", "snapshot"],
    mapper: {
      serializedName: "snapshot",
      xmlName: "snapshot",
      type: {
        name: "String"
      }
    }
  };
  exports.versionId = {
    parameterPath: ["options", "versionId"],
    mapper: {
      serializedName: "versionid",
      xmlName: "versionid",
      type: {
        name: "String"
      }
    }
  };
  exports.range = {
    parameterPath: ["options", "range"],
    mapper: {
      serializedName: "x-ms-range",
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  exports.rangeGetContentMD5 = {
    parameterPath: ["options", "rangeGetContentMD5"],
    mapper: {
      serializedName: "x-ms-range-get-content-md5",
      xmlName: "x-ms-range-get-content-md5",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.rangeGetContentCRC64 = {
    parameterPath: ["options", "rangeGetContentCRC64"],
    mapper: {
      serializedName: "x-ms-range-get-content-crc64",
      xmlName: "x-ms-range-get-content-crc64",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.encryptionKey = {
    parameterPath: ["options", "cpkInfo", "encryptionKey"],
    mapper: {
      serializedName: "x-ms-encryption-key",
      xmlName: "x-ms-encryption-key",
      type: {
        name: "String"
      }
    }
  };
  exports.encryptionKeySha256 = {
    parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
    mapper: {
      serializedName: "x-ms-encryption-key-sha256",
      xmlName: "x-ms-encryption-key-sha256",
      type: {
        name: "String"
      }
    }
  };
  exports.encryptionAlgorithm = {
    parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
    mapper: {
      serializedName: "x-ms-encryption-algorithm",
      xmlName: "x-ms-encryption-algorithm",
      type: {
        name: "String"
      }
    }
  };
  exports.ifMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
    mapper: {
      serializedName: "If-Match",
      xmlName: "If-Match",
      type: {
        name: "String"
      }
    }
  };
  exports.ifNoneMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
    mapper: {
      serializedName: "If-None-Match",
      xmlName: "If-None-Match",
      type: {
        name: "String"
      }
    }
  };
  exports.ifTags = {
    parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
    mapper: {
      serializedName: "x-ms-if-tags",
      xmlName: "x-ms-if-tags",
      type: {
        name: "String"
      }
    }
  };
  exports.deleteSnapshots = {
    parameterPath: ["options", "deleteSnapshots"],
    mapper: {
      serializedName: "x-ms-delete-snapshots",
      xmlName: "x-ms-delete-snapshots",
      type: {
        name: "Enum",
        allowedValues: ["include", "only"]
      }
    }
  };
  exports.blobDeleteType = {
    parameterPath: ["options", "blobDeleteType"],
    mapper: {
      serializedName: "deletetype",
      xmlName: "deletetype",
      type: {
        name: "String"
      }
    }
  };
  exports.comp11 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "expiry",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.expiryOptions = {
    parameterPath: "expiryOptions",
    mapper: {
      serializedName: "x-ms-expiry-option",
      required: !0,
      xmlName: "x-ms-expiry-option",
      type: {
        name: "String"
      }
    }
  };
  exports.expiresOn = {
    parameterPath: ["options", "expiresOn"],
    mapper: {
      serializedName: "x-ms-expiry-time",
      xmlName: "x-ms-expiry-time",
      type: {
        name: "String"
      }
    }
  };
  exports.blobCacheControl = {
    parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
    mapper: {
      serializedName: "x-ms-blob-cache-control",
      xmlName: "x-ms-blob-cache-control",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentType = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
    mapper: {
      serializedName: "x-ms-blob-content-type",
      xmlName: "x-ms-blob-content-type",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentMD5 = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
    mapper: {
      serializedName: "x-ms-blob-content-md5",
      xmlName: "x-ms-blob-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.blobContentEncoding = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
    mapper: {
      serializedName: "x-ms-blob-content-encoding",
      xmlName: "x-ms-blob-content-encoding",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentLanguage = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
    mapper: {
      serializedName: "x-ms-blob-content-language",
      xmlName: "x-ms-blob-content-language",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentDisposition = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
    mapper: {
      serializedName: "x-ms-blob-content-disposition",
      xmlName: "x-ms-blob-content-disposition",
      type: {
        name: "String"
      }
    }
  };
  exports.comp12 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "immutabilityPolicies",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.immutabilityPolicyExpiry = {
    parameterPath: ["options", "immutabilityPolicyExpiry"],
    mapper: {
      serializedName: "x-ms-immutability-policy-until-date",
      xmlName: "x-ms-immutability-policy-until-date",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.immutabilityPolicyMode = {
    parameterPath: ["options", "immutabilityPolicyMode"],
    mapper: {
      serializedName: "x-ms-immutability-policy-mode",
      xmlName: "x-ms-immutability-policy-mode",
      type: {
        name: "Enum",
        allowedValues: ["Mutable", "Unlocked", "Locked"]
      }
    }
  };
  exports.comp13 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "legalhold",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.legalHold = {
    parameterPath: "legalHold",
    mapper: {
      serializedName: "x-ms-legal-hold",
      required: !0,
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.encryptionScope = {
    parameterPath: ["options", "encryptionScope"],
    mapper: {
      serializedName: "x-ms-encryption-scope",
      xmlName: "x-ms-encryption-scope",
      type: {
        name: "String"
      }
    }
  };
  exports.comp14 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "snapshot",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.tier = {
    parameterPath: ["options", "tier"],
    mapper: {
      serializedName: "x-ms-access-tier",
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  exports.rehydratePriority = {
    parameterPath: ["options", "rehydratePriority"],
    mapper: {
      serializedName: "x-ms-rehydrate-priority",
      xmlName: "x-ms-rehydrate-priority",
      type: {
        name: "Enum",
        allowedValues: ["High", "Standard"]
      }
    }
  };
  exports.sourceIfModifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfModifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-modified-since",
      xmlName: "x-ms-source-if-modified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.sourceIfUnmodifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfUnmodifiedSince"
    ],
    mapper: {
      serializedName: "x-ms-source-if-unmodified-since",
      xmlName: "x-ms-source-if-unmodified-since",
      type: {
        name: "DateTimeRfc1123"
      }
    }
  };
  exports.sourceIfMatch = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfMatch"],
    mapper: {
      serializedName: "x-ms-source-if-match",
      xmlName: "x-ms-source-if-match",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceIfNoneMatch = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfNoneMatch"
    ],
    mapper: {
      serializedName: "x-ms-source-if-none-match",
      xmlName: "x-ms-source-if-none-match",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceIfTags = {
    parameterPath: ["options", "sourceModifiedAccessConditions", "sourceIfTags"],
    mapper: {
      serializedName: "x-ms-source-if-tags",
      xmlName: "x-ms-source-if-tags",
      type: {
        name: "String"
      }
    }
  };
  exports.copySource = {
    parameterPath: "copySource",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: !0,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  exports.blobTagsString = {
    parameterPath: ["options", "blobTagsString"],
    mapper: {
      serializedName: "x-ms-tags",
      xmlName: "x-ms-tags",
      type: {
        name: "String"
      }
    }
  };
  exports.sealBlob = {
    parameterPath: ["options", "sealBlob"],
    mapper: {
      serializedName: "x-ms-seal-blob",
      xmlName: "x-ms-seal-blob",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.legalHold1 = {
    parameterPath: ["options", "legalHold"],
    mapper: {
      serializedName: "x-ms-legal-hold",
      xmlName: "x-ms-legal-hold",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.xMsRequiresSync = {
    parameterPath: "xMsRequiresSync",
    mapper: {
      defaultValue: "true",
      isConstant: !0,
      serializedName: "x-ms-requires-sync",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceContentMD5 = {
    parameterPath: ["options", "sourceContentMD5"],
    mapper: {
      serializedName: "x-ms-source-content-md5",
      xmlName: "x-ms-source-content-md5",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.copySourceAuthorization = {
    parameterPath: ["options", "copySourceAuthorization"],
    mapper: {
      serializedName: "x-ms-copy-source-authorization",
      xmlName: "x-ms-copy-source-authorization",
      type: {
        name: "String"
      }
    }
  };
  exports.copySourceTags = {
    parameterPath: ["options", "copySourceTags"],
    mapper: {
      serializedName: "x-ms-copy-source-tag-option",
      xmlName: "x-ms-copy-source-tag-option",
      type: {
        name: "Enum",
        allowedValues: ["REPLACE", "COPY"]
      }
    }
  };
  exports.fileRequestIntent = {
    parameterPath: ["options", "fileRequestIntent"],
    mapper: {
      serializedName: "x-ms-file-request-intent",
      xmlName: "x-ms-file-request-intent",
      type: {
        name: "String"
      }
    }
  };
  exports.comp15 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "copy",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
      defaultValue: "abort",
      isConstant: !0,
      serializedName: "x-ms-copy-action",
      type: {
        name: "String"
      }
    }
  };
  exports.copyId = {
    parameterPath: "copyId",
    mapper: {
      serializedName: "copyid",
      required: !0,
      xmlName: "copyid",
      type: {
        name: "String"
      }
    }
  };
  exports.comp16 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tier",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.tier1 = {
    parameterPath: "tier",
    mapper: {
      serializedName: "x-ms-access-tier",
      required: !0,
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold"
        ]
      }
    }
  };
  exports.queryRequest = {
    parameterPath: ["options", "queryRequest"],
    mapper: mappers_js_1.QueryRequest
  };
  exports.comp17 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "query",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.comp18 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tags",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.tags = {
    parameterPath: ["options", "tags"],
    mapper: mappers_js_1.BlobTags
  };
  exports.transactionalContentMD5 = {
    parameterPath: ["options", "transactionalContentMD5"],
    mapper: {
      serializedName: "Content-MD5",
      xmlName: "Content-MD5",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.transactionalContentCrc64 = {
    parameterPath: ["options", "transactionalContentCrc64"],
    mapper: {
      serializedName: "x-ms-content-crc64",
      xmlName: "x-ms-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.blobType = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "PageBlob",
      isConstant: !0,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  exports.blobContentLength = {
    parameterPath: "blobContentLength",
    mapper: {
      serializedName: "x-ms-blob-content-length",
      required: !0,
      xmlName: "x-ms-blob-content-length",
      type: {
        name: "Number"
      }
    }
  };
  exports.blobSequenceNumber = {
    parameterPath: ["options", "blobSequenceNumber"],
    mapper: {
      defaultValue: 0,
      serializedName: "x-ms-blob-sequence-number",
      xmlName: "x-ms-blob-sequence-number",
      type: {
        name: "Number"
      }
    }
  };
  exports.contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/octet-stream",
      isConstant: !0,
      serializedName: "Content-Type",
      type: {
        name: "String"
      }
    }
  };
  exports.body1 = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: !0,
      xmlName: "body",
      type: {
        name: "Stream"
      }
    }
  };
  exports.accept2 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: !0,
      serializedName: "Accept",
      type: {
        name: "String"
      }
    }
  };
  exports.comp19 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "page",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.pageWrite = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "update",
      isConstant: !0,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  exports.ifSequenceNumberLessThanOrEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThanOrEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-le",
      xmlName: "x-ms-if-sequence-number-le",
      type: {
        name: "Number"
      }
    }
  };
  exports.ifSequenceNumberLessThan = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThan"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-lt",
      xmlName: "x-ms-if-sequence-number-lt",
      type: {
        name: "Number"
      }
    }
  };
  exports.ifSequenceNumberEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberEqualTo"
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-eq",
      xmlName: "x-ms-if-sequence-number-eq",
      type: {
        name: "Number"
      }
    }
  };
  exports.pageWrite1 = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "clear",
      isConstant: !0,
      serializedName: "x-ms-page-write",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceUrl = {
    parameterPath: "sourceUrl",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: !0,
      xmlName: "x-ms-copy-source",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceRange = {
    parameterPath: "sourceRange",
    mapper: {
      serializedName: "x-ms-source-range",
      required: !0,
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  exports.sourceContentCrc64 = {
    parameterPath: ["options", "sourceContentCrc64"],
    mapper: {
      serializedName: "x-ms-source-content-crc64",
      xmlName: "x-ms-source-content-crc64",
      type: {
        name: "ByteArray"
      }
    }
  };
  exports.range1 = {
    parameterPath: "range",
    mapper: {
      serializedName: "x-ms-range",
      required: !0,
      xmlName: "x-ms-range",
      type: {
        name: "String"
      }
    }
  };
  exports.comp20 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "pagelist",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.prevsnapshot = {
    parameterPath: ["options", "prevsnapshot"],
    mapper: {
      serializedName: "prevsnapshot",
      xmlName: "prevsnapshot",
      type: {
        name: "String"
      }
    }
  };
  exports.prevSnapshotUrl = {
    parameterPath: ["options", "prevSnapshotUrl"],
    mapper: {
      serializedName: "x-ms-previous-snapshot-url",
      xmlName: "x-ms-previous-snapshot-url",
      type: {
        name: "String"
      }
    }
  };
  exports.sequenceNumberAction = {
    parameterPath: "sequenceNumberAction",
    mapper: {
      serializedName: "x-ms-sequence-number-action",
      required: !0,
      xmlName: "x-ms-sequence-number-action",
      type: {
        name: "Enum",
        allowedValues: ["max", "update", "increment"]
      }
    }
  };
  exports.comp21 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "incrementalcopy",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.blobType1 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "AppendBlob",
      isConstant: !0,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  exports.comp22 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "appendblock",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.maxSize = {
    parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
    mapper: {
      serializedName: "x-ms-blob-condition-maxsize",
      xmlName: "x-ms-blob-condition-maxsize",
      type: {
        name: "Number"
      }
    }
  };
  exports.appendPosition = {
    parameterPath: [
      "options",
      "appendPositionAccessConditions",
      "appendPosition"
    ],
    mapper: {
      serializedName: "x-ms-blob-condition-appendpos",
      xmlName: "x-ms-blob-condition-appendpos",
      type: {
        name: "Number"
      }
    }
  };
  exports.sourceRange1 = {
    parameterPath: ["options", "sourceRange"],
    mapper: {
      serializedName: "x-ms-source-range",
      xmlName: "x-ms-source-range",
      type: {
        name: "String"
      }
    }
  };
  exports.comp23 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "seal",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.blobType2 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "BlockBlob",
      isConstant: !0,
      serializedName: "x-ms-blob-type",
      type: {
        name: "String"
      }
    }
  };
  exports.copySourceBlobProperties = {
    parameterPath: ["options", "copySourceBlobProperties"],
    mapper: {
      serializedName: "x-ms-copy-source-blob-properties",
      xmlName: "x-ms-copy-source-blob-properties",
      type: {
        name: "Boolean"
      }
    }
  };
  exports.comp24 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "block",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.blockId = {
    parameterPath: "blockId",
    mapper: {
      serializedName: "blockid",
      required: !0,
      xmlName: "blockid",
      type: {
        name: "String"
      }
    }
  };
  exports.blocks = {
    parameterPath: "blocks",
    mapper: mappers_js_1.BlockLookupList
  };
  exports.comp25 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blocklist",
      isConstant: !0,
      serializedName: "comp",
      type: {
        name: "String"
      }
    }
  };
  exports.listType = {
    parameterPath: "listType",
    mapper: {
      defaultValue: "committed",
      serializedName: "blocklisttype",
      required: !0,
      xmlName: "blocklisttype",
      type: {
        name: "Enum",
        allowedValues: ["committed", "uncommitted", "all"]
      }
    }
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/service.js
var require_service = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ServiceImpl = void 0;
  var tslib_1 = require_tslib(), coreClient = tslib_1.__importStar(require_commonjs12()), Mappers = tslib_1.__importStar(require_mappers()), Parameters = tslib_1.__importStar(require_parameters());

  class ServiceImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    setProperties(blobServiceProperties, options) {
      return this.client.sendOperationRequest({ blobServiceProperties, options }, setPropertiesOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
    }
    getStatistics(options) {
      return this.client.sendOperationRequest({ options }, getStatisticsOperationSpec);
    }
    listContainersSegment(options) {
      return this.client.sendOperationRequest({ options }, listContainersSegmentOperationSpec);
    }
    getUserDelegationKey(keyInfo, options) {
      return this.client.sendOperationRequest({ keyInfo, options }, getUserDelegationKeyOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
    }
    submitBatch(contentLength, multipartContentType, body, options) {
      return this.client.sendOperationRequest({ contentLength, multipartContentType, body, options }, submitBatchOperationSpec);
    }
    filterBlobs(options) {
      return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
    }
  }
  exports.ServiceImpl = ServiceImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, !0), setPropertiesOperationSpec = {
    path: "/",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.ServiceSetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceSetPropertiesExceptionHeaders
      }
    },
    requestBody: Parameters.blobServiceProperties,
    queryParameters: [
      Parameters.restype,
      Parameters.comp,
      Parameters.timeoutInSeconds
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  }, getPropertiesOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlobServiceProperties,
        headersMapper: Mappers.ServiceGetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.restype,
      Parameters.comp,
      Parameters.timeoutInSeconds
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, getStatisticsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlobServiceStatistics,
        headersMapper: Mappers.ServiceGetStatisticsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetStatisticsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.restype,
      Parameters.timeoutInSeconds,
      Parameters.comp1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, listContainersSegmentOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ListContainersSegmentResponse,
        headersMapper: Mappers.ServiceListContainersSegmentHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceListContainersSegmentExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp2,
      Parameters.prefix,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.include
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, getUserDelegationKeyOperationSpec = {
    path: "/",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: Mappers.UserDelegationKey,
        headersMapper: Mappers.ServiceGetUserDelegationKeyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetUserDelegationKeyExceptionHeaders
      }
    },
    requestBody: Parameters.keyInfo,
    queryParameters: [
      Parameters.restype,
      Parameters.timeoutInSeconds,
      Parameters.comp3
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  }, getAccountInfoOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.ServiceGetAccountInfoHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.comp,
      Parameters.timeoutInSeconds,
      Parameters.restype1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, submitBatchOperationSpec = {
    path: "/",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.ServiceSubmitBatchHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceSubmitBatchExceptionHeaders
      }
    },
    requestBody: Parameters.body,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp4],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.multipartContentType
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  }, filterBlobsOperationSpec = {
    path: "/",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.FilterBlobSegment,
        headersMapper: Mappers.ServiceFilterBlobsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ServiceFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.comp5,
      Parameters.where
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/container.js
var require_container = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ContainerImpl = void 0;
  var tslib_1 = require_tslib(), coreClient = tslib_1.__importStar(require_commonjs12()), Mappers = tslib_1.__importStar(require_mappers()), Parameters = tslib_1.__importStar(require_parameters());

  class ContainerImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    create(options) {
      return this.client.sendOperationRequest({ options }, createOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
    }
    delete(options) {
      return this.client.sendOperationRequest({ options }, deleteOperationSpec);
    }
    setMetadata(options) {
      return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
    }
    getAccessPolicy(options) {
      return this.client.sendOperationRequest({ options }, getAccessPolicyOperationSpec);
    }
    setAccessPolicy(options) {
      return this.client.sendOperationRequest({ options }, setAccessPolicyOperationSpec);
    }
    restore(options) {
      return this.client.sendOperationRequest({ options }, restoreOperationSpec);
    }
    rename(sourceContainerName, options) {
      return this.client.sendOperationRequest({ sourceContainerName, options }, renameOperationSpec);
    }
    submitBatch(contentLength, multipartContentType, body, options) {
      return this.client.sendOperationRequest({ contentLength, multipartContentType, body, options }, submitBatchOperationSpec);
    }
    filterBlobs(options) {
      return this.client.sendOperationRequest({ options }, filterBlobsOperationSpec);
    }
    acquireLease(options) {
      return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
    }
    releaseLease(leaseId, options) {
      return this.client.sendOperationRequest({ leaseId, options }, releaseLeaseOperationSpec);
    }
    renewLease(leaseId, options) {
      return this.client.sendOperationRequest({ leaseId, options }, renewLeaseOperationSpec);
    }
    breakLease(options) {
      return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
    }
    changeLease(leaseId, proposedLeaseId, options) {
      return this.client.sendOperationRequest({ leaseId, proposedLeaseId, options }, changeLeaseOperationSpec);
    }
    listBlobFlatSegment(options) {
      return this.client.sendOperationRequest({ options }, listBlobFlatSegmentOperationSpec);
    }
    listBlobHierarchySegment(delimiter, options) {
      return this.client.sendOperationRequest({ delimiter, options }, listBlobHierarchySegmentOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
    }
  }
  exports.ContainerImpl = ContainerImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, !0), createOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.ContainerCreateHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerCreateExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.access,
      Parameters.defaultEncryptionScope,
      Parameters.preventEncryptionScopeOverride
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, getPropertiesOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.ContainerGetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, deleteOperationSpec = {
    path: "/{containerName}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: Mappers.ContainerDeleteHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerDeleteExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.restype2],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, setMetadataOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerSetMetadataHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerSetMetadataExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp6
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, getAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "SignedIdentifier" }
            }
          },
          serializedName: "SignedIdentifiers",
          xmlName: "SignedIdentifiers",
          xmlIsWrapped: !0,
          xmlElementName: "SignedIdentifier"
        },
        headersMapper: Mappers.ContainerGetAccessPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerGetAccessPolicyExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp7
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, setAccessPolicyOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerSetAccessPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerSetAccessPolicyExceptionHeaders
      }
    },
    requestBody: Parameters.containerAcl,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp7
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.access,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  }, restoreOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.ContainerRestoreHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerRestoreExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp8
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.deletedContainerName,
      Parameters.deletedContainerVersion
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, renameOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerRenameHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerRenameExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp9
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.sourceContainerName,
      Parameters.sourceLeaseId
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, submitBatchOperationSpec = {
    path: "/{containerName}",
    httpMethod: "POST",
    responses: {
      202: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.ContainerSubmitBatchHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerSubmitBatchExceptionHeaders
      }
    },
    requestBody: Parameters.body,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp4,
      Parameters.restype2
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.multipartContentType
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  }, filterBlobsOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.FilterBlobSegment,
        headersMapper: Mappers.ContainerFilterBlobsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerFilterBlobsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.comp5,
      Parameters.where,
      Parameters.restype2
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, acquireLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.ContainerAcquireLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action,
      Parameters.duration,
      Parameters.proposedLeaseId
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, releaseLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerReleaseLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action1,
      Parameters.leaseId1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, renewLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerRenewLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action2
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, breakLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.ContainerBreakLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action3,
      Parameters.breakPeriod
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, changeLeaseOperationSpec = {
    path: "/{containerName}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.ContainerChangeLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.restype2,
      Parameters.comp10
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action4,
      Parameters.proposedLeaseId1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, listBlobFlatSegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ListBlobsFlatSegmentResponse,
        headersMapper: Mappers.ContainerListBlobFlatSegmentHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerListBlobFlatSegmentExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp2,
      Parameters.prefix,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.restype2,
      Parameters.include1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, listBlobHierarchySegmentOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.ListBlobsHierarchySegmentResponse,
        headersMapper: Mappers.ContainerListBlobHierarchySegmentHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerListBlobHierarchySegmentExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp2,
      Parameters.prefix,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.restype2,
      Parameters.include1,
      Parameters.delimiter
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, getAccountInfoOperationSpec = {
    path: "/{containerName}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.ContainerGetAccountInfoHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.ContainerGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.comp,
      Parameters.timeoutInSeconds,
      Parameters.restype1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/blob.js
var require_blob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobImpl = void 0;
  var tslib_1 = require_tslib(), coreClient = tslib_1.__importStar(require_commonjs12()), Mappers = tslib_1.__importStar(require_mappers()), Parameters = tslib_1.__importStar(require_parameters());

  class BlobImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    download(options) {
      return this.client.sendOperationRequest({ options }, downloadOperationSpec);
    }
    getProperties(options) {
      return this.client.sendOperationRequest({ options }, getPropertiesOperationSpec);
    }
    delete(options) {
      return this.client.sendOperationRequest({ options }, deleteOperationSpec);
    }
    undelete(options) {
      return this.client.sendOperationRequest({ options }, undeleteOperationSpec);
    }
    setExpiry(expiryOptions, options) {
      return this.client.sendOperationRequest({ expiryOptions, options }, setExpiryOperationSpec);
    }
    setHttpHeaders(options) {
      return this.client.sendOperationRequest({ options }, setHttpHeadersOperationSpec);
    }
    setImmutabilityPolicy(options) {
      return this.client.sendOperationRequest({ options }, setImmutabilityPolicyOperationSpec);
    }
    deleteImmutabilityPolicy(options) {
      return this.client.sendOperationRequest({ options }, deleteImmutabilityPolicyOperationSpec);
    }
    setLegalHold(legalHold, options) {
      return this.client.sendOperationRequest({ legalHold, options }, setLegalHoldOperationSpec);
    }
    setMetadata(options) {
      return this.client.sendOperationRequest({ options }, setMetadataOperationSpec);
    }
    acquireLease(options) {
      return this.client.sendOperationRequest({ options }, acquireLeaseOperationSpec);
    }
    releaseLease(leaseId, options) {
      return this.client.sendOperationRequest({ leaseId, options }, releaseLeaseOperationSpec);
    }
    renewLease(leaseId, options) {
      return this.client.sendOperationRequest({ leaseId, options }, renewLeaseOperationSpec);
    }
    changeLease(leaseId, proposedLeaseId, options) {
      return this.client.sendOperationRequest({ leaseId, proposedLeaseId, options }, changeLeaseOperationSpec);
    }
    breakLease(options) {
      return this.client.sendOperationRequest({ options }, breakLeaseOperationSpec);
    }
    createSnapshot(options) {
      return this.client.sendOperationRequest({ options }, createSnapshotOperationSpec);
    }
    startCopyFromURL(copySource, options) {
      return this.client.sendOperationRequest({ copySource, options }, startCopyFromURLOperationSpec);
    }
    copyFromURL(copySource, options) {
      return this.client.sendOperationRequest({ copySource, options }, copyFromURLOperationSpec);
    }
    abortCopyFromURL(copyId, options) {
      return this.client.sendOperationRequest({ copyId, options }, abortCopyFromURLOperationSpec);
    }
    setTier(tier, options) {
      return this.client.sendOperationRequest({ tier, options }, setTierOperationSpec);
    }
    getAccountInfo(options) {
      return this.client.sendOperationRequest({ options }, getAccountInfoOperationSpec);
    }
    query(options) {
      return this.client.sendOperationRequest({ options }, queryOperationSpec);
    }
    getTags(options) {
      return this.client.sendOperationRequest({ options }, getTagsOperationSpec);
    }
    setTags(options) {
      return this.client.sendOperationRequest({ options }, setTagsOperationSpec);
    }
  }
  exports.BlobImpl = BlobImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, !0), downloadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobDownloadHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobDownloadHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobDownloadExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.rangeGetContentMD5,
      Parameters.rangeGetContentCRC64,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, getPropertiesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "HEAD",
    responses: {
      200: {
        headersMapper: Mappers.BlobGetPropertiesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobGetPropertiesExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, deleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      202: {
        headersMapper: Mappers.BlobDeleteHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobDeleteExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.blobDeleteType
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.deleteSnapshots
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, undeleteOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobUndeleteHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobUndeleteExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp8],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, setExpiryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetExpiryHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetExpiryExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp11],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.expiryOptions,
      Parameters.expiresOn
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, setHttpHeadersOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetHttpHeadersHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetHttpHeadersExceptionHeaders
      }
    },
    queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, setImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp12
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifUnmodifiedSince,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, deleteImmutabilityPolicyOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "DELETE",
    responses: {
      200: {
        headersMapper: Mappers.BlobDeleteImmutabilityPolicyHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobDeleteImmutabilityPolicyExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp12
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, setLegalHoldOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetLegalHoldHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetLegalHoldExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp13
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.legalHold
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, setMetadataOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetMetadataHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetMetadataExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp6],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, acquireLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlobAcquireLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobAcquireLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action,
      Parameters.duration,
      Parameters.proposedLeaseId,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, releaseLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobReleaseLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobReleaseLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action1,
      Parameters.leaseId1,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, renewLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobRenewLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobRenewLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action2,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, changeLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobChangeLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobChangeLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.leaseId1,
      Parameters.action4,
      Parameters.proposedLeaseId1,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, breakLeaseOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.BlobBreakLeaseHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobBreakLeaseExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp10],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.action3,
      Parameters.breakPeriod,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, createSnapshotOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlobCreateSnapshotHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobCreateSnapshotExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp14],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, startCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.BlobStartCopyFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobStartCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.tier,
      Parameters.rehydratePriority,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceIfTags,
      Parameters.copySource,
      Parameters.blobTagsString,
      Parameters.sealBlob,
      Parameters.legalHold1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, copyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.BlobCopyFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.copySource,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.xMsRequiresSync,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.copySourceTags,
      Parameters.fileRequestIntent
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, abortCopyFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: Mappers.BlobAbortCopyFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobAbortCopyFromURLExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp15,
      Parameters.copyId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.copyActionAbortConstant
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, setTierOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.BlobSetTierHeaders
      },
      202: {
        headersMapper: Mappers.BlobSetTierHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetTierExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp16
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifTags,
      Parameters.rehydratePriority,
      Parameters.tier1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, getAccountInfoOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        headersMapper: Mappers.BlobGetAccountInfoHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobGetAccountInfoExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.comp,
      Parameters.timeoutInSeconds,
      Parameters.restype1
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, queryOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "POST",
    responses: {
      200: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobQueryHeaders
      },
      206: {
        bodyMapper: {
          type: { name: "Stream" },
          serializedName: "parsedResponse"
        },
        headersMapper: Mappers.BlobQueryHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobQueryExceptionHeaders
      }
    },
    requestBody: Parameters.queryRequest,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.comp17
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  }, getTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlobTags,
        headersMapper: Mappers.BlobGetTagsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobGetTagsExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.versionId,
      Parameters.comp18
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, setTagsOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      204: {
        headersMapper: Mappers.BlobSetTagsHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlobSetTagsExceptionHeaders
      }
    },
    requestBody: Parameters.tags,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.versionId,
      Parameters.comp18
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.leaseId,
      Parameters.ifTags,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/pageBlob.js
var require_pageBlob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.PageBlobImpl = void 0;
  var tslib_1 = require_tslib(), coreClient = tslib_1.__importStar(require_commonjs12()), Mappers = tslib_1.__importStar(require_mappers()), Parameters = tslib_1.__importStar(require_parameters());

  class PageBlobImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    create(contentLength, blobContentLength, options) {
      return this.client.sendOperationRequest({ contentLength, blobContentLength, options }, createOperationSpec);
    }
    uploadPages(contentLength, body, options) {
      return this.client.sendOperationRequest({ contentLength, body, options }, uploadPagesOperationSpec);
    }
    clearPages(contentLength, options) {
      return this.client.sendOperationRequest({ contentLength, options }, clearPagesOperationSpec);
    }
    uploadPagesFromURL(sourceUrl, sourceRange, contentLength, range, options) {
      return this.client.sendOperationRequest({ sourceUrl, sourceRange, contentLength, range, options }, uploadPagesFromURLOperationSpec);
    }
    getPageRanges(options) {
      return this.client.sendOperationRequest({ options }, getPageRangesOperationSpec);
    }
    getPageRangesDiff(options) {
      return this.client.sendOperationRequest({ options }, getPageRangesDiffOperationSpec);
    }
    resize(blobContentLength, options) {
      return this.client.sendOperationRequest({ blobContentLength, options }, resizeOperationSpec);
    }
    updateSequenceNumber(sequenceNumberAction, options) {
      return this.client.sendOperationRequest({ sequenceNumberAction, options }, updateSequenceNumberOperationSpec);
    }
    copyIncremental(copySource, options) {
      return this.client.sendOperationRequest({ copySource, options }, copyIncrementalOperationSpec);
    }
  }
  exports.PageBlobImpl = PageBlobImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, !0), createOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobCreateHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobCreateExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.blobType,
      Parameters.blobContentLength,
      Parameters.blobSequenceNumber
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, uploadPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobUploadPagesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobUploadPagesExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2,
      Parameters.pageWrite,
      Parameters.ifSequenceNumberLessThanOrEqualTo,
      Parameters.ifSequenceNumberLessThan,
      Parameters.ifSequenceNumberEqualTo
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  }, clearPagesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobClearPagesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobClearPagesExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.ifSequenceNumberLessThanOrEqualTo,
      Parameters.ifSequenceNumberLessThan,
      Parameters.ifSequenceNumberEqualTo,
      Parameters.pageWrite1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, uploadPagesFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.PageBlobUploadPagesFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobUploadPagesFromURLExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp19],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.fileRequestIntent,
      Parameters.pageWrite,
      Parameters.ifSequenceNumberLessThanOrEqualTo,
      Parameters.ifSequenceNumberLessThan,
      Parameters.ifSequenceNumberEqualTo,
      Parameters.sourceUrl,
      Parameters.sourceRange,
      Parameters.sourceContentCrc64,
      Parameters.range1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, getPageRangesOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.PageList,
        headersMapper: Mappers.PageBlobGetPageRangesHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobGetPageRangesExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.snapshot,
      Parameters.comp20
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, getPageRangesDiffOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.PageList,
        headersMapper: Mappers.PageBlobGetPageRangesDiffHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobGetPageRangesDiffExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.marker,
      Parameters.maxPageSize,
      Parameters.snapshot,
      Parameters.comp20,
      Parameters.prevsnapshot
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.range,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.prevSnapshotUrl
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, resizeOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.PageBlobResizeHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobResizeExceptionHeaders
      }
    },
    queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.blobContentLength
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, updateSequenceNumberOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.PageBlobUpdateSequenceNumberHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobUpdateSequenceNumberExceptionHeaders
      }
    },
    queryParameters: [Parameters.comp, Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobSequenceNumber,
      Parameters.sequenceNumberAction
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, copyIncrementalOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      202: {
        headersMapper: Mappers.PageBlobCopyIncrementalHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.PageBlobCopyIncrementalExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp21],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.copySource
    ],
    isXML: !0,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/appendBlob.js
var require_appendBlob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AppendBlobImpl = void 0;
  var tslib_1 = require_tslib(), coreClient = tslib_1.__importStar(require_commonjs12()), Mappers = tslib_1.__importStar(require_mappers()), Parameters = tslib_1.__importStar(require_parameters());

  class AppendBlobImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    create(contentLength, options) {
      return this.client.sendOperationRequest({ contentLength, options }, createOperationSpec);
    }
    appendBlock(contentLength, body, options) {
      return this.client.sendOperationRequest({ contentLength, body, options }, appendBlockOperationSpec);
    }
    appendBlockFromUrl(sourceUrl, contentLength, options) {
      return this.client.sendOperationRequest({ sourceUrl, contentLength, options }, appendBlockFromUrlOperationSpec);
    }
    seal(options) {
      return this.client.sendOperationRequest({ options }, sealOperationSpec);
    }
  }
  exports.AppendBlobImpl = AppendBlobImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, !0), createOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.AppendBlobCreateHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobCreateExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.blobType1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, appendBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.AppendBlobAppendBlockHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobAppendBlockExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2,
      Parameters.maxSize,
      Parameters.appendPosition
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  }, appendBlockFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.AppendBlobAppendBlockFromUrlHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobAppendBlockFromUrlExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp22],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.encryptionScope,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.fileRequestIntent,
      Parameters.transactionalContentMD5,
      Parameters.sourceUrl,
      Parameters.sourceContentCrc64,
      Parameters.maxSize,
      Parameters.appendPosition,
      Parameters.sourceRange1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, sealOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      200: {
        headersMapper: Mappers.AppendBlobSealHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.AppendBlobSealExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp23],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.appendPosition
    ],
    isXML: !0,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/blockBlob.js
var require_blockBlob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlockBlobImpl = void 0;
  var tslib_1 = require_tslib(), coreClient = tslib_1.__importStar(require_commonjs12()), Mappers = tslib_1.__importStar(require_mappers()), Parameters = tslib_1.__importStar(require_parameters());

  class BlockBlobImpl {
    client;
    constructor(client) {
      this.client = client;
    }
    upload(contentLength, body, options) {
      return this.client.sendOperationRequest({ contentLength, body, options }, uploadOperationSpec);
    }
    putBlobFromUrl(contentLength, copySource, options) {
      return this.client.sendOperationRequest({ contentLength, copySource, options }, putBlobFromUrlOperationSpec);
    }
    stageBlock(blockId, contentLength, body, options) {
      return this.client.sendOperationRequest({ blockId, contentLength, body, options }, stageBlockOperationSpec);
    }
    stageBlockFromURL(blockId, contentLength, sourceUrl, options) {
      return this.client.sendOperationRequest({ blockId, contentLength, sourceUrl, options }, stageBlockFromURLOperationSpec);
    }
    commitBlockList(blocks, options) {
      return this.client.sendOperationRequest({ blocks, options }, commitBlockListOperationSpec);
    }
    getBlockList(listType, options) {
      return this.client.sendOperationRequest({ listType, options }, getBlockListOperationSpec);
    }
  }
  exports.BlockBlobImpl = BlockBlobImpl;
  var xmlSerializer = coreClient.createSerializer(Mappers, !0), uploadOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobUploadHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobUploadExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2,
      Parameters.blobType2
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  }, putBlobFromUrlOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobPutBlobFromUrlHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobPutBlobFromUrlExceptionHeaders
      }
    },
    queryParameters: [Parameters.timeoutInSeconds],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceIfTags,
      Parameters.copySource,
      Parameters.blobTagsString,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.copySourceTags,
      Parameters.fileRequestIntent,
      Parameters.transactionalContentMD5,
      Parameters.blobType2,
      Parameters.copySourceBlobProperties
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, stageBlockOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobStageBlockHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobStageBlockExceptionHeaders
      }
    },
    requestBody: Parameters.body1,
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp24,
      Parameters.blockId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.encryptionScope,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64,
      Parameters.contentType1,
      Parameters.accept2
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "binary",
    serializer: xmlSerializer
  }, stageBlockFromURLOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobStageBlockFromURLHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobStageBlockFromURLExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.comp24,
      Parameters.blockId
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.contentLength,
      Parameters.leaseId,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.encryptionScope,
      Parameters.sourceIfModifiedSince,
      Parameters.sourceIfUnmodifiedSince,
      Parameters.sourceIfMatch,
      Parameters.sourceIfNoneMatch,
      Parameters.sourceContentMD5,
      Parameters.copySourceAuthorization,
      Parameters.fileRequestIntent,
      Parameters.sourceUrl,
      Parameters.sourceContentCrc64,
      Parameters.sourceRange1
    ],
    isXML: !0,
    serializer: xmlSerializer
  }, commitBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "PUT",
    responses: {
      201: {
        headersMapper: Mappers.BlockBlobCommitBlockListHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobCommitBlockListExceptionHeaders
      }
    },
    requestBody: Parameters.blocks,
    queryParameters: [Parameters.timeoutInSeconds, Parameters.comp25],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.contentType,
      Parameters.accept,
      Parameters.version,
      Parameters.requestId,
      Parameters.metadata,
      Parameters.leaseId,
      Parameters.ifModifiedSince,
      Parameters.ifUnmodifiedSince,
      Parameters.encryptionKey,
      Parameters.encryptionKeySha256,
      Parameters.encryptionAlgorithm,
      Parameters.ifMatch,
      Parameters.ifNoneMatch,
      Parameters.ifTags,
      Parameters.blobCacheControl,
      Parameters.blobContentType,
      Parameters.blobContentMD5,
      Parameters.blobContentEncoding,
      Parameters.blobContentLanguage,
      Parameters.blobContentDisposition,
      Parameters.immutabilityPolicyExpiry,
      Parameters.immutabilityPolicyMode,
      Parameters.encryptionScope,
      Parameters.tier,
      Parameters.blobTagsString,
      Parameters.legalHold1,
      Parameters.transactionalContentMD5,
      Parameters.transactionalContentCrc64
    ],
    isXML: !0,
    contentType: "application/xml; charset=utf-8",
    mediaType: "xml",
    serializer: xmlSerializer
  }, getBlockListOperationSpec = {
    path: "/{containerName}/{blob}",
    httpMethod: "GET",
    responses: {
      200: {
        bodyMapper: Mappers.BlockList,
        headersMapper: Mappers.BlockBlobGetBlockListHeaders
      },
      default: {
        bodyMapper: Mappers.StorageError,
        headersMapper: Mappers.BlockBlobGetBlockListExceptionHeaders
      }
    },
    queryParameters: [
      Parameters.timeoutInSeconds,
      Parameters.snapshot,
      Parameters.comp25,
      Parameters.listType
    ],
    urlParameters: [Parameters.url],
    headerParameters: [
      Parameters.version,
      Parameters.requestId,
      Parameters.accept1,
      Parameters.leaseId,
      Parameters.ifTags
    ],
    isXML: !0,
    serializer: xmlSerializer
  };
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operations/index.js
var require_operations = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_service(), exports);
  tslib_1.__exportStar(require_container(), exports);
  tslib_1.__exportStar(require_blob(), exports);
  tslib_1.__exportStar(require_pageBlob(), exports);
  tslib_1.__exportStar(require_appendBlob(), exports);
  tslib_1.__exportStar(require_blockBlob(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/storageClient.js
var require_storageClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageClient = void 0;
  var tslib_1 = require_tslib(), coreHttpCompat = tslib_1.__importStar(require_commonjs13()), index_js_1 = require_operations();

  class StorageClient extends coreHttpCompat.ExtendedServiceClient {
    url;
    version;
    constructor(url, options) {
      if (url === void 0)
        throw Error("'url' cannot be null");
      if (!options)
        options = {};
      let defaults = {
        requestContentType: "application/json; charset=utf-8"
      }, packageDetails = "azsdk-js-azure-storage-blob/12.29.1", userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`, optionsWithDefaults = {
        ...defaults,
        ...options,
        userAgentOptions: {
          userAgentPrefix
        },
        endpoint: options.endpoint ?? options.baseUri ?? "{url}"
      };
      super(optionsWithDefaults);
      this.url = url, this.version = options.version || "2025-11-05", this.service = new index_js_1.ServiceImpl(this), this.container = new index_js_1.ContainerImpl(this), this.blob = new index_js_1.BlobImpl(this), this.pageBlob = new index_js_1.PageBlobImpl(this), this.appendBlob = new index_js_1.AppendBlobImpl(this), this.blockBlob = new index_js_1.BlockBlobImpl(this);
    }
    service;
    container;
    blob;
    pageBlob;
    appendBlob;
    blockBlob;
  }
  exports.StorageClient = StorageClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/service.js
var require_service2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/container.js
var require_container2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/blob.js
var require_blob2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/pageBlob.js
var require_pageBlob2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/appendBlob.js
var require_appendBlob2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/blockBlob.js
var require_blockBlob2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/operationsInterfaces/index.js
var require_operationsInterfaces = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_service2(), exports);
  tslib_1.__exportStar(require_container2(), exports);
  tslib_1.__exportStar(require_blob2(), exports);
  tslib_1.__exportStar(require_pageBlob2(), exports);
  tslib_1.__exportStar(require_appendBlob2(), exports);
  tslib_1.__exportStar(require_blockBlob2(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/generated/src/index.js
var require_src2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageClient = void 0;
  var tslib_1 = require_tslib();
  tslib_1.__exportStar(require_models(), exports);
  var storageClient_js_1 = require_storageClient();
  Object.defineProperty(exports, "StorageClient", { enumerable: !0, get: function() {
    return storageClient_js_1.StorageClient;
  } });
  tslib_1.__exportStar(require_operationsInterfaces(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageContextClient.js
var require_StorageContextClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageContextClient = void 0;
  var index_js_1 = require_src2();

  class StorageContextClient extends index_js_1.StorageClient {
    async sendOperationRequest(operationArguments, operationSpec) {
      let operationSpecToSend = { ...operationSpec };
      if (operationSpecToSend.path === "/{containerName}" || operationSpecToSend.path === "/{containerName}/{blob}")
        operationSpecToSend.path = "";
      return super.sendOperationRequest(operationArguments, operationSpecToSend);
    }
  }
  exports.StorageContextClient = StorageContextClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/StorageClient.js
var require_StorageClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageClient = void 0;
  var StorageContextClient_js_1 = require_StorageContextClient(), Pipeline_js_1 = require_Pipeline(), utils_common_js_1 = require_utils_common();

  class StorageClient {
    url;
    accountName;
    pipeline;
    credential;
    storageClientContext;
    isHttps;
    constructor(url, pipeline) {
      this.url = (0, utils_common_js_1.escapeURLPath)(url), this.accountName = (0, utils_common_js_1.getAccountNameFromUrl)(url), this.pipeline = pipeline, this.storageClientContext = new StorageContextClient_js_1.StorageContextClient(this.url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline)), this.isHttps = (0, utils_common_js_1.iEqual)((0, utils_common_js_1.getURLScheme)(this.url) || "", "https"), this.credential = (0, Pipeline_js_1.getCredentialFromPipeline)(pipeline);
      let storageClientContext = this.storageClientContext;
      storageClientContext.requestContentType = void 0;
    }
  }
  exports.StorageClient = StorageClient;
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingContext.js
var require_tracingContext2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.TracingContextImpl = exports.knownContextKeys = void 0;
  exports.createTracingContext = createTracingContext;
  exports.knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace")
  };
  function createTracingContext(options = {}) {
    let context = new TracingContextImpl(options.parentContext);
    if (options.span)
      context = context.setValue(exports.knownContextKeys.span, options.span);
    if (options.namespace)
      context = context.setValue(exports.knownContextKeys.namespace, options.namespace);
    return context;
  }

  class TracingContextImpl {
    constructor(initialContext) {
      this._contextMap = initialContext instanceof TracingContextImpl ? new Map(initialContext._contextMap) : /* @__PURE__ */ new Map;
    }
    setValue(key, value) {
      let newContext = new TracingContextImpl(this);
      return newContext._contextMap.set(key, value), newContext;
    }
    getValue(key) {
      return this._contextMap.get(key);
    }
    deleteValue(key) {
      let newContext = new TracingContextImpl(this);
      return newContext._contextMap.delete(key), newContext;
    }
  }
  exports.TracingContextImpl = TracingContextImpl;
});

// node_modules/@azure/core-tracing/dist/commonjs/state.js
var require_state3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.state = void 0;
  exports.state = {
    instrumenterImplementation: void 0
  };
});

// node_modules/@azure/core-tracing/dist/commonjs/instrumenter.js
var require_instrumenter2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createDefaultTracingSpan = createDefaultTracingSpan;
  exports.createDefaultInstrumenter = createDefaultInstrumenter;
  exports.useInstrumenter = useInstrumenter;
  exports.getInstrumenter = getInstrumenter;
  var tracingContext_js_1 = require_tracingContext2(), state_js_1 = require_state3();
  function createDefaultTracingSpan() {
    return {
      end: () => {},
      isRecording: () => !1,
      recordException: () => {},
      setAttribute: () => {},
      setStatus: () => {},
      addEvent: () => {}
    };
  }
  function createDefaultInstrumenter() {
    return {
      createRequestHeaders: () => {
        return {};
      },
      parseTraceparentHeader: () => {
        return;
      },
      startSpan: (_name, spanOptions) => {
        return {
          span: createDefaultTracingSpan(),
          tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext })
        };
      },
      withContext(_context, callback, ...callbackArgs) {
        return callback(...callbackArgs);
      }
    };
  }
  function useInstrumenter(instrumenter) {
    state_js_1.state.instrumenterImplementation = instrumenter;
  }
  function getInstrumenter() {
    if (!state_js_1.state.instrumenterImplementation)
      state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
    return state_js_1.state.instrumenterImplementation;
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/tracingClient.js
var require_tracingClient2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createTracingClient = createTracingClient;
  var instrumenter_js_1 = require_instrumenter2(), tracingContext_js_1 = require_tracingContext2();
  function createTracingClient(options) {
    let { namespace, packageName, packageVersion } = options;
    function startSpan(name, operationOptions, spanOptions) {
      var _a;
      let startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, Object.assign(Object.assign({}, spanOptions), { packageName, packageVersion, tracingContext: (_a = operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) === null || _a === void 0 ? void 0 : _a.tracingContext })), tracingContext = startSpanResult.tracingContext, span = startSpanResult.span;
      if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace))
        tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
      span.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
      let updatedOptions = Object.assign({}, operationOptions, {
        tracingOptions: Object.assign(Object.assign({}, operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions), { tracingContext })
      });
      return {
        span,
        updatedOptions
      };
    }
    async function withSpan(name, operationOptions, callback, spanOptions) {
      let { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
      try {
        let result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
        return span.setStatus({ status: "success" }), result;
      } catch (err) {
        throw span.setStatus({ status: "error", error: err }), err;
      } finally {
        span.end();
      }
    }
    function withContext(context, callback, ...callbackArgs) {
      return (0, instrumenter_js_1.getInstrumenter)().withContext(context, callback, ...callbackArgs);
    }
    function parseTraceparentHeader(traceparentHeader) {
      return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
    }
    function createRequestHeaders(tracingContext) {
      return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
    }
    return {
      startSpan,
      withSpan,
      withContext,
      parseTraceparentHeader,
      createRequestHeaders
    };
  }
});

// node_modules/@azure/core-tracing/dist/commonjs/index.js
var require_commonjs19 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createTracingClient = exports.useInstrumenter = void 0;
  var instrumenter_js_1 = require_instrumenter2();
  Object.defineProperty(exports, "useInstrumenter", { enumerable: !0, get: function() {
    return instrumenter_js_1.useInstrumenter;
  } });
  var tracingClient_js_1 = require_tracingClient2();
  Object.defineProperty(exports, "createTracingClient", { enumerable: !0, get: function() {
    return tracingClient_js_1.createTracingClient;
  } });
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/tracing.js
var require_tracing = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.tracingClient = void 0;
  var core_tracing_1 = require_commonjs19(), constants_js_1 = require_constants8();
  exports.tracingClient = (0, core_tracing_1.createTracingClient)({
    packageName: "@azure/storage-blob",
    packageVersion: constants_js_1.SDK_VERSION,
    namespace: "Microsoft.Storage"
  });
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/BlobSASPermissions.js
var require_BlobSASPermissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobSASPermissions = void 0;

  class BlobSASPermissions {
    static parse(permissions) {
      let blobSASPermissions = new BlobSASPermissions;
      for (let char of permissions)
        switch (char) {
          case "r":
            blobSASPermissions.read = !0;
            break;
          case "a":
            blobSASPermissions.add = !0;
            break;
          case "c":
            blobSASPermissions.create = !0;
            break;
          case "w":
            blobSASPermissions.write = !0;
            break;
          case "d":
            blobSASPermissions.delete = !0;
            break;
          case "x":
            blobSASPermissions.deleteVersion = !0;
            break;
          case "t":
            blobSASPermissions.tag = !0;
            break;
          case "m":
            blobSASPermissions.move = !0;
            break;
          case "e":
            blobSASPermissions.execute = !0;
            break;
          case "i":
            blobSASPermissions.setImmutabilityPolicy = !0;
            break;
          case "y":
            blobSASPermissions.permanentDelete = !0;
            break;
          default:
            throw RangeError(`Invalid permission: ${char}`);
        }
      return blobSASPermissions;
    }
    static from(permissionLike) {
      let blobSASPermissions = new BlobSASPermissions;
      if (permissionLike.read)
        blobSASPermissions.read = !0;
      if (permissionLike.add)
        blobSASPermissions.add = !0;
      if (permissionLike.create)
        blobSASPermissions.create = !0;
      if (permissionLike.write)
        blobSASPermissions.write = !0;
      if (permissionLike.delete)
        blobSASPermissions.delete = !0;
      if (permissionLike.deleteVersion)
        blobSASPermissions.deleteVersion = !0;
      if (permissionLike.tag)
        blobSASPermissions.tag = !0;
      if (permissionLike.move)
        blobSASPermissions.move = !0;
      if (permissionLike.execute)
        blobSASPermissions.execute = !0;
      if (permissionLike.setImmutabilityPolicy)
        blobSASPermissions.setImmutabilityPolicy = !0;
      if (permissionLike.permanentDelete)
        blobSASPermissions.permanentDelete = !0;
      return blobSASPermissions;
    }
    read = !1;
    add = !1;
    create = !1;
    write = !1;
    delete = !1;
    deleteVersion = !1;
    tag = !1;
    move = !1;
    execute = !1;
    setImmutabilityPolicy = !1;
    permanentDelete = !1;
    toString() {
      let permissions = [];
      if (this.read)
        permissions.push("r");
      if (this.add)
        permissions.push("a");
      if (this.create)
        permissions.push("c");
      if (this.write)
        permissions.push("w");
      if (this.delete)
        permissions.push("d");
      if (this.deleteVersion)
        permissions.push("x");
      if (this.tag)
        permissions.push("t");
      if (this.move)
        permissions.push("m");
      if (this.execute)
        permissions.push("e");
      if (this.setImmutabilityPolicy)
        permissions.push("i");
      if (this.permanentDelete)
        permissions.push("y");
      return permissions.join("");
    }
  }
  exports.BlobSASPermissions = BlobSASPermissions;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/ContainerSASPermissions.js
var require_ContainerSASPermissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ContainerSASPermissions = void 0;

  class ContainerSASPermissions {
    static parse(permissions) {
      let containerSASPermissions = new ContainerSASPermissions;
      for (let char of permissions)
        switch (char) {
          case "r":
            containerSASPermissions.read = !0;
            break;
          case "a":
            containerSASPermissions.add = !0;
            break;
          case "c":
            containerSASPermissions.create = !0;
            break;
          case "w":
            containerSASPermissions.write = !0;
            break;
          case "d":
            containerSASPermissions.delete = !0;
            break;
          case "l":
            containerSASPermissions.list = !0;
            break;
          case "t":
            containerSASPermissions.tag = !0;
            break;
          case "x":
            containerSASPermissions.deleteVersion = !0;
            break;
          case "m":
            containerSASPermissions.move = !0;
            break;
          case "e":
            containerSASPermissions.execute = !0;
            break;
          case "i":
            containerSASPermissions.setImmutabilityPolicy = !0;
            break;
          case "y":
            containerSASPermissions.permanentDelete = !0;
            break;
          case "f":
            containerSASPermissions.filterByTags = !0;
            break;
          default:
            throw RangeError(`Invalid permission ${char}`);
        }
      return containerSASPermissions;
    }
    static from(permissionLike) {
      let containerSASPermissions = new ContainerSASPermissions;
      if (permissionLike.read)
        containerSASPermissions.read = !0;
      if (permissionLike.add)
        containerSASPermissions.add = !0;
      if (permissionLike.create)
        containerSASPermissions.create = !0;
      if (permissionLike.write)
        containerSASPermissions.write = !0;
      if (permissionLike.delete)
        containerSASPermissions.delete = !0;
      if (permissionLike.list)
        containerSASPermissions.list = !0;
      if (permissionLike.deleteVersion)
        containerSASPermissions.deleteVersion = !0;
      if (permissionLike.tag)
        containerSASPermissions.tag = !0;
      if (permissionLike.move)
        containerSASPermissions.move = !0;
      if (permissionLike.execute)
        containerSASPermissions.execute = !0;
      if (permissionLike.setImmutabilityPolicy)
        containerSASPermissions.setImmutabilityPolicy = !0;
      if (permissionLike.permanentDelete)
        containerSASPermissions.permanentDelete = !0;
      if (permissionLike.filterByTags)
        containerSASPermissions.filterByTags = !0;
      return containerSASPermissions;
    }
    read = !1;
    add = !1;
    create = !1;
    write = !1;
    delete = !1;
    deleteVersion = !1;
    list = !1;
    tag = !1;
    move = !1;
    execute = !1;
    setImmutabilityPolicy = !1;
    permanentDelete = !1;
    filterByTags = !1;
    toString() {
      let permissions = [];
      if (this.read)
        permissions.push("r");
      if (this.add)
        permissions.push("a");
      if (this.create)
        permissions.push("c");
      if (this.write)
        permissions.push("w");
      if (this.delete)
        permissions.push("d");
      if (this.deleteVersion)
        permissions.push("x");
      if (this.list)
        permissions.push("l");
      if (this.tag)
        permissions.push("t");
      if (this.move)
        permissions.push("m");
      if (this.execute)
        permissions.push("e");
      if (this.setImmutabilityPolicy)
        permissions.push("i");
      if (this.permanentDelete)
        permissions.push("y");
      if (this.filterByTags)
        permissions.push("f");
      return permissions.join("");
    }
  }
  exports.ContainerSASPermissions = ContainerSASPermissions;
});

// node_modules/@azure/storage-blob/dist/commonjs/credentials/UserDelegationKeyCredential.js
var require_UserDelegationKeyCredential = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.UserDelegationKeyCredential = void 0;
  var node_crypto_1 = __require("node:crypto");

  class UserDelegationKeyCredential {
    accountName;
    userDelegationKey;
    key;
    constructor(accountName, userDelegationKey) {
      this.accountName = accountName, this.userDelegationKey = userDelegationKey, this.key = Buffer.from(userDelegationKey.value, "base64");
    }
    computeHMACSHA256(stringToSign) {
      return (0, node_crypto_1.createHmac)("sha256", this.key).update(stringToSign, "utf8").digest("base64");
    }
  }
  exports.UserDelegationKeyCredential = UserDelegationKeyCredential;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/SasIPRange.js
var require_SasIPRange = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ipRangeToString = ipRangeToString;
  function ipRangeToString(ipRange) {
    return ipRange.end ? `${ipRange.start}-${ipRange.end}` : ipRange.start;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/SASQueryParameters.js
var require_SASQueryParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.SASQueryParameters = exports.SASProtocol = void 0;
  var SasIPRange_js_1 = require_SasIPRange(), utils_common_js_1 = require_utils_common(), SASProtocol;
  (function(SASProtocol2) {
    SASProtocol2.Https = "https", SASProtocol2.HttpsAndHttp = "https,http";
  })(SASProtocol || (exports.SASProtocol = SASProtocol = {}));

  class SASQueryParameters {
    version;
    protocol;
    startsOn;
    expiresOn;
    permissions;
    services;
    resourceTypes;
    identifier;
    encryptionScope;
    resource;
    signature;
    cacheControl;
    contentDisposition;
    contentEncoding;
    contentLanguage;
    contentType;
    ipRangeInner;
    signedOid;
    signedTenantId;
    signedStartsOn;
    signedExpiresOn;
    signedService;
    signedVersion;
    preauthorizedAgentObjectId;
    correlationId;
    get ipRange() {
      if (this.ipRangeInner)
        return {
          end: this.ipRangeInner.end,
          start: this.ipRangeInner.start
        };
      return;
    }
    constructor(version, signature, permissionsOrOptions, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, userDelegationKey, preauthorizedAgentObjectId, correlationId, encryptionScope) {
      if (this.version = version, this.signature = signature, permissionsOrOptions !== void 0 && typeof permissionsOrOptions !== "string") {
        if (this.permissions = permissionsOrOptions.permissions, this.services = permissionsOrOptions.services, this.resourceTypes = permissionsOrOptions.resourceTypes, this.protocol = permissionsOrOptions.protocol, this.startsOn = permissionsOrOptions.startsOn, this.expiresOn = permissionsOrOptions.expiresOn, this.ipRangeInner = permissionsOrOptions.ipRange, this.identifier = permissionsOrOptions.identifier, this.encryptionScope = permissionsOrOptions.encryptionScope, this.resource = permissionsOrOptions.resource, this.cacheControl = permissionsOrOptions.cacheControl, this.contentDisposition = permissionsOrOptions.contentDisposition, this.contentEncoding = permissionsOrOptions.contentEncoding, this.contentLanguage = permissionsOrOptions.contentLanguage, this.contentType = permissionsOrOptions.contentType, permissionsOrOptions.userDelegationKey)
          this.signedOid = permissionsOrOptions.userDelegationKey.signedObjectId, this.signedTenantId = permissionsOrOptions.userDelegationKey.signedTenantId, this.signedStartsOn = permissionsOrOptions.userDelegationKey.signedStartsOn, this.signedExpiresOn = permissionsOrOptions.userDelegationKey.signedExpiresOn, this.signedService = permissionsOrOptions.userDelegationKey.signedService, this.signedVersion = permissionsOrOptions.userDelegationKey.signedVersion, this.preauthorizedAgentObjectId = permissionsOrOptions.preauthorizedAgentObjectId, this.correlationId = permissionsOrOptions.correlationId;
      } else if (this.services = services, this.resourceTypes = resourceTypes, this.expiresOn = expiresOn, this.permissions = permissionsOrOptions, this.protocol = protocol, this.startsOn = startsOn, this.ipRangeInner = ipRange, this.encryptionScope = encryptionScope, this.identifier = identifier, this.resource = resource, this.cacheControl = cacheControl, this.contentDisposition = contentDisposition, this.contentEncoding = contentEncoding, this.contentLanguage = contentLanguage, this.contentType = contentType, userDelegationKey)
        this.signedOid = userDelegationKey.signedObjectId, this.signedTenantId = userDelegationKey.signedTenantId, this.signedStartsOn = userDelegationKey.signedStartsOn, this.signedExpiresOn = userDelegationKey.signedExpiresOn, this.signedService = userDelegationKey.signedService, this.signedVersion = userDelegationKey.signedVersion, this.preauthorizedAgentObjectId = preauthorizedAgentObjectId, this.correlationId = correlationId;
    }
    toString() {
      let params = [
        "sv",
        "ss",
        "srt",
        "spr",
        "st",
        "se",
        "sip",
        "si",
        "ses",
        "skoid",
        "sktid",
        "skt",
        "ske",
        "sks",
        "skv",
        "sr",
        "sp",
        "sig",
        "rscc",
        "rscd",
        "rsce",
        "rscl",
        "rsct",
        "saoid",
        "scid"
      ], queries = [];
      for (let param of params)
        switch (param) {
          case "sv":
            this.tryAppendQueryParameter(queries, param, this.version);
            break;
          case "ss":
            this.tryAppendQueryParameter(queries, param, this.services);
            break;
          case "srt":
            this.tryAppendQueryParameter(queries, param, this.resourceTypes);
            break;
          case "spr":
            this.tryAppendQueryParameter(queries, param, this.protocol);
            break;
          case "st":
            this.tryAppendQueryParameter(queries, param, this.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.startsOn, !1) : void 0);
            break;
          case "se":
            this.tryAppendQueryParameter(queries, param, this.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.expiresOn, !1) : void 0);
            break;
          case "sip":
            this.tryAppendQueryParameter(queries, param, this.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(this.ipRange) : void 0);
            break;
          case "si":
            this.tryAppendQueryParameter(queries, param, this.identifier);
            break;
          case "ses":
            this.tryAppendQueryParameter(queries, param, this.encryptionScope);
            break;
          case "skoid":
            this.tryAppendQueryParameter(queries, param, this.signedOid);
            break;
          case "sktid":
            this.tryAppendQueryParameter(queries, param, this.signedTenantId);
            break;
          case "skt":
            this.tryAppendQueryParameter(queries, param, this.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedStartsOn, !1) : void 0);
            break;
          case "ske":
            this.tryAppendQueryParameter(queries, param, this.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(this.signedExpiresOn, !1) : void 0);
            break;
          case "sks":
            this.tryAppendQueryParameter(queries, param, this.signedService);
            break;
          case "skv":
            this.tryAppendQueryParameter(queries, param, this.signedVersion);
            break;
          case "sr":
            this.tryAppendQueryParameter(queries, param, this.resource);
            break;
          case "sp":
            this.tryAppendQueryParameter(queries, param, this.permissions);
            break;
          case "sig":
            this.tryAppendQueryParameter(queries, param, this.signature);
            break;
          case "rscc":
            this.tryAppendQueryParameter(queries, param, this.cacheControl);
            break;
          case "rscd":
            this.tryAppendQueryParameter(queries, param, this.contentDisposition);
            break;
          case "rsce":
            this.tryAppendQueryParameter(queries, param, this.contentEncoding);
            break;
          case "rscl":
            this.tryAppendQueryParameter(queries, param, this.contentLanguage);
            break;
          case "rsct":
            this.tryAppendQueryParameter(queries, param, this.contentType);
            break;
          case "saoid":
            this.tryAppendQueryParameter(queries, param, this.preauthorizedAgentObjectId);
            break;
          case "scid":
            this.tryAppendQueryParameter(queries, param, this.correlationId);
            break;
        }
      return queries.join("&");
    }
    tryAppendQueryParameter(queries, key, value) {
      if (!value)
        return;
      if (key = encodeURIComponent(key), value = encodeURIComponent(value), key.length > 0 && value.length > 0)
        queries.push(`${key}=${value}`);
    }
  }
  exports.SASQueryParameters = SASQueryParameters;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/BlobSASSignatureValues.js
var require_BlobSASSignatureValues = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.generateBlobSASQueryParameters = generateBlobSASQueryParameters;
  exports.generateBlobSASQueryParametersInternal = generateBlobSASQueryParametersInternal;
  var BlobSASPermissions_js_1 = require_BlobSASPermissions(), ContainerSASPermissions_js_1 = require_ContainerSASPermissions(), StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential(), UserDelegationKeyCredential_js_1 = require_UserDelegationKeyCredential(), SasIPRange_js_1 = require_SasIPRange(), SASQueryParameters_js_1 = require_SASQueryParameters(), constants_js_1 = require_constants8(), utils_common_js_1 = require_utils_common();
  function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    return generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName).sasQueryParameters;
  }
  function generateBlobSASQueryParametersInternal(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {
    let version = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION, sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : void 0, userDelegationKeyCredential;
    if (sharedKeyCredential === void 0 && accountName !== void 0)
      userDelegationKeyCredential = new UserDelegationKeyCredential_js_1.UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);
    if (sharedKeyCredential === void 0 && userDelegationKeyCredential === void 0)
      throw TypeError("Invalid sharedKeyCredential, userDelegationKey or accountName.");
    if (version >= "2020-12-06")
      if (sharedKeyCredential !== void 0)
        return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);
      else if (version >= "2025-07-05")
        return generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential);
      else
        return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);
    if (version >= "2018-11-09")
      if (sharedKeyCredential !== void 0)
        return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);
      else if (version >= "2020-02-10")
        return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);
      else
        return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);
    if (version >= "2015-04-05")
      if (sharedKeyCredential !== void 0)
        return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);
      else
        throw RangeError("'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.");
    throw RangeError("'version' must be >= '2015-04-05'.");
  }
  function generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {
    if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn))
      throw RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    let resource = "c";
    if (blobSASSignatureValues.blobName)
      resource = "b";
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions)
      if (blobSASSignatureValues.blobName)
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      else
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
    let stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, !1) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, !1) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`), signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {
    if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn))
      throw RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    let resource = "c", timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      if (resource = "b", blobSASSignatureValues.snapshotTime)
        resource = "bs";
      else if (blobSASSignatureValues.versionId)
        resource = "bv", timestamp = blobSASSignatureValues.versionId;
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions)
      if (blobSASSignatureValues.blobName)
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      else
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
    let stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, !1) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, !1) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`), signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType),
      stringToSign
    };
  }
  function generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {
    if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn))
      throw RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.");
    let resource = "c", timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      if (resource = "b", blobSASSignatureValues.snapshotTime)
        resource = "bs";
      else if (blobSASSignatureValues.versionId)
        resource = "bv", timestamp = blobSASSignatureValues.versionId;
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions)
      if (blobSASSignatureValues.blobName)
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      else
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
    let stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, !1) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, !1) : "",
      getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      blobSASSignatureValues.identifier,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : "",
      blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : "",
      blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : "",
      blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : "",
      blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : ""
    ].join(`
`), signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, void 0, void 0, void 0, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {
    if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn)
      throw RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    let resource = "c", timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      if (resource = "b", blobSASSignatureValues.snapshotTime)
        resource = "bs";
      else if (blobSASSignatureValues.versionId)
        resource = "bv", timestamp = blobSASSignatureValues.versionId;
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions)
      if (blobSASSignatureValues.blobName)
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      else
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
    let stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, !1) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, !1) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, !1) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, !1) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`), signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {
    if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn)
      throw RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    let resource = "c", timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      if (resource = "b", blobSASSignatureValues.snapshotTime)
        resource = "bs";
      else if (blobSASSignatureValues.versionId)
        resource = "bv", timestamp = blobSASSignatureValues.versionId;
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions)
      if (blobSASSignatureValues.blobName)
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      else
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
    let stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, !1) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, !1) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, !1) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, !1) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      void 0,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`), signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {
    if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn)
      throw RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    let resource = "c", timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      if (resource = "b", blobSASSignatureValues.snapshotTime)
        resource = "bs";
      else if (blobSASSignatureValues.versionId)
        resource = "bv", timestamp = blobSASSignatureValues.versionId;
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions)
      if (blobSASSignatureValues.blobName)
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      else
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
    let stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, !1) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, !1) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, !1) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, !1) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      void 0,
      blobSASSignatureValues.correlationId,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`), signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function generateBlobSASQueryParametersUDK20250705(blobSASSignatureValues, userDelegationKeyCredential) {
    if (blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues), !blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn)
      throw RangeError("Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.");
    let resource = "c", timestamp = blobSASSignatureValues.snapshotTime;
    if (blobSASSignatureValues.blobName) {
      if (resource = "b", blobSASSignatureValues.snapshotTime)
        resource = "bs";
      else if (blobSASSignatureValues.versionId)
        resource = "bv", timestamp = blobSASSignatureValues.versionId;
    }
    let verifiedPermissions;
    if (blobSASSignatureValues.permissions)
      if (blobSASSignatureValues.blobName)
        verifiedPermissions = BlobSASPermissions_js_1.BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
      else
        verifiedPermissions = ContainerSASPermissions_js_1.ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();
    let stringToSign = [
      verifiedPermissions ? verifiedPermissions : "",
      blobSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.startsOn, !1) : "",
      blobSASSignatureValues.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(blobSASSignatureValues.expiresOn, !1) : "",
      getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName),
      userDelegationKeyCredential.userDelegationKey.signedObjectId,
      userDelegationKeyCredential.userDelegationKey.signedTenantId,
      userDelegationKeyCredential.userDelegationKey.signedStartsOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedStartsOn, !1) : "",
      userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, !1) : "",
      userDelegationKeyCredential.userDelegationKey.signedService,
      userDelegationKeyCredential.userDelegationKey.signedVersion,
      blobSASSignatureValues.preauthorizedAgentObjectId,
      void 0,
      blobSASSignatureValues.correlationId,
      void 0,
      void 0,
      blobSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(blobSASSignatureValues.ipRange) : "",
      blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : "",
      blobSASSignatureValues.version,
      resource,
      timestamp,
      blobSASSignatureValues.encryptionScope,
      blobSASSignatureValues.cacheControl,
      blobSASSignatureValues.contentDisposition,
      blobSASSignatureValues.contentEncoding,
      blobSASSignatureValues.contentLanguage,
      blobSASSignatureValues.contentType
    ].join(`
`), signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, void 0, void 0, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
  function getCanonicalName(accountName, containerName, blobName) {
    let elements = [`/blob/${accountName}/${containerName}`];
    if (blobName)
      elements.push(`/${blobName}`);
    return elements.join("");
  }
  function SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {
    let version = blobSASSignatureValues.version ? blobSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
    if (blobSASSignatureValues.snapshotTime && version < "2018-11-09")
      throw RangeError("'version' must be >= '2018-11-09' when providing 'snapshotTime'.");
    if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.snapshotTime)
      throw RangeError("Must provide 'blobName' when providing 'snapshotTime'.");
    if (blobSASSignatureValues.versionId && version < "2019-10-10")
      throw RangeError("'version' must be >= '2019-10-10' when providing 'versionId'.");
    if (blobSASSignatureValues.blobName === void 0 && blobSASSignatureValues.versionId)
      throw RangeError("Must provide 'blobName' when providing 'versionId'.");
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04")
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version < "2019-10-10")
      throw RangeError("'version' must be >= '2019-10-10' when providing 'x' permission.");
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version < "2019-10-10")
      throw RangeError("'version' must be >= '2019-10-10' when providing 'y' permission.");
    if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version < "2019-12-12")
      throw RangeError("'version' must be >= '2019-12-12' when providing 't' permission.");
    if (version < "2020-02-10" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute))
      throw RangeError("'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.");
    if (version < "2021-04-10" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags)
      throw RangeError("'version' must be >= '2021-04-10' when providing the 'f' permission.");
    if (version < "2020-02-10" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId))
      throw RangeError("'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.");
    if (blobSASSignatureValues.encryptionScope && version < "2020-12-06")
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    return blobSASSignatureValues.version = version, blobSASSignatureValues;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobLeaseClient.js
var require_BlobLeaseClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobLeaseClient = void 0;
  var core_util_1 = require_commonjs9(), constants_js_1 = require_constants8(), tracing_js_1 = require_tracing(), utils_common_js_1 = require_utils_common();

  class BlobLeaseClient {
    _leaseId;
    _url;
    _containerOrBlobOperation;
    _isContainer;
    get leaseId() {
      return this._leaseId;
    }
    get url() {
      return this._url;
    }
    constructor(client, leaseId) {
      let clientContext = client.storageClientContext;
      if (this._url = client.url, client.name === void 0)
        this._isContainer = !0, this._containerOrBlobOperation = clientContext.container;
      else
        this._isContainer = !1, this._containerOrBlobOperation = clientContext.blob;
      if (!leaseId)
        leaseId = (0, core_util_1.randomUUID)();
      this._leaseId = leaseId;
    }
    async acquireLease(duration, options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions))
        throw RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-acquireLease", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.acquireLease({
          abortSignal: options.abortSignal,
          duration,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          proposedLeaseId: this._leaseId,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async changeLease(proposedLeaseId, options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions))
        throw RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-changeLease", options, async (updatedOptions) => {
        let response = (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.changeLease(this._leaseId, proposedLeaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
        return this._leaseId = proposedLeaseId, response;
      });
    }
    async releaseLease(options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions))
        throw RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-releaseLease", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.releaseLease(this._leaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async renewLease(options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions))
        throw RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-renewLease", options, async (updatedOptions) => {
        return this._containerOrBlobOperation.renewLease(this._leaseId, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        });
      });
    }
    async breakLease(breakPeriod, options = {}) {
      if (this._isContainer && (options.conditions?.ifMatch && options.conditions?.ifMatch !== constants_js_1.ETagNone || options.conditions?.ifNoneMatch && options.conditions?.ifNoneMatch !== constants_js_1.ETagNone || options.conditions?.tagConditions))
        throw RangeError("The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.");
      return tracing_js_1.tracingClient.withSpan("BlobLeaseClient-breakLease", options, async (updatedOptions) => {
        let operationOptions = {
          abortSignal: options.abortSignal,
          breakPeriod,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        };
        return (0, utils_common_js_1.assertResponse)(await this._containerOrBlobOperation.breakLease(operationOptions));
      });
    }
  }
  exports.BlobLeaseClient = BlobLeaseClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/RetriableReadableStream.js
var require_RetriableReadableStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.RetriableReadableStream = void 0;
  var abort_controller_1 = require_commonjs5(), node_stream_1 = __require("node:stream");

  class RetriableReadableStream extends node_stream_1.Readable {
    start;
    offset;
    end;
    getter;
    source;
    retries = 0;
    maxRetryRequests;
    onProgress;
    options;
    constructor(source, getter, offset, count, options = {}) {
      super({ highWaterMark: options.highWaterMark });
      this.getter = getter, this.source = source, this.start = offset, this.offset = offset, this.end = offset + count - 1, this.maxRetryRequests = options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0, this.onProgress = options.onProgress, this.options = options, this.setSourceEventHandlers();
    }
    _read() {
      this.source.resume();
    }
    setSourceEventHandlers() {
      this.source.on("data", this.sourceDataHandler), this.source.on("end", this.sourceErrorOrEndHandler), this.source.on("error", this.sourceErrorOrEndHandler), this.source.on("aborted", this.sourceAbortedHandler);
    }
    removeSourceEventHandlers() {
      this.source.removeListener("data", this.sourceDataHandler), this.source.removeListener("end", this.sourceErrorOrEndHandler), this.source.removeListener("error", this.sourceErrorOrEndHandler), this.source.removeListener("aborted", this.sourceAbortedHandler);
    }
    sourceDataHandler = (data) => {
      if (this.options.doInjectErrorOnce) {
        this.options.doInjectErrorOnce = void 0, this.source.pause(), this.sourceErrorOrEndHandler(), this.source.destroy();
        return;
      }
      if (this.offset += data.length, this.onProgress)
        this.onProgress({ loadedBytes: this.offset - this.start });
      if (!this.push(data))
        this.source.pause();
    };
    sourceAbortedHandler = () => {
      let abortError = new abort_controller_1.AbortError("The operation was aborted.");
      this.destroy(abortError);
    };
    sourceErrorOrEndHandler = (err) => {
      if (err && err.name === "AbortError") {
        this.destroy(err);
        return;
      }
      if (this.removeSourceEventHandlers(), this.offset - 1 === this.end)
        this.push(null);
      else if (this.offset <= this.end)
        if (this.retries < this.maxRetryRequests)
          this.retries += 1, this.getter(this.offset).then((newSource) => {
            this.source = newSource, this.setSourceEventHandlers();
            return;
          }).catch((error) => {
            this.destroy(error);
          });
        else
          this.destroy(Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
      else
        this.destroy(Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
    };
    _destroy(error, callback) {
      this.removeSourceEventHandlers(), this.source.destroy(), callback(error === null ? void 0 : error);
    }
  }
  exports.RetriableReadableStream = RetriableReadableStream;
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobDownloadResponse.js
var require_BlobDownloadResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobDownloadResponse = void 0;
  var core_util_1 = require_commonjs9(), RetriableReadableStream_js_1 = require_RetriableReadableStream();

  class BlobDownloadResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return this.originalResponse.copyCompletedOn;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get tagCount() {
      return this.originalResponse.tagCount;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get lastAccessed() {
      return this.originalResponse.lastAccessed;
    }
    get createdOn() {
      return this.originalResponse.createdOn;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get versionId() {
      return this.originalResponse.versionId;
    }
    get isCurrentVersion() {
      return this.originalResponse.isCurrentVersion;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get objectReplicationDestinationPolicyId() {
      return this.originalResponse.objectReplicationDestinationPolicyId;
    }
    get objectReplicationSourceProperties() {
      return this.originalResponse.objectReplicationSourceProperties;
    }
    get isSealed() {
      return this.originalResponse.isSealed;
    }
    get immutabilityPolicyExpiresOn() {
      return this.originalResponse.immutabilityPolicyExpiresOn;
    }
    get immutabilityPolicyMode() {
      return this.originalResponse.immutabilityPolicyMode;
    }
    get legalHold() {
      return this.originalResponse.legalHold;
    }
    get contentAsBlob() {
      return this.originalResponse.blobBody;
    }
    get readableStreamBody() {
      return core_util_1.isNodeLike ? this.blobDownloadStream : void 0;
    }
    get _response() {
      return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    constructor(originalResponse, getter, offset, count, options = {}) {
      this.originalResponse = originalResponse, this.blobDownloadStream = new RetriableReadableStream_js_1.RetriableReadableStream(this.originalResponse.readableStreamBody, getter, offset, count, options);
    }
  }
  exports.BlobDownloadResponse = BlobDownloadResponse;
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroConstants.js
var require_AvroConstants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AVRO_SCHEMA_KEY = exports.AVRO_CODEC_KEY = exports.AVRO_INIT_BYTES = exports.AVRO_SYNC_MARKER_SIZE = void 0;
  exports.AVRO_SYNC_MARKER_SIZE = 16;
  exports.AVRO_INIT_BYTES = new Uint8Array([79, 98, 106, 1]);
  exports.AVRO_CODEC_KEY = "avro.codec";
  exports.AVRO_SCHEMA_KEY = "avro.schema";
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroParser.js
var require_AvroParser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AvroType = exports.AvroParser = void 0;

  class AvroParser {
    static async readFixedBytes(stream, length, options = {}) {
      let bytes = await stream.read(length, { abortSignal: options.abortSignal });
      if (bytes.length !== length)
        throw Error("Hit stream end.");
      return bytes;
    }
    static async readByte(stream, options = {}) {
      return (await AvroParser.readFixedBytes(stream, 1, options))[0];
    }
    static async readZigZagLong(stream, options = {}) {
      let zigZagEncoded = 0, significanceInBit = 0, byte, haveMoreByte, significanceInFloat;
      do
        byte = await AvroParser.readByte(stream, options), haveMoreByte = byte & 128, zigZagEncoded |= (byte & 127) << significanceInBit, significanceInBit += 7;
      while (haveMoreByte && significanceInBit < 28);
      if (haveMoreByte) {
        zigZagEncoded = zigZagEncoded, significanceInFloat = 268435456;
        do
          byte = await AvroParser.readByte(stream, options), zigZagEncoded += (byte & 127) * significanceInFloat, significanceInFloat *= 128;
        while (byte & 128);
        let res = (zigZagEncoded % 2 ? -(zigZagEncoded + 1) : zigZagEncoded) / 2;
        if (res < Number.MIN_SAFE_INTEGER || res > Number.MAX_SAFE_INTEGER)
          throw Error("Integer overflow.");
        return res;
      }
      return zigZagEncoded >> 1 ^ -(zigZagEncoded & 1);
    }
    static async readLong(stream, options = {}) {
      return AvroParser.readZigZagLong(stream, options);
    }
    static async readInt(stream, options = {}) {
      return AvroParser.readZigZagLong(stream, options);
    }
    static async readNull() {
      return null;
    }
    static async readBoolean(stream, options = {}) {
      let b = await AvroParser.readByte(stream, options);
      if (b === 1)
        return !0;
      else if (b === 0)
        return !1;
      else
        throw Error("Byte was not a boolean.");
    }
    static async readFloat(stream, options = {}) {
      let u8arr = await AvroParser.readFixedBytes(stream, 4, options);
      return new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength).getFloat32(0, !0);
    }
    static async readDouble(stream, options = {}) {
      let u8arr = await AvroParser.readFixedBytes(stream, 8, options);
      return new DataView(u8arr.buffer, u8arr.byteOffset, u8arr.byteLength).getFloat64(0, !0);
    }
    static async readBytes(stream, options = {}) {
      let size = await AvroParser.readLong(stream, options);
      if (size < 0)
        throw Error("Bytes size was negative.");
      return stream.read(size, { abortSignal: options.abortSignal });
    }
    static async readString(stream, options = {}) {
      let u8arr = await AvroParser.readBytes(stream, options);
      return (/* @__PURE__ */ new TextDecoder()).decode(u8arr);
    }
    static async readMapPair(stream, readItemMethod, options = {}) {
      let key = await AvroParser.readString(stream, options), value = await readItemMethod(stream, options);
      return { key, value };
    }
    static async readMap(stream, readItemMethod, options = {}) {
      let readPairMethod = (s, opts = {}) => {
        return AvroParser.readMapPair(s, readItemMethod, opts);
      }, pairs = await AvroParser.readArray(stream, readPairMethod, options), dict = {};
      for (let pair of pairs)
        dict[pair.key] = pair.value;
      return dict;
    }
    static async readArray(stream, readItemMethod, options = {}) {
      let items = [];
      for (let count = await AvroParser.readLong(stream, options);count !== 0; count = await AvroParser.readLong(stream, options)) {
        if (count < 0)
          await AvroParser.readLong(stream, options), count = -count;
        while (count--) {
          let item = await readItemMethod(stream, options);
          items.push(item);
        }
      }
      return items;
    }
  }
  exports.AvroParser = AvroParser;
  var AvroComplex;
  (function(AvroComplex2) {
    AvroComplex2.RECORD = "record", AvroComplex2.ENUM = "enum", AvroComplex2.ARRAY = "array", AvroComplex2.MAP = "map", AvroComplex2.UNION = "union", AvroComplex2.FIXED = "fixed";
  })(AvroComplex || (AvroComplex = {}));
  var AvroPrimitive;
  (function(AvroPrimitive2) {
    AvroPrimitive2.NULL = "null", AvroPrimitive2.BOOLEAN = "boolean", AvroPrimitive2.INT = "int", AvroPrimitive2.LONG = "long", AvroPrimitive2.FLOAT = "float", AvroPrimitive2.DOUBLE = "double", AvroPrimitive2.BYTES = "bytes", AvroPrimitive2.STRING = "string";
  })(AvroPrimitive || (AvroPrimitive = {}));

  class AvroType {
    static fromSchema(schema) {
      if (typeof schema === "string")
        return AvroType.fromStringSchema(schema);
      else if (Array.isArray(schema))
        return AvroType.fromArraySchema(schema);
      else
        return AvroType.fromObjectSchema(schema);
    }
    static fromStringSchema(schema) {
      switch (schema) {
        case AvroPrimitive.NULL:
        case AvroPrimitive.BOOLEAN:
        case AvroPrimitive.INT:
        case AvroPrimitive.LONG:
        case AvroPrimitive.FLOAT:
        case AvroPrimitive.DOUBLE:
        case AvroPrimitive.BYTES:
        case AvroPrimitive.STRING:
          return new AvroPrimitiveType(schema);
        default:
          throw Error(`Unexpected Avro type ${schema}`);
      }
    }
    static fromArraySchema(schema) {
      return new AvroUnionType(schema.map(AvroType.fromSchema));
    }
    static fromObjectSchema(schema) {
      let type = schema.type;
      try {
        return AvroType.fromStringSchema(type);
      } catch {}
      switch (type) {
        case AvroComplex.RECORD:
          if (schema.aliases)
            throw Error(`aliases currently is not supported, schema: ${schema}`);
          if (!schema.name)
            throw Error(`Required attribute 'name' doesn't exist on schema: ${schema}`);
          let fields = {};
          if (!schema.fields)
            throw Error(`Required attribute 'fields' doesn't exist on schema: ${schema}`);
          for (let field of schema.fields)
            fields[field.name] = AvroType.fromSchema(field.type);
          return new AvroRecordType(fields, schema.name);
        case AvroComplex.ENUM:
          if (schema.aliases)
            throw Error(`aliases currently is not supported, schema: ${schema}`);
          if (!schema.symbols)
            throw Error(`Required attribute 'symbols' doesn't exist on schema: ${schema}`);
          return new AvroEnumType(schema.symbols);
        case AvroComplex.MAP:
          if (!schema.values)
            throw Error(`Required attribute 'values' doesn't exist on schema: ${schema}`);
          return new AvroMapType(AvroType.fromSchema(schema.values));
        case AvroComplex.ARRAY:
        case AvroComplex.FIXED:
        default:
          throw Error(`Unexpected Avro type ${type} in ${schema}`);
      }
    }
  }
  exports.AvroType = AvroType;

  class AvroPrimitiveType extends AvroType {
    _primitive;
    constructor(primitive) {
      super();
      this._primitive = primitive;
    }
    read(stream, options = {}) {
      switch (this._primitive) {
        case AvroPrimitive.NULL:
          return AvroParser.readNull();
        case AvroPrimitive.BOOLEAN:
          return AvroParser.readBoolean(stream, options);
        case AvroPrimitive.INT:
          return AvroParser.readInt(stream, options);
        case AvroPrimitive.LONG:
          return AvroParser.readLong(stream, options);
        case AvroPrimitive.FLOAT:
          return AvroParser.readFloat(stream, options);
        case AvroPrimitive.DOUBLE:
          return AvroParser.readDouble(stream, options);
        case AvroPrimitive.BYTES:
          return AvroParser.readBytes(stream, options);
        case AvroPrimitive.STRING:
          return AvroParser.readString(stream, options);
        default:
          throw Error("Unknown Avro Primitive");
      }
    }
  }

  class AvroEnumType extends AvroType {
    _symbols;
    constructor(symbols) {
      super();
      this._symbols = symbols;
    }
    async read(stream, options = {}) {
      let value = await AvroParser.readInt(stream, options);
      return this._symbols[value];
    }
  }

  class AvroUnionType extends AvroType {
    _types;
    constructor(types) {
      super();
      this._types = types;
    }
    async read(stream, options = {}) {
      let typeIndex = await AvroParser.readInt(stream, options);
      return this._types[typeIndex].read(stream, options);
    }
  }

  class AvroMapType extends AvroType {
    _itemType;
    constructor(itemType) {
      super();
      this._itemType = itemType;
    }
    read(stream, options = {}) {
      let readItemMethod = (s, opts) => {
        return this._itemType.read(s, opts);
      };
      return AvroParser.readMap(stream, readItemMethod, options);
    }
  }

  class AvroRecordType extends AvroType {
    _name;
    _fields;
    constructor(fields, name) {
      super();
      this._fields = fields, this._name = name;
    }
    async read(stream, options = {}) {
      let record = {};
      record.$schema = this._name;
      for (let key in this._fields)
        if (Object.prototype.hasOwnProperty.call(this._fields, key))
          record[key] = await this._fields[key].read(stream, options);
      return record;
    }
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/utils/utils.common.js
var require_utils_common3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.arraysEqual = arraysEqual;
  function arraysEqual(a, b) {
    if (a === b)
      return !0;
    if (a == null || b == null)
      return !1;
    if (a.length !== b.length)
      return !1;
    for (let i = 0;i < a.length; ++i)
      if (a[i] !== b[i])
        return !1;
    return !0;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReader.js
var require_AvroReader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AvroReader = void 0;
  var AvroConstants_js_1 = require_AvroConstants(), AvroParser_js_1 = require_AvroParser(), utils_common_js_1 = require_utils_common3();

  class AvroReader {
    _dataStream;
    _headerStream;
    _syncMarker;
    _metadata;
    _itemType;
    _itemsRemainingInBlock;
    _initialBlockOffset;
    _blockOffset;
    get blockOffset() {
      return this._blockOffset;
    }
    _objectIndex;
    get objectIndex() {
      return this._objectIndex;
    }
    _initialized;
    constructor(dataStream, headerStream, currentBlockOffset, indexWithinCurrentBlock) {
      this._dataStream = dataStream, this._headerStream = headerStream || dataStream, this._initialized = !1, this._blockOffset = currentBlockOffset || 0, this._objectIndex = indexWithinCurrentBlock || 0, this._initialBlockOffset = currentBlockOffset || 0;
    }
    async initialize(options = {}) {
      let header = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_INIT_BYTES.length, {
        abortSignal: options.abortSignal
      });
      if (!(0, utils_common_js_1.arraysEqual)(header, AvroConstants_js_1.AVRO_INIT_BYTES))
        throw Error("Stream is not an Avro file.");
      this._metadata = await AvroParser_js_1.AvroParser.readMap(this._headerStream, AvroParser_js_1.AvroParser.readString, {
        abortSignal: options.abortSignal
      });
      let codec = this._metadata[AvroConstants_js_1.AVRO_CODEC_KEY];
      if (!(codec === void 0 || codec === null || codec === "null"))
        throw Error("Codecs are not supported");
      this._syncMarker = await AvroParser_js_1.AvroParser.readFixedBytes(this._headerStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, {
        abortSignal: options.abortSignal
      });
      let schema = JSON.parse(this._metadata[AvroConstants_js_1.AVRO_SCHEMA_KEY]);
      if (this._itemType = AvroParser_js_1.AvroType.fromSchema(schema), this._blockOffset === 0)
        this._blockOffset = this._initialBlockOffset + this._dataStream.position;
      if (this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, {
        abortSignal: options.abortSignal
      }), await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal }), this._initialized = !0, this._objectIndex && this._objectIndex > 0)
        for (let i = 0;i < this._objectIndex; i++)
          await this._itemType.read(this._dataStream, { abortSignal: options.abortSignal }), this._itemsRemainingInBlock--;
    }
    hasNext() {
      return !this._initialized || this._itemsRemainingInBlock > 0;
    }
    async* parseObjects(options = {}) {
      if (!this._initialized)
        await this.initialize(options);
      while (this.hasNext()) {
        let result = await this._itemType.read(this._dataStream, {
          abortSignal: options.abortSignal
        });
        if (this._itemsRemainingInBlock--, this._objectIndex++, this._itemsRemainingInBlock === 0) {
          let marker = await AvroParser_js_1.AvroParser.readFixedBytes(this._dataStream, AvroConstants_js_1.AVRO_SYNC_MARKER_SIZE, {
            abortSignal: options.abortSignal
          });
          if (this._blockOffset = this._initialBlockOffset + this._dataStream.position, this._objectIndex = 0, !(0, utils_common_js_1.arraysEqual)(this._syncMarker, marker))
            throw Error("Stream is not a valid Avro file.");
          try {
            this._itemsRemainingInBlock = await AvroParser_js_1.AvroParser.readLong(this._dataStream, {
              abortSignal: options.abortSignal
            });
          } catch {
            this._itemsRemainingInBlock = 0;
          }
          if (this._itemsRemainingInBlock > 0)
            await AvroParser_js_1.AvroParser.readLong(this._dataStream, { abortSignal: options.abortSignal });
        }
        yield result;
      }
    }
  }
  exports.AvroReader = AvroReader;
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReadable.js
var require_AvroReadable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AvroReadable = void 0;

  class AvroReadable {
  }
  exports.AvroReadable = AvroReadable;
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/AvroReadableFromStream.js
var require_AvroReadableFromStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AvroReadableFromStream = void 0;
  var AvroReadable_js_1 = require_AvroReadable(), abort_controller_1 = require_commonjs5(), buffer_1 = __require("buffer"), ABORT_ERROR = new abort_controller_1.AbortError("Reading from the avro stream was aborted.");

  class AvroReadableFromStream extends AvroReadable_js_1.AvroReadable {
    _position;
    _readable;
    toUint8Array(data) {
      if (typeof data === "string")
        return buffer_1.Buffer.from(data);
      return data;
    }
    constructor(readable) {
      super();
      this._readable = readable, this._position = 0;
    }
    get position() {
      return this._position;
    }
    async read(size, options = {}) {
      if (options.abortSignal?.aborted)
        throw ABORT_ERROR;
      if (size < 0)
        throw Error(`size parameter should be positive: ${size}`);
      if (size === 0)
        return new Uint8Array;
      if (!this._readable.readable)
        throw Error("Stream no longer readable.");
      let chunk = this._readable.read(size);
      if (chunk)
        return this._position += chunk.length, this.toUint8Array(chunk);
      else
        return new Promise((resolve, reject) => {
          let cleanUp = () => {
            if (this._readable.removeListener("readable", readableCallback), this._readable.removeListener("error", rejectCallback), this._readable.removeListener("end", rejectCallback), this._readable.removeListener("close", rejectCallback), options.abortSignal)
              options.abortSignal.removeEventListener("abort", abortHandler);
          }, readableCallback = () => {
            let callbackChunk = this._readable.read(size);
            if (callbackChunk)
              this._position += callbackChunk.length, cleanUp(), resolve(this.toUint8Array(callbackChunk));
          }, rejectCallback = () => {
            cleanUp(), reject();
          }, abortHandler = () => {
            cleanUp(), reject(ABORT_ERROR);
          };
          if (this._readable.on("readable", readableCallback), this._readable.once("error", rejectCallback), this._readable.once("end", rejectCallback), this._readable.once("close", rejectCallback), options.abortSignal)
            options.abortSignal.addEventListener("abort", abortHandler);
        });
    }
  }
  exports.AvroReadableFromStream = AvroReadableFromStream;
});

// node_modules/@azure/storage-blob/dist/commonjs/internal-avro/index.js
var require_internal_avro = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AvroReadableFromStream = exports.AvroReadable = exports.AvroReader = void 0;
  var AvroReader_js_1 = require_AvroReader();
  Object.defineProperty(exports, "AvroReader", { enumerable: !0, get: function() {
    return AvroReader_js_1.AvroReader;
  } });
  var AvroReadable_js_1 = require_AvroReadable();
  Object.defineProperty(exports, "AvroReadable", { enumerable: !0, get: function() {
    return AvroReadable_js_1.AvroReadable;
  } });
  var AvroReadableFromStream_js_1 = require_AvroReadableFromStream();
  Object.defineProperty(exports, "AvroReadableFromStream", { enumerable: !0, get: function() {
    return AvroReadableFromStream_js_1.AvroReadableFromStream;
  } });
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/BlobQuickQueryStream.js
var require_BlobQuickQueryStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobQuickQueryStream = void 0;
  var node_stream_1 = __require("node:stream"), index_js_1 = require_internal_avro();

  class BlobQuickQueryStream extends node_stream_1.Readable {
    source;
    avroReader;
    avroIter;
    avroPaused = !0;
    onProgress;
    onError;
    constructor(source, options = {}) {
      super();
      this.source = source, this.onProgress = options.onProgress, this.onError = options.onError, this.avroReader = new index_js_1.AvroReader(new index_js_1.AvroReadableFromStream(this.source)), this.avroIter = this.avroReader.parseObjects({ abortSignal: options.abortSignal });
    }
    _read() {
      if (this.avroPaused)
        this.readInternal().catch((err) => {
          this.emit("error", err);
        });
    }
    async readInternal() {
      this.avroPaused = !1;
      let avroNext;
      do {
        if (avroNext = await this.avroIter.next(), avroNext.done)
          break;
        let obj = avroNext.value, schema = obj.$schema;
        if (typeof schema !== "string")
          throw Error("Missing schema in avro record.");
        switch (schema) {
          case "com.microsoft.azure.storage.queryBlobContents.resultData":
            {
              let data = obj.data;
              if (data instanceof Uint8Array === !1)
                throw Error("Invalid data in avro result record.");
              if (!this.push(Buffer.from(data)))
                this.avroPaused = !0;
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.progress":
            {
              let bytesScanned = obj.bytesScanned;
              if (typeof bytesScanned !== "number")
                throw Error("Invalid bytesScanned in avro progress record.");
              if (this.onProgress)
                this.onProgress({ loadedBytes: bytesScanned });
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.end":
            if (this.onProgress) {
              let totalBytes = obj.totalBytes;
              if (typeof totalBytes !== "number")
                throw Error("Invalid totalBytes in avro end record.");
              this.onProgress({ loadedBytes: totalBytes });
            }
            this.push(null);
            break;
          case "com.microsoft.azure.storage.queryBlobContents.error":
            if (this.onError) {
              let fatal = obj.fatal;
              if (typeof fatal !== "boolean")
                throw Error("Invalid fatal in avro error record.");
              let name = obj.name;
              if (typeof name !== "string")
                throw Error("Invalid name in avro error record.");
              let description = obj.description;
              if (typeof description !== "string")
                throw Error("Invalid description in avro error record.");
              let position = obj.position;
              if (typeof position !== "number")
                throw Error("Invalid position in avro error record.");
              this.onError({
                position,
                name,
                isFatal: fatal,
                description
              });
            }
            break;
          default:
            throw Error(`Unknown schema ${schema} in avro progress record.`);
        }
      } while (!avroNext.done && !this.avroPaused);
    }
  }
  exports.BlobQuickQueryStream = BlobQuickQueryStream;
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobQueryResponse.js
var require_BlobQueryResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobQueryResponse = void 0;
  var core_util_1 = require_commonjs9(), BlobQuickQueryStream_js_1 = require_BlobQuickQueryStream();

  class BlobQueryResponse {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get blobBody() {
      return;
    }
    get readableStreamBody() {
      return core_util_1.isNodeLike ? this.blobDownloadStream : void 0;
    }
    get _response() {
      return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    constructor(originalResponse, options = {}) {
      this.originalResponse = originalResponse, this.blobDownloadStream = new BlobQuickQueryStream_js_1.BlobQuickQueryStream(this.originalResponse.readableStreamBody, options);
    }
  }
  exports.BlobQueryResponse = BlobQueryResponse;
});

// node_modules/@azure/storage-blob/dist/commonjs/models.js
var require_models2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.StorageBlobAudience = exports.PremiumPageBlobTier = exports.BlockBlobTier = void 0;
  exports.toAccessTier = toAccessTier;
  exports.ensureCpkIfSpecified = ensureCpkIfSpecified;
  exports.getBlobServiceAccountAudience = getBlobServiceAccountAudience;
  var constants_js_1 = require_constants8(), BlockBlobTier;
  (function(BlockBlobTier2) {
    BlockBlobTier2.Hot = "Hot", BlockBlobTier2.Cool = "Cool", BlockBlobTier2.Cold = "Cold", BlockBlobTier2.Archive = "Archive";
  })(BlockBlobTier || (exports.BlockBlobTier = BlockBlobTier = {}));
  var PremiumPageBlobTier;
  (function(PremiumPageBlobTier2) {
    PremiumPageBlobTier2.P4 = "P4", PremiumPageBlobTier2.P6 = "P6", PremiumPageBlobTier2.P10 = "P10", PremiumPageBlobTier2.P15 = "P15", PremiumPageBlobTier2.P20 = "P20", PremiumPageBlobTier2.P30 = "P30", PremiumPageBlobTier2.P40 = "P40", PremiumPageBlobTier2.P50 = "P50", PremiumPageBlobTier2.P60 = "P60", PremiumPageBlobTier2.P70 = "P70", PremiumPageBlobTier2.P80 = "P80";
  })(PremiumPageBlobTier || (exports.PremiumPageBlobTier = PremiumPageBlobTier = {}));
  function toAccessTier(tier) {
    if (tier === void 0)
      return;
    return tier;
  }
  function ensureCpkIfSpecified(cpk, isHttps) {
    if (cpk && !isHttps)
      throw RangeError("Customer-provided encryption key must be used over HTTPS.");
    if (cpk && !cpk.encryptionAlgorithm)
      cpk.encryptionAlgorithm = constants_js_1.EncryptionAlgorithmAES25;
  }
  var StorageBlobAudience;
  (function(StorageBlobAudience2) {
    StorageBlobAudience2.StorageOAuthScopes = "https://storage.azure.com/.default", StorageBlobAudience2.DiskComputeOAuthScopes = "https://disk.compute.azure.com/.default";
  })(StorageBlobAudience || (exports.StorageBlobAudience = StorageBlobAudience = {}));
  function getBlobServiceAccountAudience(storageAccountName) {
    return `https://${storageAccountName}.blob.core.windows.net/.default`;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/PageBlobRangeResponse.js
var require_PageBlobRangeResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.rangeResponseFromModel = rangeResponseFromModel;
  function rangeResponseFromModel(response) {
    let pageRange = (response._response.parsedBody.pageRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    })), clearRange = (response._response.parsedBody.clearRange || []).map((x) => ({
      offset: x.start,
      count: x.end - x.start
    }));
    return {
      ...response,
      pageRange,
      clearRange,
      _response: {
        ...response._response,
        parsedBody: {
          pageRange,
          clearRange
        }
      }
    };
  }
});

// node_modules/@azure/core-lro/node_modules/tslib/tslib.js
var require_tslib3 = __commonJS((exports, module) => {
  var __extends, __assign, __rest, __decorate, __param, __esDecorate, __runInitializers, __propKey, __setFunctionName, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __spreadArray, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet, __classPrivateFieldIn, __createBinding, __addDisposableResource, __disposeResources, __rewriteRelativeImportExtension;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd)
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    else if (typeof module === "object" && typeof exports === "object")
      factory(createExporter(root, createExporter(exports)));
    else
      factory(createExporter(root));
    function createExporter(exports2, previous) {
      if (exports2 !== root)
        if (typeof Object.create === "function")
          Object.defineProperty(exports2, "__esModule", { value: !0 });
        else
          exports2.__esModule = !0;
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    }, __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    }, __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++)
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
      }
      return t;
    }, __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }, __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    }, __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function")
          throw TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value", target = !descriptorIn && ctor ? contextIn.static ? ctor : ctor.prototype : null, descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {}), _2, done = !1;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === void 0)
            continue;
          if (result === null || typeof result !== "object")
            throw TypeError("Object expected");
          if (_2 = accept(result.get))
            descriptor.get = _2;
          if (_2 = accept(result.set))
            descriptor.set = _2;
          if (_2 = accept(result.init))
            initializers.unshift(_2);
        } else if (_2 = accept(result))
          if (kind === "field")
            initializers.unshift(_2);
          else
            descriptor[key] = _2;
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = !0;
    }, __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++)
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      return useValue ? value : void 0;
    }, __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    }, __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: !0, value: prefix ? "".concat(prefix, " ", name) : name });
    }, __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    }, __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }, __generator = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
      return g.next = verb(0), g.throw = verb(1), g.return = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_2 = 0)), _2)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                return _2.label++, { value: op[1], done: !1 };
              case 5:
                _2.label++, y = op[1], op = [0];
                continue;
              case 7:
                op = _2.ops.pop(), _2.trys.pop();
                continue;
              default:
                if ((t = _2.trys, !(t = t.length > 0 && t[t.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t[1]) {
                  _2.label = t[1], t = op;
                  break;
                }
                if (t && _2.label < t[2]) {
                  _2.label = t[2], _2.ops.push(op);
                  break;
                }
                if (t[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e) {
            op = [6, e], y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: !0 };
      }
    }, __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    }, __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
        desc = { enumerable: !0, get: function() {
          return m[k];
        } };
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    }, __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i.return))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    }, __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    }, __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    }, __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) {
        for (var i = 0, l = from.length, ar;i < l; i++)
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    }, __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }, __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          if (i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          }, f)
            i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    }, __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: !1 } : f ? f(v) : v;
        } : f;
      }
    }, __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    }, __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty)
        Object.defineProperty(cooked, "raw", { value: raw });
      else
        cooked.raw = raw;
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      return __setModuleDefault(result, mod), result;
    }, __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    }, __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }, __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    }, __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    }, __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function")
          throw TypeError("Object expected.");
        var dispose, inner;
        if (async) {
          if (!Symbol.asyncDispose)
            throw TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
          if (!Symbol.dispose)
            throw TypeError("Symbol.dispose is not defined.");
          if (dispose = value[Symbol.dispose], async)
            inner = dispose;
        }
        if (typeof dispose !== "function")
          throw TypeError("Object not disposable.");
        if (inner)
          dispose = function() {
            try {
              inner.call(this);
            } catch (e) {
              return Promise.reject(e);
            }
          };
        env.stack.push({ value, dispose, async });
      } else if (async)
        env.stack.push({ async: !0 });
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e, env.hasError = !0;
      }
      var r, s = 0;
      function next() {
        while (r = env.stack.pop())
          try {
            if (!r.async && s === 1)
              return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
              var result = r.dispose.call(r.value);
              if (r.async)
                return s |= 2, Promise.resolve(result).then(next, function(e) {
                  return fail(e), next();
                });
            } else
              s |= 1;
          } catch (e) {
            fail(e);
          }
        if (s === 1)
          return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError)
          throw env.error;
      }
      return next();
    }, __rewriteRelativeImportExtension = function(path, preserveJsx) {
      if (typeof path === "string" && /^\.\.?\//.test(path))
        return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
        });
      return path;
    }, exporter("__extends", __extends), exporter("__assign", __assign), exporter("__rest", __rest), exporter("__decorate", __decorate), exporter("__param", __param), exporter("__esDecorate", __esDecorate), exporter("__runInitializers", __runInitializers), exporter("__propKey", __propKey), exporter("__setFunctionName", __setFunctionName), exporter("__metadata", __metadata), exporter("__awaiter", __awaiter), exporter("__generator", __generator), exporter("__exportStar", __exportStar), exporter("__createBinding", __createBinding), exporter("__values", __values), exporter("__read", __read), exporter("__spread", __spread), exporter("__spreadArrays", __spreadArrays), exporter("__spreadArray", __spreadArray), exporter("__await", __await), exporter("__asyncGenerator", __asyncGenerator), exporter("__asyncDelegator", __asyncDelegator), exporter("__asyncValues", __asyncValues), exporter("__makeTemplateObject", __makeTemplateObject), exporter("__importStar", __importStar), exporter("__importDefault", __importDefault), exporter("__classPrivateFieldGet", __classPrivateFieldGet), exporter("__classPrivateFieldSet", __classPrivateFieldSet), exporter("__classPrivateFieldIn", __classPrivateFieldIn), exporter("__addDisposableResource", __addDisposableResource), exporter("__disposeResources", __disposeResources), exporter("__rewriteRelativeImportExtension", __rewriteRelativeImportExtension);
  });
});

// node_modules/@azure/core-lro/dist/commonjs/logger.js
var require_logger2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.logger = void 0;
  var logger_1 = require_commonjs15();
  exports.logger = (0, logger_1.createClientLogger)("core-lro");
});

// node_modules/@azure/core-lro/dist/commonjs/poller/constants.js
var require_constants10 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.terminalStates = exports.POLL_INTERVAL_IN_MS = void 0;
  exports.POLL_INTERVAL_IN_MS = 2000;
  exports.terminalStates = ["succeeded", "canceled", "failed"];
});

// node_modules/@azure/core-lro/dist/commonjs/poller/operation.js
var require_operation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.pollOperation = exports.initOperation = exports.deserializeState = void 0;
  var logger_js_1 = require_logger2(), constants_js_1 = require_constants10();
  function deserializeState(serializedState) {
    try {
      return JSON.parse(serializedState).state;
    } catch (e) {
      throw Error(`Unable to deserialize input state: ${serializedState}`);
    }
  }
  exports.deserializeState = deserializeState;
  function setStateError(inputs) {
    let { state, stateProxy, isOperationError } = inputs;
    return (error) => {
      if (isOperationError(error))
        stateProxy.setError(state, error), stateProxy.setFailed(state);
      throw error;
    };
  }
  function appendReadableErrorMessage(currentMessage, innerMessage) {
    let message = currentMessage;
    if (message.slice(-1) !== ".")
      message = message + ".";
    return message + " " + innerMessage;
  }
  function simplifyError(err) {
    let { message, code } = err, curErr = err;
    while (curErr.innererror)
      curErr = curErr.innererror, code = curErr.code, message = appendReadableErrorMessage(message, curErr.message);
    return {
      code,
      message
    };
  }
  function processOperationStatus(result) {
    let { state, stateProxy, status, isDone, processResult, getError, response, setErrorAsResult } = result;
    switch (status) {
      case "succeeded": {
        stateProxy.setSucceeded(state);
        break;
      }
      case "failed": {
        let err = getError === null || getError === void 0 ? void 0 : getError(response), postfix = "";
        if (err) {
          let { code, message } = simplifyError(err);
          postfix = `. ${code}. ${message}`;
        }
        let errStr = `The long-running operation has failed${postfix}`;
        stateProxy.setError(state, Error(errStr)), stateProxy.setFailed(state), logger_js_1.logger.warning(errStr);
        break;
      }
      case "canceled": {
        stateProxy.setCanceled(state);
        break;
      }
    }
    if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === void 0 && ["succeeded", "canceled"].concat(setErrorAsResult ? [] : ["failed"]).includes(status))
      stateProxy.setResult(state, buildResult({
        response,
        state,
        processResult
      }));
  }
  function buildResult(inputs) {
    let { processResult, response, state } = inputs;
    return processResult ? processResult(response, state) : response;
  }
  async function initOperation(inputs) {
    let { init, stateProxy, processResult, getOperationStatus, withOperationLocation, setErrorAsResult } = inputs, { operationLocation, resourceLocation, metadata, response } = await init();
    if (operationLocation)
      withOperationLocation === null || withOperationLocation === void 0 || withOperationLocation(operationLocation, !1);
    let config = {
      metadata,
      operationLocation,
      resourceLocation
    };
    logger_js_1.logger.verbose("LRO: Operation description:", config);
    let state = stateProxy.initState(config), status = getOperationStatus({ response, state, operationLocation });
    return processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult }), state;
  }
  exports.initOperation = initOperation;
  async function pollOperationHelper(inputs) {
    let { poll, state, stateProxy, operationLocation, getOperationStatus, getResourceLocation, isOperationError, options } = inputs, response = await poll(operationLocation, options).catch(setStateError({
      state,
      stateProxy,
      isOperationError
    })), status = getOperationStatus(response, state);
    if (logger_js_1.logger.verbose(`LRO: Status:
	Polling from: ${state.config.operationLocation}
	Operation status: ${status}
	Polling status: ${constants_js_1.terminalStates.includes(status) ? "Stopped" : "Running"}`), status === "succeeded") {
      let resourceLocation = getResourceLocation(response, state);
      if (resourceLocation !== void 0)
        return {
          response: await poll(resourceLocation).catch(setStateError({ state, stateProxy, isOperationError })),
          status
        };
    }
    return { response, status };
  }
  async function pollOperation(inputs) {
    let { poll, state, stateProxy, options, getOperationStatus, getResourceLocation, getOperationLocation, isOperationError, withOperationLocation, getPollingInterval, processResult, getError, updateState, setDelay, isDone, setErrorAsResult } = inputs, { operationLocation } = state.config;
    if (operationLocation !== void 0) {
      let { response, status } = await pollOperationHelper({
        poll,
        getOperationStatus,
        state,
        stateProxy,
        operationLocation,
        getResourceLocation,
        isOperationError,
        options
      });
      if (processOperationStatus({
        status,
        response,
        state,
        stateProxy,
        isDone,
        processResult,
        getError,
        setErrorAsResult
      }), !constants_js_1.terminalStates.includes(status)) {
        let intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);
        if (intervalInMs)
          setDelay(intervalInMs);
        let location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);
        if (location !== void 0) {
          let isUpdated = operationLocation !== location;
          state.config.operationLocation = location, withOperationLocation === null || withOperationLocation === void 0 || withOperationLocation(location, isUpdated);
        } else
          withOperationLocation === null || withOperationLocation === void 0 || withOperationLocation(operationLocation, !1);
      }
      updateState === null || updateState === void 0 || updateState(state, response);
    }
  }
  exports.pollOperation = pollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/http/operation.js
var require_operation2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.pollHttpOperation = exports.isOperationError = exports.getResourceLocation = exports.getOperationStatus = exports.getOperationLocation = exports.initHttpOperation = exports.getStatusFromInitialResponse = exports.getErrorFromResponse = exports.parseRetryAfter = exports.inferLroMode = void 0;
  var operation_js_1 = require_operation(), logger_js_1 = require_logger2();
  function getOperationLocationPollingUrl(inputs) {
    let { azureAsyncOperation, operationLocation } = inputs;
    return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;
  }
  function getLocationHeader(rawResponse) {
    return rawResponse.headers.location;
  }
  function getOperationLocationHeader(rawResponse) {
    return rawResponse.headers["operation-location"];
  }
  function getAzureAsyncOperationHeader(rawResponse) {
    return rawResponse.headers["azure-asyncoperation"];
  }
  function findResourceLocation(inputs) {
    var _a;
    let { location, requestMethod, requestPath, resourceLocationConfig } = inputs;
    switch (requestMethod) {
      case "PUT":
        return requestPath;
      case "DELETE":
        return;
      case "PATCH":
        return (_a = getDefault()) !== null && _a !== void 0 ? _a : requestPath;
      default:
        return getDefault();
    }
    function getDefault() {
      switch (resourceLocationConfig) {
        case "azure-async-operation":
          return;
        case "original-uri":
          return requestPath;
        case "location":
        default:
          return location;
      }
    }
  }
  function inferLroMode(inputs) {
    let { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs, operationLocation = getOperationLocationHeader(rawResponse), azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse), pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation }), location = getLocationHeader(rawResponse), normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();
    if (pollingUrl !== void 0)
      return {
        mode: "OperationLocation",
        operationLocation: pollingUrl,
        resourceLocation: findResourceLocation({
          requestMethod: normalizedRequestMethod,
          location,
          requestPath,
          resourceLocationConfig
        })
      };
    else if (location !== void 0)
      return {
        mode: "ResourceLocation",
        operationLocation: location
      };
    else if (normalizedRequestMethod === "PUT" && requestPath)
      return {
        mode: "Body",
        operationLocation: requestPath
      };
    else
      return;
  }
  exports.inferLroMode = inferLroMode;
  function transformStatus(inputs) {
    let { status, statusCode } = inputs;
    if (typeof status !== "string" && status !== void 0)
      throw Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);
    switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {
      case void 0:
        return toOperationStatus(statusCode);
      case "succeeded":
        return "succeeded";
      case "failed":
        return "failed";
      case "running":
      case "accepted":
      case "started":
      case "canceling":
      case "cancelling":
        return "running";
      case "canceled":
      case "cancelled":
        return "canceled";
      default:
        return logger_js_1.logger.verbose(`LRO: unrecognized operation status: ${status}`), status;
    }
  }
  function getStatus(rawResponse) {
    var _a;
    let { status } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function getProvisioningState(rawResponse) {
    var _a, _b;
    let { properties, provisioningState } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {}, status = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;
    return transformStatus({ status, statusCode: rawResponse.statusCode });
  }
  function toOperationStatus(statusCode) {
    if (statusCode === 202)
      return "running";
    else if (statusCode < 300)
      return "succeeded";
    else
      return "failed";
  }
  function parseRetryAfter({ rawResponse }) {
    let retryAfter = rawResponse.headers["retry-after"];
    if (retryAfter !== void 0) {
      let retryAfterInSeconds = parseInt(retryAfter);
      return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;
    }
    return;
  }
  exports.parseRetryAfter = parseRetryAfter;
  function getErrorFromResponse(response) {
    let error = accessBodyProperty(response, "error");
    if (!error) {
      logger_js_1.logger.warning("The long-running operation failed but there is no error property in the response's body");
      return;
    }
    if (!error.code || !error.message) {
      logger_js_1.logger.warning("The long-running operation failed but the error property in the response's body doesn't contain code or message");
      return;
    }
    return error;
  }
  exports.getErrorFromResponse = getErrorFromResponse;
  function calculatePollingIntervalFromDate(retryAfterDate) {
    let timeNow = Math.floor((/* @__PURE__ */ new Date()).getTime()), retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime)
      return retryAfterTime - timeNow;
    return;
  }
  function getStatusFromInitialResponse(inputs) {
    let { response, state, operationLocation } = inputs;
    function helper() {
      var _a;
      switch ((_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a.mode) {
        case void 0:
          return toOperationStatus(response.rawResponse.statusCode);
        case "Body":
          return getOperationStatus(response, state);
        default:
          return "running";
      }
    }
    let status = helper();
    return status === "running" && operationLocation === void 0 ? "succeeded" : status;
  }
  exports.getStatusFromInitialResponse = getStatusFromInitialResponse;
  async function initHttpOperation(inputs) {
    let { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;
    return (0, operation_js_1.initOperation)({
      init: async () => {
        let response = await lro.sendInitialRequest(), config = inferLroMode({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation, resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation }, (config === null || config === void 0 ? void 0 : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      stateProxy,
      processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse,
      getOperationStatus: getStatusFromInitialResponse,
      setErrorAsResult
    });
  }
  exports.initHttpOperation = initHttpOperation;
  function getOperationLocation({ rawResponse }, state) {
    var _a;
    switch ((_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a.mode) {
      case "OperationLocation":
        return getOperationLocationPollingUrl({
          operationLocation: getOperationLocationHeader(rawResponse),
          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)
        });
      case "ResourceLocation":
        return getLocationHeader(rawResponse);
      case "Body":
      default:
        return;
    }
  }
  exports.getOperationLocation = getOperationLocation;
  function getOperationStatus({ rawResponse }, state) {
    var _a;
    let mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a.mode;
    switch (mode) {
      case "OperationLocation":
        return getStatus(rawResponse);
      case "ResourceLocation":
        return toOperationStatus(rawResponse.statusCode);
      case "Body":
        return getProvisioningState(rawResponse);
      default:
        throw Error(`Internal error: Unexpected operation mode: ${mode}`);
    }
  }
  exports.getOperationStatus = getOperationStatus;
  function accessBodyProperty({ flatResponse, rawResponse }, prop) {
    var _a, _b;
    return (_a = flatResponse === null || flatResponse === void 0 ? void 0 : flatResponse[prop]) !== null && _a !== void 0 ? _a : (_b = rawResponse.body) === null || _b === void 0 ? void 0 : _b[prop];
  }
  function getResourceLocation(res, state) {
    let loc = accessBodyProperty(res, "resourceLocation");
    if (loc && typeof loc === "string")
      state.config.resourceLocation = loc;
    return state.config.resourceLocation;
  }
  exports.getResourceLocation = getResourceLocation;
  function isOperationError(e) {
    return e.name === "RestError";
  }
  exports.isOperationError = isOperationError;
  async function pollHttpOperation(inputs) {
    let { lro, stateProxy, options, processResult, updateState, setDelay, state, setErrorAsResult } = inputs;
    return (0, operation_js_1.pollOperation)({
      state,
      stateProxy,
      setDelay,
      processResult: processResult ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState) : ({ flatResponse }) => flatResponse,
      getError: getErrorFromResponse,
      updateState,
      getPollingInterval: parseRetryAfter,
      getOperationLocation,
      getOperationStatus,
      isOperationError,
      getResourceLocation,
      options,
      poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),
      setErrorAsResult
    });
  }
  exports.pollHttpOperation = pollHttpOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/poller/poller.js
var require_poller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.buildCreatePoller = void 0;
  var operation_js_1 = require_operation(), constants_js_1 = require_constants10(), core_util_1 = require_commonjs9(), createStateProxy = () => ({
    initState: (config) => ({ status: "running", config }),
    setCanceled: (state) => state.status = "canceled",
    setError: (state, error) => state.error = error,
    setResult: (state, result) => state.result = result,
    setRunning: (state) => state.status = "running",
    setSucceeded: (state) => state.status = "succeeded",
    setFailed: (state) => state.status = "failed",
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => state.status === "canceled",
    isFailed: (state) => state.status === "failed",
    isRunning: (state) => state.status === "running",
    isSucceeded: (state) => state.status === "succeeded"
  });
  function buildCreatePoller(inputs) {
    let { getOperationLocation, getStatusFromInitialResponse, getStatusFromPollResponse, isOperationError, getResourceLocation, getPollingInterval, getError, resolveOnUnsuccessful } = inputs;
    return async ({ init, poll }, options) => {
      let { processResult, updateState, withOperationLocation: withOperationLocationCallback, intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, restoreFrom } = options || {}, stateProxy = createStateProxy(), withOperationLocation = withOperationLocationCallback ? (() => {
        let called = !1;
        return (operationLocation, isUpdated) => {
          if (isUpdated)
            withOperationLocationCallback(operationLocation);
          else if (!called)
            withOperationLocationCallback(operationLocation);
          called = !0;
        };
      })() : void 0, state = restoreFrom ? (0, operation_js_1.deserializeState)(restoreFrom) : await (0, operation_js_1.initOperation)({
        init,
        stateProxy,
        processResult,
        getOperationStatus: getStatusFromInitialResponse,
        withOperationLocation,
        setErrorAsResult: !resolveOnUnsuccessful
      }), resultPromise, abortController = new AbortController, handlers = /* @__PURE__ */ new Map, handleProgressEvents = async () => handlers.forEach((h) => h(state)), cancelErrMsg = "Operation was canceled", currentPollIntervalInMs = intervalInMs, poller = {
        getOperationState: () => state,
        getResult: () => state.result,
        isDone: () => ["succeeded", "failed", "canceled"].includes(state.status),
        isStopped: () => resultPromise === void 0,
        stopPolling: () => {
          abortController.abort();
        },
        toString: () => JSON.stringify({
          state
        }),
        onProgress: (callback) => {
          let s = Symbol();
          return handlers.set(s, callback), () => handlers.delete(s);
        },
        pollUntilDone: (pollOptions) => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = (async () => {
          let { abortSignal: inputAbortSignal } = pollOptions || {};
          function abortListener() {
            abortController.abort();
          }
          let abortSignal = abortController.signal;
          if (inputAbortSignal === null || inputAbortSignal === void 0 ? void 0 : inputAbortSignal.aborted)
            abortController.abort();
          else if (!abortSignal.aborted)
            inputAbortSignal === null || inputAbortSignal === void 0 || inputAbortSignal.addEventListener("abort", abortListener, { once: !0 });
          try {
            if (!poller.isDone()) {
              await poller.poll({ abortSignal });
              while (!poller.isDone())
                await (0, core_util_1.delay)(currentPollIntervalInMs, { abortSignal }), await poller.poll({ abortSignal });
            }
          } finally {
            inputAbortSignal === null || inputAbortSignal === void 0 || inputAbortSignal.removeEventListener("abort", abortListener);
          }
          if (resolveOnUnsuccessful)
            return poller.getResult();
          else
            switch (state.status) {
              case "succeeded":
                return poller.getResult();
              case "canceled":
                throw Error("Operation was canceled");
              case "failed":
                throw state.error;
              case "notStarted":
              case "running":
                throw Error("Polling completed without succeeding or failing");
            }
        })().finally(() => {
          resultPromise = void 0;
        }),
        async poll(pollOptions) {
          if (resolveOnUnsuccessful) {
            if (poller.isDone())
              return;
          } else
            switch (state.status) {
              case "succeeded":
                return;
              case "canceled":
                throw Error("Operation was canceled");
              case "failed":
                throw state.error;
            }
          if (await (0, operation_js_1.pollOperation)({
            poll,
            state,
            stateProxy,
            getOperationLocation,
            isOperationError,
            withOperationLocation,
            getPollingInterval,
            getOperationStatus: getStatusFromPollResponse,
            getResourceLocation,
            processResult,
            getError,
            updateState,
            options: pollOptions,
            setDelay: (pollIntervalInMs) => {
              currentPollIntervalInMs = pollIntervalInMs;
            },
            setErrorAsResult: !resolveOnUnsuccessful
          }), await handleProgressEvents(), !resolveOnUnsuccessful)
            switch (state.status) {
              case "canceled":
                throw Error("Operation was canceled");
              case "failed":
                throw state.error;
            }
        }
      };
      return poller;
    };
  }
  exports.buildCreatePoller = buildCreatePoller;
});

// node_modules/@azure/core-lro/dist/commonjs/http/poller.js
var require_poller2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createHttpPoller = void 0;
  var operation_js_1 = require_operation2(), poller_js_1 = require_poller();
  async function createHttpPoller(lro, options) {
    let { resourceLocationConfig, intervalInMs, processResult, restoreFrom, updateState, withOperationLocation, resolveOnUnsuccessful = !1 } = options || {};
    return (0, poller_js_1.buildCreatePoller)({
      getStatusFromInitialResponse: operation_js_1.getStatusFromInitialResponse,
      getStatusFromPollResponse: operation_js_1.getOperationStatus,
      isOperationError: operation_js_1.isOperationError,
      getOperationLocation: operation_js_1.getOperationLocation,
      getResourceLocation: operation_js_1.getResourceLocation,
      getPollingInterval: operation_js_1.parseRetryAfter,
      getError: operation_js_1.getErrorFromResponse,
      resolveOnUnsuccessful
    })({
      init: async () => {
        let response = await lro.sendInitialRequest(), config = (0, operation_js_1.inferLroMode)({
          rawResponse: response.rawResponse,
          requestPath: lro.requestPath,
          requestMethod: lro.requestMethod,
          resourceLocationConfig
        });
        return Object.assign({ response, operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation, resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation }, (config === null || config === void 0 ? void 0 : config.mode) ? { metadata: { mode: config.mode } } : {});
      },
      poll: lro.sendPollRequest
    }, {
      intervalInMs,
      withOperationLocation,
      restoreFrom,
      updateState,
      processResult: processResult ? ({ flatResponse }, state) => processResult(flatResponse, state) : ({ flatResponse }) => flatResponse
    });
  }
  exports.createHttpPoller = createHttpPoller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/operation.js
var require_operation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.GenericPollOperation = void 0;
  var operation_js_1 = require_operation2(), logger_js_1 = require_logger2(), createStateProxy = () => ({
    initState: (config) => ({ config, isStarted: !0 }),
    setCanceled: (state) => state.isCancelled = !0,
    setError: (state, error) => state.error = error,
    setResult: (state, result) => state.result = result,
    setRunning: (state) => state.isStarted = !0,
    setSucceeded: (state) => state.isCompleted = !0,
    setFailed: () => {},
    getError: (state) => state.error,
    getResult: (state) => state.result,
    isCanceled: (state) => !!state.isCancelled,
    isFailed: (state) => !!state.error,
    isRunning: (state) => !!state.isStarted,
    isSucceeded: (state) => Boolean(state.isCompleted && !state.isCancelled && !state.error)
  });

  class GenericPollOperation {
    constructor(state, lro, setErrorAsResult, lroResourceLocationConfig, processResult, updateState, isDone) {
      this.state = state, this.lro = lro, this.setErrorAsResult = setErrorAsResult, this.lroResourceLocationConfig = lroResourceLocationConfig, this.processResult = processResult, this.updateState = updateState, this.isDone = isDone;
    }
    setPollerConfig(pollerConfig) {
      this.pollerConfig = pollerConfig;
    }
    async update(options) {
      var _a;
      let stateProxy = createStateProxy();
      if (!this.state.isStarted)
        this.state = Object.assign(Object.assign({}, this.state), await (0, operation_js_1.initHttpOperation)({
          lro: this.lro,
          stateProxy,
          resourceLocationConfig: this.lroResourceLocationConfig,
          processResult: this.processResult,
          setErrorAsResult: this.setErrorAsResult
        }));
      let updateState = this.updateState, isDone = this.isDone;
      if (!this.state.isCompleted && this.state.error === void 0)
        await (0, operation_js_1.pollHttpOperation)({
          lro: this.lro,
          state: this.state,
          stateProxy,
          processResult: this.processResult,
          updateState: updateState ? (state, { rawResponse }) => updateState(state, rawResponse) : void 0,
          isDone: isDone ? ({ flatResponse }, state) => isDone(flatResponse, state) : void 0,
          options,
          setDelay: (intervalInMs) => {
            this.pollerConfig.intervalInMs = intervalInMs;
          },
          setErrorAsResult: this.setErrorAsResult
        });
      return (_a = options === null || options === void 0 ? void 0 : options.fireProgress) === null || _a === void 0 || _a.call(options, this.state), this;
    }
    async cancel() {
      return logger_js_1.logger.error("`cancelOperation` is deprecated because it wasn't implemented"), this;
    }
    toString() {
      return JSON.stringify({
        state: this.state
      });
    }
  }
  exports.GenericPollOperation = GenericPollOperation;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/poller.js
var require_poller3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Poller = exports.PollerCancelledError = exports.PollerStoppedError = void 0;

  class PollerStoppedError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerStoppedError", Object.setPrototypeOf(this, PollerStoppedError.prototype);
    }
  }
  exports.PollerStoppedError = PollerStoppedError;

  class PollerCancelledError extends Error {
    constructor(message) {
      super(message);
      this.name = "PollerCancelledError", Object.setPrototypeOf(this, PollerCancelledError.prototype);
    }
  }
  exports.PollerCancelledError = PollerCancelledError;

  class Poller {
    constructor(operation) {
      this.resolveOnUnsuccessful = !1, this.stopped = !0, this.pollProgressCallbacks = [], this.operation = operation, this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve, this.reject = reject;
      }), this.promise.catch(() => {});
    }
    async startPolling(pollOptions = {}) {
      if (this.stopped)
        this.stopped = !1;
      while (!this.isStopped() && !this.isDone())
        await this.poll(pollOptions), await this.delay();
    }
    async pollOnce(options = {}) {
      if (!this.isDone())
        this.operation = await this.operation.update({
          abortSignal: options.abortSignal,
          fireProgress: this.fireProgress.bind(this)
        });
      this.processUpdatedState();
    }
    fireProgress(state) {
      for (let callback of this.pollProgressCallbacks)
        callback(state);
    }
    async cancelOnce(options = {}) {
      this.operation = await this.operation.cancel(options);
    }
    poll(options = {}) {
      if (!this.pollOncePromise) {
        this.pollOncePromise = this.pollOnce(options);
        let clearPollOncePromise = () => {
          this.pollOncePromise = void 0;
        };
        this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
      }
      return this.pollOncePromise;
    }
    processUpdatedState() {
      if (this.operation.state.error) {
        if (this.stopped = !0, !this.resolveOnUnsuccessful)
          throw this.reject(this.operation.state.error), this.operation.state.error;
      }
      if (this.operation.state.isCancelled) {
        if (this.stopped = !0, !this.resolveOnUnsuccessful) {
          let error = new PollerCancelledError("Operation was canceled");
          throw this.reject(error), error;
        }
      }
      if (this.isDone() && this.resolve)
        this.resolve(this.getResult());
    }
    async pollUntilDone(pollOptions = {}) {
      if (this.stopped)
        this.startPolling(pollOptions).catch(this.reject);
      return this.processUpdatedState(), this.promise;
    }
    onProgress(callback) {
      return this.pollProgressCallbacks.push(callback), () => {
        this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c) => c !== callback);
      };
    }
    isDone() {
      let state = this.operation.state;
      return Boolean(state.isCompleted || state.isCancelled || state.error);
    }
    stopPolling() {
      if (!this.stopped) {
        if (this.stopped = !0, this.reject)
          this.reject(new PollerStoppedError("This poller is already stopped"));
      }
    }
    isStopped() {
      return this.stopped;
    }
    cancelOperation(options = {}) {
      if (!this.cancelPromise)
        this.cancelPromise = this.cancelOnce(options);
      else if (options.abortSignal)
        throw Error("A cancel request is currently pending");
      return this.cancelPromise;
    }
    getOperationState() {
      return this.operation.state;
    }
    getResult() {
      return this.operation.state.result;
    }
    toString() {
      return this.operation.toString();
    }
  }
  exports.Poller = Poller;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/lroEngine.js
var require_lroEngine = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.LroEngine = void 0;
  var operation_js_1 = require_operation3(), constants_js_1 = require_constants10(), poller_js_1 = require_poller3(), operation_js_2 = require_operation();

  class LroEngine extends poller_js_1.Poller {
    constructor(lro, options) {
      let { intervalInMs = constants_js_1.POLL_INTERVAL_IN_MS, resumeFrom, resolveOnUnsuccessful = !1, isDone, lroResourceLocationConfig, processResult, updateState } = options || {}, state = resumeFrom ? (0, operation_js_2.deserializeState)(resumeFrom) : {}, operation = new operation_js_1.GenericPollOperation(state, lro, !resolveOnUnsuccessful, lroResourceLocationConfig, processResult, updateState, isDone);
      super(operation);
      this.resolveOnUnsuccessful = resolveOnUnsuccessful, this.config = { intervalInMs }, operation.setPollerConfig(this.config);
    }
    delay() {
      return new Promise((resolve) => setTimeout(() => resolve(), this.config.intervalInMs));
    }
  }
  exports.LroEngine = LroEngine;
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/lroEngine/index.js
var require_lroEngine2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.LroEngine = void 0;
  var lroEngine_js_1 = require_lroEngine();
  Object.defineProperty(exports, "LroEngine", { enumerable: !0, get: function() {
    return lroEngine_js_1.LroEngine;
  } });
});

// node_modules/@azure/core-lro/dist/commonjs/legacy/pollOperation.js
var require_pollOperation = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@azure/core-lro/dist/commonjs/index.js
var require_commonjs20 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.createHttpPoller = void 0;
  var tslib_1 = require_tslib3(), poller_js_1 = require_poller2();
  Object.defineProperty(exports, "createHttpPoller", { enumerable: !0, get: function() {
    return poller_js_1.createHttpPoller;
  } });
  tslib_1.__exportStar(require_lroEngine2(), exports);
  tslib_1.__exportStar(require_poller3(), exports);
  tslib_1.__exportStar(require_pollOperation(), exports);
});

// node_modules/@azure/storage-blob/dist/commonjs/pollers/BlobStartCopyFromUrlPoller.js
var require_BlobStartCopyFromUrlPoller = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobBeginCopyFromUrlPoller = void 0;
  var core_util_1 = require_commonjs9(), core_lro_1 = require_commonjs20();

  class BlobBeginCopyFromUrlPoller extends core_lro_1.Poller {
    intervalInMs;
    constructor(options) {
      let { blobClient, copySource, intervalInMs = 15000, onProgress, resumeFrom, startCopyFromURLOptions } = options, state;
      if (resumeFrom)
        state = JSON.parse(resumeFrom).state;
      let operation = makeBlobBeginCopyFromURLPollOperation({
        ...state,
        blobClient,
        copySource,
        startCopyFromURLOptions
      });
      super(operation);
      if (typeof onProgress === "function")
        this.onProgress(onProgress);
      this.intervalInMs = intervalInMs;
    }
    delay() {
      return (0, core_util_1.delay)(this.intervalInMs);
    }
  }
  exports.BlobBeginCopyFromUrlPoller = BlobBeginCopyFromUrlPoller;
  var cancel = async function(options = {}) {
    let state = this.state, { copyId } = state;
    if (state.isCompleted)
      return makeBlobBeginCopyFromURLPollOperation(state);
    if (!copyId)
      return state.isCancelled = !0, makeBlobBeginCopyFromURLPollOperation(state);
    return await state.blobClient.abortCopyFromURL(copyId, {
      abortSignal: options.abortSignal
    }), state.isCancelled = !0, makeBlobBeginCopyFromURLPollOperation(state);
  }, update = async function(options = {}) {
    let state = this.state, { blobClient, copySource, startCopyFromURLOptions } = state;
    if (!state.isStarted) {
      state.isStarted = !0;
      let result = await blobClient.startCopyFromURL(copySource, startCopyFromURLOptions);
      if (state.copyId = result.copyId, result.copyStatus === "success")
        state.result = result, state.isCompleted = !0;
    } else if (!state.isCompleted)
      try {
        let result = await state.blobClient.getProperties({ abortSignal: options.abortSignal }), { copyStatus, copyProgress } = result, prevCopyProgress = state.copyProgress;
        if (copyProgress)
          state.copyProgress = copyProgress;
        if (copyStatus === "pending" && copyProgress !== prevCopyProgress && typeof options.fireProgress === "function")
          options.fireProgress(state);
        else if (copyStatus === "success")
          state.result = result, state.isCompleted = !0;
        else if (copyStatus === "failed")
          state.error = Error(`Blob copy failed with reason: "${result.copyStatusDescription || "unknown"}"`), state.isCompleted = !0;
      } catch (err) {
        state.error = err, state.isCompleted = !0;
      }
    return makeBlobBeginCopyFromURLPollOperation(state);
  }, toString = function() {
    return JSON.stringify({ state: this.state }, (key, value) => {
      if (key === "blobClient")
        return;
      return value;
    });
  };
  function makeBlobBeginCopyFromURLPollOperation(state) {
    return {
      state: { ...state },
      cancel,
      toString,
      update
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/Range.js
var require_Range = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.rangeToString = rangeToString;
  function rangeToString(iRange) {
    if (iRange.offset < 0)
      throw RangeError("Range.offset cannot be smaller than 0.");
    if (iRange.count && iRange.count <= 0)
      throw RangeError("Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.");
    return iRange.count ? `bytes=${iRange.offset}-${iRange.offset + iRange.count - 1}` : `bytes=${iRange.offset}-`;
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/Batch.js
var require_Batch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Batch = void 0;
  var events_1 = __require("events"), BatchStates;
  (function(BatchStates2) {
    BatchStates2[BatchStates2.Good = 0] = "Good", BatchStates2[BatchStates2.Error = 1] = "Error";
  })(BatchStates || (BatchStates = {}));

  class Batch {
    concurrency;
    actives = 0;
    completed = 0;
    offset = 0;
    operations = [];
    state = BatchStates.Good;
    emitter;
    constructor(concurrency = 5) {
      if (concurrency < 1)
        throw RangeError("concurrency must be larger than 0");
      this.concurrency = concurrency, this.emitter = new events_1.EventEmitter;
    }
    addOperation(operation) {
      this.operations.push(async () => {
        try {
          this.actives++, await operation(), this.actives--, this.completed++, this.parallelExecute();
        } catch (error) {
          this.emitter.emit("error", error);
        }
      });
    }
    async do() {
      if (this.operations.length === 0)
        return Promise.resolve();
      return this.parallelExecute(), new Promise((resolve, reject) => {
        this.emitter.on("finish", resolve), this.emitter.on("error", (error) => {
          this.state = BatchStates.Error, reject(error);
        });
      });
    }
    nextOperation() {
      if (this.offset < this.operations.length)
        return this.operations[this.offset++];
      return null;
    }
    parallelExecute() {
      if (this.state === BatchStates.Error)
        return;
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      while (this.actives < this.concurrency) {
        let operation = this.nextOperation();
        if (operation)
          operation();
        else
          return;
      }
    }
  }
  exports.Batch = Batch;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/utils.js
var require_utils4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.fsCreateReadStream = exports.fsStat = void 0;
  exports.streamToBuffer = streamToBuffer;
  exports.streamToBuffer2 = streamToBuffer2;
  exports.streamToBuffer3 = streamToBuffer3;
  exports.readStreamToLocalFile = readStreamToLocalFile;
  var tslib_1 = require_tslib(), node_fs_1 = tslib_1.__importDefault(__require("node:fs")), node_util_1 = tslib_1.__importDefault(__require("node:util")), constants_js_1 = require_constants8();
  async function streamToBuffer(stream, buffer, offset, end, encoding) {
    let pos = 0, count = end - offset;
    return new Promise((resolve, reject) => {
      let timeout = setTimeout(() => reject(Error("The operation cannot be completed in timeout.")), constants_js_1.REQUEST_TIMEOUT);
      stream.on("readable", () => {
        if (pos >= count) {
          clearTimeout(timeout), resolve();
          return;
        }
        let chunk = stream.read();
        if (!chunk)
          return;
        if (typeof chunk === "string")
          chunk = Buffer.from(chunk, encoding);
        let chunkLength = pos + chunk.length > count ? count - pos : chunk.length;
        buffer.fill(chunk.slice(0, chunkLength), offset + pos, offset + pos + chunkLength), pos += chunkLength;
      }), stream.on("end", () => {
        if (clearTimeout(timeout), pos < count)
          reject(Error(`Stream drains before getting enough data needed. Data read: ${pos}, data need: ${count}`));
        resolve();
      }), stream.on("error", (msg) => {
        clearTimeout(timeout), reject(msg);
      });
    });
  }
  async function streamToBuffer2(stream, buffer, encoding) {
    let pos = 0, bufferSize = buffer.length;
    return new Promise((resolve, reject) => {
      stream.on("readable", () => {
        let chunk = stream.read();
        if (!chunk)
          return;
        if (typeof chunk === "string")
          chunk = Buffer.from(chunk, encoding);
        if (pos + chunk.length > bufferSize) {
          reject(Error(`Stream exceeds buffer size. Buffer size: ${bufferSize}`));
          return;
        }
        buffer.fill(chunk, pos, pos + chunk.length), pos += chunk.length;
      }), stream.on("end", () => {
        resolve(pos);
      }), stream.on("error", reject);
    });
  }
  async function streamToBuffer3(readableStream, encoding) {
    return new Promise((resolve, reject) => {
      let chunks = [];
      readableStream.on("data", (data) => {
        chunks.push(typeof data === "string" ? Buffer.from(data, encoding) : data);
      }), readableStream.on("end", () => {
        resolve(Buffer.concat(chunks));
      }), readableStream.on("error", reject);
    });
  }
  async function readStreamToLocalFile(rs, file) {
    return new Promise((resolve, reject) => {
      let ws = node_fs_1.default.createWriteStream(file);
      rs.on("error", (err) => {
        reject(err);
      }), ws.on("error", (err) => {
        reject(err);
      }), ws.on("close", resolve), rs.pipe(ws);
    });
  }
  exports.fsStat = node_util_1.default.promisify(node_fs_1.default.stat);
  exports.fsCreateReadStream = node_fs_1.default.createReadStream;
});

// node_modules/@azure/storage-blob/dist/commonjs/Clients.js
var require_Clients = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.PageBlobClient = exports.BlockBlobClient = exports.AppendBlobClient = exports.BlobClient = void 0;
  var core_rest_pipeline_1 = require_commonjs8(), core_auth_1 = require_commonjs10(), core_util_1 = require_commonjs9(), core_util_2 = require_commonjs9(), BlobDownloadResponse_js_1 = require_BlobDownloadResponse(), BlobQueryResponse_js_1 = require_BlobQueryResponse(), AnonymousCredential_js_1 = require_AnonymousCredential(), StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential(), models_js_1 = require_models2(), PageBlobRangeResponse_js_1 = require_PageBlobRangeResponse(), Pipeline_js_1 = require_Pipeline(), BlobStartCopyFromUrlPoller_js_1 = require_BlobStartCopyFromUrlPoller(), Range_js_1 = require_Range(), StorageClient_js_1 = require_StorageClient(), Batch_js_1 = require_Batch(), storage_common_1 = require_commonjs18(), constants_js_1 = require_constants8(), tracing_js_1 = require_tracing(), utils_common_js_1 = require_utils_common(), utils_js_1 = require_utils4(), BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues(), BlobLeaseClient_js_1 = require_BlobLeaseClient();

  class BlobClient extends StorageClient_js_1.StorageClient {
    blobContext;
    _name;
    _containerName;
    _versionId;
    _snapshot;
    get name() {
      return this._name;
    }
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      options = options || {};
      let pipeline, url;
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
      else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, options = blobNameOrOptions, pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        if (url = urlOrConnectionString, blobNameOrOptions && typeof blobNameOrOptions !== "string")
          options = blobNameOrOptions;
        pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        let containerName = credentialOrPipelineOrContainerName, blobName = blobNameOrOptions, extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString")
          if (core_util_1.isNodeLike) {
            let sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            if (url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)), !options.proxyOptions)
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else
            throw Error("Account connection string is only supported in Node.js environment");
        else if (extractedCreds.kind === "SASConnString")
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas, pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
        else
          throw Error("Connection string must be either an Account connection string or a SAS connection string");
      } else
        throw Error("Expecting non-empty strings for containerName and blobName parameters");
      super(url, pipeline);
      ({ blobName: this._name, containerName: this._containerName } = this.getBlobAndContainerNamesFromUrl()), this.blobContext = this.storageClientContext.blob, this._snapshot = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT), this._versionId = (0, utils_common_js_1.getURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID);
    }
    withSnapshot(snapshot) {
      return new BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
    }
    withVersion(versionId) {
      return new BlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.VERSIONID, versionId.length === 0 ? void 0 : versionId), this.pipeline);
    }
    getAppendBlobClient() {
      return new AppendBlobClient(this.url, this.pipeline);
    }
    getBlockBlobClient() {
      return new BlockBlobClient(this.url, this.pipeline);
    }
    getPageBlobClient() {
      return new PageBlobClient(this.url, this.pipeline);
    }
    async download(offset = 0, count, options = {}) {
      return options.conditions = options.conditions || {}, options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlobClient-download", options, async (updatedOptions) => {
        let res = (0, utils_common_js_1.assertResponse)(await this.blobContext.download({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          requestOptions: {
            onDownloadProgress: core_util_1.isNodeLike ? void 0 : options.onProgress
          },
          range: offset === 0 && !count ? void 0 : (0, Range_js_1.rangeToString)({ offset, count }),
          rangeGetContentMD5: options.rangeGetContentMD5,
          rangeGetContentCRC64: options.rangeGetContentCrc64,
          snapshot: options.snapshot,
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        })), wrappedRes = {
          ...res,
          _response: res._response,
          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
          objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
        };
        if (!core_util_1.isNodeLike)
          return wrappedRes;
        if (options.maxRetryRequests === void 0 || options.maxRetryRequests < 0)
          options.maxRetryRequests = constants_js_1.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
        if (res.contentLength === void 0)
          throw RangeError("File download response doesn't contain valid content length header");
        if (!res.etag)
          throw RangeError("File download response doesn't contain valid etag header");
        return new BlobDownloadResponse_js_1.BlobDownloadResponse(wrappedRes, async (start) => {
          let updatedDownloadOptions = {
            leaseAccessConditions: options.conditions,
            modifiedAccessConditions: {
              ifMatch: options.conditions.ifMatch || res.etag,
              ifModifiedSince: options.conditions.ifModifiedSince,
              ifNoneMatch: options.conditions.ifNoneMatch,
              ifUnmodifiedSince: options.conditions.ifUnmodifiedSince,
              ifTags: options.conditions?.tagConditions
            },
            range: (0, Range_js_1.rangeToString)({
              count: offset + res.contentLength - start,
              offset: start
            }),
            rangeGetContentMD5: options.rangeGetContentMD5,
            rangeGetContentCRC64: options.rangeGetContentCrc64,
            snapshot: options.snapshot,
            cpkInfo: options.customerProvidedKey
          };
          return (await this.blobContext.download({
            abortSignal: options.abortSignal,
            ...updatedDownloadOptions
          })).readableStreamBody;
        }, offset, res.contentLength, {
          maxRetryRequests: options.maxRetryRequests,
          onProgress: options.onProgress
        });
      });
    }
    async exists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-exists", options, async (updatedOptions) => {
        try {
          return (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), await this.getProperties({
            abortSignal: options.abortSignal,
            customerProvidedKey: options.customerProvidedKey,
            conditions: options.conditions,
            tracingOptions: updatedOptions.tracingOptions
          }), !0;
        } catch (e) {
          if (e.statusCode === 404)
            return !1;
          else if (e.statusCode === 409 && (e.details.errorCode === constants_js_1.BlobUsesCustomerSpecifiedEncryptionMsg || e.details.errorCode === constants_js_1.BlobDoesNotUseCustomerSpecifiedEncryption))
            return !0;
          throw e;
        }
      });
    }
    async getProperties(options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlobClient-getProperties", options, async (updatedOptions) => {
        let res = (0, utils_common_js_1.assertResponse)(await this.blobContext.getProperties({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return {
          ...res,
          _response: res._response,
          objectReplicationDestinationPolicyId: res.objectReplicationPolicyId,
          objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(res.objectReplicationRules)
        };
      });
    }
    async delete(options = {}) {
      return options.conditions = options.conditions || {}, tracing_js_1.tracingClient.withSpan("BlobClient-delete", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.delete({
          abortSignal: options.abortSignal,
          deleteSnapshots: options.deleteSnapshots,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-deleteIfExists", options, async (updatedOptions) => {
        try {
          let res = (0, utils_common_js_1.assertResponse)(await this.delete(updatedOptions));
          return {
            succeeded: !0,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "BlobNotFound")
            return {
              succeeded: !1,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          throw e;
        }
      });
    }
    async undelete(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-undelete", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.undelete({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setHTTPHeaders(blobHTTPHeaders, options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlobClient-setHTTPHeaders", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setHttpHeaders({
          abortSignal: options.abortSignal,
          blobHttpHeaders: blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setMetadata(metadata, options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlobClient-setMetadata", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setMetadata({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setTags(tags, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setTags", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTags({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions,
          tags: (0, utils_common_js_1.toBlobTags)(tags)
        }));
      });
    }
    async getTags(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-getTags", options, async (updatedOptions) => {
        let response = (0, utils_common_js_1.assertResponse)(await this.blobContext.getTags({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
        return {
          ...response,
          _response: response._response,
          tags: (0, utils_common_js_1.toTags)({ blobTagSet: response.blobTagSet }) || {}
        };
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
    }
    async createSnapshot(options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlobClient-createSnapshot", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.createSnapshot({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async beginCopyFromURL(copySource, options = {}) {
      let client = {
        abortCopyFromURL: (...args) => this.abortCopyFromURL(...args),
        getProperties: (...args) => this.getProperties(...args),
        startCopyFromURL: (...args) => this.startCopyFromURL(...args)
      }, poller = new BlobStartCopyFromUrlPoller_js_1.BlobBeginCopyFromUrlPoller({
        blobClient: client,
        copySource,
        intervalInMs: options.intervalInMs,
        onProgress: options.onProgress,
        resumeFrom: options.resumeFrom,
        startCopyFromURLOptions: options
      });
      return await poller.poll(), poller;
    }
    async abortCopyFromURL(copyId, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-abortCopyFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.abortCopyFromURL(copyId, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncCopyFromURL(copySource, options = {}) {
      return options.conditions = options.conditions || {}, options.sourceConditions = options.sourceConditions || {}, tracing_js_1.tracingClient.withSpan("BlobClient-syncCopyFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.copyFromURL(copySource, {
          abortSignal: options.abortSignal,
          metadata: options.metadata,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
          },
          sourceContentMD5: options.sourceContentMD5,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          encryptionScope: options.encryptionScope,
          copySourceTags: options.copySourceTags,
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setAccessTier(tier, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setAccessTier", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setTier((0, models_js_1.toAccessTier)(tier), {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          rehydratePriority: options.rehydratePriority,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async downloadToBuffer(param1, param2, param3, param4 = {}) {
      let buffer, offset = 0, count = 0, options = param4;
      if (param1 instanceof Buffer)
        buffer = param1, offset = param2 || 0, count = typeof param3 === "number" ? param3 : 0;
      else
        offset = typeof param1 === "number" ? param1 : 0, count = typeof param2 === "number" ? param2 : 0, options = param3 || {};
      let blockSize = options.blockSize ?? 0;
      if (blockSize < 0)
        throw RangeError("blockSize option must be >= 0");
      if (blockSize === 0)
        blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
      if (offset < 0)
        throw RangeError("offset option must be >= 0");
      if (count && count <= 0)
        throw RangeError("count option must be greater than 0");
      if (!options.conditions)
        options.conditions = {};
      return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToBuffer", options, async (updatedOptions) => {
        if (!count) {
          let response = await this.getProperties({
            ...options,
            tracingOptions: updatedOptions.tracingOptions
          });
          if (count = response.contentLength - offset, count < 0)
            throw RangeError(`offset ${offset} shouldn't be larger than blob size ${response.contentLength}`);
        }
        if (!buffer)
          try {
            buffer = Buffer.alloc(count);
          } catch (error) {
            throw Error(`Unable to allocate the buffer of size: ${count}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".	 ${error.message}`);
          }
        if (buffer.length < count)
          throw RangeError(`The buffer's size should be equal to or larger than the request count of bytes: ${count}`);
        let transferProgress = 0, batch = new Batch_js_1.Batch(options.concurrency);
        for (let off = offset;off < offset + count; off = off + blockSize)
          batch.addOperation(async () => {
            let chunkEnd = offset + count;
            if (off + blockSize < chunkEnd)
              chunkEnd = off + blockSize;
            let stream = (await this.download(off, chunkEnd - off, {
              abortSignal: options.abortSignal,
              conditions: options.conditions,
              maxRetryRequests: options.maxRetryRequestsPerBlock,
              customerProvidedKey: options.customerProvidedKey,
              tracingOptions: updatedOptions.tracingOptions
            })).readableStreamBody;
            if (await (0, utils_js_1.streamToBuffer)(stream, buffer, off - offset, chunkEnd - offset), transferProgress += chunkEnd - off, options.onProgress)
              options.onProgress({ loadedBytes: transferProgress });
          });
        return await batch.do(), buffer;
      });
    }
    async downloadToFile(filePath, offset = 0, count, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-downloadToFile", options, async (updatedOptions) => {
        let response = await this.download(offset, count, {
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        });
        if (response.readableStreamBody)
          await (0, utils_js_1.readStreamToLocalFile)(response.readableStreamBody, filePath);
        return response.blobDownloadStream = void 0, response;
      });
    }
    getBlobAndContainerNamesFromUrl() {
      let containerName, blobName;
      try {
        let parsedUrl = new URL(this.url);
        if (parsedUrl.host.split(".")[1] === "blob") {
          let pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1], blobName = pathComponents[3];
        } else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl)) {
          let pathComponents = parsedUrl.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
          containerName = pathComponents[2], blobName = pathComponents[4];
        } else {
          let pathComponents = parsedUrl.pathname.match("/([^/]*)(/(.*))?");
          containerName = pathComponents[1], blobName = pathComponents[3];
        }
        if (containerName = decodeURIComponent(containerName), blobName = decodeURIComponent(blobName), blobName = blobName.replace(/\\/g, "/"), !containerName)
          throw Error("Provided containerName is invalid.");
        return { blobName, containerName };
      } catch (error) {
        throw Error("Unable to extract blobName and containerName with provided information.");
      }
    }
    async startCopyFromURL(copySource, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-startCopyFromURL", options, async (updatedOptions) => {
        return options.conditions = options.conditions || {}, options.sourceConditions = options.sourceConditions || {}, (0, utils_common_js_1.assertResponse)(await this.blobContext.startCopyFromURL(copySource, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions.ifMatch,
            sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince,
            sourceIfTags: options.sourceConditions.tagConditions
          },
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          rehydratePriority: options.rehydratePriority,
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          sealBlob: options.sealBlob,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    generateSasUrl(options) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential))
          throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        let sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...options
        }, this.credential).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    generateSasStringToSign(options) {
      if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential))
        throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        blobName: this._name,
        snapshotTime: this._snapshot,
        versionId: this._versionId,
        ...options
      }, this.credential).stringToSign;
    }
    generateUserDelegationSasUrl(options, userDelegationKey) {
      return new Promise((resolve) => {
        let sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...options
        }, userDelegationKey, this.accountName).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    generateUserDelegationSasStringToSign(options, userDelegationKey) {
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        blobName: this._name,
        snapshotTime: this._snapshot,
        versionId: this._versionId,
        ...options
      }, userDelegationKey, this.accountName).stringToSign;
    }
    async deleteImmutabilityPolicy(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-deleteImmutabilityPolicy", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.deleteImmutabilityPolicy({
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setImmutabilityPolicy(immutabilityPolicy, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setImmutabilityPolicy", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setImmutabilityPolicy({
          immutabilityPolicyExpiry: immutabilityPolicy.expiriesOn,
          immutabilityPolicyMode: immutabilityPolicy.policyMode,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setLegalHold(legalHoldEnabled, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-setLegalHold", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.setLegalHold(legalHoldEnabled, {
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobClient-getAccountInfo", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blobContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  exports.BlobClient = BlobClient;

  class AppendBlobClient extends BlobClient {
    appendBlobContext;
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline, url;
      if (options = options || {}, (0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
      else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, options = blobNameOrOptions, pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string")
        url = urlOrConnectionString, pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
      else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        let containerName = credentialOrPipelineOrContainerName, blobName = blobNameOrOptions, extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString")
          if (core_util_1.isNodeLike) {
            let sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            if (url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)), !options.proxyOptions)
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else
            throw Error("Account connection string is only supported in Node.js environment");
        else if (extractedCreds.kind === "SASConnString")
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas, pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
        else
          throw Error("Connection string must be either an Account connection string or a SAS connection string");
      } else
        throw Error("Expecting non-empty strings for containerName and blobName parameters");
      super(url, pipeline);
      this.appendBlobContext = this.storageClientContext.appendBlob;
    }
    withSnapshot(snapshot) {
      return new AppendBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
    }
    async create(options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("AppendBlobClient-create", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.create(0, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(options = {}) {
      let conditions = { ifNoneMatch: constants_js_1.ETagAny };
      return tracing_js_1.tracingClient.withSpan("AppendBlobClient-createIfNotExists", options, async (updatedOptions) => {
        try {
          let res = (0, utils_common_js_1.assertResponse)(await this.create({
            ...updatedOptions,
            conditions
          }));
          return {
            succeeded: !0,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "BlobAlreadyExists")
            return {
              succeeded: !1,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          throw e;
        }
      });
    }
    async seal(options = {}) {
      return options.conditions = options.conditions || {}, tracing_js_1.tracingClient.withSpan("AppendBlobClient-seal", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.seal({
          abortSignal: options.abortSignal,
          appendPositionAccessConditions: options.conditions,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlock(body, contentLength, options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlock", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlock(contentLength, body, {
          abortSignal: options.abortSignal,
          appendPositionAccessConditions: options.conditions,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async appendBlockFromURL(sourceURL, sourceOffset, count, options = {}) {
      return options.conditions = options.conditions || {}, options.sourceConditions = options.sourceConditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("AppendBlobClient-appendBlockFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
          abortSignal: options.abortSignal,
          sourceRange: (0, Range_js_1.rangeToString)({ offset: sourceOffset, count }),
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          leaseAccessConditions: options.conditions,
          appendPositionAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
          },
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  exports.AppendBlobClient = AppendBlobClient;

  class BlockBlobClient extends BlobClient {
    _blobContext;
    blockBlobContext;
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline, url;
      if (options = options || {}, (0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
      else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, options = blobNameOrOptions, pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string") {
        if (url = urlOrConnectionString, blobNameOrOptions && typeof blobNameOrOptions !== "string")
          options = blobNameOrOptions;
        pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
      } else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        let containerName = credentialOrPipelineOrContainerName, blobName = blobNameOrOptions, extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString")
          if (core_util_1.isNodeLike) {
            let sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            if (url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)), !options.proxyOptions)
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else
            throw Error("Account connection string is only supported in Node.js environment");
        else if (extractedCreds.kind === "SASConnString")
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas, pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
        else
          throw Error("Connection string must be either an Account connection string or a SAS connection string");
      } else
        throw Error("Expecting non-empty strings for containerName and blobName parameters");
      super(url, pipeline);
      this.blockBlobContext = this.storageClientContext.blockBlob, this._blobContext = this.storageClientContext.blob;
    }
    withSnapshot(snapshot) {
      return new BlockBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
    }
    async query(query, options = {}) {
      if ((0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), !core_util_1.isNodeLike)
        throw Error("This operation currently is only supported in Node.js.");
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-query", options, async (updatedOptions) => {
        let response = (0, utils_common_js_1.assertResponse)(await this._blobContext.query({
          abortSignal: options.abortSignal,
          queryRequest: {
            queryType: "SQL",
            expression: query,
            inputSerialization: (0, utils_common_js_1.toQuerySerialization)(options.inputTextConfiguration),
            outputSerialization: (0, utils_common_js_1.toQuerySerialization)(options.outputTextConfiguration)
          },
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return new BlobQueryResponse_js_1.BlobQueryResponse(response, {
          abortSignal: options.abortSignal,
          onProgress: options.onProgress,
          onError: options.onError
        });
      });
    }
    async upload(body, contentLength, options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlockBlobClient-upload", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.upload(contentLength, body, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async syncUploadFromURL(sourceURL, options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlockBlobClient-syncUploadFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.putBlobFromUrl(0, sourceURL, {
          ...options,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince,
            sourceIfTags: options.sourceConditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          copySourceTags: options.copySourceTags,
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async stageBlock(blockId, body, contentLength, options = {}) {
      return (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlock", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlock(blockId, contentLength, body, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async stageBlockFromURL(blockId, sourceURL, offset = 0, count, options = {}) {
      return (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlockBlobClient-stageBlockFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          sourceRange: offset === 0 && !count ? void 0 : (0, Range_js_1.rangeToString)({ offset, count }),
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async commitBlockList(blocks, options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("BlockBlobClient-commitBlockList", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.commitBlockList({ latest: blocks }, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getBlockList(listType, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-getBlockList", options, async (updatedOptions) => {
        let res = (0, utils_common_js_1.assertResponse)(await this.blockBlobContext.getBlockList(listType, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
        if (!res.committedBlocks)
          res.committedBlocks = [];
        if (!res.uncommittedBlocks)
          res.uncommittedBlocks = [];
        return res;
      });
    }
    async uploadData(data, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadData", options, async (updatedOptions) => {
        if (core_util_1.isNodeLike) {
          let buffer;
          if (data instanceof Buffer)
            buffer = data;
          else if (data instanceof ArrayBuffer)
            buffer = Buffer.from(data);
          else
            data = data, buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
          return this.uploadSeekableInternal((offset, size) => buffer.slice(offset, offset + size), buffer.byteLength, updatedOptions);
        } else {
          let browserBlob = new Blob([data]);
          return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
        }
      });
    }
    async uploadBrowserData(browserData, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadBrowserData", options, async (updatedOptions) => {
        let browserBlob = new Blob([browserData]);
        return this.uploadSeekableInternal((offset, size) => browserBlob.slice(offset, offset + size), browserBlob.size, updatedOptions);
      });
    }
    async uploadSeekableInternal(bodyFactory, size, options = {}) {
      let blockSize = options.blockSize ?? 0;
      if (blockSize < 0 || blockSize > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES)
        throw RangeError(`blockSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`);
      let maxSingleShotSize = options.maxSingleShotSize ?? constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
      if (maxSingleShotSize < 0 || maxSingleShotSize > constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES)
        throw RangeError(`maxSingleShotSize option must be >= 0 and <= ${constants_js_1.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`);
      if (blockSize === 0) {
        if (size > constants_js_1.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * constants_js_1.BLOCK_BLOB_MAX_BLOCKS)
          throw RangeError(`${size} is too larger to upload to a block blob.`);
        if (size > maxSingleShotSize) {
          if (blockSize = Math.ceil(size / constants_js_1.BLOCK_BLOB_MAX_BLOCKS), blockSize < constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES)
            blockSize = constants_js_1.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
        }
      }
      if (!options.blobHTTPHeaders)
        options.blobHTTPHeaders = {};
      if (!options.conditions)
        options.conditions = {};
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadSeekableInternal", options, async (updatedOptions) => {
        if (size <= maxSingleShotSize)
          return (0, utils_common_js_1.assertResponse)(await this.upload(bodyFactory(0, size), size, updatedOptions));
        let numBlocks = Math.floor((size - 1) / blockSize) + 1;
        if (numBlocks > constants_js_1.BLOCK_BLOB_MAX_BLOCKS)
          throw RangeError(`The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= ${constants_js_1.BLOCK_BLOB_MAX_BLOCKS}`);
        let blockList = [], blockIDPrefix = (0, core_util_2.randomUUID)(), transferProgress = 0, batch = new Batch_js_1.Batch(options.concurrency);
        for (let i = 0;i < numBlocks; i++)
          batch.addOperation(async () => {
            let blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, i), start = blockSize * i, contentLength = (i === numBlocks - 1 ? size : start + blockSize) - start;
            if (blockList.push(blockID), await this.stageBlock(blockID, bodyFactory(start, contentLength), contentLength, {
              abortSignal: options.abortSignal,
              conditions: options.conditions,
              encryptionScope: options.encryptionScope,
              tracingOptions: updatedOptions.tracingOptions
            }), transferProgress += contentLength, options.onProgress)
              options.onProgress({
                loadedBytes: transferProgress
              });
          });
        return await batch.do(), this.commitBlockList(blockList, updatedOptions);
      });
    }
    async uploadFile(filePath, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadFile", options, async (updatedOptions) => {
        let size = (await (0, utils_js_1.fsStat)(filePath)).size;
        return this.uploadSeekableInternal((offset, count) => {
          return () => (0, utils_js_1.fsCreateReadStream)(filePath, {
            autoClose: !0,
            end: count ? offset + count - 1 : 1 / 0,
            start: offset
          });
        }, size, {
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        });
      });
    }
    async uploadStream(stream, bufferSize = constants_js_1.DEFAULT_BLOCK_BUFFER_SIZE_BYTES, maxConcurrency = 5, options = {}) {
      if (!options.blobHTTPHeaders)
        options.blobHTTPHeaders = {};
      if (!options.conditions)
        options.conditions = {};
      return tracing_js_1.tracingClient.withSpan("BlockBlobClient-uploadStream", options, async (updatedOptions) => {
        let blockNum = 0, blockIDPrefix = (0, core_util_2.randomUUID)(), transferProgress = 0, blockList = [];
        return await new storage_common_1.BufferScheduler(stream, bufferSize, maxConcurrency, async (body, length) => {
          let blockID = (0, utils_common_js_1.generateBlockID)(blockIDPrefix, blockNum);
          if (blockList.push(blockID), blockNum++, await this.stageBlock(blockID, body, length, {
            customerProvidedKey: options.customerProvidedKey,
            conditions: options.conditions,
            encryptionScope: options.encryptionScope,
            tracingOptions: updatedOptions.tracingOptions
          }), transferProgress += length, options.onProgress)
            options.onProgress({ loadedBytes: transferProgress });
        }, Math.ceil(maxConcurrency / 4 * 3)).do(), (0, utils_common_js_1.assertResponse)(await this.commitBlockList(blockList, {
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  exports.BlockBlobClient = BlockBlobClient;

  class PageBlobClient extends BlobClient {
    pageBlobContext;
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
      let pipeline, url;
      if (options = options || {}, (0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
      else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, options = blobNameOrOptions, pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string")
        url = urlOrConnectionString, pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
      else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string" && blobNameOrOptions && typeof blobNameOrOptions === "string") {
        let containerName = credentialOrPipelineOrContainerName, blobName = blobNameOrOptions, extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString")
          if (core_util_1.isNodeLike) {
            let sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            if (url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)), !options.proxyOptions)
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else
            throw Error("Account connection string is only supported in Node.js environment");
        else if (extractedCreds.kind === "SASConnString")
          url = (0, utils_common_js_1.appendToURLPath)((0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) + "?" + extractedCreds.accountSas, pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
        else
          throw Error("Connection string must be either an Account connection string or a SAS connection string");
      } else
        throw Error("Expecting non-empty strings for containerName and blobName parameters");
      super(url, pipeline);
      this.pageBlobContext = this.storageClientContext.pageBlob;
    }
    withSnapshot(snapshot) {
      return new PageBlobClient((0, utils_common_js_1.setURLParameter)(this.url, constants_js_1.URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? void 0 : snapshot), this.pipeline);
    }
    async create(size, options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("PageBlobClient-create", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.create(0, size, {
          abortSignal: options.abortSignal,
          blobHttpHeaders: options.blobHTTPHeaders,
          blobSequenceNumber: options.blobSequenceNumber,
          leaseAccessConditions: options.conditions,
          metadata: options.metadata,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          immutabilityPolicyExpiry: options.immutabilityPolicy?.expiriesOn,
          immutabilityPolicyMode: options.immutabilityPolicy?.policyMode,
          legalHold: options.legalHold,
          tier: (0, models_js_1.toAccessTier)(options.tier),
          blobTagsString: (0, utils_common_js_1.toBlobTagsString)(options.tags),
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async createIfNotExists(size, options = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-createIfNotExists", options, async (updatedOptions) => {
        try {
          let conditions = { ifNoneMatch: constants_js_1.ETagAny }, res = (0, utils_common_js_1.assertResponse)(await this.create(size, {
            ...options,
            conditions,
            tracingOptions: updatedOptions.tracingOptions
          }));
          return {
            succeeded: !0,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "BlobAlreadyExists")
            return {
              succeeded: !1,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          throw e;
        }
      });
    }
    async uploadPages(body, offset, count, options = {}) {
      return options.conditions = options.conditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPages", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPages(count, body, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          requestOptions: {
            onUploadProgress: options.onProgress
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          sequenceNumberAccessConditions: options.conditions,
          transactionalContentMD5: options.transactionalContentMD5,
          transactionalContentCrc64: options.transactionalContentCrc64,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async uploadPagesFromURL(sourceURL, sourceOffset, destOffset, count, options = {}) {
      return options.conditions = options.conditions || {}, options.sourceConditions = options.sourceConditions || {}, (0, models_js_1.ensureCpkIfSpecified)(options.customerProvidedKey, this.isHttps), tracing_js_1.tracingClient.withSpan("PageBlobClient-uploadPagesFromURL", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.uploadPagesFromURL(sourceURL, (0, Range_js_1.rangeToString)({ offset: sourceOffset, count }), 0, (0, Range_js_1.rangeToString)({ offset: destOffset, count }), {
          abortSignal: options.abortSignal,
          sourceContentMD5: options.sourceContentMD5,
          sourceContentCrc64: options.sourceContentCrc64,
          leaseAccessConditions: options.conditions,
          sequenceNumberAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          sourceModifiedAccessConditions: {
            sourceIfMatch: options.sourceConditions?.ifMatch,
            sourceIfModifiedSince: options.sourceConditions?.ifModifiedSince,
            sourceIfNoneMatch: options.sourceConditions?.ifNoneMatch,
            sourceIfUnmodifiedSince: options.sourceConditions?.ifUnmodifiedSince
          },
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          copySourceAuthorization: (0, utils_common_js_1.httpAuthorizationToString)(options.sourceAuthorization),
          fileRequestIntent: options.sourceShareTokenIntent,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async clearPages(offset = 0, count, options = {}) {
      return options.conditions = options.conditions || {}, tracing_js_1.tracingClient.withSpan("PageBlobClient-clearPages", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.clearPages(0, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          sequenceNumberAccessConditions: options.conditions,
          cpkInfo: options.customerProvidedKey,
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getPageRanges(offset = 0, count, options = {}) {
      return options.conditions = options.conditions || {}, tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRanges", options, async (updatedOptions) => {
        let response = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response);
      });
    }
    async listPageRangesSegment(offset = 0, count, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesSegment", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRanges({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          marker,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async* listPageRangeItemSegments(offset = 0, count, marker, options = {}) {
      let getPageRangeItemSegmentsResponse;
      if (!!marker || marker === void 0)
        do
          getPageRangeItemSegmentsResponse = await this.listPageRangesSegment(offset, count, marker, options), marker = getPageRangeItemSegmentsResponse.continuationToken, yield await getPageRangeItemSegmentsResponse;
        while (marker);
    }
    async* listPageRangeItems(offset = 0, count, options = {}) {
      let marker;
      for await (let getPageRangesSegment of this.listPageRangeItemSegments(offset, count, marker, options))
        yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
    }
    listPageRanges(offset = 0, count, options = {}) {
      options.conditions = options.conditions || {};
      let iter = this.listPageRangeItems(offset, count, options);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeItemSegments(offset, count, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...options
          });
        }
      };
    }
    async getPageRangesDiff(offset, count, prevSnapshot, options = {}) {
      return options.conditions = options.conditions || {}, tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiff", options, async (updatedOptions) => {
        let result = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          prevsnapshot: prevSnapshot,
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(result);
      });
    }
    async listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-getPageRangesDiffSegment", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options?.abortSignal,
          leaseAccessConditions: options?.conditions,
          modifiedAccessConditions: {
            ...options?.conditions,
            ifTags: options?.conditions?.tagConditions
          },
          prevsnapshot: prevSnapshotOrUrl,
          range: (0, Range_js_1.rangeToString)({
            offset,
            count
          }),
          marker,
          maxPageSize: options?.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async* listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options) {
      let getPageRangeItemSegmentsResponse;
      if (!!marker || marker === void 0)
        do
          getPageRangeItemSegmentsResponse = await this.listPageRangesDiffSegment(offset, count, prevSnapshotOrUrl, marker, options), marker = getPageRangeItemSegmentsResponse.continuationToken, yield await getPageRangeItemSegmentsResponse;
        while (marker);
    }
    async* listPageRangeDiffItems(offset, count, prevSnapshotOrUrl, options) {
      let marker;
      for await (let getPageRangesSegment of this.listPageRangeDiffItemSegments(offset, count, prevSnapshotOrUrl, marker, options))
        yield* (0, utils_common_js_1.ExtractPageRangeInfoItems)(getPageRangesSegment);
    }
    listPageRangesDiff(offset, count, prevSnapshot, options = {}) {
      options.conditions = options.conditions || {};
      let iter = this.listPageRangeDiffItems(offset, count, prevSnapshot, {
        ...options
      });
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listPageRangeDiffItemSegments(offset, count, prevSnapshot, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...options
          });
        }
      };
    }
    async getPageRangesDiffForManagedDisks(offset, count, prevSnapshotUrl, options = {}) {
      return options.conditions = options.conditions || {}, tracing_js_1.tracingClient.withSpan("PageBlobClient-GetPageRangesDiffForManagedDisks", options, async (updatedOptions) => {
        let response = (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.getPageRangesDiff({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          prevSnapshotUrl,
          range: (0, Range_js_1.rangeToString)({ offset, count }),
          tracingOptions: updatedOptions.tracingOptions
        }));
        return (0, PageBlobRangeResponse_js_1.rangeResponseFromModel)(response);
      });
    }
    async resize(size, options = {}) {
      return options.conditions = options.conditions || {}, tracing_js_1.tracingClient.withSpan("PageBlobClient-resize", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.resize(size, {
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          encryptionScope: options.encryptionScope,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async updateSequenceNumber(sequenceNumberAction, sequenceNumber, options = {}) {
      return options.conditions = options.conditions || {}, tracing_js_1.tracingClient.withSpan("PageBlobClient-updateSequenceNumber", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, {
          abortSignal: options.abortSignal,
          blobSequenceNumber: sequenceNumber,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async startCopyIncremental(copySource, options = {}) {
      return tracing_js_1.tracingClient.withSpan("PageBlobClient-startCopyIncremental", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.pageBlobContext.copyIncremental(copySource, {
          abortSignal: options.abortSignal,
          modifiedAccessConditions: {
            ...options.conditions,
            ifTags: options.conditions?.tagConditions
          },
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
  }
  exports.PageBlobClient = PageBlobClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/BatchUtils.js
var require_BatchUtils = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getBodyAsText = getBodyAsText;
  exports.utf8ByteLength = utf8ByteLength;
  var utils_js_1 = require_utils4(), constants_js_1 = require_constants8();
  async function getBodyAsText(batchResponse) {
    let buffer = Buffer.alloc(constants_js_1.BATCH_MAX_PAYLOAD_IN_BYTES), responseLength = await (0, utils_js_1.streamToBuffer2)(batchResponse.readableStreamBody, buffer);
    return buffer = buffer.slice(0, responseLength), buffer.toString();
  }
  function utf8ByteLength(str) {
    return Buffer.byteLength(str);
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BatchResponseParser.js
var require_BatchResponseParser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BatchResponseParser = void 0;
  var core_rest_pipeline_1 = require_commonjs8(), core_http_compat_1 = require_commonjs13(), constants_js_1 = require_constants8(), BatchUtils_js_1 = require_BatchUtils(), log_js_1 = require_log6(), HTTP_HEADER_DELIMITER = ": ", SPACE_DELIMITER = " ", NOT_FOUND = -1;

  class BatchResponseParser {
    batchResponse;
    responseBatchBoundary;
    perResponsePrefix;
    batchResponseEnding;
    subRequests;
    constructor(batchResponse, subRequests) {
      if (!batchResponse || !batchResponse.contentType)
        throw RangeError("batchResponse is malformed or doesn't contain valid content-type.");
      if (!subRequests || subRequests.size === 0)
        throw RangeError("Invalid state: subRequests is not provided or size is 0.");
      this.batchResponse = batchResponse, this.subRequests = subRequests, this.responseBatchBoundary = this.batchResponse.contentType.split("=")[1], this.perResponsePrefix = `--${this.responseBatchBoundary}${constants_js_1.HTTP_LINE_ENDING}`, this.batchResponseEnding = `--${this.responseBatchBoundary}--`;
    }
    async parseBatchResponse() {
      if (this.batchResponse._response.status !== constants_js_1.HTTPURLConnection.HTTP_ACCEPTED)
        throw Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);
      let subResponses = (await (0, BatchUtils_js_1.getBodyAsText)(this.batchResponse)).split(this.batchResponseEnding)[0].split(this.perResponsePrefix).slice(1), subResponseCount = subResponses.length;
      if (subResponseCount !== this.subRequests.size && subResponseCount !== 1)
        throw Error("Invalid state: sub responses' count is not equal to sub requests' count.");
      let deserializedSubResponses = Array(subResponseCount), subResponsesSucceededCount = 0, subResponsesFailedCount = 0;
      for (let index = 0;index < subResponseCount; index++) {
        let subResponse = subResponses[index], deserializedSubResponse = {};
        deserializedSubResponse.headers = (0, core_http_compat_1.toHttpHeadersLike)((0, core_rest_pipeline_1.createHttpHeaders)());
        let responseLines = subResponse.split(`${constants_js_1.HTTP_LINE_ENDING}`), subRespHeaderStartFound = !1, subRespHeaderEndFound = !1, subRespFailed = !1, contentId = NOT_FOUND;
        for (let responseLine of responseLines) {
          if (!subRespHeaderStartFound) {
            if (responseLine.startsWith(constants_js_1.HeaderConstants.CONTENT_ID))
              contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);
            if (responseLine.startsWith(constants_js_1.HTTP_VERSION_1_1)) {
              subRespHeaderStartFound = !0;
              let tokens = responseLine.split(SPACE_DELIMITER);
              deserializedSubResponse.status = parseInt(tokens[1]), deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);
            }
            continue;
          }
          if (responseLine.trim() === "") {
            if (!subRespHeaderEndFound)
              subRespHeaderEndFound = !0;
            continue;
          }
          if (!subRespHeaderEndFound) {
            if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1)
              throw Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);
            let tokens = responseLine.split(HTTP_HEADER_DELIMITER);
            if (deserializedSubResponse.headers.set(tokens[0], tokens[1]), tokens[0] === constants_js_1.HeaderConstants.X_MS_ERROR_CODE)
              deserializedSubResponse.errorCode = tokens[1], subRespFailed = !0;
          } else {
            if (!deserializedSubResponse.bodyAsText)
              deserializedSubResponse.bodyAsText = "";
            deserializedSubResponse.bodyAsText += responseLine;
          }
        }
        if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === void 0)
          deserializedSubResponse._request = this.subRequests.get(contentId), deserializedSubResponses[contentId] = deserializedSubResponse;
        else
          log_js_1.logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);
        if (subRespFailed)
          subResponsesFailedCount++;
        else
          subResponsesSucceededCount++;
      }
      return {
        subResponses: deserializedSubResponses,
        subResponsesSucceededCount,
        subResponsesFailedCount
      };
    }
  }
  exports.BatchResponseParser = BatchResponseParser;
});

// node_modules/@azure/storage-blob/dist/commonjs/utils/Mutex.js
var require_Mutex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Mutex = void 0;
  var MutexLockStatus;
  (function(MutexLockStatus2) {
    MutexLockStatus2[MutexLockStatus2.LOCKED = 0] = "LOCKED", MutexLockStatus2[MutexLockStatus2.UNLOCKED = 1] = "UNLOCKED";
  })(MutexLockStatus || (MutexLockStatus = {}));

  class Mutex {
    static async lock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === void 0 || this.keys[key] === MutexLockStatus.UNLOCKED)
          this.keys[key] = MutexLockStatus.LOCKED, resolve();
        else
          this.onUnlockEvent(key, () => {
            this.keys[key] = MutexLockStatus.LOCKED, resolve();
          });
      });
    }
    static async unlock(key) {
      return new Promise((resolve) => {
        if (this.keys[key] === MutexLockStatus.LOCKED)
          this.emitUnlockEvent(key);
        delete this.keys[key], resolve();
      });
    }
    static keys = {};
    static listeners = {};
    static onUnlockEvent(key, handler) {
      if (this.listeners[key] === void 0)
        this.listeners[key] = [handler];
      else
        this.listeners[key].push(handler);
    }
    static emitUnlockEvent(key) {
      if (this.listeners[key] !== void 0 && this.listeners[key].length > 0) {
        let handler = this.listeners[key].shift();
        setImmediate(() => {
          handler.call(this);
        });
      }
    }
  }
  exports.Mutex = Mutex;
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobBatch.js
var require_BlobBatch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobBatch = void 0;
  var core_util_1 = require_commonjs9(), core_auth_1 = require_commonjs10(), core_rest_pipeline_1 = require_commonjs8(), core_util_2 = require_commonjs9(), AnonymousCredential_js_1 = require_AnonymousCredential(), Clients_js_1 = require_Clients(), Mutex_js_1 = require_Mutex(), Pipeline_js_1 = require_Pipeline(), utils_common_js_1 = require_utils_common(), core_xml_1 = require_commonjs14(), constants_js_1 = require_constants8(), StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential(), tracing_js_1 = require_tracing(), core_client_1 = require_commonjs12(), StorageSharedKeyCredentialPolicyV2_js_1 = require_StorageSharedKeyCredentialPolicyV22();

  class BlobBatch {
    batchRequest;
    batch = "batch";
    batchType;
    constructor() {
      this.batchRequest = new InnerBatchRequest;
    }
    getMultiPartContentType() {
      return this.batchRequest.getMultipartContentType();
    }
    getHttpRequestBody() {
      return this.batchRequest.getHttpRequestBody();
    }
    getSubRequests() {
      return this.batchRequest.getSubRequests();
    }
    async addSubRequestInternal(subRequest, assembleSubRequestFunc) {
      await Mutex_js_1.Mutex.lock(this.batch);
      try {
        this.batchRequest.preAddSubRequest(subRequest), await assembleSubRequestFunc(), this.batchRequest.postAddSubRequest(subRequest);
      } finally {
        await Mutex_js_1.Mutex.unlock(this.batch);
      }
    }
    setBatchType(batchType) {
      if (!this.batchType)
        this.batchType = batchType;
      if (this.batchType !== batchType)
        throw RangeError(`BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`);
    }
    async deleteBlob(urlOrBlobClient, credentialOrOptions, options) {
      let url, credential;
      if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrOptions instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrOptions instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrOptions)))
        url = urlOrBlobClient, credential = credentialOrOptions;
      else if (urlOrBlobClient instanceof Clients_js_1.BlobClient)
        url = urlOrBlobClient.url, credential = urlOrBlobClient.credential, options = credentialOrOptions;
      else
        throw RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      if (!options)
        options = {};
      return tracing_js_1.tracingClient.withSpan("BatchDeleteRequest-addSubRequest", options, async (updatedOptions) => {
        this.setBatchType("delete"), await this.addSubRequestInternal({
          url,
          credential
        }, async () => {
          await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).delete(updatedOptions);
        });
      });
    }
    async setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options) {
      let url, credential, tier;
      if (typeof urlOrBlobClient === "string" && (core_util_2.isNodeLike && credentialOrTier instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrTier instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrTier)))
        url = urlOrBlobClient, credential = credentialOrTier, tier = tierOrOptions;
      else if (urlOrBlobClient instanceof Clients_js_1.BlobClient)
        url = urlOrBlobClient.url, credential = urlOrBlobClient.credential, tier = credentialOrTier, options = tierOrOptions;
      else
        throw RangeError("Invalid arguments. Either url and credential, or BlobClient need be provided.");
      if (!options)
        options = {};
      return tracing_js_1.tracingClient.withSpan("BatchSetTierRequest-addSubRequest", options, async (updatedOptions) => {
        this.setBatchType("setAccessTier"), await this.addSubRequestInternal({
          url,
          credential
        }, async () => {
          await new Clients_js_1.BlobClient(url, this.batchRequest.createPipeline(credential)).setAccessTier(tier, updatedOptions);
        });
      });
    }
  }
  exports.BlobBatch = BlobBatch;

  class InnerBatchRequest {
    operationCount;
    body;
    subRequests;
    boundary;
    subRequestPrefix;
    multipartContentType;
    batchRequestEnding;
    constructor() {
      this.operationCount = 0, this.body = "";
      let tempGuid = (0, core_util_1.randomUUID)();
      this.boundary = `batch_${tempGuid}`, this.subRequestPrefix = `--${this.boundary}${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TYPE}: application/http${constants_js_1.HTTP_LINE_ENDING}${constants_js_1.HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`, this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`, this.batchRequestEnding = `--${this.boundary}--`, this.subRequests = /* @__PURE__ */ new Map;
    }
    createPipeline(credential) {
      let corePipeline = (0, core_rest_pipeline_1.createEmptyPipeline)();
      if (corePipeline.addPolicy((0, core_client_1.serializationPolicy)({
        stringifyXML: core_xml_1.stringifyXML,
        serializerOptions: {
          xml: {
            xmlCharKey: "#"
          }
        }
      }), { phase: "Serialize" }), corePipeline.addPolicy(batchHeaderFilterPolicy()), corePipeline.addPolicy(batchRequestAssemblePolicy(this), { afterPhase: "Sign" }), (0, core_auth_1.isTokenCredential)(credential))
        corePipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
          credential,
          scopes: constants_js_1.StorageOAuthScopes,
          challengeCallbacks: { authorizeRequestOnChallenge: core_client_1.authorizeRequestOnTenantChallenge }
        }), { phase: "Sign" });
      else if (credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential)
        corePipeline.addPolicy((0, StorageSharedKeyCredentialPolicyV2_js_1.storageSharedKeyCredentialPolicy)({
          accountName: credential.accountName,
          accountKey: credential.accountKey
        }), { phase: "Sign" });
      let pipeline = new Pipeline_js_1.Pipeline([]);
      return pipeline._credential = credential, pipeline._corePipeline = corePipeline, pipeline;
    }
    appendSubRequestToBody(request) {
      this.body += [
        this.subRequestPrefix,
        `${constants_js_1.HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
        "",
        `${request.method.toString()} ${(0, utils_common_js_1.getURLPathAndQuery)(request.url)} ${constants_js_1.HTTP_VERSION_1_1}${constants_js_1.HTTP_LINE_ENDING}`
      ].join(constants_js_1.HTTP_LINE_ENDING);
      for (let [name, value] of request.headers)
        this.body += `${name}: ${value}${constants_js_1.HTTP_LINE_ENDING}`;
      this.body += constants_js_1.HTTP_LINE_ENDING;
    }
    preAddSubRequest(subRequest) {
      if (this.operationCount >= constants_js_1.BATCH_MAX_REQUEST)
        throw RangeError(`Cannot exceed ${constants_js_1.BATCH_MAX_REQUEST} sub requests in a single batch`);
      let path = (0, utils_common_js_1.getURLPath)(subRequest.url);
      if (!path || path === "")
        throw RangeError(`Invalid url for sub request: '${subRequest.url}'`);
    }
    postAddSubRequest(subRequest) {
      this.subRequests.set(this.operationCount, subRequest), this.operationCount++;
    }
    getHttpRequestBody() {
      return `${this.body}${this.batchRequestEnding}${constants_js_1.HTTP_LINE_ENDING}`;
    }
    getMultipartContentType() {
      return this.multipartContentType;
    }
    getSubRequests() {
      return this.subRequests;
    }
  }
  function batchRequestAssemblePolicy(batchRequest) {
    return {
      name: "batchRequestAssemblePolicy",
      async sendRequest(request) {
        return batchRequest.appendSubRequestToBody(request), {
          request,
          status: 200,
          headers: (0, core_rest_pipeline_1.createHttpHeaders)()
        };
      }
    };
  }
  function batchHeaderFilterPolicy() {
    return {
      name: "batchHeaderFilterPolicy",
      async sendRequest(request, next) {
        let xMsHeaderName = "";
        for (let [name] of request.headers)
          if ((0, utils_common_js_1.iEqual)(name, constants_js_1.HeaderConstants.X_MS_VERSION))
            xMsHeaderName = name;
        if (xMsHeaderName !== "")
          request.headers.delete(xMsHeaderName);
        return next(request);
      }
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobBatchClient.js
var require_BlobBatchClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobBatchClient = void 0;
  var BatchResponseParser_js_1 = require_BatchResponseParser(), BatchUtils_js_1 = require_BatchUtils(), BlobBatch_js_1 = require_BlobBatch(), tracing_js_1 = require_tracing(), AnonymousCredential_js_1 = require_AnonymousCredential(), StorageContextClient_js_1 = require_StorageContextClient(), Pipeline_js_1 = require_Pipeline(), utils_common_js_1 = require_utils_common();

  class BlobBatchClient {
    serviceOrContainerContext;
    constructor(url, credentialOrPipeline, options) {
      let pipeline;
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline))
        pipeline = credentialOrPipeline;
      else if (!credentialOrPipeline)
        pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
      else
        pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options);
      let storageClientContext = new StorageContextClient_js_1.StorageContextClient(url, (0, Pipeline_js_1.getCoreClientOptions)(pipeline)), path = (0, utils_common_js_1.getURLPath)(url);
      if (path && path !== "/")
        this.serviceOrContainerContext = storageClientContext.container;
      else
        this.serviceOrContainerContext = storageClientContext.service;
    }
    createBatch() {
      return new BlobBatch_js_1.BlobBatch;
    }
    async deleteBlobs(urlsOrBlobClients, credentialOrOptions, options) {
      let batch = new BlobBatch_js_1.BlobBatch;
      for (let urlOrBlobClient of urlsOrBlobClients)
        if (typeof urlOrBlobClient === "string")
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions, options);
        else
          await batch.deleteBlob(urlOrBlobClient, credentialOrOptions);
      return this.submitBatch(batch);
    }
    async setBlobsAccessTier(urlsOrBlobClients, credentialOrTier, tierOrOptions, options) {
      let batch = new BlobBatch_js_1.BlobBatch;
      for (let urlOrBlobClient of urlsOrBlobClients)
        if (typeof urlOrBlobClient === "string")
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions, options);
        else
          await batch.setBlobAccessTier(urlOrBlobClient, credentialOrTier, tierOrOptions);
      return this.submitBatch(batch);
    }
    async submitBatch(batchRequest, options = {}) {
      if (!batchRequest || batchRequest.getSubRequests().size === 0)
        throw RangeError("Batch request should contain one or more sub requests.");
      return tracing_js_1.tracingClient.withSpan("BlobBatchClient-submitBatch", options, async (updatedOptions) => {
        let batchRequestBody = batchRequest.getHttpRequestBody(), rawBatchResponse = (0, utils_common_js_1.assertResponse)(await this.serviceOrContainerContext.submitBatch((0, BatchUtils_js_1.utf8ByteLength)(batchRequestBody), batchRequest.getMultiPartContentType(), batchRequestBody, {
          ...updatedOptions
        })), responseSummary = await new BatchResponseParser_js_1.BatchResponseParser(rawBatchResponse, batchRequest.getSubRequests()).parseBatchResponse();
        return {
          _response: rawBatchResponse._response,
          contentType: rawBatchResponse.contentType,
          errorCode: rawBatchResponse.errorCode,
          requestId: rawBatchResponse.requestId,
          clientRequestId: rawBatchResponse.clientRequestId,
          version: rawBatchResponse.version,
          subResponses: responseSummary.subResponses,
          subResponsesSucceededCount: responseSummary.subResponsesSucceededCount,
          subResponsesFailedCount: responseSummary.subResponsesFailedCount
        };
      });
    }
  }
  exports.BlobBatchClient = BlobBatchClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/ContainerClient.js
var require_ContainerClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ContainerClient = void 0;
  var core_rest_pipeline_1 = require_commonjs8(), core_util_1 = require_commonjs9(), core_auth_1 = require_commonjs10(), AnonymousCredential_js_1 = require_AnonymousCredential(), StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential(), Pipeline_js_1 = require_Pipeline(), StorageClient_js_1 = require_StorageClient(), tracing_js_1 = require_tracing(), utils_common_js_1 = require_utils_common(), BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues(), BlobLeaseClient_js_1 = require_BlobLeaseClient(), Clients_js_1 = require_Clients(), BlobBatchClient_js_1 = require_BlobBatchClient();

  class ContainerClient extends StorageClient_js_1.StorageClient {
    containerContext;
    _containerName;
    get containerName() {
      return this._containerName;
    }
    constructor(urlOrConnectionString, credentialOrPipelineOrContainerName, options) {
      let pipeline, url;
      if (options = options || {}, (0, Pipeline_js_1.isPipelineLike)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, pipeline = credentialOrPipelineOrContainerName;
      else if (core_util_1.isNodeLike && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipelineOrContainerName instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipelineOrContainerName))
        url = urlOrConnectionString, pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipelineOrContainerName, options);
      else if (!credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName !== "string")
        url = urlOrConnectionString, pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
      else if (credentialOrPipelineOrContainerName && typeof credentialOrPipelineOrContainerName === "string") {
        let containerName = credentialOrPipelineOrContainerName, extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(urlOrConnectionString);
        if (extractedCreds.kind === "AccountConnString")
          if (core_util_1.isNodeLike) {
            let sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
            if (url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)), !options.proxyOptions)
              options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
            pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          } else
            throw Error("Account connection string is only supported in Node.js environment");
        else if (extractedCreds.kind === "SASConnString")
          url = (0, utils_common_js_1.appendToURLPath)(extractedCreds.url, encodeURIComponent(containerName)) + "?" + extractedCreds.accountSas, pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
        else
          throw Error("Connection string must be either an Account connection string or a SAS connection string");
      } else
        throw Error("Expecting non-empty strings for containerName parameter");
      super(url, pipeline);
      this._containerName = this.getContainerNameFromUrl(), this.containerContext = this.storageClientContext.container;
    }
    async create(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-create", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.create(updatedOptions));
      });
    }
    async createIfNotExists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-createIfNotExists", options, async (updatedOptions) => {
        try {
          let res = await this.create(updatedOptions);
          return {
            succeeded: !0,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "ContainerAlreadyExists")
            return {
              succeeded: !1,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          else
            throw e;
        }
      });
    }
    async exists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-exists", options, async (updatedOptions) => {
        try {
          return await this.getProperties({
            abortSignal: options.abortSignal,
            tracingOptions: updatedOptions.tracingOptions
          }), !0;
        } catch (e) {
          if (e.statusCode === 404)
            return !1;
          throw e;
        }
      });
    }
    getBlobClient(blobName) {
      return new Clients_js_1.BlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    getAppendBlobClient(blobName) {
      return new Clients_js_1.AppendBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    getBlockBlobClient(blobName) {
      return new Clients_js_1.BlockBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    getPageBlobClient(blobName) {
      return new Clients_js_1.PageBlobClient((0, utils_common_js_1.appendToURLPath)(this.url, (0, utils_common_js_1.EscapePath)(blobName)), this.pipeline);
    }
    async getProperties(options = {}) {
      if (!options.conditions)
        options.conditions = {};
      return tracing_js_1.tracingClient.withSpan("ContainerClient-getProperties", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.getProperties({
          abortSignal: options.abortSignal,
          ...options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async delete(options = {}) {
      if (!options.conditions)
        options.conditions = {};
      return tracing_js_1.tracingClient.withSpan("ContainerClient-delete", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.delete({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async deleteIfExists(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteIfExists", options, async (updatedOptions) => {
        try {
          let res = await this.delete(updatedOptions);
          return {
            succeeded: !0,
            ...res,
            _response: res._response
          };
        } catch (e) {
          if (e.details?.errorCode === "ContainerNotFound")
            return {
              succeeded: !1,
              ...e.response?.parsedHeaders,
              _response: e.response
            };
          throw e;
        }
      });
    }
    async setMetadata(metadata, options = {}) {
      if (!options.conditions)
        options.conditions = {};
      if (options.conditions.ifUnmodifiedSince)
        throw RangeError("the IfUnmodifiedSince must have their default values because they are ignored by the blob service");
      return tracing_js_1.tracingClient.withSpan("ContainerClient-setMetadata", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.setMetadata({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          metadata,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccessPolicy(options = {}) {
      if (!options.conditions)
        options.conditions = {};
      return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccessPolicy", options, async (updatedOptions) => {
        let response = (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccessPolicy({
          abortSignal: options.abortSignal,
          leaseAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        })), res = {
          _response: response._response,
          blobPublicAccess: response.blobPublicAccess,
          date: response.date,
          etag: response.etag,
          errorCode: response.errorCode,
          lastModified: response.lastModified,
          requestId: response.requestId,
          clientRequestId: response.clientRequestId,
          signedIdentifiers: [],
          version: response.version
        };
        for (let identifier of response) {
          let accessPolicy = void 0;
          if (identifier.accessPolicy) {
            if (accessPolicy = {
              permissions: identifier.accessPolicy.permissions
            }, identifier.accessPolicy.expiresOn)
              accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
            if (identifier.accessPolicy.startsOn)
              accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
          }
          res.signedIdentifiers.push({
            accessPolicy,
            id: identifier.id
          });
        }
        return res;
      });
    }
    async setAccessPolicy(access, containerAcl, options = {}) {
      return options.conditions = options.conditions || {}, tracing_js_1.tracingClient.withSpan("ContainerClient-setAccessPolicy", options, async (updatedOptions) => {
        let acl = [];
        for (let identifier of containerAcl || [])
          acl.push({
            accessPolicy: {
              expiresOn: identifier.accessPolicy.expiresOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.expiresOn) : "",
              permissions: identifier.accessPolicy.permissions,
              startsOn: identifier.accessPolicy.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(identifier.accessPolicy.startsOn) : ""
            },
            id: identifier.id
          });
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.setAccessPolicy({
          abortSignal: options.abortSignal,
          access,
          containerAcl: acl,
          leaseAccessConditions: options.conditions,
          modifiedAccessConditions: options.conditions,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getBlobLeaseClient(proposeLeaseId) {
      return new BlobLeaseClient_js_1.BlobLeaseClient(this, proposeLeaseId);
    }
    async uploadBlockBlob(blobName, body, contentLength, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-uploadBlockBlob", options, async (updatedOptions) => {
        let blockBlobClient = this.getBlockBlobClient(blobName), response = await blockBlobClient.upload(body, contentLength, updatedOptions);
        return {
          blockBlobClient,
          response
        };
      });
    }
    async deleteBlob(blobName, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-deleteBlob", options, async (updatedOptions) => {
        let blobClient = this.getBlobClient(blobName);
        if (options.versionId)
          blobClient = blobClient.withVersion(options.versionId);
        return blobClient.delete(updatedOptions);
      });
    }
    async listBlobFlatSegment(marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobFlatSegment", options, async (updatedOptions) => {
        let response = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobFlatSegment({
          marker,
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return {
          ...response,
          _response: {
            ...response._response,
            parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobFlat)(response._response.parsedBody)
          },
          segment: {
            ...response.segment,
            blobItems: response.segment.blobItems.map((blobItemInternal) => {
              return {
                ...blobItemInternal,
                name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
                tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
                objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
              };
            })
          }
        };
      });
    }
    async listBlobHierarchySegment(delimiter, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-listBlobHierarchySegment", options, async (updatedOptions) => {
        let response = (0, utils_common_js_1.assertResponse)(await this.containerContext.listBlobHierarchySegment(delimiter, {
          marker,
          ...options,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return {
          ...response,
          _response: {
            ...response._response,
            parsedBody: (0, utils_common_js_1.ConvertInternalResponseOfListBlobHierarchy)(response._response.parsedBody)
          },
          segment: {
            ...response.segment,
            blobItems: response.segment.blobItems.map((blobItemInternal) => {
              return {
                ...blobItemInternal,
                name: (0, utils_common_js_1.BlobNameToString)(blobItemInternal.name),
                tags: (0, utils_common_js_1.toTags)(blobItemInternal.blobTags),
                objectReplicationSourceProperties: (0, utils_common_js_1.parseObjectReplicationRecord)(blobItemInternal.objectReplicationMetadata)
              };
            }),
            blobPrefixes: response.segment.blobPrefixes?.map((blobPrefixInternal) => {
              return {
                ...blobPrefixInternal,
                name: (0, utils_common_js_1.BlobNameToString)(blobPrefixInternal.name)
              };
            })
          }
        };
      });
    }
    async* listSegments(marker, options = {}) {
      let listBlobsFlatSegmentResponse;
      if (!!marker || marker === void 0)
        do
          listBlobsFlatSegmentResponse = await this.listBlobFlatSegment(marker, options), marker = listBlobsFlatSegmentResponse.continuationToken, yield await listBlobsFlatSegmentResponse;
        while (marker);
    }
    async* listItems(options = {}) {
      let marker;
      for await (let listBlobsFlatSegmentResponse of this.listSegments(marker, options))
        yield* listBlobsFlatSegmentResponse.segment.blobItems;
    }
    listBlobsFlat(options = {}) {
      let include = [];
      if (options.includeCopy)
        include.push("copy");
      if (options.includeDeleted)
        include.push("deleted");
      if (options.includeMetadata)
        include.push("metadata");
      if (options.includeSnapshots)
        include.push("snapshots");
      if (options.includeVersions)
        include.push("versions");
      if (options.includeUncommitedBlobs)
        include.push("uncommittedblobs");
      if (options.includeTags)
        include.push("tags");
      if (options.includeDeletedWithVersions)
        include.push("deletedwithversions");
      if (options.includeImmutabilityPolicy)
        include.push("immutabilitypolicy");
      if (options.includeLegalHold)
        include.push("legalhold");
      if (options.prefix === "")
        options.prefix = void 0;
      let updatedOptions = {
        ...options,
        ...include.length > 0 ? { include } : {}
      }, iter = this.listItems(updatedOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...updatedOptions
          });
        }
      };
    }
    async* listHierarchySegments(delimiter, marker, options = {}) {
      let listBlobsHierarchySegmentResponse;
      if (!!marker || marker === void 0)
        do
          listBlobsHierarchySegmentResponse = await this.listBlobHierarchySegment(delimiter, marker, options), marker = listBlobsHierarchySegmentResponse.continuationToken, yield await listBlobsHierarchySegmentResponse;
        while (marker);
    }
    async* listItemsByHierarchy(delimiter, options = {}) {
      let marker;
      for await (let listBlobsHierarchySegmentResponse of this.listHierarchySegments(delimiter, marker, options)) {
        let segment = listBlobsHierarchySegmentResponse.segment;
        if (segment.blobPrefixes)
          for (let prefix of segment.blobPrefixes)
            yield {
              kind: "prefix",
              ...prefix
            };
        for (let blob of segment.blobItems)
          yield { kind: "blob", ...blob };
      }
    }
    listBlobsByHierarchy(delimiter, options = {}) {
      if (delimiter === "")
        throw RangeError("delimiter should contain one or more characters");
      let include = [];
      if (options.includeCopy)
        include.push("copy");
      if (options.includeDeleted)
        include.push("deleted");
      if (options.includeMetadata)
        include.push("metadata");
      if (options.includeSnapshots)
        include.push("snapshots");
      if (options.includeVersions)
        include.push("versions");
      if (options.includeUncommitedBlobs)
        include.push("uncommittedblobs");
      if (options.includeTags)
        include.push("tags");
      if (options.includeDeletedWithVersions)
        include.push("deletedwithversions");
      if (options.includeImmutabilityPolicy)
        include.push("immutabilitypolicy");
      if (options.includeLegalHold)
        include.push("legalhold");
      if (options.prefix === "")
        options.prefix = void 0;
      let updatedOptions = {
        ...options,
        ...include.length > 0 ? { include } : {}
      }, iter = this.listItemsByHierarchy(delimiter, updatedOptions);
      return {
        async next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listHierarchySegments(delimiter, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...updatedOptions
          });
        }
      };
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
        let response = (0, utils_common_js_1.assertResponse)(await this.containerContext.filterBlobs({
          abortSignal: options.abortSignal,
          where: tagFilterSqlExpression,
          marker,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return {
          ...response,
          _response: response._response,
          blobs: response.blobs.map((blob) => {
            let tagValue = "";
            if (blob.tags?.blobTagSet.length === 1)
              tagValue = blob.tags.blobTagSet[0].value;
            return { ...blob, tags: (0, utils_common_js_1.toTags)(blob.tags), tagValue };
          })
        };
      });
    }
    async* findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
      let response;
      if (!!marker || marker === void 0)
        do
          response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options), response.blobs = response.blobs || [], marker = response.continuationToken, yield response;
        while (marker);
    }
    async* findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
      let marker;
      for await (let segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options))
        yield* segment.blobs;
    }
    findBlobsByTags(tagFilterSqlExpression, options = {}) {
      let listSegmentOptions = {
        ...options
      }, iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...listSegmentOptions
          });
        }
      };
    }
    async getAccountInfo(options = {}) {
      return tracing_js_1.tracingClient.withSpan("ContainerClient-getAccountInfo", options, async (updatedOptions) => {
        return (0, utils_common_js_1.assertResponse)(await this.containerContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    getContainerNameFromUrl() {
      let containerName;
      try {
        let parsedUrl = new URL(this.url);
        if (parsedUrl.hostname.split(".")[1] === "blob")
          containerName = parsedUrl.pathname.split("/")[1];
        else if ((0, utils_common_js_1.isIpEndpointStyle)(parsedUrl))
          containerName = parsedUrl.pathname.split("/")[2];
        else
          containerName = parsedUrl.pathname.split("/")[1];
        if (containerName = decodeURIComponent(containerName), !containerName)
          throw Error("Provided containerName is invalid.");
        return containerName;
      } catch (error) {
        throw Error("Unable to extract containerName with provided information.");
      }
    }
    generateSasUrl(options) {
      return new Promise((resolve) => {
        if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential))
          throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
        let sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          ...options
        }, this.credential).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    generateSasStringToSign(options) {
      if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential))
        throw RangeError("Can only generate the SAS when the client is initialized with a shared key credential");
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        ...options
      }, this.credential).stringToSign;
    }
    generateUserDelegationSasUrl(options, userDelegationKey) {
      return new Promise((resolve) => {
        let sas = (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParameters)({
          containerName: this._containerName,
          ...options
        }, userDelegationKey, this.accountName).toString();
        resolve((0, utils_common_js_1.appendToURLQuery)(this.url, sas));
      });
    }
    generateUserDelegationSasStringToSign(options, userDelegationKey) {
      return (0, BlobSASSignatureValues_js_1.generateBlobSASQueryParametersInternal)({
        containerName: this._containerName,
        ...options
      }, userDelegationKey, this.accountName).stringToSign;
    }
    getBlobBatchClient() {
      return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
    }
  }
  exports.ContainerClient = ContainerClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASPermissions.js
var require_AccountSASPermissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AccountSASPermissions = void 0;

  class AccountSASPermissions {
    static parse(permissions) {
      let accountSASPermissions = new AccountSASPermissions;
      for (let c of permissions)
        switch (c) {
          case "r":
            accountSASPermissions.read = !0;
            break;
          case "w":
            accountSASPermissions.write = !0;
            break;
          case "d":
            accountSASPermissions.delete = !0;
            break;
          case "x":
            accountSASPermissions.deleteVersion = !0;
            break;
          case "l":
            accountSASPermissions.list = !0;
            break;
          case "a":
            accountSASPermissions.add = !0;
            break;
          case "c":
            accountSASPermissions.create = !0;
            break;
          case "u":
            accountSASPermissions.update = !0;
            break;
          case "p":
            accountSASPermissions.process = !0;
            break;
          case "t":
            accountSASPermissions.tag = !0;
            break;
          case "f":
            accountSASPermissions.filter = !0;
            break;
          case "i":
            accountSASPermissions.setImmutabilityPolicy = !0;
            break;
          case "y":
            accountSASPermissions.permanentDelete = !0;
            break;
          default:
            throw RangeError(`Invalid permission character: ${c}`);
        }
      return accountSASPermissions;
    }
    static from(permissionLike) {
      let accountSASPermissions = new AccountSASPermissions;
      if (permissionLike.read)
        accountSASPermissions.read = !0;
      if (permissionLike.write)
        accountSASPermissions.write = !0;
      if (permissionLike.delete)
        accountSASPermissions.delete = !0;
      if (permissionLike.deleteVersion)
        accountSASPermissions.deleteVersion = !0;
      if (permissionLike.filter)
        accountSASPermissions.filter = !0;
      if (permissionLike.tag)
        accountSASPermissions.tag = !0;
      if (permissionLike.list)
        accountSASPermissions.list = !0;
      if (permissionLike.add)
        accountSASPermissions.add = !0;
      if (permissionLike.create)
        accountSASPermissions.create = !0;
      if (permissionLike.update)
        accountSASPermissions.update = !0;
      if (permissionLike.process)
        accountSASPermissions.process = !0;
      if (permissionLike.setImmutabilityPolicy)
        accountSASPermissions.setImmutabilityPolicy = !0;
      if (permissionLike.permanentDelete)
        accountSASPermissions.permanentDelete = !0;
      return accountSASPermissions;
    }
    read = !1;
    write = !1;
    delete = !1;
    deleteVersion = !1;
    list = !1;
    add = !1;
    create = !1;
    update = !1;
    process = !1;
    tag = !1;
    filter = !1;
    setImmutabilityPolicy = !1;
    permanentDelete = !1;
    toString() {
      let permissions = [];
      if (this.read)
        permissions.push("r");
      if (this.write)
        permissions.push("w");
      if (this.delete)
        permissions.push("d");
      if (this.deleteVersion)
        permissions.push("x");
      if (this.filter)
        permissions.push("f");
      if (this.tag)
        permissions.push("t");
      if (this.list)
        permissions.push("l");
      if (this.add)
        permissions.push("a");
      if (this.create)
        permissions.push("c");
      if (this.update)
        permissions.push("u");
      if (this.process)
        permissions.push("p");
      if (this.setImmutabilityPolicy)
        permissions.push("i");
      if (this.permanentDelete)
        permissions.push("y");
      return permissions.join("");
    }
  }
  exports.AccountSASPermissions = AccountSASPermissions;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASResourceTypes.js
var require_AccountSASResourceTypes = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AccountSASResourceTypes = void 0;

  class AccountSASResourceTypes {
    static parse(resourceTypes) {
      let accountSASResourceTypes = new AccountSASResourceTypes;
      for (let c of resourceTypes)
        switch (c) {
          case "s":
            accountSASResourceTypes.service = !0;
            break;
          case "c":
            accountSASResourceTypes.container = !0;
            break;
          case "o":
            accountSASResourceTypes.object = !0;
            break;
          default:
            throw RangeError(`Invalid resource type: ${c}`);
        }
      return accountSASResourceTypes;
    }
    service = !1;
    container = !1;
    object = !1;
    toString() {
      let resourceTypes = [];
      if (this.service)
        resourceTypes.push("s");
      if (this.container)
        resourceTypes.push("c");
      if (this.object)
        resourceTypes.push("o");
      return resourceTypes.join("");
    }
  }
  exports.AccountSASResourceTypes = AccountSASResourceTypes;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASServices.js
var require_AccountSASServices = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AccountSASServices = void 0;

  class AccountSASServices {
    static parse(services) {
      let accountSASServices = new AccountSASServices;
      for (let c of services)
        switch (c) {
          case "b":
            accountSASServices.blob = !0;
            break;
          case "f":
            accountSASServices.file = !0;
            break;
          case "q":
            accountSASServices.queue = !0;
            break;
          case "t":
            accountSASServices.table = !0;
            break;
          default:
            throw RangeError(`Invalid service character: ${c}`);
        }
      return accountSASServices;
    }
    blob = !1;
    file = !1;
    queue = !1;
    table = !1;
    toString() {
      let services = [];
      if (this.blob)
        services.push("b");
      if (this.table)
        services.push("t");
      if (this.queue)
        services.push("q");
      if (this.file)
        services.push("f");
      return services.join("");
    }
  }
  exports.AccountSASServices = AccountSASServices;
});

// node_modules/@azure/storage-blob/dist/commonjs/sas/AccountSASSignatureValues.js
var require_AccountSASSignatureValues = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.generateAccountSASQueryParameters = generateAccountSASQueryParameters;
  exports.generateAccountSASQueryParametersInternal = generateAccountSASQueryParametersInternal;
  var AccountSASPermissions_js_1 = require_AccountSASPermissions(), AccountSASResourceTypes_js_1 = require_AccountSASResourceTypes(), AccountSASServices_js_1 = require_AccountSASServices(), SasIPRange_js_1 = require_SasIPRange(), SASQueryParameters_js_1 = require_SASQueryParameters(), constants_js_1 = require_constants8(), utils_common_js_1 = require_utils_common();
  function generateAccountSASQueryParameters(accountSASSignatureValues, sharedKeyCredential) {
    return generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential).sasQueryParameters;
  }
  function generateAccountSASQueryParametersInternal(accountSASSignatureValues, sharedKeyCredential) {
    let version = accountSASSignatureValues.version ? accountSASSignatureValues.version : constants_js_1.SERVICE_VERSION;
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.setImmutabilityPolicy && version < "2020-08-04")
      throw RangeError("'version' must be >= '2020-08-04' when provided 'i' permission.");
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.deleteVersion && version < "2019-10-10")
      throw RangeError("'version' must be >= '2019-10-10' when provided 'x' permission.");
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.permanentDelete && version < "2019-10-10")
      throw RangeError("'version' must be >= '2019-10-10' when provided 'y' permission.");
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.tag && version < "2019-12-12")
      throw RangeError("'version' must be >= '2019-12-12' when provided 't' permission.");
    if (accountSASSignatureValues.permissions && accountSASSignatureValues.permissions.filter && version < "2019-12-12")
      throw RangeError("'version' must be >= '2019-12-12' when provided 'f' permission.");
    if (accountSASSignatureValues.encryptionScope && version < "2020-12-06")
      throw RangeError("'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.");
    let parsedPermissions = AccountSASPermissions_js_1.AccountSASPermissions.parse(accountSASSignatureValues.permissions.toString()), parsedServices = AccountSASServices_js_1.AccountSASServices.parse(accountSASSignatureValues.services).toString(), parsedResourceTypes = AccountSASResourceTypes_js_1.AccountSASResourceTypes.parse(accountSASSignatureValues.resourceTypes).toString(), stringToSign;
    if (version >= "2020-12-06")
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, !1) : "",
        (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, !1),
        accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version,
        accountSASSignatureValues.encryptionScope ? accountSASSignatureValues.encryptionScope : "",
        ""
      ].join(`
`);
    else
      stringToSign = [
        sharedKeyCredential.accountName,
        parsedPermissions,
        parsedServices,
        parsedResourceTypes,
        accountSASSignatureValues.startsOn ? (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.startsOn, !1) : "",
        (0, utils_common_js_1.truncatedISO8061Date)(accountSASSignatureValues.expiresOn, !1),
        accountSASSignatureValues.ipRange ? (0, SasIPRange_js_1.ipRangeToString)(accountSASSignatureValues.ipRange) : "",
        accountSASSignatureValues.protocol ? accountSASSignatureValues.protocol : "",
        version,
        ""
      ].join(`
`);
    let signature = sharedKeyCredential.computeHMACSHA256(stringToSign);
    return {
      sasQueryParameters: new SASQueryParameters_js_1.SASQueryParameters(version, signature, parsedPermissions.toString(), parsedServices, parsedResourceTypes, accountSASSignatureValues.protocol, accountSASSignatureValues.startsOn, accountSASSignatureValues.expiresOn, accountSASSignatureValues.ipRange, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, accountSASSignatureValues.encryptionScope),
      stringToSign
    };
  }
});

// node_modules/@azure/storage-blob/dist/commonjs/BlobServiceClient.js
var require_BlobServiceClient = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.BlobServiceClient = void 0;
  var core_auth_1 = require_commonjs10(), core_rest_pipeline_1 = require_commonjs8(), core_util_1 = require_commonjs9(), Pipeline_js_1 = require_Pipeline(), ContainerClient_js_1 = require_ContainerClient(), utils_common_js_1 = require_utils_common(), StorageSharedKeyCredential_js_1 = require_StorageSharedKeyCredential(), AnonymousCredential_js_1 = require_AnonymousCredential(), utils_common_js_2 = require_utils_common(), tracing_js_1 = require_tracing(), BlobBatchClient_js_1 = require_BlobBatchClient(), StorageClient_js_1 = require_StorageClient(), AccountSASPermissions_js_1 = require_AccountSASPermissions(), AccountSASSignatureValues_js_1 = require_AccountSASSignatureValues(), AccountSASServices_js_1 = require_AccountSASServices();

  class BlobServiceClient extends StorageClient_js_1.StorageClient {
    serviceContext;
    static fromConnectionString(connectionString, options) {
      options = options || {};
      let extractedCreds = (0, utils_common_js_1.extractConnectionStringParts)(connectionString);
      if (extractedCreds.kind === "AccountConnString")
        if (core_util_1.isNodeLike) {
          let sharedKeyCredential = new StorageSharedKeyCredential_js_1.StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
          if (!options.proxyOptions)
            options.proxyOptions = (0, core_rest_pipeline_1.getDefaultProxySettings)(extractedCreds.proxyUri);
          let pipeline = (0, Pipeline_js_1.newPipeline)(sharedKeyCredential, options);
          return new BlobServiceClient(extractedCreds.url, pipeline);
        } else
          throw Error("Account connection string is only supported in Node.js environment");
      else if (extractedCreds.kind === "SASConnString") {
        let pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
        return new BlobServiceClient(extractedCreds.url + "?" + extractedCreds.accountSas, pipeline);
      } else
        throw Error("Connection string must be either an Account connection string or a SAS connection string");
    }
    constructor(url, credentialOrPipeline, options) {
      let pipeline;
      if ((0, Pipeline_js_1.isPipelineLike)(credentialOrPipeline))
        pipeline = credentialOrPipeline;
      else if (core_util_1.isNodeLike && credentialOrPipeline instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential_js_1.AnonymousCredential || (0, core_auth_1.isTokenCredential)(credentialOrPipeline))
        pipeline = (0, Pipeline_js_1.newPipeline)(credentialOrPipeline, options);
      else
        pipeline = (0, Pipeline_js_1.newPipeline)(new AnonymousCredential_js_1.AnonymousCredential, options);
      super(url, pipeline);
      this.serviceContext = this.storageClientContext.service;
    }
    getContainerClient(containerName) {
      return new ContainerClient_js_1.ContainerClient((0, utils_common_js_1.appendToURLPath)(this.url, encodeURIComponent(containerName)), this.pipeline);
    }
    async createContainer(containerName, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-createContainer", options, async (updatedOptions) => {
        let containerClient = this.getContainerClient(containerName), containerCreateResponse = await containerClient.create(updatedOptions);
        return {
          containerClient,
          containerCreateResponse
        };
      });
    }
    async deleteContainer(containerName, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-deleteContainer", options, async (updatedOptions) => {
        return this.getContainerClient(containerName).delete(updatedOptions);
      });
    }
    async undeleteContainer(deletedContainerName, deletedContainerVersion, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-undeleteContainer", options, async (updatedOptions) => {
        let containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName), containerContext = containerClient.storageClientContext.container, containerUndeleteResponse = (0, utils_common_js_2.assertResponse)(await containerContext.restore({
          deletedContainerName,
          deletedContainerVersion,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return { containerClient, containerUndeleteResponse };
      });
    }
    async getProperties(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getProperties", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getProperties({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async setProperties(properties, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-setProperties", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.setProperties(properties, {
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getStatistics(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getStatistics", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getStatistics({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async getAccountInfo(options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getAccountInfo", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.getAccountInfo({
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async listContainersSegment(marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-listContainersSegment", options, async (updatedOptions) => {
        return (0, utils_common_js_2.assertResponse)(await this.serviceContext.listContainersSegment({
          abortSignal: options.abortSignal,
          marker,
          ...options,
          include: typeof options.include === "string" ? [options.include] : options.include,
          tracingOptions: updatedOptions.tracingOptions
        }));
      });
    }
    async findBlobsByTagsSegment(tagFilterSqlExpression, marker, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-findBlobsByTagsSegment", options, async (updatedOptions) => {
        let response = (0, utils_common_js_2.assertResponse)(await this.serviceContext.filterBlobs({
          abortSignal: options.abortSignal,
          where: tagFilterSqlExpression,
          marker,
          maxPageSize: options.maxPageSize,
          tracingOptions: updatedOptions.tracingOptions
        }));
        return {
          ...response,
          _response: response._response,
          blobs: response.blobs.map((blob) => {
            let tagValue = "";
            if (blob.tags?.blobTagSet.length === 1)
              tagValue = blob.tags.blobTagSet[0].value;
            return { ...blob, tags: (0, utils_common_js_1.toTags)(blob.tags), tagValue };
          })
        };
      });
    }
    async* findBlobsByTagsSegments(tagFilterSqlExpression, marker, options = {}) {
      let response;
      if (!!marker || marker === void 0)
        do
          response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options), response.blobs = response.blobs || [], marker = response.continuationToken, yield response;
        while (marker);
    }
    async* findBlobsByTagsItems(tagFilterSqlExpression, options = {}) {
      let marker;
      for await (let segment of this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options))
        yield* segment.blobs;
    }
    findBlobsByTags(tagFilterSqlExpression, options = {}) {
      let listSegmentOptions = {
        ...options
      }, iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...listSegmentOptions
          });
        }
      };
    }
    async* listSegments(marker, options = {}) {
      let listContainersSegmentResponse;
      if (!!marker || marker === void 0)
        do
          listContainersSegmentResponse = await this.listContainersSegment(marker, options), listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [], marker = listContainersSegmentResponse.continuationToken, yield await listContainersSegmentResponse;
        while (marker);
    }
    async* listItems(options = {}) {
      let marker;
      for await (let segment of this.listSegments(marker, options))
        yield* segment.containerItems;
    }
    listContainers(options = {}) {
      if (options.prefix === "")
        options.prefix = void 0;
      let include = [];
      if (options.includeDeleted)
        include.push("deleted");
      if (options.includeMetadata)
        include.push("metadata");
      if (options.includeSystem)
        include.push("system");
      let listSegmentOptions = {
        ...options,
        ...include.length > 0 ? { include } : {}
      }, iter = this.listItems(listSegmentOptions);
      return {
        next() {
          return iter.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (settings = {}) => {
          return this.listSegments(settings.continuationToken, {
            maxPageSize: settings.maxPageSize,
            ...listSegmentOptions
          });
        }
      };
    }
    async getUserDelegationKey(startsOn, expiresOn, options = {}) {
      return tracing_js_1.tracingClient.withSpan("BlobServiceClient-getUserDelegationKey", options, async (updatedOptions) => {
        let response = (0, utils_common_js_2.assertResponse)(await this.serviceContext.getUserDelegationKey({
          startsOn: (0, utils_common_js_2.truncatedISO8061Date)(startsOn, !1),
          expiresOn: (0, utils_common_js_2.truncatedISO8061Date)(expiresOn, !1)
        }, {
          abortSignal: options.abortSignal,
          tracingOptions: updatedOptions.tracingOptions
        })), userDelegationKey = {
          signedObjectId: response.signedObjectId,
          signedTenantId: response.signedTenantId,
          signedStartsOn: new Date(response.signedStartsOn),
          signedExpiresOn: new Date(response.signedExpiresOn),
          signedService: response.signedService,
          signedVersion: response.signedVersion,
          value: response.value
        };
        return {
          _response: response._response,
          requestId: response.requestId,
          clientRequestId: response.clientRequestId,
          version: response.version,
          date: response.date,
          errorCode: response.errorCode,
          ...userDelegationKey
        };
      });
    }
    getBlobBatchClient() {
      return new BlobBatchClient_js_1.BlobBatchClient(this.url, this.pipeline);
    }
    generateAccountSasUrl(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
      if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential))
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      if (expiresOn === void 0)
        expiresOn = new Date((/* @__PURE__ */ new Date()).getTime() + 3600000);
      let sas = (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParameters)({
        permissions,
        expiresOn,
        resourceTypes,
        services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
        ...options
      }, this.credential).toString();
      return (0, utils_common_js_1.appendToURLQuery)(this.url, sas);
    }
    generateSasStringToSign(expiresOn, permissions = AccountSASPermissions_js_1.AccountSASPermissions.parse("r"), resourceTypes = "sco", options = {}) {
      if (!(this.credential instanceof StorageSharedKeyCredential_js_1.StorageSharedKeyCredential))
        throw RangeError("Can only generate the account SAS when the client is initialized with a shared key credential");
      if (expiresOn === void 0)
        expiresOn = new Date((/* @__PURE__ */ new Date()).getTime() + 3600000);
      return (0, AccountSASSignatureValues_js_1.generateAccountSASQueryParametersInternal)({
        permissions,
        expiresOn,
        resourceTypes,
        services: AccountSASServices_js_1.AccountSASServices.parse("b").toString(),
        ...options
      }, this.credential).stringToSign;
    }
  }
  exports.BlobServiceClient = BlobServiceClient;
});

// node_modules/@azure/storage-blob/dist/commonjs/BatchResponse.js
var require_BatchResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@azure/storage-blob/dist/commonjs/generatedModels.js
var require_generatedModels = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.KnownEncryptionAlgorithmType = void 0;
  var KnownEncryptionAlgorithmType;
  (function(KnownEncryptionAlgorithmType2) {
    KnownEncryptionAlgorithmType2.AES256 = "AES256";
  })(KnownEncryptionAlgorithmType || (exports.KnownEncryptionAlgorithmType = KnownEncryptionAlgorithmType = {}));
});

// node_modules/@azure/storage-blob/dist/commonjs/index.js
var require_commonjs21 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.logger = exports.RestError = exports.BaseRequestPolicy = exports.StorageOAuthScopes = exports.newPipeline = exports.isPipelineLike = exports.Pipeline = exports.getBlobServiceAccountAudience = exports.StorageBlobAudience = exports.PremiumPageBlobTier = exports.BlockBlobTier = exports.generateBlobSASQueryParameters = exports.generateAccountSASQueryParameters = void 0;
  var tslib_1 = require_tslib(), core_rest_pipeline_1 = require_commonjs8();
  Object.defineProperty(exports, "RestError", { enumerable: !0, get: function() {
    return core_rest_pipeline_1.RestError;
  } });
  tslib_1.__exportStar(require_BlobServiceClient(), exports);
  tslib_1.__exportStar(require_Clients(), exports);
  tslib_1.__exportStar(require_ContainerClient(), exports);
  tslib_1.__exportStar(require_BlobLeaseClient(), exports);
  tslib_1.__exportStar(require_AccountSASPermissions(), exports);
  tslib_1.__exportStar(require_AccountSASResourceTypes(), exports);
  tslib_1.__exportStar(require_AccountSASServices(), exports);
  var AccountSASSignatureValues_js_1 = require_AccountSASSignatureValues();
  Object.defineProperty(exports, "generateAccountSASQueryParameters", { enumerable: !0, get: function() {
    return AccountSASSignatureValues_js_1.generateAccountSASQueryParameters;
  } });
  tslib_1.__exportStar(require_BlobBatch(), exports);
  tslib_1.__exportStar(require_BlobBatchClient(), exports);
  tslib_1.__exportStar(require_BatchResponse(), exports);
  tslib_1.__exportStar(require_BlobSASPermissions(), exports);
  var BlobSASSignatureValues_js_1 = require_BlobSASSignatureValues();
  Object.defineProperty(exports, "generateBlobSASQueryParameters", { enumerable: !0, get: function() {
    return BlobSASSignatureValues_js_1.generateBlobSASQueryParameters;
  } });
  tslib_1.__exportStar(require_StorageBrowserPolicyFactory2(), exports);
  tslib_1.__exportStar(require_ContainerSASPermissions(), exports);
  tslib_1.__exportStar(require_AnonymousCredential(), exports);
  tslib_1.__exportStar(require_Credential(), exports);
  tslib_1.__exportStar(require_StorageSharedKeyCredential(), exports);
  var models_js_1 = require_models2();
  Object.defineProperty(exports, "BlockBlobTier", { enumerable: !0, get: function() {
    return models_js_1.BlockBlobTier;
  } });
  Object.defineProperty(exports, "PremiumPageBlobTier", { enumerable: !0, get: function() {
    return models_js_1.PremiumPageBlobTier;
  } });
  Object.defineProperty(exports, "StorageBlobAudience", { enumerable: !0, get: function() {
    return models_js_1.StorageBlobAudience;
  } });
  Object.defineProperty(exports, "getBlobServiceAccountAudience", { enumerable: !0, get: function() {
    return models_js_1.getBlobServiceAccountAudience;
  } });
  var Pipeline_js_1 = require_Pipeline();
  Object.defineProperty(exports, "Pipeline", { enumerable: !0, get: function() {
    return Pipeline_js_1.Pipeline;
  } });
  Object.defineProperty(exports, "isPipelineLike", { enumerable: !0, get: function() {
    return Pipeline_js_1.isPipelineLike;
  } });
  Object.defineProperty(exports, "newPipeline", { enumerable: !0, get: function() {
    return Pipeline_js_1.newPipeline;
  } });
  Object.defineProperty(exports, "StorageOAuthScopes", { enumerable: !0, get: function() {
    return Pipeline_js_1.StorageOAuthScopes;
  } });
  tslib_1.__exportStar(require_StorageRetryPolicyFactory(), exports);
  var RequestPolicy_js_1 = require_RequestPolicy();
  Object.defineProperty(exports, "BaseRequestPolicy", { enumerable: !0, get: function() {
    return RequestPolicy_js_1.BaseRequestPolicy;
  } });
  tslib_1.__exportStar(require_AnonymousCredentialPolicy(), exports);
  tslib_1.__exportStar(require_CredentialPolicy(), exports);
  tslib_1.__exportStar(require_StorageRetryPolicyFactory(), exports);
  tslib_1.__exportStar(require_StorageSharedKeyCredentialPolicy(), exports);
  tslib_1.__exportStar(require_SASQueryParameters(), exports);
  tslib_1.__exportStar(require_generatedModels(), exports);
  var log_js_1 = require_log6();
  Object.defineProperty(exports, "logger", { enumerable: !0, get: function() {
    return log_js_1.logger;
  } });
});

// node_modules/@actions/artifact/lib/internal/upload/blob-upload.js
var require_blob_upload = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.uploadZipToBlobStorage = uploadZipToBlobStorage;
  var storage_blob_1 = require_commonjs21(), config_1 = require_config(), core = __importStar(require_core()), crypto2 = __importStar(__require("crypto")), stream = __importStar(__require("stream")), errors_1 = require_errors2();
  function uploadZipToBlobStorage(authenticatedUploadURL, zipUploadStream) {
    return __awaiter(this, void 0, void 0, function* () {
      let uploadByteCount = 0, lastProgressTime = Date.now(), abortController = new AbortController, chunkTimer = (interval) => __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          let timer = setInterval(() => {
            if (Date.now() - lastProgressTime > interval)
              reject(Error("Upload progress stalled."));
          }, interval);
          abortController.signal.addEventListener("abort", () => {
            clearInterval(timer), resolve();
          });
        });
      }), maxConcurrency = (0, config_1.getConcurrency)(), bufferSize = (0, config_1.getUploadChunkSize)(), blockBlobClient = new storage_blob_1.BlobClient(authenticatedUploadURL).getBlockBlobClient();
      core.debug(`Uploading artifact zip to blob storage with maxConcurrency: ${maxConcurrency}, bufferSize: ${bufferSize}`);
      let options = {
        blobHTTPHeaders: { blobContentType: "zip" },
        onProgress: (progress) => {
          core.info(`Uploaded bytes ${progress.loadedBytes}`), uploadByteCount = progress.loadedBytes, lastProgressTime = Date.now();
        },
        abortSignal: abortController.signal
      }, sha256Hash = void 0, uploadStream = new stream.PassThrough, hashStream = crypto2.createHash("sha256");
      zipUploadStream.pipe(uploadStream), zipUploadStream.pipe(hashStream).setEncoding("hex"), core.info("Beginning upload of artifact content to blob storage");
      try {
        yield Promise.race([
          blockBlobClient.uploadStream(uploadStream, bufferSize, maxConcurrency, options),
          chunkTimer((0, config_1.getUploadChunkTimeout)())
        ]);
      } catch (error) {
        if (errors_1.NetworkError.isNetworkErrorCode(error === null || error === void 0 ? void 0 : error.code))
          throw new errors_1.NetworkError(error === null || error === void 0 ? void 0 : error.code);
        throw error;
      } finally {
        abortController.abort();
      }
      if (core.info("Finished uploading artifact content to blob storage!"), hashStream.end(), sha256Hash = hashStream.read(), core.info(`SHA256 digest of uploaded artifact zip is ${sha256Hash}`), uploadByteCount === 0)
        core.warning("No data was uploaded to blob storage. Reported upload byte count is 0.");
      return {
        uploadSize: uploadByteCount,
        sha256Hash
      };
    });
  }
});

// node_modules/minimatch/lib/path.js
var require_path = __commonJS((exports, module) => {
  var isWindows = typeof process === "object" && process && process.platform === "win32";
  module.exports = isWindows ? { sep: "\\" } : { sep: "/" };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports, module) => {
  module.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result, ai = str.indexOf(a), bi = str.indexOf(b, ai + 1), i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b)
        return [ai, bi];
      begs = [], left = str.length;
      while (i >= 0 && !result) {
        if (i == ai)
          begs.push(i), ai = str.indexOf(a, i + 1);
        else if (begs.length == 1)
          result = [begs.pop(), bi];
        else {
          if (beg = begs.pop(), beg < left)
            left = beg, right = bi;
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length)
        result = [left, right];
    }
    return result;
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports, module) => {
  var balanced = require_balanced_match();
  module.exports = expandTop;
  var escSlash = "\x00SLASH" + Math.random() + "\x00", escOpen = "\x00OPEN" + Math.random() + "\x00", escClose = "\x00CLOSE" + Math.random() + "\x00", escComma = "\x00COMMA" + Math.random() + "\x00", escPeriod = "\x00PERIOD" + Math.random() + "\x00";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [], m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var { pre, body, post } = m, p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length)
      p[p.length - 1] += postParts.shift(), p.push.apply(p, postParts);
    return parts.push.apply(parts, p), parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}")
      str = "\\{\\}" + str.substr(2);
    return expand(escapeBraces(str), !0).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [], m = balanced("{", "}", str);
    if (!m)
      return [str];
    var pre = m.pre, post = m.post.length ? expand(m.post, !1) : [""];
    if (/\$$/.test(m.pre))
      for (var k = 0;k < post.length; k++) {
        var expansion = pre + "{" + m.body + "}" + post[k];
        expansions.push(expansion);
      }
    else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body), isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body), isSequence = isNumericSequence || isAlphaSequence, isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/))
          return str = m.pre + "{" + m.body + escClose + m.post, expand(str);
        return [str];
      }
      var n;
      if (isSequence)
        n = m.body.split(/\.\./);
      else if (n = parseCommaParts(m.body), n.length === 1) {
        if (n = expand(n[0], !1).map(embrace), n.length === 1)
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
      }
      var N;
      if (isSequence) {
        var x = numeric(n[0]), y = numeric(n[1]), width = Math.max(n[0].length, n[1].length), incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1, test = lte, reverse = y < x;
        if (reverse)
          incr *= -1, test = gte;
        var pad = n.some(isPadded);
        N = [];
        for (var i = x;test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            if (c = String.fromCharCode(i), c === "\\")
              c = "";
          } else if (c = String(i), pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
          N.push(c);
        }
      } else {
        N = [];
        for (var j = 0;j < n.length; j++)
          N.push.apply(N, expand(n[j], !1));
      }
      for (var j = 0;j < N.length; j++)
        for (var k = 0;k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
    }
    return expansions;
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports, module) => {
  var minimatch = module.exports = (p, pattern, options = {}) => {
    if (assertValidPattern(pattern), !options.nocomment && pattern.charAt(0) === "#")
      return !1;
    return new Minimatch(pattern, options).match(p);
  };
  module.exports = minimatch;
  var path = require_path();
  minimatch.sep = path.sep;
  var GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  var expand = require_brace_expansion(), plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, qmark = "[^/]", star = qmark + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", charSet = (s) => s.split("").reduce((set, c) => {
    return set[c] = !0, set;
  }, {}), reSpecials = charSet("().*{}+?[]^$\\!"), addPatternStartSet = charSet("[.("), slashSplit = /\/+/;
  minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
  var ext = (a, b = {}) => {
    let t = {};
    return Object.keys(a).forEach((k) => t[k] = a[k]), Object.keys(b).forEach((k) => t[k] = b[k]), t;
  };
  minimatch.defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length)
      return minimatch;
    let orig = minimatch, m = (p, pattern, options) => orig(p, pattern, ext(def, options));
    return m.Minimatch = class extends orig.Minimatch {
      constructor(pattern, options) {
        super(pattern, ext(def, options));
      }
    }, m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch, m.filter = (pattern, options) => orig.filter(pattern, ext(def, options)), m.defaults = (options) => orig.defaults(ext(def, options)), m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options)), m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options)), m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options)), m;
  };
  minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
  var braceExpand = (pattern, options = {}) => {
    if (assertValidPattern(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern))
      return [pattern];
    return expand(pattern);
  }, MAX_PATTERN_LENGTH = 65536, assertValidPattern = (pattern) => {
    if (typeof pattern !== "string")
      throw TypeError("invalid pattern");
    if (pattern.length > MAX_PATTERN_LENGTH)
      throw TypeError("pattern is too long");
  }, SUBPARSE = Symbol("subparse");
  minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
  minimatch.match = (list, pattern, options = {}) => {
    let mm = new Minimatch(pattern, options);
    if (list = list.filter((f) => mm.match(f)), mm.options.nonull && !list.length)
      list.push(pattern);
    return list;
  };
  var globUnescape = (s) => s.replace(/\\(.)/g, "$1"), charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1"), regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");

  class Minimatch {
    constructor(pattern, options) {
      if (assertValidPattern(pattern), !options)
        options = {};
      if (this.options = options, this.set = [], this.pattern = pattern, this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === !1, this.windowsPathsNoEscape)
        this.pattern = this.pattern.replace(/\\/g, "/");
      this.regexp = null, this.negate = !1, this.comment = !1, this.empty = !1, this.partial = !!options.partial, this.make();
    }
    debug() {}
    make() {
      let pattern = this.pattern, options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!pattern) {
        this.empty = !0;
        return;
      }
      this.parseNegate();
      let set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = (...args) => console.error(...args);
      this.debug(this.pattern, set), set = this.globParts = set.map((s) => s.split(slashSplit)), this.debug(this.pattern, set), set = set.map((s, si, set2) => s.map(this.parse, this)), this.debug(this.pattern, set), set = set.filter((s) => s.indexOf(!1) === -1), this.debug(this.pattern, set), this.set = set;
    }
    parseNegate() {
      if (this.options.nonegate)
        return;
      let pattern = this.pattern, negate = !1, negateOffset = 0;
      for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++)
        negate = !negate, negateOffset++;
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    matchOne(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { this: this, file, pattern }), this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi], f = file[fi];
        if (this.debug(pattern, p, f), p === !1)
          return !1;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi, pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (;fi < fl; fi++)
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return !1;
            return !0;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
              return this.debug("globstar found match!", fr, fl, swallowee), !0;
            else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), fr++;
            }
          }
          if (partial) {
            if (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl)
              return !0;
          }
          return !1;
        }
        var hit;
        if (typeof p === "string")
          hit = f === p, this.debug("string match", p, f, hit);
        else
          hit = f.match(p), this.debug("pattern match", p, f, hit);
        if (!hit)
          return !1;
      }
      if (fi === fl && pi === pl)
        return !0;
      else if (fi === fl)
        return partial;
      else if (pi === pl)
        return fi === fl - 1 && file[fi] === "";
      throw Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern, isSub) {
      assertValidPattern(pattern);
      let options = this.options;
      if (pattern === "**")
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      if (pattern === "")
        return "";
      let re = "", hasMagic = !1, escaping = !1, patternListStack = [], negativeLists = [], stateChar, inClass = !1, reClassStart = -1, classStart = -1, cs, pl, sp, dotTravAllowed = pattern.charAt(0) === ".", dotFileAllowed = options.dot || dotTravAllowed, patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", clearStateChar = () => {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star, hasMagic = !0;
              break;
            case "?":
              re += qmark, hasMagic = !0;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          this.debug("clearStateChar %j %j", stateChar, re), stateChar = !1;
        }
      };
      for (let i = 0, c;i < pattern.length && (c = pattern.charAt(i)); i++) {
        if (this.debug("%s\t%s %s %j", pattern, i, re, c), escaping) {
          if (c === "/")
            return !1;
          if (reSpecials[c])
            re += "\\";
          re += c, escaping = !1;
          continue;
        }
        switch (c) {
          case "/":
            return !1;
          case "\\":
            if (inClass && pattern.charAt(i + 1) === "-") {
              re += c;
              continue;
            }
            clearStateChar(), escaping = !0;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            if (this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c), inClass) {
              if (this.debug("  in class"), c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            if (this.debug("call clearStateChar %j", stateChar), clearStateChar(), stateChar = c, options.noext)
              clearStateChar();
            continue;
          case "(": {
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            let plEntry = {
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            };
            if (this.debug(this.pattern, "\t", plEntry), patternListStack.push(plEntry), re += plEntry.open, plEntry.start === 0 && plEntry.type !== "!")
              dotTravAllowed = !0, re += subPatternStart(pattern.slice(i + 1));
            this.debug("plType %j %j", stateChar, re), stateChar = !1;
            continue;
          }
          case ")": {
            let plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\)";
              continue;
            }
            if (patternListStack.pop(), clearStateChar(), hasMagic = !0, pl = plEntry, re += pl.close, pl.type === "!")
              negativeLists.push(Object.assign(pl, { reEnd: re.length }));
            continue;
          }
          case "|": {
            let plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\|";
              continue;
            }
            if (clearStateChar(), re += "|", plEntry.start === 0 && plEntry.type !== "!")
              dotTravAllowed = !0, re += subPatternStart(pattern.slice(i + 1));
            continue;
          }
          case "[":
            if (clearStateChar(), inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = !0, classStart = i, reClassStart = re.length, re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              continue;
            }
            cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + braExpEscape(charUnescape(cs)) + "]"), re += c;
            } catch (er) {
              re = re.substring(0, reClassStart) + "(?:$.)";
            }
            hasMagic = !0, inClass = !1;
            continue;
          default:
            if (clearStateChar(), reSpecials[c] && !(c === "^" && inClass))
              re += "\\";
            re += c;
            break;
        }
      }
      if (inClass)
        cs = pattern.slice(classStart + 1), sp = this.parse(cs, SUBPARSE), re = re.substring(0, reClassStart) + "\\[" + sp[0], hasMagic = hasMagic || sp[1];
      for (pl = patternListStack.pop();pl; pl = patternListStack.pop()) {
        let tail;
        tail = re.slice(pl.reStart + pl.open.length), this.debug("setting tail", re, pl), tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
          if (!$2)
            $2 = "\\";
          return $1 + $1 + $2 + "|";
        }), this.debug(`tail=%j
   %s`, tail, tail, pl, re);
        let t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = !0, re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      if (clearStateChar(), escaping)
        re += "\\\\";
      let addPatternStart = addPatternStartSet[re.charAt(0)];
      for (let n = negativeLists.length - 1;n > -1; n--) {
        let nl = negativeLists[n], nlBefore = re.slice(0, nl.reStart), nlFirst = re.slice(nl.reStart, nl.reEnd - 8), nlAfter = re.slice(nl.reEnd), nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter, closeParensBefore = nlBefore.split(")").length, openParensBefore = nlBefore.split("(").length - closeParensBefore, cleanAfter = nlAfter;
        for (let i = 0;i < openParensBefore; i++)
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        nlAfter = cleanAfter;
        let dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
        re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      }
      if (re !== "" && hasMagic)
        re = "(?=.)" + re;
      if (addPatternStart)
        re = patternStart() + re;
      if (isSub === SUBPARSE)
        return [re, hasMagic];
      if (options.nocase && !hasMagic)
        hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
      if (!hasMagic)
        return globUnescape(pattern);
      let flags = options.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + re + "$", flags), {
          _glob: pattern,
          _src: re
        });
      } catch (er) {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === !1)
        return this.regexp;
      let set = this.set;
      if (!set.length)
        return this.regexp = !1, this.regexp;
      let options = this.options, twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot, flags = options.nocase ? "i" : "", re = set.map((pattern) => {
        return pattern = pattern.map((p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set2, p) => {
          if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR))
            set2.push(p);
          return set2;
        }, []), pattern.forEach((p, i) => {
          if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR)
            return;
          if (i === 0)
            if (pattern.length > 1)
              pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
            else
              pattern[i] = twoStar;
          else if (i === pattern.length - 1)
            pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
          else
            pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1], pattern[i + 1] = GLOBSTAR;
        }), pattern.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      if (re = "^(?:" + re + ")$", this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = !1;
      }
      return this.regexp;
    }
    match(f, partial = this.partial) {
      if (this.debug("match", f, this.pattern), this.comment)
        return !1;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return !0;
      let options = this.options;
      if (path.sep !== "/")
        f = f.split(path.sep).join("/");
      f = f.split(slashSplit), this.debug(this.pattern, "split", f);
      let set = this.set;
      this.debug(this.pattern, "set", set);
      let filename;
      for (let i = f.length - 1;i >= 0; i--)
        if (filename = f[i], filename)
          break;
      for (let i = 0;i < set.length; i++) {
        let pattern = set[i], file = f;
        if (options.matchBase && pattern.length === 1)
          file = [filename];
        if (this.matchOne(file, pattern, partial)) {
          if (options.flipNegate)
            return !0;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return !1;
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  }
  minimatch.Minimatch = Minimatch;
});

// node_modules/readdir-glob/index.js
var require_readdir_glob = __commonJS((exports, module) => {
  module.exports = readdirGlob;
  var fs = __require("fs"), { EventEmitter } = __require("events"), { Minimatch } = require_minimatch(), { resolve } = __require("path");
  function readdir(dir, strict) {
    return new Promise((resolve2, reject) => {
      fs.readdir(dir, { withFileTypes: !0 }, (err, files) => {
        if (err)
          switch (err.code) {
            case "ENOTDIR":
              if (strict)
                reject(err);
              else
                resolve2([]);
              break;
            case "ENOTSUP":
            case "ENOENT":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              resolve2([]);
              break;
            case "ELOOP":
            default:
              reject(err);
              break;
          }
        else
          resolve2(files);
      });
    });
  }
  function stat(file, followSymlinks) {
    return new Promise((resolve2, reject) => {
      (followSymlinks ? fs.stat : fs.lstat)(file, (err, stats) => {
        if (err)
          switch (err.code) {
            case "ENOENT":
              if (followSymlinks)
                resolve2(stat(file, !1));
              else
                resolve2(null);
              break;
            default:
              resolve2(null);
              break;
          }
        else
          resolve2(stats);
      });
    });
  }
  async function* exploreWalkAsync(dir, path, followSymlinks, useStat, shouldSkip, strict) {
    let files = await readdir(path + dir, strict);
    for (let file of files) {
      let name = file.name;
      if (name === void 0)
        name = file, useStat = !0;
      let filename = dir + "/" + name, relative = filename.slice(1), absolute = path + "/" + relative, stats = null;
      if (useStat || followSymlinks)
        stats = await stat(absolute, followSymlinks);
      if (!stats && file.name !== void 0)
        stats = file;
      if (stats === null)
        stats = { isDirectory: () => !1 };
      if (stats.isDirectory()) {
        if (!shouldSkip(relative))
          yield { relative, absolute, stats }, yield* exploreWalkAsync(filename, path, followSymlinks, useStat, shouldSkip, !1);
      } else
        yield { relative, absolute, stats };
    }
  }
  async function* explore(path, followSymlinks, useStat, shouldSkip) {
    yield* exploreWalkAsync("", path, followSymlinks, useStat, shouldSkip, !0);
  }
  function readOptions(options) {
    return {
      pattern: options.pattern,
      dot: !!options.dot,
      noglobstar: !!options.noglobstar,
      matchBase: !!options.matchBase,
      nocase: !!options.nocase,
      ignore: options.ignore,
      skip: options.skip,
      follow: !!options.follow,
      stat: !!options.stat,
      nodir: !!options.nodir,
      mark: !!options.mark,
      silent: !!options.silent,
      absolute: !!options.absolute
    };
  }

  class ReaddirGlob extends EventEmitter {
    constructor(cwd, options, cb) {
      super();
      if (typeof options === "function")
        cb = options, options = null;
      if (this.options = readOptions(options || {}), this.matchers = [], this.options.pattern) {
        let matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
        this.matchers = matchers.map((m) => new Minimatch(m, {
          dot: this.options.dot,
          noglobstar: this.options.noglobstar,
          matchBase: this.options.matchBase,
          nocase: this.options.nocase
        }));
      }
      if (this.ignoreMatchers = [], this.options.ignore) {
        let ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
        this.ignoreMatchers = ignorePatterns.map((ignore) => new Minimatch(ignore, { dot: !0 }));
      }
      if (this.skipMatchers = [], this.options.skip) {
        let skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
        this.skipMatchers = skipPatterns.map((skip) => new Minimatch(skip, { dot: !0 }));
      }
      if (this.iterator = explore(resolve(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this)), this.paused = !1, this.inactive = !1, this.aborted = !1, cb)
        this._matches = [], this.on("match", (match) => this._matches.push(this.options.absolute ? match.absolute : match.relative)), this.on("error", (err) => cb(err)), this.on("end", () => cb(null, this._matches));
      setTimeout(() => this._next(), 0);
    }
    _shouldSkipDirectory(relative) {
      return this.skipMatchers.some((m) => m.match(relative));
    }
    _fileMatches(relative, isDirectory) {
      let file = relative + (isDirectory ? "/" : "");
      return (this.matchers.length === 0 || this.matchers.some((m) => m.match(file))) && !this.ignoreMatchers.some((m) => m.match(file)) && (!this.options.nodir || !isDirectory);
    }
    _next() {
      if (!this.paused && !this.aborted)
        this.iterator.next().then((obj) => {
          if (!obj.done) {
            let isDirectory = obj.value.stats.isDirectory();
            if (this._fileMatches(obj.value.relative, isDirectory)) {
              let relative = obj.value.relative, absolute = obj.value.absolute;
              if (this.options.mark && isDirectory)
                relative += "/", absolute += "/";
              if (this.options.stat)
                this.emit("match", { relative, absolute, stat: obj.value.stats });
              else
                this.emit("match", { relative, absolute });
            }
            this._next(this.iterator);
          } else
            this.emit("end");
        }).catch((err) => {
          if (this.abort(), this.emit("error", err), !err.code && !this.options.silent)
            console.error(err);
        });
      else
        this.inactive = !0;
    }
    abort() {
      this.aborted = !0;
    }
    pause() {
      this.paused = !0;
    }
    resume() {
      if (this.paused = !1, this.inactive)
        this.inactive = !1, this._next();
    }
  }
  function readdirGlob(pattern, options, cb) {
    return new ReaddirGlob(pattern, options, cb);
  }
  readdirGlob.ReaddirGlob = ReaddirGlob;
});

// node_modules/async/dist/async.js
var require_async = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module < "u" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis < "u" ? globalThis : global2 || self, factory(global2.async = {}));
  })(exports, function(exports2) {
    function apply(fn, ...args) {
      return (...callArgs) => fn(...args, ...callArgs);
    }
    function initialParams(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    }
    var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask, hasSetImmediate = typeof setImmediate === "function" && setImmediate, hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    var _defer$1;
    if (hasQueueMicrotask)
      _defer$1 = queueMicrotask;
    else if (hasSetImmediate)
      _defer$1 = setImmediate;
    else if (hasNextTick)
      _defer$1 = process.nextTick;
    else
      _defer$1 = fallback;
    var setImmediate$1 = wrap(_defer$1);
    function asyncify(func) {
      if (isAsync(func))
        return function(...args) {
          let callback = args.pop(), promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      return initialParams(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result && typeof result.then === "function")
          return handlePromise(result, callback);
        else
          callback(null, result);
      });
    }
    function handlePromise(promise, callback) {
      return promise.then((value) => {
        invokeCallback(callback, null, value);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : Error(err));
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (err) {
        setImmediate$1((e) => {
          throw e;
        }, err);
      }
    }
    function isAsync(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function")
        throw Error("expected a function");
      return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
    }
    function awaitify(asyncFn, arity) {
      if (!arity)
        arity = asyncFn.length;
      if (!arity)
        throw Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function")
          return asyncFn.apply(this, args);
        return new Promise((resolve, reject2) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err)
              return reject2(err);
            resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          }, asyncFn.apply(this, args);
        });
      }
      return awaitable;
    }
    function applyEach$1(eachfn) {
      return function(fns, ...callArgs) {
        return awaitify(function(callback) {
          var that = this;
          return eachfn(fns, (fn, cb) => {
            wrapAsync(fn).apply(that, callArgs.concat(cb));
          }, callback);
        });
      };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      arr = arr || [];
      var results = [], counter = 0, _iteratee = wrapAsync(iteratee);
      return eachfn(arr, (value, _2, iterCb) => {
        var index2 = counter++;
        _iteratee(value, (err, v) => {
          results[index2] = v, iterCb(err);
        });
      }, (err) => {
        callback(err, results);
      });
    }
    function isArrayLike(value) {
      return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
    }
    let breakLoop = {};
    function once(fn) {
      function wrapper(...args) {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null, callFn.apply(this, args);
      }
      return Object.assign(wrapper, fn), wrapper;
    }
    function getIterator(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    }
    function createArrayIterator(coll) {
      var i = -1, len = coll.length;
      return function() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator) {
      var i = -1;
      return function() {
        var item = iterator.next();
        if (item.done)
          return null;
        return i++, { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [], i = -1, len = okeys.length;
      return function next() {
        var key = okeys[++i];
        if (key === "__proto__")
          return next();
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function createIterator(coll) {
      if (isArrayLike(coll))
        return createArrayIterator(coll);
      var iterator = getIterator(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null)
          throw Error("Callback was already called.");
        var callFn = fn;
        fn = null, callFn.apply(this, args);
      };
    }
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = !1, canceled = !1, awaiting = !1, running = 0, idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done)
          return;
        awaiting = !0, generator.next().then(({ value, done: iterDone }) => {
          if (canceled || done)
            return;
          if (awaiting = !1, iterDone) {
            if (done = !0, running <= 0)
              callback(null);
            return;
          }
          running++, iteratee(value, idx, iterateeCallback), idx++, replenish();
        }).catch(handleError);
      }
      function iterateeCallback(err, result) {
        if (running -= 1, canceled)
          return;
        if (err)
          return handleError(err);
        if (err === !1) {
          done = !0, canceled = !0;
          return;
        }
        if (result === breakLoop || done && running <= 0)
          return done = !0, callback(null);
        replenish();
      }
      function handleError(err) {
        if (canceled)
          return;
        awaiting = !1, done = !0, callback(err);
      }
      replenish();
    }
    var eachOfLimit$2 = (limit) => {
      return (obj, iteratee, callback) => {
        if (callback = once(callback), limit <= 0)
          throw RangeError("concurrency limit cannot be less than 1");
        if (!obj)
          return callback(null);
        if (isAsyncGenerator(obj))
          return asyncEachOfLimit(obj, limit, iteratee, callback);
        if (isAsyncIterable(obj))
          return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        var nextElem = createIterator(obj), done = !1, canceled = !1, running = 0, looping = !1;
        function iterateeCallback(err, value) {
          if (canceled)
            return;
          if (running -= 1, err)
            done = !0, callback(err);
          else if (err === !1)
            done = !0, canceled = !0;
          else if (value === breakLoop || done && running <= 0)
            return done = !0, callback(null);
          else if (!looping)
            replenish();
        }
        function replenish() {
          looping = !0;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              if (done = !0, running <= 0)
                callback(null);
              return;
            }
            running += 1, iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
          }
          looping = !1;
        }
        replenish();
      };
    };
    function eachOfLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
    }
    var eachOfLimit$1 = awaitify(eachOfLimit, 4);
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = once(callback);
      var index2 = 0, completed = 0, { length } = coll, canceled = !1;
      if (length === 0)
        callback(null);
      function iteratorCallback(err, value) {
        if (err === !1)
          canceled = !0;
        if (canceled === !0)
          return;
        if (err)
          callback(err);
        else if (++completed === length || value === breakLoop)
          callback(null);
      }
      for (;index2 < length; index2++)
        iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
    }
    function eachOfGeneric(coll, iteratee, callback) {
      return eachOfLimit$1(coll, 1 / 0, iteratee, callback);
    }
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, wrapAsync(iteratee), callback);
    }
    var eachOf$1 = awaitify(eachOf, 3);
    function map(coll, iteratee, callback) {
      return _asyncMap(eachOf$1, coll, iteratee, callback);
    }
    var map$1 = awaitify(map, 3), applyEach = applyEach$1(map$1);
    function eachOfSeries(coll, iteratee, callback) {
      return eachOfLimit$1(coll, 1, iteratee, callback);
    }
    var eachOfSeries$1 = awaitify(eachOfSeries, 3);
    function mapSeries(coll, iteratee, callback) {
      return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
    }
    var mapSeries$1 = awaitify(mapSeries, 3), applyEachSeries = applyEach$1(mapSeries$1);
    let PROMISE_SYMBOL = Symbol("promiseCallback");
    function promiseCallback() {
      let resolve, reject2;
      function callback(err, ...args) {
        if (err)
          return reject2(err);
        resolve(args.length > 1 ? args : args[0]);
      }
      return callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res, reject2 = rej;
      }), callback;
    }
    function auto(tasks, concurrency, callback) {
      if (typeof concurrency !== "number")
        callback = concurrency, concurrency = null;
      callback = once(callback || promiseCallback());
      var numTasks = Object.keys(tasks).length;
      if (!numTasks)
        return callback(null);
      if (!concurrency)
        concurrency = numTasks;
      var results = {}, runningTasks = 0, canceled = !1, hasError = !1, listeners = Object.create(null), readyTasks = [], readyToCheck = [], uncheckedDependencies = {};
      Object.keys(tasks).forEach((key) => {
        var task = tasks[key];
        if (!Array.isArray(task)) {
          enqueueTask(key, [task]), readyToCheck.push(key);
          return;
        }
        var dependencies = task.slice(0, task.length - 1), remainingDependencies = dependencies.length;
        if (remainingDependencies === 0) {
          enqueueTask(key, task), readyToCheck.push(key);
          return;
        }
        uncheckedDependencies[key] = remainingDependencies, dependencies.forEach((dependencyName) => {
          if (!tasks[dependencyName])
            throw Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
          addListener(dependencyName, () => {
            if (remainingDependencies--, remainingDependencies === 0)
              enqueueTask(key, task);
          });
        });
      }), checkForDeadlocks(), processQueue();
      function enqueueTask(key, task) {
        readyTasks.push(() => runTask(key, task));
      }
      function processQueue() {
        if (canceled)
          return;
        if (readyTasks.length === 0 && runningTasks === 0)
          return callback(null, results);
        while (readyTasks.length && runningTasks < concurrency) {
          var run = readyTasks.shift();
          run();
        }
      }
      function addListener(taskName, fn) {
        var taskListeners = listeners[taskName];
        if (!taskListeners)
          taskListeners = listeners[taskName] = [];
        taskListeners.push(fn);
      }
      function taskComplete(taskName) {
        var taskListeners = listeners[taskName] || [];
        taskListeners.forEach((fn) => fn()), processQueue();
      }
      function runTask(key, task) {
        if (hasError)
          return;
        var taskCallback = onlyOnce((err, ...result) => {
          if (runningTasks--, err === !1) {
            canceled = !0;
            return;
          }
          if (result.length < 2)
            [result] = result;
          if (err) {
            var safeResults = {};
            if (Object.keys(results).forEach((rkey) => {
              safeResults[rkey] = results[rkey];
            }), safeResults[key] = result, hasError = !0, listeners = Object.create(null), canceled)
              return;
            callback(err, safeResults);
          } else
            results[key] = result, taskComplete(key);
        });
        runningTasks++;
        var taskFn = wrapAsync(task[task.length - 1]);
        if (task.length > 1)
          taskFn(results, taskCallback);
        else
          taskFn(taskCallback);
      }
      function checkForDeadlocks() {
        var currentTask, counter = 0;
        while (readyToCheck.length)
          currentTask = readyToCheck.pop(), counter++, getDependents(currentTask).forEach((dependent) => {
            if (--uncheckedDependencies[dependent] === 0)
              readyToCheck.push(dependent);
          });
        if (counter !== numTasks)
          throw Error("async.auto cannot execute tasks due to a recursive dependency");
      }
      function getDependents(taskName) {
        var result = [];
        return Object.keys(tasks).forEach((key) => {
          let task = tasks[key];
          if (Array.isArray(task) && task.indexOf(taskName) >= 0)
            result.push(key);
        }), result;
      }
      return callback[PROMISE_SYMBOL];
    }
    var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/, ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/, FN_ARG_SPLIT = /,/, FN_ARG = /(=.+)?(\s*)$/;
    function stripComments(string) {
      let stripped = "", index2 = 0, endBlockComment = string.indexOf("*/");
      while (index2 < string.length)
        if (string[index2] === "/" && string[index2 + 1] === "/") {
          let endIndex = string.indexOf(`
`, index2);
          index2 = endIndex === -1 ? string.length : endIndex;
        } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
          let endIndex = string.indexOf("*/", index2);
          if (endIndex !== -1)
            index2 = endIndex + 2, endBlockComment = string.indexOf("*/", index2);
          else
            stripped += string[index2], index2++;
        } else
          stripped += string[index2], index2++;
      return stripped;
    }
    function parseParams(func) {
      let src = stripComments(func.toString()), match = src.match(FN_ARGS);
      if (!match)
        match = src.match(ARROW_FN_ARGS);
      if (!match)
        throw Error(`could not parse args in autoInject
Source:
` + src);
      let [, args] = match;
      return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
    }
    function autoInject(tasks, callback) {
      var newTasks = {};
      return Object.keys(tasks).forEach((key) => {
        var taskFn = tasks[key], params, fnIsAsync = isAsync(taskFn), hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
        if (Array.isArray(taskFn))
          params = [...taskFn], taskFn = params.pop(), newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
        else if (hasNoDeps)
          newTasks[key] = taskFn;
        else {
          if (params = parseParams(taskFn), taskFn.length === 0 && !fnIsAsync && params.length === 0)
            throw Error("autoInject task functions require explicit parameters.");
          if (!fnIsAsync)
            params.pop();
          newTasks[key] = params.concat(newTask);
        }
        function newTask(results, taskCb) {
          var newArgs = params.map((name) => results[name]);
          newArgs.push(taskCb), wrapAsync(taskFn)(...newArgs);
        }
      }), auto(newTasks, callback);
    }

    class DLL {
      constructor() {
        this.head = this.tail = null, this.length = 0;
      }
      removeLink(node) {
        if (node.prev)
          node.prev.next = node.next;
        else
          this.head = node.next;
        if (node.next)
          node.next.prev = node.prev;
        else
          this.tail = node.prev;
        return node.prev = node.next = null, this.length -= 1, node;
      }
      empty() {
        while (this.head)
          this.shift();
        return this;
      }
      insertAfter(node, newNode) {
        if (newNode.prev = node, newNode.next = node.next, node.next)
          node.next.prev = newNode;
        else
          this.tail = newNode;
        node.next = newNode, this.length += 1;
      }
      insertBefore(node, newNode) {
        if (newNode.prev = node.prev, newNode.next = node, node.prev)
          node.prev.next = newNode;
        else
          this.head = newNode;
        node.prev = newNode, this.length += 1;
      }
      unshift(node) {
        if (this.head)
          this.insertBefore(this.head, node);
        else
          setInitial(this, node);
      }
      push(node) {
        if (this.tail)
          this.insertAfter(this.tail, node);
        else
          setInitial(this, node);
      }
      shift() {
        return this.head && this.removeLink(this.head);
      }
      pop() {
        return this.tail && this.removeLink(this.tail);
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        var cur = this.head;
        while (cur)
          yield cur.data, cur = cur.next;
      }
      remove(testFn) {
        var curr = this.head;
        while (curr) {
          var { next } = curr;
          if (testFn(curr))
            this.removeLink(curr);
          curr = next;
        }
        return this;
      }
    }
    function setInitial(dll, node) {
      dll.length = 1, dll.head = dll.tail = node;
    }
    function queue$1(worker, concurrency, payload) {
      if (concurrency == null)
        concurrency = 1;
      else if (concurrency === 0)
        throw RangeError("Concurrency must not be zero");
      var _worker = wrapAsync(worker), numRunning = 0, workersList = [];
      let events = {
        error: [],
        drain: [],
        saturated: [],
        unsaturated: [],
        empty: []
      };
      function on(event, handler) {
        events[event].push(handler);
      }
      function once2(event, handler) {
        let handleAndRemove = (...args) => {
          off(event, handleAndRemove), handler(...args);
        };
        events[event].push(handleAndRemove);
      }
      function off(event, handler) {
        if (!event)
          return Object.keys(events).forEach((ev) => events[ev] = []);
        if (!handler)
          return events[event] = [];
        events[event] = events[event].filter((ev) => ev !== handler);
      }
      function trigger(event, ...args) {
        events[event].forEach((handler) => handler(...args));
      }
      var processingScheduled = !1;
      function _insert(data, insertAtFront, rejectOnError, callback) {
        if (callback != null && typeof callback !== "function")
          throw Error("task callback must be a function");
        q.started = !0;
        var res, rej;
        function promiseCallback2(err, ...args) {
          if (err)
            return rejectOnError ? rej(err) : res();
          if (args.length <= 1)
            return res(args[0]);
          res(args);
        }
        var item = q._createTaskItem(data, rejectOnError ? promiseCallback2 : callback || promiseCallback2);
        if (insertAtFront)
          q._tasks.unshift(item);
        else
          q._tasks.push(item);
        if (!processingScheduled)
          processingScheduled = !0, setImmediate$1(() => {
            processingScheduled = !1, q.process();
          });
        if (rejectOnError || !callback)
          return new Promise((resolve, reject2) => {
            res = resolve, rej = reject2;
          });
      }
      function _createCB(tasks) {
        return function(err, ...args) {
          numRunning -= 1;
          for (var i = 0, l = tasks.length;i < l; i++) {
            var task = tasks[i], index2 = workersList.indexOf(task);
            if (index2 === 0)
              workersList.shift();
            else if (index2 > 0)
              workersList.splice(index2, 1);
            if (task.callback(err, ...args), err != null)
              trigger("error", err, task.data);
          }
          if (numRunning <= q.concurrency - q.buffer)
            trigger("unsaturated");
          if (q.idle())
            trigger("drain");
          q.process();
        };
      }
      function _maybeDrain(data) {
        if (data.length === 0 && q.idle())
          return setImmediate$1(() => trigger("drain")), !0;
        return !1;
      }
      let eventMethod = (name) => (handler) => {
        if (!handler)
          return new Promise((resolve, reject2) => {
            once2(name, (err, data) => {
              if (err)
                return reject2(err);
              resolve(data);
            });
          });
        off(name), on(name, handler);
      };
      var isProcessing = !1, q = {
        _tasks: new DLL,
        _createTaskItem(data, callback) {
          return {
            data,
            callback
          };
        },
        *[Symbol.iterator]() {
          yield* q._tasks[Symbol.iterator]();
        },
        concurrency,
        payload,
        buffer: concurrency / 4,
        started: !1,
        paused: !1,
        push(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, !1, !1, callback));
          }
          return _insert(data, !1, !1, callback);
        },
        pushAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, !1, !0, callback));
          }
          return _insert(data, !1, !0, callback);
        },
        kill() {
          off(), q._tasks.empty();
        },
        unshift(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, !0, !1, callback));
          }
          return _insert(data, !0, !1, callback);
        },
        unshiftAsync(data, callback) {
          if (Array.isArray(data)) {
            if (_maybeDrain(data))
              return;
            return data.map((datum) => _insert(datum, !0, !0, callback));
          }
          return _insert(data, !0, !0, callback);
        },
        remove(testFn) {
          q._tasks.remove(testFn);
        },
        process() {
          if (isProcessing)
            return;
          isProcessing = !0;
          while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
            var tasks = [], data = [], l = q._tasks.length;
            if (q.payload)
              l = Math.min(l, q.payload);
            for (var i = 0;i < l; i++) {
              var node = q._tasks.shift();
              tasks.push(node), workersList.push(node), data.push(node.data);
            }
            if (numRunning += 1, q._tasks.length === 0)
              trigger("empty");
            if (numRunning === q.concurrency)
              trigger("saturated");
            var cb = onlyOnce(_createCB(tasks));
            _worker(data, cb);
          }
          isProcessing = !1;
        },
        length() {
          return q._tasks.length;
        },
        running() {
          return numRunning;
        },
        workersList() {
          return workersList;
        },
        idle() {
          return q._tasks.length + numRunning === 0;
        },
        pause() {
          q.paused = !0;
        },
        resume() {
          if (q.paused === !1)
            return;
          q.paused = !1, setImmediate$1(q.process);
        }
      };
      return Object.defineProperties(q, {
        saturated: {
          writable: !1,
          value: eventMethod("saturated")
        },
        unsaturated: {
          writable: !1,
          value: eventMethod("unsaturated")
        },
        empty: {
          writable: !1,
          value: eventMethod("empty")
        },
        drain: {
          writable: !1,
          value: eventMethod("drain")
        },
        error: {
          writable: !1,
          value: eventMethod("error")
        }
      }), q;
    }
    function cargo$1(worker, payload) {
      return queue$1(worker, 1, payload);
    }
    function cargo(worker, concurrency, payload) {
      return queue$1(worker, concurrency, payload);
    }
    function reduce(coll, memo, iteratee, callback) {
      callback = once(callback);
      var _iteratee = wrapAsync(iteratee);
      return eachOfSeries$1(coll, (x, i, iterCb) => {
        _iteratee(memo, x, (err, v) => {
          memo = v, iterCb(err);
        });
      }, (err) => callback(err, memo));
    }
    var reduce$1 = awaitify(reduce, 4);
    function seq(...functions) {
      var _functions = functions.map(wrapAsync);
      return function(...args) {
        var that = this, cb = args[args.length - 1];
        if (typeof cb == "function")
          args.pop();
        else
          cb = promiseCallback();
        return reduce$1(_functions, args, (newargs, fn, iterCb) => {
          fn.apply(that, newargs.concat((err, ...nextargs) => {
            iterCb(err, nextargs);
          }));
        }, (err, results) => cb(err, ...results)), cb[PROMISE_SYMBOL];
      };
    }
    function compose(...args) {
      return seq(...args.reverse());
    }
    function mapLimit(coll, limit, iteratee, callback) {
      return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var mapLimit$1 = awaitify(mapLimit, 4);
    function concatLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, ...args) => {
          if (err)
            return iterCb(err);
          return iterCb(err, args);
        });
      }, (err, mapResults) => {
        var result = [];
        for (var i = 0;i < mapResults.length; i++)
          if (mapResults[i])
            result = result.concat(...mapResults[i]);
        return callback(err, result);
      });
    }
    var concatLimit$1 = awaitify(concatLimit, 4);
    function concat(coll, iteratee, callback) {
      return concatLimit$1(coll, 1 / 0, iteratee, callback);
    }
    var concat$1 = awaitify(concat, 3);
    function concatSeries(coll, iteratee, callback) {
      return concatLimit$1(coll, 1, iteratee, callback);
    }
    var concatSeries$1 = awaitify(concatSeries, 3);
    function constant$1(...args) {
      return function(...ignoredArgs) {
        var callback = ignoredArgs.pop();
        return callback(null, ...args);
      };
    }
    function _createTester(check, getResult) {
      return (eachfn, arr, _iteratee, cb) => {
        var testPassed = !1, testResult;
        let iteratee = wrapAsync(_iteratee);
        eachfn(arr, (value, _2, callback) => {
          iteratee(value, (err, result) => {
            if (err || err === !1)
              return callback(err);
            if (check(result) && !testResult)
              return testPassed = !0, testResult = getResult(!0, value), callback(null, breakLoop);
            callback();
          });
        }, (err) => {
          if (err)
            return cb(err);
          cb(null, testPassed ? testResult : getResult(!1));
        });
      };
    }
    function detect(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
    }
    var detect$1 = awaitify(detect, 3);
    function detectLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var detectLimit$1 = awaitify(detectLimit, 4);
    function detectSeries(coll, iteratee, callback) {
      return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
    }
    var detectSeries$1 = awaitify(detectSeries, 3);
    function consoleFunc(name) {
      return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
        if (typeof console === "object") {
          if (err) {
            if (console.error)
              console.error(err);
          } else if (console[name])
            resultArgs.forEach((x) => console[name](x));
        }
      });
    }
    var dir = consoleFunc("dir");
    function doWhilst(iteratee, test, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee), _test = wrapAsync(test), results;
      function next(err, ...args) {
        if (err)
          return callback(err);
        if (err === !1)
          return;
        results = args, _test(...args, check);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (err === !1)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return check(null, !0);
    }
    var doWhilst$1 = awaitify(doWhilst, 3);
    function doUntil(iteratee, test, callback) {
      let _test = wrapAsync(test);
      return doWhilst$1(iteratee, (...args) => {
        let cb = args.pop();
        _test(...args, (err, truth) => cb(err, !truth));
      }, callback);
    }
    function _withoutIndex(iteratee) {
      return (value, index2, callback) => iteratee(value, callback);
    }
    function eachLimit$2(coll, iteratee, callback) {
      return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var each = awaitify(eachLimit$2, 3);
    function eachLimit(coll, limit, iteratee, callback) {
      return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
    }
    var eachLimit$1 = awaitify(eachLimit, 4);
    function eachSeries(coll, iteratee, callback) {
      return eachLimit$1(coll, 1, iteratee, callback);
    }
    var eachSeries$1 = awaitify(eachSeries, 3);
    function ensureAsync(fn) {
      if (isAsync(fn))
        return fn;
      return function(...args) {
        var callback = args.pop(), sync = !0;
        args.push((...innerArgs) => {
          if (sync)
            setImmediate$1(() => callback(...innerArgs));
          else
            callback(...innerArgs);
        }), fn.apply(this, args), sync = !1;
      };
    }
    function every(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
    }
    var every$1 = awaitify(every, 3);
    function everyLimit(coll, limit, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var everyLimit$1 = awaitify(everyLimit, 4);
    function everySeries(coll, iteratee, callback) {
      return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var everySeries$1 = awaitify(everySeries, 3);
    function filterArray(eachfn, arr, iteratee, callback) {
      var truthValues = Array(arr.length);
      eachfn(arr, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          truthValues[index2] = !!v, iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        var results = [];
        for (var i = 0;i < arr.length; i++)
          if (truthValues[i])
            results.push(arr[i]);
        callback(null, results);
      });
    }
    function filterGeneric(eachfn, coll, iteratee, callback) {
      var results = [];
      eachfn(coll, (x, index2, iterCb) => {
        iteratee(x, (err, v) => {
          if (err)
            return iterCb(err);
          if (v)
            results.push({ index: index2, value: x });
          iterCb(err);
        });
      }, (err) => {
        if (err)
          return callback(err);
        callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
      });
    }
    function _filter(eachfn, coll, iteratee, callback) {
      var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
      return filter2(eachfn, coll, wrapAsync(iteratee), callback);
    }
    function filter(coll, iteratee, callback) {
      return _filter(eachOf$1, coll, iteratee, callback);
    }
    var filter$1 = awaitify(filter, 3);
    function filterLimit(coll, limit, iteratee, callback) {
      return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var filterLimit$1 = awaitify(filterLimit, 4);
    function filterSeries(coll, iteratee, callback) {
      return _filter(eachOfSeries$1, coll, iteratee, callback);
    }
    var filterSeries$1 = awaitify(filterSeries, 3);
    function forever(fn, errback) {
      var done = onlyOnce(errback), task = wrapAsync(ensureAsync(fn));
      function next(err) {
        if (err)
          return done(err);
        if (err === !1)
          return;
        task(next);
      }
      return next();
    }
    var forever$1 = awaitify(forever, 2);
    function groupByLimit(coll, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(coll, limit, (val, iterCb) => {
        _iteratee(val, (err, key) => {
          if (err)
            return iterCb(err);
          return iterCb(err, { key, val });
        });
      }, (err, mapResults) => {
        var result = {}, { hasOwnProperty } = Object.prototype;
        for (var i = 0;i < mapResults.length; i++)
          if (mapResults[i]) {
            var { key } = mapResults[i], { val } = mapResults[i];
            if (hasOwnProperty.call(result, key))
              result[key].push(val);
            else
              result[key] = [val];
          }
        return callback(err, result);
      });
    }
    var groupByLimit$1 = awaitify(groupByLimit, 4);
    function groupBy(coll, iteratee, callback) {
      return groupByLimit$1(coll, 1 / 0, iteratee, callback);
    }
    function groupBySeries(coll, iteratee, callback) {
      return groupByLimit$1(coll, 1, iteratee, callback);
    }
    var log = consoleFunc("log");
    function mapValuesLimit(obj, limit, iteratee, callback) {
      callback = once(callback);
      var newObj = {}, _iteratee = wrapAsync(iteratee);
      return eachOfLimit$2(limit)(obj, (val, key, next) => {
        _iteratee(val, key, (err, result) => {
          if (err)
            return next(err);
          newObj[key] = result, next(err);
        });
      }, (err) => callback(err, newObj));
    }
    var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
    function mapValues(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, 1 / 0, iteratee, callback);
    }
    function mapValuesSeries(obj, iteratee, callback) {
      return mapValuesLimit$1(obj, 1, iteratee, callback);
    }
    function memoize(fn, hasher = (v) => v) {
      var memo = Object.create(null), queues = Object.create(null), _fn = wrapAsync(fn), memoized = initialParams((args, callback) => {
        var key = hasher(...args);
        if (key in memo)
          setImmediate$1(() => callback(null, ...memo[key]));
        else if (key in queues)
          queues[key].push(callback);
        else
          queues[key] = [callback], _fn(...args, (err, ...resultArgs) => {
            if (!err)
              memo[key] = resultArgs;
            var q = queues[key];
            delete queues[key];
            for (var i = 0, l = q.length;i < l; i++)
              q[i](err, ...resultArgs);
          });
      });
      return memoized.memo = memo, memoized.unmemoized = fn, memoized;
    }
    var _defer;
    if (hasNextTick)
      _defer = process.nextTick;
    else if (hasSetImmediate)
      _defer = setImmediate;
    else
      _defer = fallback;
    var nextTick = wrap(_defer), _parallel = awaitify((eachfn, tasks, callback) => {
      var results = isArrayLike(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        wrapAsync(task)((err, ...result) => {
          if (result.length < 2)
            [result] = result;
          results[key] = result, taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    function parallel(tasks, callback) {
      return _parallel(eachOf$1, tasks, callback);
    }
    function parallelLimit(tasks, limit, callback) {
      return _parallel(eachOfLimit$2(limit), tasks, callback);
    }
    function queue(worker, concurrency) {
      var _worker = wrapAsync(worker);
      return queue$1((items, cb) => {
        _worker(items[0], cb);
      }, concurrency, 1);
    }

    class Heap {
      constructor() {
        this.heap = [], this.pushCount = Number.MIN_SAFE_INTEGER;
      }
      get length() {
        return this.heap.length;
      }
      empty() {
        return this.heap = [], this;
      }
      percUp(index2) {
        let p;
        while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
          let t = this.heap[index2];
          this.heap[index2] = this.heap[p], this.heap[p] = t, index2 = p;
        }
      }
      percDown(index2) {
        let l;
        while ((l = leftChi(index2)) < this.heap.length) {
          if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l]))
            l = l + 1;
          if (smaller(this.heap[index2], this.heap[l]))
            break;
          let t = this.heap[index2];
          this.heap[index2] = this.heap[l], this.heap[l] = t, index2 = l;
        }
      }
      push(node) {
        node.pushCount = ++this.pushCount, this.heap.push(node), this.percUp(this.heap.length - 1);
      }
      unshift(node) {
        return this.heap.push(node);
      }
      shift() {
        let [top] = this.heap;
        return this.heap[0] = this.heap[this.heap.length - 1], this.heap.pop(), this.percDown(0), top;
      }
      toArray() {
        return [...this];
      }
      *[Symbol.iterator]() {
        for (let i = 0;i < this.heap.length; i++)
          yield this.heap[i].data;
      }
      remove(testFn) {
        let j = 0;
        for (let i = 0;i < this.heap.length; i++)
          if (!testFn(this.heap[i]))
            this.heap[j] = this.heap[i], j++;
        this.heap.splice(j);
        for (let i = parent(this.heap.length - 1);i >= 0; i--)
          this.percDown(i);
        return this;
      }
    }
    function leftChi(i) {
      return (i << 1) + 1;
    }
    function parent(i) {
      return (i + 1 >> 1) - 1;
    }
    function smaller(x, y) {
      if (x.priority !== y.priority)
        return x.priority < y.priority;
      else
        return x.pushCount < y.pushCount;
    }
    function priorityQueue(worker, concurrency) {
      var q = queue(worker, concurrency), {
        push,
        pushAsync
      } = q;
      q._tasks = new Heap, q._createTaskItem = ({ data, priority }, callback) => {
        return {
          data,
          priority,
          callback
        };
      };
      function createDataItems(tasks, priority) {
        if (!Array.isArray(tasks))
          return { data: tasks, priority };
        return tasks.map((data) => {
          return { data, priority };
        });
      }
      return q.push = function(data, priority = 0, callback) {
        return push(createDataItems(data, priority), callback);
      }, q.pushAsync = function(data, priority = 0, callback) {
        return pushAsync(createDataItems(data, priority), callback);
      }, delete q.unshift, delete q.unshiftAsync, q;
    }
    function race(tasks, callback) {
      if (callback = once(callback), !Array.isArray(tasks))
        return callback(TypeError("First argument to race must be an array of functions"));
      if (!tasks.length)
        return callback();
      for (var i = 0, l = tasks.length;i < l; i++)
        wrapAsync(tasks[i])(callback);
    }
    var race$1 = awaitify(race, 2);
    function reduceRight(array, memo, iteratee, callback) {
      var reversed = [...array].reverse();
      return reduce$1(reversed, memo, iteratee, callback);
    }
    function reflect(fn) {
      var _fn = wrapAsync(fn);
      return initialParams(function(args, reflectCallback) {
        return args.push((error, ...cbArgs) => {
          let retVal = {};
          if (error)
            retVal.error = error;
          if (cbArgs.length > 0) {
            var value = cbArgs;
            if (cbArgs.length <= 1)
              [value] = cbArgs;
            retVal.value = value;
          }
          reflectCallback(null, retVal);
        }), _fn.apply(this, args);
      });
    }
    function reflectAll(tasks) {
      var results;
      if (Array.isArray(tasks))
        results = tasks.map(reflect);
      else
        results = {}, Object.keys(tasks).forEach((key) => {
          results[key] = reflect.call(this, tasks[key]);
        });
      return results;
    }
    function reject$2(eachfn, arr, _iteratee, callback) {
      let iteratee = wrapAsync(_iteratee);
      return _filter(eachfn, arr, (value, cb) => {
        iteratee(value, (err, v) => {
          cb(err, !v);
        });
      }, callback);
    }
    function reject(coll, iteratee, callback) {
      return reject$2(eachOf$1, coll, iteratee, callback);
    }
    var reject$1 = awaitify(reject, 3);
    function rejectLimit(coll, limit, iteratee, callback) {
      return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var rejectLimit$1 = awaitify(rejectLimit, 4);
    function rejectSeries(coll, iteratee, callback) {
      return reject$2(eachOfSeries$1, coll, iteratee, callback);
    }
    var rejectSeries$1 = awaitify(rejectSeries, 3);
    function constant(value) {
      return function() {
        return value;
      };
    }
    let DEFAULT_TIMES = 5, DEFAULT_INTERVAL = 0;
    function retry(opts, task, callback) {
      var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant(DEFAULT_INTERVAL)
      };
      if (arguments.length < 3 && typeof opts === "function")
        callback = task || promiseCallback(), task = opts;
      else
        parseTimes(options, opts), callback = callback || promiseCallback();
      if (typeof task !== "function")
        throw Error("Invalid arguments for async.retry");
      var _task = wrapAsync(task), attempt = 1;
      function retryAttempt() {
        _task((err, ...args) => {
          if (err === !1)
            return;
          if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err)))
            setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
          else
            callback(err, ...args);
        });
      }
      return retryAttempt(), callback[PROMISE_SYMBOL];
    }
    function parseTimes(acc, t) {
      if (typeof t === "object")
        acc.times = +t.times || DEFAULT_TIMES, acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL), acc.errorFilter = t.errorFilter;
      else if (typeof t === "number" || typeof t === "string")
        acc.times = +t || DEFAULT_TIMES;
      else
        throw Error("Invalid arguments for async.retry");
    }
    function retryable(opts, task) {
      if (!task)
        task = opts, opts = null;
      let arity = opts && opts.arity || task.length;
      if (isAsync(task))
        arity += 1;
      var _task = wrapAsync(task);
      return initialParams((args, callback) => {
        if (args.length < arity - 1 || callback == null)
          args.push(callback), callback = promiseCallback();
        function taskFn(cb) {
          _task(...args, cb);
        }
        if (opts)
          retry(opts, taskFn, callback);
        else
          retry(taskFn, callback);
        return callback[PROMISE_SYMBOL];
      });
    }
    function series(tasks, callback) {
      return _parallel(eachOfSeries$1, tasks, callback);
    }
    function some(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
    }
    var some$1 = awaitify(some, 3);
    function someLimit(coll, limit, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
    }
    var someLimit$1 = awaitify(someLimit, 4);
    function someSeries(coll, iteratee, callback) {
      return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
    }
    var someSeries$1 = awaitify(someSeries, 3);
    function sortBy(coll, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return map$1(coll, (x, iterCb) => {
        _iteratee(x, (err, criteria) => {
          if (err)
            return iterCb(err);
          iterCb(err, { value: x, criteria });
        });
      }, (err, results) => {
        if (err)
          return callback(err);
        callback(null, results.sort(comparator).map((v) => v.value));
      });
      function comparator(left, right) {
        var a = left.criteria, b = right.criteria;
        return a < b ? -1 : a > b ? 1 : 0;
      }
    }
    var sortBy$1 = awaitify(sortBy, 3);
    function timeout(asyncFn, milliseconds, info) {
      var fn = wrapAsync(asyncFn);
      return initialParams((args, callback) => {
        var timedOut = !1, timer;
        function timeoutCallback() {
          var name = asyncFn.name || "anonymous", error = Error('Callback function "' + name + '" timed out.');
          if (error.code = "ETIMEDOUT", info)
            error.info = info;
          timedOut = !0, callback(error);
        }
        args.push((...cbArgs) => {
          if (!timedOut)
            callback(...cbArgs), clearTimeout(timer);
        }), timer = setTimeout(timeoutCallback, milliseconds), fn(...args);
      });
    }
    function range(size) {
      var result = Array(size);
      while (size--)
        result[size] = size;
      return result;
    }
    function timesLimit(count, limit, iteratee, callback) {
      var _iteratee = wrapAsync(iteratee);
      return mapLimit$1(range(count), limit, _iteratee, callback);
    }
    function times(n, iteratee, callback) {
      return timesLimit(n, 1 / 0, iteratee, callback);
    }
    function timesSeries(n, iteratee, callback) {
      return timesLimit(n, 1, iteratee, callback);
    }
    function transform(coll, accumulator, iteratee, callback) {
      if (arguments.length <= 3 && typeof accumulator === "function")
        callback = iteratee, iteratee = accumulator, accumulator = Array.isArray(coll) ? [] : {};
      callback = once(callback || promiseCallback());
      var _iteratee = wrapAsync(iteratee);
      return eachOf$1(coll, (v, k, cb) => {
        _iteratee(accumulator, v, k, cb);
      }, (err) => callback(err, accumulator)), callback[PROMISE_SYMBOL];
    }
    function tryEach(tasks, callback) {
      var error = null, result;
      return eachSeries$1(tasks, (task, taskCb) => {
        wrapAsync(task)((err, ...args) => {
          if (err === !1)
            return taskCb(err);
          if (args.length < 2)
            [result] = args;
          else
            result = args;
          error = err, taskCb(err ? null : {});
        });
      }, () => callback(error, result));
    }
    var tryEach$1 = awaitify(tryEach);
    function unmemoize(fn) {
      return (...args) => {
        return (fn.unmemoized || fn)(...args);
      };
    }
    function whilst(test, iteratee, callback) {
      callback = onlyOnce(callback);
      var _fn = wrapAsync(iteratee), _test = wrapAsync(test), results = [];
      function next(err, ...rest) {
        if (err)
          return callback(err);
        if (results = rest, err === !1)
          return;
        _test(check);
      }
      function check(err, truth) {
        if (err)
          return callback(err);
        if (err === !1)
          return;
        if (!truth)
          return callback(null, ...results);
        _fn(next);
      }
      return _test(check);
    }
    var whilst$1 = awaitify(whilst, 3);
    function until(test, iteratee, callback) {
      let _test = wrapAsync(test);
      return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
    }
    function waterfall(tasks, callback) {
      if (callback = once(callback), !Array.isArray(tasks))
        return callback(Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = wrapAsync(tasks[taskIndex++]);
        task(...args, onlyOnce(next));
      }
      function next(err, ...args) {
        if (err === !1)
          return;
        if (err || taskIndex === tasks.length)
          return callback(err, ...args);
        nextTask(args);
      }
      nextTask([]);
    }
    var waterfall$1 = awaitify(waterfall), index = {
      apply,
      applyEach,
      applyEachSeries,
      asyncify,
      auto,
      autoInject,
      cargo: cargo$1,
      cargoQueue: cargo,
      compose,
      concat: concat$1,
      concatLimit: concatLimit$1,
      concatSeries: concatSeries$1,
      constant: constant$1,
      detect: detect$1,
      detectLimit: detectLimit$1,
      detectSeries: detectSeries$1,
      dir,
      doUntil,
      doWhilst: doWhilst$1,
      each,
      eachLimit: eachLimit$1,
      eachOf: eachOf$1,
      eachOfLimit: eachOfLimit$1,
      eachOfSeries: eachOfSeries$1,
      eachSeries: eachSeries$1,
      ensureAsync,
      every: every$1,
      everyLimit: everyLimit$1,
      everySeries: everySeries$1,
      filter: filter$1,
      filterLimit: filterLimit$1,
      filterSeries: filterSeries$1,
      forever: forever$1,
      groupBy,
      groupByLimit: groupByLimit$1,
      groupBySeries,
      log,
      map: map$1,
      mapLimit: mapLimit$1,
      mapSeries: mapSeries$1,
      mapValues,
      mapValuesLimit: mapValuesLimit$1,
      mapValuesSeries,
      memoize,
      nextTick,
      parallel,
      parallelLimit,
      priorityQueue,
      queue,
      race: race$1,
      reduce: reduce$1,
      reduceRight,
      reflect,
      reflectAll,
      reject: reject$1,
      rejectLimit: rejectLimit$1,
      rejectSeries: rejectSeries$1,
      retry,
      retryable,
      seq,
      series,
      setImmediate: setImmediate$1,
      some: some$1,
      someLimit: someLimit$1,
      someSeries: someSeries$1,
      sortBy: sortBy$1,
      timeout,
      times,
      timesLimit,
      timesSeries,
      transform,
      tryEach: tryEach$1,
      unmemoize,
      until,
      waterfall: waterfall$1,
      whilst: whilst$1,
      all: every$1,
      allLimit: everyLimit$1,
      allSeries: everySeries$1,
      any: some$1,
      anyLimit: someLimit$1,
      anySeries: someSeries$1,
      find: detect$1,
      findLimit: detectLimit$1,
      findSeries: detectSeries$1,
      flatMap: concat$1,
      flatMapLimit: concatLimit$1,
      flatMapSeries: concatSeries$1,
      forEach: each,
      forEachSeries: eachSeries$1,
      forEachLimit: eachLimit$1,
      forEachOf: eachOf$1,
      forEachOfSeries: eachOfSeries$1,
      forEachOfLimit: eachOfLimit$1,
      inject: reduce$1,
      foldl: reduce$1,
      foldr: reduceRight,
      select: filter$1,
      selectLimit: filterLimit$1,
      selectSeries: filterSeries$1,
      wrapSync: asyncify,
      during: whilst$1,
      doDuring: doWhilst$1
    };
    exports2.all = every$1, exports2.allLimit = everyLimit$1, exports2.allSeries = everySeries$1, exports2.any = some$1, exports2.anyLimit = someLimit$1, exports2.anySeries = someSeries$1, exports2.apply = apply, exports2.applyEach = applyEach, exports2.applyEachSeries = applyEachSeries, exports2.asyncify = asyncify, exports2.auto = auto, exports2.autoInject = autoInject, exports2.cargo = cargo$1, exports2.cargoQueue = cargo, exports2.compose = compose, exports2.concat = concat$1, exports2.concatLimit = concatLimit$1, exports2.concatSeries = concatSeries$1, exports2.constant = constant$1, exports2.default = index, exports2.detect = detect$1, exports2.detectLimit = detectLimit$1, exports2.detectSeries = detectSeries$1, exports2.dir = dir, exports2.doDuring = doWhilst$1, exports2.doUntil = doUntil, exports2.doWhilst = doWhilst$1, exports2.during = whilst$1, exports2.each = each, exports2.eachLimit = eachLimit$1, exports2.eachOf = eachOf$1, exports2.eachOfLimit = eachOfLimit$1, exports2.eachOfSeries = eachOfSeries$1, exports2.eachSeries = eachSeries$1, exports2.ensureAsync = ensureAsync, exports2.every = every$1, exports2.everyLimit = everyLimit$1, exports2.everySeries = everySeries$1, exports2.filter = filter$1, exports2.filterLimit = filterLimit$1, exports2.filterSeries = filterSeries$1, exports2.find = detect$1, exports2.findLimit = detectLimit$1, exports2.findSeries = detectSeries$1, exports2.flatMap = concat$1, exports2.flatMapLimit = concatLimit$1, exports2.flatMapSeries = concatSeries$1, exports2.foldl = reduce$1, exports2.foldr = reduceRight, exports2.forEach = each, exports2.forEachLimit = eachLimit$1, exports2.forEachOf = eachOf$1, exports2.forEachOfLimit = eachOfLimit$1, exports2.forEachOfSeries = eachOfSeries$1, exports2.forEachSeries = eachSeries$1, exports2.forever = forever$1, exports2.groupBy = groupBy, exports2.groupByLimit = groupByLimit$1, exports2.groupBySeries = groupBySeries, exports2.inject = reduce$1, exports2.log = log, exports2.map = map$1, exports2.mapLimit = mapLimit$1, exports2.mapSeries = mapSeries$1, exports2.mapValues = mapValues, exports2.mapValuesLimit = mapValuesLimit$1, exports2.mapValuesSeries = mapValuesSeries, exports2.memoize = memoize, exports2.nextTick = nextTick, exports2.parallel = parallel, exports2.parallelLimit = parallelLimit, exports2.priorityQueue = priorityQueue, exports2.queue = queue, exports2.race = race$1, exports2.reduce = reduce$1, exports2.reduceRight = reduceRight, exports2.reflect = reflect, exports2.reflectAll = reflectAll, exports2.reject = reject$1, exports2.rejectLimit = rejectLimit$1, exports2.rejectSeries = rejectSeries$1, exports2.retry = retry, exports2.retryable = retryable, exports2.select = filter$1, exports2.selectLimit = filterLimit$1, exports2.selectSeries = filterSeries$1, exports2.seq = seq, exports2.series = series, exports2.setImmediate = setImmediate$1, exports2.some = some$1, exports2.someLimit = someLimit$1, exports2.someSeries = someSeries$1, exports2.sortBy = sortBy$1, exports2.timeout = timeout, exports2.times = times, exports2.timesLimit = timesLimit, exports2.timesSeries = timesSeries, exports2.transform = transform, exports2.tryEach = tryEach$1, exports2.unmemoize = unmemoize, exports2.until = until, exports2.waterfall = waterfall$1, exports2.whilst = whilst$1, exports2.wrapSync = asyncify, Object.defineProperty(exports2, "__esModule", { value: !0 });
  });
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS((exports, module) => {
  var constants = __require("constants"), origCwd = process.cwd, cwd = null, platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {}
  if (typeof process.chdir === "function") {
    if (chdir = process.chdir, process.chdir = function(d) {
      cwd = null, chdir.call(process, d);
    }, Object.setPrototypeOf)
      Object.setPrototypeOf(process.chdir, chdir);
  }
  var chdir;
  module.exports = patch;
  function patch(fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./))
      patchLchmod(fs);
    if (!fs.lutimes)
      patchLutimes(fs);
    if (fs.chown = chownFix(fs.chown), fs.fchown = chownFix(fs.fchown), fs.lchown = chownFix(fs.lchown), fs.chmod = chmodFix(fs.chmod), fs.fchmod = chmodFix(fs.fchmod), fs.lchmod = chmodFix(fs.lchmod), fs.chownSync = chownFixSync(fs.chownSync), fs.fchownSync = chownFixSync(fs.fchownSync), fs.lchownSync = chownFixSync(fs.lchownSync), fs.chmodSync = chmodFixSync(fs.chmodSync), fs.fchmodSync = chmodFixSync(fs.fchmodSync), fs.lchmodSync = chmodFixSync(fs.lchmodSync), fs.stat = statFix(fs.stat), fs.fstat = statFix(fs.fstat), fs.lstat = statFix(fs.lstat), fs.statSync = statFixSync(fs.statSync), fs.fstatSync = statFixSync(fs.fstatSync), fs.lstatSync = statFixSync(fs.lstatSync), fs.chmod && !fs.lchmod)
      fs.lchmod = function(path, mode, cb) {
        if (cb)
          process.nextTick(cb);
      }, fs.lchmodSync = function() {};
    if (fs.chown && !fs.lchown)
      fs.lchown = function(path, uid, gid, cb) {
        if (cb)
          process.nextTick(cb);
      }, fs.lchownSync = function() {};
    if (platform === "win32")
      fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now(), backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
              if (setTimeout(function() {
                fs.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff), backoff < 100)
                backoff += 10;
              return;
            }
            if (cb)
              cb(er);
          });
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs.rename);
    fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _2, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10)
              return eagCounter++, fs$read.call(fs, fd, buffer, offset, length, position, callback);
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs.read), fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (!0)
          try {
            return fs$readSync.call(fs, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
      };
    }(fs.readSync);
    function patchLchmod(fs2) {
      fs2.lchmod = function(path, mode, callback) {
        fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
          if (err) {
            if (callback)
              callback(err);
            return;
          }
          fs2.fchmod(fd, mode, function(err2) {
            fs2.close(fd, function(err22) {
              if (callback)
                callback(err2 || err22);
            });
          });
        });
      }, fs2.lchmodSync = function(path, mode) {
        var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode), threw = !0, ret;
        try {
          ret = fs2.fchmodSync(fd, mode), threw = !1;
        } finally {
          if (threw)
            try {
              fs2.closeSync(fd);
            } catch (er) {}
          else
            fs2.closeSync(fd);
        }
        return ret;
      };
    }
    function patchLutimes(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes)
        fs2.lutimes = function(path, at, mt, cb) {
          fs2.open(path, constants.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb)
                cb(er);
              return;
            }
            fs2.futimes(fd, at, mt, function(er2) {
              fs2.close(fd, function(er22) {
                if (cb)
                  cb(er2 || er22);
              });
            });
          });
        }, fs2.lutimesSync = function(path, at, mt) {
          var fd = fs2.openSync(path, constants.O_SYMLINK), ret, threw = !0;
          try {
            ret = fs2.futimesSync(fd, at, mt), threw = !1;
          } finally {
            if (threw)
              try {
                fs2.closeSync(fd);
              } catch (er) {}
            else
              fs2.closeSync(fd);
          }
          return ret;
        };
      else if (fs2.futimes)
        fs2.lutimes = function(_a, _b, _c, cb) {
          if (cb)
            process.nextTick(cb);
        }, fs2.lutimesSync = function() {};
    }
    function chmodFix(orig) {
      if (!orig)
        return orig;
      return function(target, mode, cb) {
        return orig.call(fs, target, mode, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, mode) {
        try {
          return orig.call(fs, target, mode);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs, target, uid, gid, function(er) {
          if (chownErOk(er))
            er = null;
          if (cb)
            cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er))
            throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig)
        return orig;
      return function(target, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          if (cb)
            cb.apply(this, arguments);
        }
        return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig)
        return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
        if (stats) {
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return !0;
      if (er.code === "ENOSYS")
        return !0;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return !0;
      }
      return !1;
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream;
  module.exports = legacy;
  function legacy(fs) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(path, options);
      Stream.call(this);
      var self2 = this;
      this.path = path, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 65536, options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.encoding)
        this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if (typeof this.start !== "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end !== "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err), self2.readable = !1;
          return;
        }
        self2.fd = fd, self2.emit("open", fd), self2._read();
      });
    }
    function WriteStream(path, options) {
      if (!(this instanceof WriteStream))
        return new WriteStream(path, options);
      Stream.call(this), this.path = path, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, options = options || {};
      var keys = Object.keys(options);
      for (var index = 0, length = keys.length;index < length; index++) {
        var key = keys[index];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if (typeof this.start !== "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw Error("start must be >= zero");
        this.pos = this.start;
      }
      if (this.busy = !1, this._queue = [], this.fd === null)
        this._open = fs.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush();
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS((exports, module) => {
  module.exports = clone;
  var getPrototypeOf = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = { __proto__: getPrototypeOf(obj) };
    else
      var copy = Object.create(null);
    return Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    }), copy;
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS((exports, module) => {
  var fs = __require("fs"), polyfills = require_polyfills(), legacy = require_legacy_streams(), clone = require_clone(), util = __require("util"), gracefulQueue, previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function")
    gracefulQueue = Symbol.for("graceful-fs.queue"), previousSymbol = Symbol.for("graceful-fs.previous");
  else
    gracefulQueue = "___graceful-fs.queue", previousSymbol = "___graceful-fs.previous";
  function noop() {}
  function publishQueue(context, queue2) {
    Object.defineProperty(context, gracefulQueue, {
      get: function() {
        return queue2;
      }
    });
  }
  var debug = noop;
  if (util.debuglog)
    debug = util.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util.format.apply(util, arguments);
      m = "GFS4: " + m.split(/\n/).join(`
GFS4: `), console.error(m);
    };
  if (!fs[gracefulQueue]) {
    if (queue = global[gracefulQueue] || [], publishQueue(fs, queue), fs.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs, fd, function(err) {
          if (!err)
            resetQueue();
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      return Object.defineProperty(close, previousSymbol, {
        value: fs$close
      }), close;
    }(fs.close), fs.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs, arguments), resetQueue();
      }
      return Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      }), closeSync;
    }(fs.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      process.on("exit", function() {
        debug(fs[gracefulQueue]), __require("assert").equal(fs[gracefulQueue].length, 0);
      });
  }
  var queue;
  if (!global[gracefulQueue])
    publishQueue(global, fs[gracefulQueue]);
  module.exports = patch(clone(fs));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched)
    module.exports = patch(fs), fs.__patched = !0;
  function patch(fs2) {
    polyfills(fs2), fs2.gracefulify = patch, fs2.createReadStream = createReadStream, fs2.createWriteStream = createWriteStream;
    var fs$readFile = fs2.readFile;
    fs2.readFile = readFile;
    function readFile(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path, options, cb);
      function go$readFile(path2, options2, cb2, startTime) {
        return fs$readFile(path2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        });
      }
    }
    var fs$writeFile = fs2.writeFile;
    fs2.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path, data, options, cb);
      function go$writeFile(path2, data2, options2, cb2, startTime) {
        return fs$writeFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        });
      }
    }
    var fs$appendFile = fs2.appendFile;
    if (fs$appendFile)
      fs2.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path, data, options, cb);
      function go$appendFile(path2, data2, options2, cb2, startTime) {
        return fs$appendFile(path2, data2, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        });
      }
    }
    var fs$copyFile = fs2.copyFile;
    if (fs$copyFile)
      fs2.copyFile = copyFile;
    function copyFile(src, dest, flags, cb) {
      if (typeof flags === "function")
        cb = flags, flags = 0;
      return go$copyFile(src, dest, flags, cb);
      function go$copyFile(src2, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src2, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        });
      }
    }
    var fs$readdir = fs2.readdir;
    fs2.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function(path2, options2, cb2, startTime) {
        return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
      } : function(path2, options2, cb2, startTime) {
        return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
      };
      return go$readdir(path, options, cb);
      function fs$readdirCallback(path2, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path2, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs2);
      ReadStream = legStreams.ReadStream, WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs2.ReadStream;
    if (fs$ReadStream)
      ReadStream.prototype = Object.create(fs$ReadStream.prototype), ReadStream.prototype.open = ReadStream$open;
    var fs$WriteStream = fs2.WriteStream;
    if (fs$WriteStream)
      WriteStream.prototype = Object.create(fs$WriteStream.prototype), WriteStream.prototype.open = WriteStream$open;
    Object.defineProperty(fs2, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(fs2, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs2, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs2, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: !0,
      configurable: !0
    });
    function ReadStream(path, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else
          that.fd = fd, that.emit("open", fd), that.read();
      });
    }
    function WriteStream(path, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err)
          that.destroy(), that.emit("error", err);
        else
          that.fd = fd, that.emit("open", fd);
      });
    }
    function createReadStream(path, options) {
      return new fs2.ReadStream(path, options);
    }
    function createWriteStream(path, options) {
      return new fs2.WriteStream(path, options);
    }
    var fs$open = fs2.open;
    fs2.open = open;
    function open(path, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path, flags, mode, cb);
      function go$open(path2, flags2, mode2, cb2, startTime) {
        return fs$open(path2, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        });
      }
    }
    return fs2;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]), fs[gracefulQueue].push(elem), retry();
  }
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0;i < fs[gracefulQueue].length; ++i)
      if (fs[gracefulQueue][i].length > 2)
        fs[gracefulQueue][i][3] = now, fs[gracefulQueue][i][4] = now;
    retry();
  }
  function retry() {
    if (clearTimeout(retryTimer), retryTimer = void 0, fs[gracefulQueue].length === 0)
      return;
    var elem = fs[gracefulQueue].shift(), fn = elem[0], args = elem[1], err = elem[2], startTime = elem[3], lastTime = elem[4];
    if (startTime === void 0)
      debug("RETRY", fn.name, args), fn.apply(null, args);
    else if (Date.now() - startTime >= 60000) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime, sinceStart = Math.max(lastTime - startTime, 1), desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay)
        debug("RETRY", fn.name, args), fn.apply(null, args.concat([startTime]));
      else
        fs[gracefulQueue].push(elem);
    }
    if (retryTimer === void 0)
      retryTimer = setTimeout(retry, 0);
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS((exports, module) => {
  var isStream = (stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  isStream.writable = (stream) => isStream(stream) && stream.writable !== !1 && typeof stream._write === "function" && typeof stream._writableState === "object";
  isStream.readable = (stream) => isStream(stream) && stream.readable !== !1 && typeof stream._read === "function" && typeof stream._readableState === "object";
  isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
  isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
  module.exports = isStream;
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS((exports, module) => {
  if (typeof process > "u" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0)
    module.exports = { nextTick };
  else
    module.exports = process;
  function nextTick(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function")
      throw TypeError('"callback" argument must be a function');
    var len = arguments.length, args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = Array(len - 1), i = 0;
        while (i < args.length)
          args[i++] = arguments[i];
        return process.nextTick(function() {
          fn.apply(null, args);
        });
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS((exports, module) => {
  var toString = {}.toString;
  module.exports = Array.isArray || function(arr) {
    return toString.call(arr) == "[object Array]";
  };
});

// node_modules/lazystream/node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  var buffer = __require("buffer"), Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src)
      dst[key] = src[key];
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow)
    module.exports = buffer;
  else
    copyProps(buffer, exports), exports.Buffer = SafeBuffer;
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number")
      throw TypeError("Argument must not be a number");
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number")
      throw TypeError("Argument must be a number");
    var buf = Buffer2(size);
    if (fill !== void 0)
      if (typeof encoding === "string")
        buf.fill(fill, encoding);
      else
        buf.fill(fill);
    else
      buf.fill(0);
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number")
      throw TypeError("Argument must be a number");
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number")
      throw TypeError("Argument must be a number");
    return buffer.SlowBuffer(size);
  };
});

// node_modules/core-util-is/lib/util.js
var require_util10 = __commonJS((exports) => {
  function isArray(arg) {
    if (Array.isArray)
      return Array.isArray(arg);
    return objectToString(arg) === "[object Array]";
  }
  exports.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports.isUndefined = isUndefined;
  function isRegExp(re) {
    return objectToString(re) === "[object RegExp]";
  }
  exports.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports.isObject = isObject;
  function isDate(d) {
    return objectToString(d) === "[object Date]";
  }
  exports.isDate = isDate;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  exports.isError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg > "u";
  }
  exports.isPrimitive = isPrimitive;
  exports.isBuffer = __require("buffer").Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function")
    module.exports = function(ctor, superCtor) {
      if (superCtor)
        ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        });
    };
  else
    module.exports = function(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
      }
    };
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports, module) => {
  try {
    if (util = __require("util"), typeof util.inherits !== "function")
      throw "";
    module.exports = util.inherits;
  } catch (e) {
    module.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS((exports, module) => {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor))
      throw TypeError("Cannot call a class as a function");
  }
  var Buffer2 = require_safe_buffer().Buffer, util = __require("util");
  function copyBuffer(src, target, offset) {
    src.copy(target, offset);
  }
  module.exports = function() {
    function BufferList() {
      _classCallCheck(this, BufferList), this.head = null, this.tail = null, this.length = 0;
    }
    return BufferList.prototype.push = function(v) {
      var entry = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry, ++this.length;
    }, BufferList.prototype.unshift = function(v) {
      var entry = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry, ++this.length;
    }, BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      return --this.length, ret;
    }, BufferList.prototype.clear = function() {
      this.head = this.tail = null, this.length = 0;
    }, BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head, ret = "" + p.data;
      while (p = p.next)
        ret += s + p.data;
      return ret;
    }, BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      var ret = Buffer2.allocUnsafe(n >>> 0), p = this.head, i = 0;
      while (p)
        copyBuffer(p.data, ret, i), i += p.data.length, p = p.next;
      return ret;
    }, BufferList;
  }();
  if (util && util.inspect && util.inspect.custom)
    module.exports.prototype[util.inspect.custom] = function() {
      var obj = util.inspect({ length: this.length });
      return this.constructor.name + " " + obj;
    };
});

// node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  function destroy(err, cb) {
    var _this = this, readableDestroyed = this._readableState && this._readableState.destroyed, writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb)
        cb(err);
      else if (err) {
        if (!this._writableState)
          pna.nextTick(emitErrorNT, this, err);
        else if (!this._writableState.errorEmitted)
          this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, this, err);
      }
      return this;
    }
    if (this._readableState)
      this._readableState.destroyed = !0;
    if (this._writableState)
      this._writableState.destroyed = !0;
    return this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState)
          pna.nextTick(emitErrorNT, _this, err2);
        else if (!_this._writableState.errorEmitted)
          _this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, _this, err2);
      } else if (cb)
        cb(err2);
    }), this;
  }
  function undestroy() {
    if (this._readableState)
      this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1;
    if (this._writableState)
      this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1;
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  module.exports = {
    destroy,
    undestroy
  };
});

// node_modules/util-deprecate/node.js
var require_node2 = __commonJS((exports, module) => {
  module.exports = __require("util").deprecate;
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js
var require__stream_writable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null, this.entry = null, this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var asyncWrite = ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick, Duplex;
  Writable.WritableState = WritableState;
  var util = Object.create(require_util10());
  util.inherits = require_inherits();
  var internalUtil = {
    deprecate: require_node2()
  }, Stream = __require("stream"), Buffer2 = require_safe_buffer().Buffer, OurUint8Array = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  util.inherits(Writable, Stream);
  function nop() {}
  function WritableState(options, stream) {
    Duplex = Duplex || require__stream_duplex(), options = options || {};
    var isDuplex = stream instanceof Duplex;
    if (this.objectMode = !!options.objectMode, isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    var { highWaterMark: hwm, writableHighWaterMark: writableHwm } = options, defaultHwm = this.objectMode ? 16 : 16384;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0))
      this.highWaterMark = writableHwm;
    else
      this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var noDecode = options.decodeStrings === !1;
    this.decodeStrings = !noDecode, this.defaultEncoding = options.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(er) {
      onwrite(stream, er);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function() {
    var current = this.bufferedRequest, out = [];
    while (current)
      out.push(current), current = current.next;
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {}
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function")
    realHasInstance = Function.prototype[Symbol.hasInstance], Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object) {
        if (realHasInstance.call(this, object))
          return !0;
        if (this !== Writable)
          return !1;
        return object && object._writableState instanceof WritableState;
      }
    });
  else
    realHasInstance = function(object) {
      return object instanceof this;
    };
  function Writable(options) {
    if (Duplex = Duplex || require__stream_duplex(), !realHasInstance.call(Writable, this) && !(this instanceof Duplex))
      return new Writable(options);
    if (this._writableState = new WritableState(options, this), this.writable = !0, options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream, cb) {
    var er = Error("write after end");
    stream.emit("error", er), pna.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var valid = !0, er = !1;
    if (chunk === null)
      er = TypeError("May not write null values to stream");
    else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode)
      er = TypeError("Invalid non-string/buffer chunk");
    if (er)
      stream.emit("error", er), pna.nextTick(cb, er), valid = !1;
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState, ret = !1, isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk))
      chunk = _uint8ArrayToBuffer(chunk);
    if (typeof encoding === "function")
      cb = encoding, encoding = null;
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ended)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb))
      state.pendingcb++, ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    return ret;
  };
  Writable.prototype.cork = function() {
    var state = this._writableState;
    state.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      if (state.corked--, !state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw TypeError("Unknown encoding: " + encoding);
    return this._writableState.defaultEncoding = encoding, this;
  };
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== !1 && typeof chunk === "string")
      chunk = Buffer2.from(chunk, encoding);
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk)
        isBuf = !0, encoding = "buffer", chunk = newChunk;
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = !0;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      if (state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      }, last)
        last.next = state.lastBufferedRequest;
      else
        state.bufferedRequest = state.lastBufferedRequest;
      state.bufferedRequestCount += 1;
    } else
      doWrite(stream, state, !1, len, chunk, encoding, cb);
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    if (state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = !1;
  }
  function onwriteError(stream, state, sync, er, cb) {
    if (--state.pendingcb, sync)
      pna.nextTick(cb, er), pna.nextTick(finishMaybe, stream, state), stream._writableState.errorEmitted = !0, stream.emit("error", er);
    else
      cb(er), stream._writableState.errorEmitted = !0, stream.emit("error", er), finishMaybe(stream, state);
  }
  function onwriteStateUpdate(state) {
    state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState, sync = state.sync, cb = state.writecb;
    if (onwriteStateUpdate(state), er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state);
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(stream, state);
      if (sync)
        asyncWrite(afterWrite, stream, state, finished, cb);
      else
        afterWrite(stream, state, finished, cb);
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--, cb(), finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain)
      state.needDrain = !1, stream.emit("drain");
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = !0;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount, buffer = Array(l), holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0, allBuffers = !0;
      while (entry) {
        if (buffer[count] = entry, !entry.isBuf)
          allBuffers = !1;
        entry = entry.next, count += 1;
      }
      if (buffer.allBuffers = allBuffers, doWrite(stream, state, !0, state.length, buffer, "", holder.finish), state.pendingcb++, state.lastBufferedRequest = null, holder.next)
        state.corkedRequestsFree = holder.next, holder.next = null;
      else
        state.corkedRequestsFree = new CorkedRequest(state);
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var { chunk, encoding, callback: cb } = entry, len = state.objectMode ? 1 : chunk.length;
        if (doWrite(stream, state, !1, len, chunk, encoding, cb), entry = entry.next, state.bufferedRequestCount--, state.writing)
          break;
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry, state.bufferProcessing = !1;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function")
      cb = chunk, chunk = null, encoding = null;
    else if (typeof encoding === "function")
      cb = encoding, encoding = null;
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked)
      state.corked = 1, this.uncork();
    if (!state.ending)
      endWritable(this, state, cb);
  };
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      if (state.pendingcb--, err)
        stream.emit("error", err);
      state.prefinished = !0, stream.emit("prefinish"), finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled)
      if (typeof stream._final === "function")
        state.pendingcb++, state.finalCalled = !0, pna.nextTick(callFinal, stream, state);
      else
        state.prefinished = !0, stream.emit("prefinish");
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      if (prefinish(stream, state), state.pendingcb === 0)
        state.finished = !0, stream.emit("finish");
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    if (state.ending = !0, finishMaybe(stream, state), cb)
      if (state.finished)
        pna.nextTick(cb);
      else
        stream.once("finish", cb);
    state.ended = !0, stream.writable = !1;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--, cb(err), entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0)
        return !1;
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState)
        return;
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end(), cb(err);
  };
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js
var require__stream_duplex = __commonJS((exports, module) => {
  var pna = require_process_nextick_args(), objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj)
      keys2.push(key);
    return keys2;
  };
  module.exports = Duplex;
  var util = Object.create(require_util10());
  util.inherits = require_inherits();
  var Readable = require__stream_readable(), Writable = require__stream_writable();
  util.inherits(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (v = 0;v < keys.length; v++)
      if (method = keys[v], !Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
  }
  var keys, method, v;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    if (Readable.call(this, options), Writable.call(this, options), options && options.readable === !1)
      this.readable = !1;
    if (options && options.writable === !1)
      this.writable = !1;
    if (this.allowHalfOpen = !0, options && options.allowHalfOpen === !1)
      this.allowHalfOpen = !1;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended)
      return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0)
        return !1;
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0)
        return;
      this._readableState.destroyed = value, this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null), this.end(), pna.nextTick(cb, err);
  };
});

// node_modules/lazystream/node_modules/readable-stream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports) => {
  var Buffer2 = require_safe_buffer().Buffer, isEncoding = Buffer2.isEncoding || function(encoding) {
    switch (encoding = "" + encoding, encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (!0)
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase(), retried = !0;
      }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text, this.end = utf16End, nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast, nb = 4;
        break;
      case "base64":
        this.text = base64Text, this.end = base64End, nb = 3;
        break;
      default:
        this.write = simpleWrite, this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r, i;
    if (this.lastNeed) {
      if (r = this.fillLast(buf), r === void 0)
        return "";
      i = this.lastNeed, this.lastNeed = 0;
    } else
      i = 0;
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length)
      return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    if (nb = utf8CheckByte(buf[j]), nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    if (nb = utf8CheckByte(buf[j]), nb >= 0) {
      if (nb > 0)
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128)
      return self2.lastNeed = 0, "";
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128)
        return self2.lastNeed = 1, "";
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128)
          return self2.lastNeed = 2, "";
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed, r = utf8CheckExtraBytes(this, buf, p);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= buf.length)
      return buf.copy(this.lastChar, p, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    buf.copy(this.lastChar, p, 0, buf.length), this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    return buf.copy(this.lastChar, 0, end), buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], r.slice(0, -1);
      }
      return r;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    if (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1)
      this.lastChar[0] = buf[buf.length - 1];
    else
      this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1];
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js
var require__stream_readable = __commonJS((exports, module) => {
  var pna = require_process_nextick_args();
  module.exports = Readable;
  var isArray = require_isarray(), Duplex;
  Readable.ReadableState = ReadableState;
  var EE = __require("events").EventEmitter, EElistenerCount = function(emitter, type) {
    return emitter.listeners(type).length;
  }, Stream = __require("stream"), Buffer2 = require_safe_buffer().Buffer, OurUint8Array = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {};
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util = Object.create(require_util10());
  util.inherits = require_inherits();
  var debugUtil = __require("util"), debug = void 0;
  if (debugUtil && debugUtil.debuglog)
    debug = debugUtil.debuglog("stream");
  else
    debug = function() {};
  var BufferList = require_BufferList(), destroyImpl = require_destroy(), StringDecoder;
  util.inherits(Readable, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream) {
    Duplex = Duplex || require__stream_duplex(), options = options || {};
    var isDuplex = stream instanceof Duplex;
    if (this.objectMode = !!options.objectMode, isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    var { highWaterMark: hwm, readableHighWaterMark: readableHwm } = options, defaultHwm = this.objectMode ? 16 : 16384;
    if (hwm || hwm === 0)
      this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0))
      this.highWaterMark = readableHwm;
    else
      this.highWaterMark = defaultHwm;
    if (this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new BufferList, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = options.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    if (Duplex = Duplex || require__stream_duplex(), !(this instanceof Readable))
      return new Readable(options);
    if (this._readableState = new ReadableState(options, this), this.readable = !0, options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0)
        return !1;
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState)
        return;
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    this.push(null), cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState, skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        if (encoding = encoding || state.defaultEncoding, encoding !== state.encoding)
          chunk = Buffer2.from(chunk, encoding), encoding = "";
        skipChunkCheck = !0;
      }
    } else
      skipChunkCheck = !0;
    return readableAddChunk(this, chunk, encoding, !1, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, !0, !1);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    var state = stream._readableState;
    if (chunk === null)
      state.reading = !1, onEofChunk(stream, state);
    else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er)
        stream.emit("error", er);
      else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype)
          chunk = _uint8ArrayToBuffer(chunk);
        if (addToFront)
          if (state.endEmitted)
            stream.emit("error", Error("stream.unshift() after end event"));
          else
            addChunk(stream, state, chunk, !0);
        else if (state.ended)
          stream.emit("error", Error("stream.push() after EOF"));
        else if (state.reading = !1, state.decoder && !encoding)
          if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)
            addChunk(stream, state, chunk, !1);
          else
            maybeReadMore(stream, state);
        else
          addChunk(stream, state, chunk, !1);
      } else if (!addToFront)
        state.reading = !1;
    }
    return needMoreData(state);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync)
      stream.emit("data", chunk), stream.read(0);
    else {
      if (state.length += state.objectMode ? 1 : chunk.length, addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode)
      er = TypeError("Invalid non-string/buffer chunk");
    return er;
  }
  function needMoreData(state) {
    return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    return this._readableState.decoder = new StringDecoder(enc), this._readableState.encoding = enc, this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM)
      n = MAX_HWM;
    else
      n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++;
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n)
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended)
      return state.needReadable = !0, 0;
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n), n = parseInt(n, 10);
    var state = this._readableState, nOrig = n;
    if (n !== 0)
      state.emittedReadable = !1;
    if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
      if (debug("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    if (n = howMuchToRead(n, state), n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    if (debug("need readable", doRead), state.length === 0 || state.length - n < state.highWaterMark)
      doRead = !0, debug("length less than watermark", doRead);
    if (state.ended || state.reading)
      doRead = !1, debug("reading or ended", doRead);
    else if (doRead) {
      if (debug("do read"), state.reading = !0, state.sync = !0, state.length === 0)
        state.needReadable = !0;
      if (this._read(state.highWaterMark), state.sync = !1, !state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null)
      state.needReadable = !0, n = 0;
    else
      state.length -= n;
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = !0;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length;
    }
    state.ended = !0, emitReadable(stream);
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    if (state.needReadable = !1, !state.emittedReadable)
      if (debug("emitReadable", state.flowing), state.emittedReadable = !0, state.sync)
        pna.nextTick(emitReadable_, stream);
      else
        emitReadable_(stream);
  }
  function emitReadable_(stream) {
    debug("emit readable"), stream.emit("readable"), flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore)
      state.readingMore = !0, pna.nextTick(maybeReadMore_, stream, state);
  }
  function maybeReadMore_(stream, state) {
    var len = state.length;
    while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark)
      if (debug("maybeReadMore read 0"), stream.read(0), len === state.length)
        break;
      else
        len = state.length;
    state.readingMore = !1;
  }
  Readable.prototype._read = function(n) {
    this.emit("error", Error("_read() is not implemented"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this, state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1, debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== !1) && dest !== process.stdout && dest !== process.stderr, endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      pna.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      if (debug("onunpipe"), readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === !1)
          unpipeInfo.hasUnpiped = !0, cleanup();
      }
    }
    function onend() {
      debug("onend"), dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = !1;
    function cleanup() {
      if (debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), dest.removeListener("drain", ondrain), dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), cleanedUp = !0, state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    var increasedAwaitDrain = !1;
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata"), increasedAwaitDrain = !1;
      var ret = dest.write(chunk);
      if (ret === !1 && !increasedAwaitDrain) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp)
          debug("false write response, pause", state.awaitDrain), state.awaitDrain++, increasedAwaitDrain = !0;
        src.pause();
      }
    }
    function onerror(er) {
      if (debug("onerror", er), unpipe(), dest.removeListener("error", onerror), EElistenerCount(dest, "error") === 0)
        dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish), unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish"), dest.removeListener("close", onclose), unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe"), src.unpipe(dest);
    }
    if (dest.emit("pipe", src), !state.flowing)
      debug("pipe resume"), src.resume();
    return dest;
  };
  function pipeOnDrain(src) {
    return function() {
      var state = src._readableState;
      if (debug("pipeOnDrain", state.awaitDrain), state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data"))
        state.flowing = !0, flow(src);
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState, unpipeInfo = { hasUnpiped: !1 };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      if (state.pipes = null, state.pipesCount = 0, state.flowing = !1, dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var { pipes: dests, pipesCount: len } = state;
      state.pipes = null, state.pipesCount = 0, state.flowing = !1;
      for (var i = 0;i < len; i++)
        dests[i].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    if (state.pipes.splice(index, 1), state.pipesCount -= 1, state.pipesCount === 1)
      state.pipes = state.pipes[0];
    return dest.emit("unpipe", this, unpipeInfo), this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== !1)
        this.resume();
    } else if (ev === "readable") {
      var state = this._readableState;
      if (!state.endEmitted && !state.readableListening) {
        if (state.readableListening = state.needReadable = !0, state.emittedReadable = !1, !state.reading)
          pna.nextTick(nReadingNextTick, this);
        else if (state.length)
          emitReadable(this);
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0"), self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing)
      debug("resume"), state.flowing = !0, resume(this, state);
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled)
      state.resumeScheduled = !0, pna.nextTick(resume_, stream, state);
  }
  function resume_(stream, state) {
    if (!state.reading)
      debug("resume read 0"), stream.read(0);
    if (state.resumeScheduled = !1, state.awaitDrain = 0, stream.emit("resume"), flow(stream), state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    if (debug("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1)
      debug("pause"), this._readableState.flowing = !1, this.emit("pause");
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this, state = this._readableState, paused = !1;
    stream.on("end", function() {
      if (debug("wrapped end"), state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    }), stream.on("data", function(chunk) {
      if (debug("wrapped data"), state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret)
        paused = !0, stream.pause();
    });
    for (var i in stream)
      if (this[i] === void 0 && typeof stream[i] === "function")
        this[i] = function(method) {
          return function() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
    for (var n = 0;n < kProxyEvents.length; n++)
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    return this._read = function(n2) {
      if (debug("wrapped _read", n2), paused)
        paused = !1, stream.resume();
    }, this;
  };
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.head.data;
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else
      ret = fromListPartial(n, state.buffer, state.decoder);
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length)
      ret = list.head.data.slice(0, n), list.head.data = list.head.data.slice(n);
    else if (n === list.head.data.length)
      ret = list.shift();
    else
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head, c = 1, ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data, nb = n > str.length ? str.length : n;
      if (nb === str.length)
        ret += str;
      else
        ret += str.slice(0, n);
      if (n -= nb, n === 0) {
        if (nb === str.length)
          if (++c, p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        else
          list.head = p, p.data = str.slice(nb);
        break;
      }
      ++c;
    }
    return list.length -= c, ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n), p = list.head, c = 1;
    p.data.copy(ret), n -= p.data.length;
    while (p = p.next) {
      var buf = p.data, nb = n > buf.length ? buf.length : n;
      if (buf.copy(ret, ret.length - n, 0, nb), n -= nb, n === 0) {
        if (nb === buf.length)
          if (++c, p.next)
            list.head = p.next;
          else
            list.head = list.tail = null;
        else
          list.head = p, p.data = buf.slice(nb);
        break;
      }
      ++c;
    }
    return list.length -= c, ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    if (state.length > 0)
      throw Error('"endReadable()" called on non-empty stream');
    if (!state.endEmitted)
      state.ended = !0, pna.nextTick(endReadableNT, state, stream);
  }
  function endReadableNT(state, stream) {
    if (!state.endEmitted && state.length === 0)
      state.endEmitted = !0, stream.readable = !1, stream.emit("end");
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length;i < l; i++)
      if (xs[i] === x)
        return i;
    return -1;
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js
var require__stream_transform = __commonJS((exports, module) => {
  module.exports = Transform;
  var Duplex = require__stream_duplex(), util = Object.create(require_util10());
  util.inherits = require_inherits();
  util.inherits(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = !1;
    var cb = ts.writecb;
    if (!cb)
      return this.emit("error", Error("write callback called multiple times"));
    if (ts.writechunk = null, ts.writecb = null, data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    if (rs.reading = !1, rs.needReadable || rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    if (Duplex.call(this, options), this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function")
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    else
      done(this, null, null);
  }
  Transform.prototype.push = function(chunk, encoding) {
    return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    if (ts.writecb = cb, ts.writechunk = chunk, ts.writeencoding = encoding, !ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming)
      ts.transforming = !0, this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    else
      ts.needTransform = !0;
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2), _this2.emit("close");
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw Error("Calling transform done when ws.length != 0");
    if (stream._transformState.transforming)
      throw Error("Calling transform done when still transforming");
    return stream.push(null);
  }
});

// node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js
var require__stream_passthrough = __commonJS((exports, module) => {
  module.exports = PassThrough;
  var Transform = require__stream_transform(), util = Object.create(require_util10());
  util.inherits = require_inherits();
  util.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/lazystream/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (process.env.READABLE_STREAM === "disable" && Stream)
    module.exports = Stream, exports = module.exports = Stream.Readable, exports.Readable = Stream.Readable, exports.Writable = Stream.Writable, exports.Duplex = Stream.Duplex, exports.Transform = Stream.Transform, exports.PassThrough = Stream.PassThrough, exports.Stream = Stream;
  else
    exports = module.exports = require__stream_readable(), exports.Stream = Stream || exports, exports.Readable = exports, exports.Writable = require__stream_writable(), exports.Duplex = require__stream_duplex(), exports.Transform = require__stream_transform(), exports.PassThrough = require__stream_passthrough();
});

// node_modules/lazystream/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS((exports, module) => {
  module.exports = require_readable2().PassThrough;
});

// node_modules/lazystream/lib/lazystream.js
var require_lazystream = __commonJS((exports, module) => {
  var util = __require("util"), PassThrough = require_passthrough();
  module.exports = {
    Readable,
    Writable
  };
  util.inherits(Readable, PassThrough);
  util.inherits(Writable, PassThrough);
  function beforeFirstCall(instance, method, callback) {
    instance[method] = function() {
      return delete instance[method], callback.apply(this, arguments), this[method].apply(this, arguments);
    };
  }
  function Readable(fn, options) {
    if (!(this instanceof Readable))
      return new Readable(fn, options);
    PassThrough.call(this, options), beforeFirstCall(this, "_read", function() {
      var source = fn.call(this, options), emit = this.emit.bind(this, "error");
      source.on("error", emit), source.pipe(this);
    }), this.emit("readable");
  }
  function Writable(fn, options) {
    if (!(this instanceof Writable))
      return new Writable(fn, options);
    PassThrough.call(this, options), beforeFirstCall(this, "_write", function() {
      var destination = fn.call(this, options), emit = this.emit.bind(this, "error");
      destination.on("error", emit), this.pipe(destination);
    }), this.emit("writable");
  }
});

// node_modules/normalize-path/index.js
var require_normalize_path = __commonJS((exports, module) => {
  /*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  module.exports = function(path, stripTrailing) {
    if (typeof path !== "string")
      throw TypeError("expected path to be a string");
    if (path === "\\" || path === "/")
      return "/";
    var len = path.length;
    if (len <= 1)
      return path;
    var prefix = "";
    if (len > 4 && path[3] === "\\") {
      var ch = path[2];
      if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\")
        path = path.slice(2), prefix = "//";
    }
    var segs = path.split(/[/\\]+/);
    if (stripTrailing !== !1 && segs[segs.length - 1] === "")
      segs.pop();
    return prefix + segs.join("/");
  };
});

// node_modules/lodash/identity.js
var require_identity = __commonJS((exports, module) => {
  function identity(value) {
    return value;
  }
  module.exports = identity;
});

// node_modules/lodash/_apply.js
var require__apply = __commonJS((exports, module) => {
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  module.exports = apply;
});

// node_modules/lodash/_overRest.js
var require__overRest = __commonJS((exports, module) => {
  var apply = require__apply(), nativeMax = Math.max;
  function overRest(func, start, transform) {
    return start = nativeMax(start === void 0 ? func.length - 1 : start, 0), function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length)
        array[index] = args[start + index];
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start)
        otherArgs[index] = args[index];
      return otherArgs[start] = transform(array), apply(func, this, otherArgs);
    };
  }
  module.exports = overRest;
});

// node_modules/lodash/constant.js
var require_constant = __commonJS((exports, module) => {
  function constant(value) {
    return function() {
      return value;
    };
  }
  module.exports = constant;
});

// node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal(), freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root(), Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, nativeObjectToString = objectProto.toString, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = !0;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked)
      if (isOwn)
        value[symToStringTag] = tag;
      else
        delete value[symToStringTag];
    return result;
  }
  module.exports = getRawTag;
});

// node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  var objectProto = Object.prototype, nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  module.exports = objectToString;
});

// node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol(), getRawTag = require__getRawTag(), objectToString = require__objectToString(), nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null)
      return value === void 0 ? undefinedTag : nullTag;
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  module.exports = baseGetTag;
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  module.exports = isObject;
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag(), isObject = require_isObject(), asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value))
      return !1;
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  module.exports = isFunction;
});

// node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root(), coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  var coreJsData = require__coreJsData(), maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  module.exports = isMasked;
});

// node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  var funcProto = Function.prototype, funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }
  module.exports = toSource;
});

// node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  var isFunction = require_isFunction(), isMasked = require__isMasked(), isObject = require_isObject(), toSource = require__toSource(), reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value))
      return !1;
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  module.exports = baseIsNative;
});

// node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  module.exports = getValue;
});

// node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  var baseIsNative = require__baseIsNative(), getValue = require__getValue();
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  module.exports = getNative;
});

// node_modules/lodash/_defineProperty.js
var require__defineProperty = __commonJS((exports, module) => {
  var getNative = require__getNative(), defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      return func({}, "", {}), func;
    } catch (e) {}
  }();
  module.exports = defineProperty;
});

// node_modules/lodash/_baseSetToString.js
var require__baseSetToString = __commonJS((exports, module) => {
  var constant = require_constant(), defineProperty = require__defineProperty(), identity = require_identity(), baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, "toString", {
      configurable: !0,
      enumerable: !1,
      value: constant(string),
      writable: !0
    });
  };
  module.exports = baseSetToString;
});

// node_modules/lodash/_shortOut.js
var require__shortOut = __commonJS((exports, module) => {
  var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      if (lastCalled = stamp, remaining > 0) {
        if (++count >= HOT_COUNT)
          return arguments[0];
      } else
        count = 0;
      return func.apply(void 0, arguments);
    };
  }
  module.exports = shortOut;
});

// node_modules/lodash/_setToString.js
var require__setToString = __commonJS((exports, module) => {
  var baseSetToString = require__baseSetToString(), shortOut = require__shortOut(), setToString = shortOut(baseSetToString);
  module.exports = setToString;
});

// node_modules/lodash/_baseRest.js
var require__baseRest = __commonJS((exports, module) => {
  var identity = require_identity(), overRest = require__overRest(), setToString = require__setToString();
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  module.exports = baseRest;
});

// node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  module.exports = eq;
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS((exports, module) => {
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  module.exports = isLength;
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS((exports, module) => {
  var isFunction = require_isFunction(), isLength = require_isLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  module.exports = isArrayLike;
});

// node_modules/lodash/_isIndex.js
var require__isIndex = __commonJS((exports, module) => {
  var MAX_SAFE_INTEGER = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length) {
    var type = typeof value;
    return length = length == null ? MAX_SAFE_INTEGER : length, !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  module.exports = isIndex;
});

// node_modules/lodash/_isIterateeCall.js
var require__isIterateeCall = __commonJS((exports, module) => {
  var eq = require_eq(), isArrayLike = require_isArrayLike(), isIndex = require__isIndex(), isObject = require_isObject();
  function isIterateeCall(value, index, object) {
    if (!isObject(object))
      return !1;
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object))
      return eq(object[index], value);
    return !1;
  }
  module.exports = isIterateeCall;
});

// node_modules/lodash/_baseTimes.js
var require__baseTimes = __commonJS((exports, module) => {
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n)
      result[index] = iteratee(index);
    return result;
  }
  module.exports = baseTimes;
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  module.exports = isObjectLike;
});

// node_modules/lodash/_baseIsArguments.js
var require__baseIsArguments = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag(), isObjectLike = require_isObjectLike(), argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  module.exports = baseIsArguments;
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS((exports, module) => {
  var baseIsArguments = require__baseIsArguments(), isObjectLike = require_isObjectLike(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, propertyIsEnumerable = objectProto.propertyIsEnumerable, isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  module.exports = isArguments;
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS((exports, module) => {
  function stubFalse() {
    return !1;
  }
  module.exports = stubFalse;
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS((exports, module) => {
  var root = require__root(), stubFalse = require_stubFalse(), freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer2 = moduleExports ? root.Buffer : void 0, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, isBuffer = nativeIsBuffer || stubFalse;
  module.exports = isBuffer;
});

// node_modules/lodash/_baseIsTypedArray.js
var require__baseIsTypedArray = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag(), isLength = require_isLength(), isObjectLike = require_isObjectLike(), argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  module.exports = baseIsTypedArray;
});

// node_modules/lodash/_baseUnary.js
var require__baseUnary = __commonJS((exports, module) => {
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  module.exports = baseUnary;
});

// node_modules/lodash/_nodeUtil.js
var require__nodeUtil = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal(), freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types)
        return types;
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {}
  }();
  module.exports = nodeUtil;
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS((exports, module) => {
  var baseIsTypedArray = require__baseIsTypedArray(), baseUnary = require__baseUnary(), nodeUtil = require__nodeUtil(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  module.exports = isTypedArray;
});

// node_modules/lodash/_arrayLikeKeys.js
var require__arrayLikeKeys = __commonJS((exports, module) => {
  var baseTimes = require__baseTimes(), isArguments = require_isArguments(), isArray = require_isArray(), isBuffer = require_isBuffer(), isIndex = require__isIndex(), isTypedArray = require_isTypedArray(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value)
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length))))
        result.push(key);
    return result;
  }
  module.exports = arrayLikeKeys;
});

// node_modules/lodash/_isPrototype.js
var require__isPrototype = __commonJS((exports, module) => {
  var objectProto = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  module.exports = isPrototype;
});

// node_modules/lodash/_nativeKeysIn.js
var require__nativeKeysIn = __commonJS((exports, module) => {
  function nativeKeysIn(object) {
    var result = [];
    if (object != null)
      for (var key in Object(object))
        result.push(key);
    return result;
  }
  module.exports = nativeKeysIn;
});

// node_modules/lodash/_baseKeysIn.js
var require__baseKeysIn = __commonJS((exports, module) => {
  var isObject = require_isObject(), isPrototype = require__isPrototype(), nativeKeysIn = require__nativeKeysIn(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeysIn(object) {
    if (!isObject(object))
      return nativeKeysIn(object);
    var isProto = isPrototype(object), result = [];
    for (var key in object)
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key))))
        result.push(key);
    return result;
  }
  module.exports = baseKeysIn;
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS((exports, module) => {
  var arrayLikeKeys = require__arrayLikeKeys(), baseKeysIn = require__baseKeysIn(), isArrayLike = require_isArrayLike();
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
  }
  module.exports = keysIn;
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS((exports, module) => {
  var baseRest = require__baseRest(), eq = require_eq(), isIterateeCall = require__isIterateeCall(), keysIn = require_keysIn(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty, defaults = baseRest(function(object, sources) {
    object = Object(object);
    var index = -1, length = sources.length, guard = length > 2 ? sources[2] : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard))
      length = 1;
    while (++index < length) {
      var source = sources[index], props = keysIn(source), propsIndex = -1, propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex], value = object[key];
        if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))
          object[key] = source[key];
      }
    }
    return object;
  });
  module.exports = defaults;
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS((exports, module) => {
  module.exports = {
    ArrayIsArray(self2) {
      return Array.isArray(self2);
    },
    ArrayPrototypeIncludes(self2, el) {
      return self2.includes(el);
    },
    ArrayPrototypeIndexOf(self2, el) {
      return self2.indexOf(el);
    },
    ArrayPrototypeJoin(self2, sep) {
      return self2.join(sep);
    },
    ArrayPrototypeMap(self2, fn) {
      return self2.map(fn);
    },
    ArrayPrototypePop(self2, el) {
      return self2.pop(el);
    },
    ArrayPrototypePush(self2, el) {
      return self2.push(el);
    },
    ArrayPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    Error,
    FunctionPrototypeCall(fn, thisArgs, ...args) {
      return fn.call(thisArgs, ...args);
    },
    FunctionPrototypeSymbolHasInstance(self2, instance) {
      return Function.prototype[Symbol.hasInstance].call(self2, instance);
    },
    MathFloor: Math.floor,
    Number,
    NumberIsInteger: Number.isInteger,
    NumberIsNaN: Number.isNaN,
    NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
    NumberParseInt: Number.parseInt,
    ObjectDefineProperties(self2, props) {
      return Object.defineProperties(self2, props);
    },
    ObjectDefineProperty(self2, name, prop) {
      return Object.defineProperty(self2, name, prop);
    },
    ObjectGetOwnPropertyDescriptor(self2, name) {
      return Object.getOwnPropertyDescriptor(self2, name);
    },
    ObjectKeys(obj) {
      return Object.keys(obj);
    },
    ObjectSetPrototypeOf(target, proto) {
      return Object.setPrototypeOf(target, proto);
    },
    Promise,
    PromisePrototypeCatch(self2, fn) {
      return self2.catch(fn);
    },
    PromisePrototypeThen(self2, thenFn, catchFn) {
      return self2.then(thenFn, catchFn);
    },
    PromiseReject(err) {
      return Promise.reject(err);
    },
    PromiseResolve(val) {
      return Promise.resolve(val);
    },
    ReflectApply: Reflect.apply,
    RegExpPrototypeTest(self2, value) {
      return self2.test(value);
    },
    SafeSet: Set,
    String,
    StringPrototypeSlice(self2, start, end) {
      return self2.slice(start, end);
    },
    StringPrototypeToLowerCase(self2) {
      return self2.toLowerCase();
    },
    StringPrototypeToUpperCase(self2) {
      return self2.toUpperCase();
    },
    StringPrototypeTrim(self2) {
      return self2.trim();
    },
    Symbol,
    SymbolFor: Symbol.for,
    SymbolAsyncIterator: Symbol.asyncIterator,
    SymbolHasInstance: Symbol.hasInstance,
    SymbolIterator: Symbol.iterator,
    SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
    SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
    TypedArrayPrototypeSet(self2, buf, len) {
      return self2.set(buf, len);
    },
    Boolean,
    Uint8Array
  };
});

// node_modules/event-target-shim/dist/event-target-shim.js
var require_event_target_shim = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var privateData = /* @__PURE__ */ new WeakMap, wrappers = /* @__PURE__ */ new WeakMap;
  function pd(event) {
    let retv = privateData.get(event);
    return console.assert(retv != null, "'this' is expected an Event object, but got", event), retv;
  }
  function setCancelFlag(data) {
    if (data.passiveListener != null) {
      if (typeof console < "u" && typeof console.error === "function")
        console.error("Unable to preventDefault inside passive event listener invocation.", data.passiveListener);
      return;
    }
    if (!data.event.cancelable)
      return;
    if (data.canceled = !0, typeof data.event.preventDefault === "function")
      data.event.preventDefault();
  }
  function Event2(eventTarget, event) {
    privateData.set(this, {
      eventTarget,
      event,
      eventPhase: 2,
      currentTarget: eventTarget,
      canceled: !1,
      stopped: !1,
      immediateStopped: !1,
      passiveListener: null,
      timeStamp: event.timeStamp || Date.now()
    }), Object.defineProperty(this, "isTrusted", { value: !1, enumerable: !0 });
    let keys = Object.keys(event);
    for (let i = 0;i < keys.length; ++i) {
      let key = keys[i];
      if (!(key in this))
        Object.defineProperty(this, key, defineRedirectDescriptor(key));
    }
  }
  Event2.prototype = {
    get type() {
      return pd(this).event.type;
    },
    get target() {
      return pd(this).eventTarget;
    },
    get currentTarget() {
      return pd(this).currentTarget;
    },
    composedPath() {
      let currentTarget = pd(this).currentTarget;
      if (currentTarget == null)
        return [];
      return [currentTarget];
    },
    get NONE() {
      return 0;
    },
    get CAPTURING_PHASE() {
      return 1;
    },
    get AT_TARGET() {
      return 2;
    },
    get BUBBLING_PHASE() {
      return 3;
    },
    get eventPhase() {
      return pd(this).eventPhase;
    },
    stopPropagation() {
      let data = pd(this);
      if (data.stopped = !0, typeof data.event.stopPropagation === "function")
        data.event.stopPropagation();
    },
    stopImmediatePropagation() {
      let data = pd(this);
      if (data.stopped = !0, data.immediateStopped = !0, typeof data.event.stopImmediatePropagation === "function")
        data.event.stopImmediatePropagation();
    },
    get bubbles() {
      return Boolean(pd(this).event.bubbles);
    },
    get cancelable() {
      return Boolean(pd(this).event.cancelable);
    },
    preventDefault() {
      setCancelFlag(pd(this));
    },
    get defaultPrevented() {
      return pd(this).canceled;
    },
    get composed() {
      return Boolean(pd(this).event.composed);
    },
    get timeStamp() {
      return pd(this).timeStamp;
    },
    get srcElement() {
      return pd(this).eventTarget;
    },
    get cancelBubble() {
      return pd(this).stopped;
    },
    set cancelBubble(value) {
      if (!value)
        return;
      let data = pd(this);
      if (data.stopped = !0, typeof data.event.cancelBubble === "boolean")
        data.event.cancelBubble = !0;
    },
    get returnValue() {
      return !pd(this).canceled;
    },
    set returnValue(value) {
      if (!value)
        setCancelFlag(pd(this));
    },
    initEvent() {}
  };
  Object.defineProperty(Event2.prototype, "constructor", {
    value: Event2,
    configurable: !0,
    writable: !0
  });
  if (typeof window < "u" && typeof window.Event < "u")
    Object.setPrototypeOf(Event2.prototype, window.Event.prototype), wrappers.set(window.Event.prototype, Event2);
  function defineRedirectDescriptor(key) {
    return {
      get() {
        return pd(this).event[key];
      },
      set(value) {
        pd(this).event[key] = value;
      },
      configurable: !0,
      enumerable: !0
    };
  }
  function defineCallDescriptor(key) {
    return {
      value() {
        let event = pd(this).event;
        return event[key].apply(event, arguments);
      },
      configurable: !0,
      enumerable: !0
    };
  }
  function defineWrapper(BaseEvent, proto) {
    let keys = Object.keys(proto);
    if (keys.length === 0)
      return BaseEvent;
    function CustomEvent(eventTarget, event) {
      BaseEvent.call(this, eventTarget, event);
    }
    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
      constructor: { value: CustomEvent, configurable: !0, writable: !0 }
    });
    for (let i = 0;i < keys.length; ++i) {
      let key = keys[i];
      if (!(key in BaseEvent.prototype)) {
        let isFunc = typeof Object.getOwnPropertyDescriptor(proto, key).value === "function";
        Object.defineProperty(CustomEvent.prototype, key, isFunc ? defineCallDescriptor(key) : defineRedirectDescriptor(key));
      }
    }
    return CustomEvent;
  }
  function getWrapper(proto) {
    if (proto == null || proto === Object.prototype)
      return Event2;
    let wrapper = wrappers.get(proto);
    if (wrapper == null)
      wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto), wrappers.set(proto, wrapper);
    return wrapper;
  }
  function wrapEvent(eventTarget, event) {
    return new (getWrapper(Object.getPrototypeOf(event)))(eventTarget, event);
  }
  function isStopped(event) {
    return pd(event).immediateStopped;
  }
  function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
  }
  function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
  }
  function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
  }
  var listenersMap = /* @__PURE__ */ new WeakMap, CAPTURE = 1, BUBBLE = 2, ATTRIBUTE = 3;
  function isObject(x) {
    return x !== null && typeof x === "object";
  }
  function getListeners(eventTarget) {
    let listeners = listenersMap.get(eventTarget);
    if (listeners == null)
      throw TypeError("'this' is expected an EventTarget object, but got another value.");
    return listeners;
  }
  function defineEventAttributeDescriptor(eventName) {
    return {
      get() {
        let node = getListeners(this).get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            return node.listener;
          node = node.next;
        }
        return null;
      },
      set(listener) {
        if (typeof listener !== "function" && !isObject(listener))
          listener = null;
        let listeners = getListeners(this), prev = null, node = listeners.get(eventName);
        while (node != null) {
          if (node.listenerType === ATTRIBUTE)
            if (prev !== null)
              prev.next = node.next;
            else if (node.next !== null)
              listeners.set(eventName, node.next);
            else
              listeners.delete(eventName);
          else
            prev = node;
          node = node.next;
        }
        if (listener !== null) {
          let newNode = {
            listener,
            listenerType: ATTRIBUTE,
            passive: !1,
            once: !1,
            next: null
          };
          if (prev === null)
            listeners.set(eventName, newNode);
          else
            prev.next = newNode;
        }
      },
      configurable: !0,
      enumerable: !0
    };
  }
  function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(eventTargetPrototype, `on${eventName}`, defineEventAttributeDescriptor(eventName));
  }
  function defineCustomEventTarget(eventNames) {
    function CustomEventTarget() {
      EventTarget2.call(this);
    }
    CustomEventTarget.prototype = Object.create(EventTarget2.prototype, {
      constructor: {
        value: CustomEventTarget,
        configurable: !0,
        writable: !0
      }
    });
    for (let i = 0;i < eventNames.length; ++i)
      defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    return CustomEventTarget;
  }
  function EventTarget2() {
    if (this instanceof EventTarget2) {
      listenersMap.set(this, /* @__PURE__ */ new Map);
      return;
    }
    if (arguments.length === 1 && Array.isArray(arguments[0]))
      return defineCustomEventTarget(arguments[0]);
    if (arguments.length > 0) {
      let types = Array(arguments.length);
      for (let i = 0;i < arguments.length; ++i)
        types[i] = arguments[i];
      return defineCustomEventTarget(types);
    }
    throw TypeError("Cannot call a class as a function");
  }
  EventTarget2.prototype = {
    addEventListener(eventName, listener, options) {
      if (listener == null)
        return;
      if (typeof listener !== "function" && !isObject(listener))
        throw TypeError("'listener' should be a function or an object.");
      let listeners = getListeners(this), optionsIsObj = isObject(options), listenerType = (optionsIsObj ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, newNode = {
        listener,
        listenerType,
        passive: optionsIsObj && Boolean(options.passive),
        once: optionsIsObj && Boolean(options.once),
        next: null
      }, node = listeners.get(eventName);
      if (node === void 0) {
        listeners.set(eventName, newNode);
        return;
      }
      let prev = null;
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType)
          return;
        prev = node, node = node.next;
      }
      prev.next = newNode;
    },
    removeEventListener(eventName, listener, options) {
      if (listener == null)
        return;
      let listeners = getListeners(this), listenerType = (isObject(options) ? Boolean(options.capture) : Boolean(options)) ? CAPTURE : BUBBLE, prev = null, node = listeners.get(eventName);
      while (node != null) {
        if (node.listener === listener && node.listenerType === listenerType) {
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners.set(eventName, node.next);
          else
            listeners.delete(eventName);
          return;
        }
        prev = node, node = node.next;
      }
    },
    dispatchEvent(event) {
      if (event == null || typeof event.type !== "string")
        throw TypeError('"event.type" should be a string.');
      let listeners = getListeners(this), eventName = event.type, node = listeners.get(eventName);
      if (node == null)
        return !0;
      let wrappedEvent = wrapEvent(this, event), prev = null;
      while (node != null) {
        if (node.once)
          if (prev !== null)
            prev.next = node.next;
          else if (node.next !== null)
            listeners.set(eventName, node.next);
          else
            listeners.delete(eventName);
        else
          prev = node;
        if (setPassiveListener(wrappedEvent, node.passive ? node.listener : null), typeof node.listener === "function")
          try {
            node.listener.call(this, wrappedEvent);
          } catch (err) {
            if (typeof console < "u" && typeof console.error === "function")
              console.error(err);
          }
        else if (node.listenerType !== ATTRIBUTE && typeof node.listener.handleEvent === "function")
          node.listener.handleEvent(wrappedEvent);
        if (isStopped(wrappedEvent))
          break;
        node = node.next;
      }
      return setPassiveListener(wrappedEvent, null), setEventPhase(wrappedEvent, 0), setCurrentTarget(wrappedEvent, null), !wrappedEvent.defaultPrevented;
    }
  };
  Object.defineProperty(EventTarget2.prototype, "constructor", {
    value: EventTarget2,
    configurable: !0,
    writable: !0
  });
  if (typeof window < "u" && typeof window.EventTarget < "u")
    Object.setPrototypeOf(EventTarget2.prototype, window.EventTarget.prototype);
  exports.defineEventAttribute = defineEventAttribute;
  exports.EventTarget = EventTarget2;
  exports.default = EventTarget2;
  module.exports = EventTarget2;
  module.exports.EventTarget = module.exports.default = EventTarget2;
  module.exports.defineEventAttribute = defineEventAttribute;
});

// node_modules/abort-controller/dist/abort-controller.js
var require_abort_controller = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var eventTargetShim = require_event_target_shim();

  class AbortSignal2 extends eventTargetShim.EventTarget {
    constructor() {
      super();
      throw TypeError("AbortSignal cannot be constructed directly");
    }
    get aborted() {
      let aborted = abortedFlags.get(this);
      if (typeof aborted !== "boolean")
        throw TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
      return aborted;
    }
  }
  eventTargetShim.defineEventAttribute(AbortSignal2.prototype, "abort");
  function createAbortSignal() {
    let signal = Object.create(AbortSignal2.prototype);
    return eventTargetShim.EventTarget.call(signal), abortedFlags.set(signal, !1), signal;
  }
  function abortSignal(signal) {
    if (abortedFlags.get(signal) !== !1)
      return;
    abortedFlags.set(signal, !0), signal.dispatchEvent({ type: "abort" });
  }
  var abortedFlags = /* @__PURE__ */ new WeakMap;
  Object.defineProperties(AbortSignal2.prototype, {
    aborted: { enumerable: !0 }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
    Object.defineProperty(AbortSignal2.prototype, Symbol.toStringTag, {
      configurable: !0,
      value: "AbortSignal"
    });

  class AbortController2 {
    constructor() {
      signals.set(this, createAbortSignal());
    }
    get signal() {
      return getSignal(this);
    }
    abort() {
      abortSignal(getSignal(this));
    }
  }
  var signals = /* @__PURE__ */ new WeakMap;
  function getSignal(controller) {
    let signal = signals.get(controller);
    if (signal == null)
      throw TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    return signal;
  }
  Object.defineProperties(AbortController2.prototype, {
    signal: { enumerable: !0 },
    abort: { enumerable: !0 }
  });
  if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol")
    Object.defineProperty(AbortController2.prototype, Symbol.toStringTag, {
      configurable: !0,
      value: "AbortController"
    });
  exports.AbortController = AbortController2;
  exports.AbortSignal = AbortSignal2;
  exports.default = AbortController2;
  module.exports = AbortController2;
  module.exports.AbortController = module.exports.default = AbortController2;
  module.exports.AbortSignal = AbortSignal2;
});

// node_modules/readable-stream/lib/ours/util.js
var require_util11 = __commonJS((exports, module) => {
  var bufferModule = __require("buffer"), { kResistStopPropagation, SymbolDispose } = require_primordials(), AbortSignal2 = globalThis.AbortSignal || require_abort_controller().AbortSignal, AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, AsyncFunction = Object.getPrototypeOf(async function() {}).constructor, Blob2 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob2 < "u" ? function(b) {
    return b instanceof Blob2;
  } : function(b) {
    return !1;
  }, validateAbortSignal = (signal, name) => {
    if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
      throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
  }, validateFunction = (value, name) => {
    if (typeof value !== "function")
      throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
  };

  class AggregateError extends Error {
    constructor(errors) {
      if (!Array.isArray(errors))
        throw TypeError(`Expected input to be an Array, got ${typeof errors}`);
      let message = "";
      for (let i = 0;i < errors.length; i++)
        message += `    ${errors[i].stack}
`;
      super(message);
      this.name = "AggregateError", this.errors = errors;
    }
  }
  module.exports = {
    AggregateError,
    kEmptyObject: Object.freeze({}),
    once(callback) {
      let called = !1;
      return function(...args) {
        if (called)
          return;
        called = !0, callback.apply(this, args);
      };
    },
    createDeferredPromise: function() {
      let resolve, reject;
      return {
        promise: new Promise((res, rej) => {
          resolve = res, reject = rej;
        }),
        resolve,
        reject
      };
    },
    promisify(fn) {
      return new Promise((resolve, reject) => {
        fn((err, ...args) => {
          if (err)
            return reject(err);
          return resolve(...args);
        });
      });
    },
    debuglog() {
      return function() {};
    },
    format(format, ...args) {
      return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
        let replacement = args.shift();
        if (type === "f")
          return replacement.toFixed(6);
        else if (type === "j")
          return JSON.stringify(replacement);
        else if (type === "s" && typeof replacement === "object")
          return `${replacement.constructor !== Object ? replacement.constructor.name : ""} {}`.trim();
        else
          return replacement.toString();
      });
    },
    inspect(value) {
      switch (typeof value) {
        case "string":
          if (value.includes("'")) {
            if (!value.includes('"'))
              return `"${value}"`;
            else if (!value.includes("`") && !value.includes("${"))
              return `\`${value}\``;
          }
          return `'${value}'`;
        case "number":
          if (isNaN(value))
            return "NaN";
          else if (Object.is(value, -0))
            return String(value);
          return value;
        case "bigint":
          return `${String(value)}n`;
        case "boolean":
        case "undefined":
          return String(value);
        case "object":
          return "{}";
      }
    },
    types: {
      isAsyncFunction(fn) {
        return fn instanceof AsyncFunction;
      },
      isArrayBufferView(arr) {
        return ArrayBuffer.isView(arr);
      }
    },
    isBlob,
    deprecate(fn, message) {
      return fn;
    },
    addAbortListener: __require("events").addAbortListener || function(signal, listener) {
      if (signal === void 0)
        throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
      validateAbortSignal(signal, "signal"), validateFunction(listener, "listener");
      let removeEventListener;
      if (signal.aborted)
        queueMicrotask(() => listener());
      else
        signal.addEventListener("abort", listener, {
          __proto__: null,
          once: !0,
          [kResistStopPropagation]: !0
        }), removeEventListener = () => {
          signal.removeEventListener("abort", listener);
        };
      return {
        __proto__: null,
        [SymbolDispose]() {
          var _removeEventListener;
          (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 || _removeEventListener();
        }
      };
    },
    AbortSignalAny: AbortSignal2.any || function(signals) {
      if (signals.length === 1)
        return signals[0];
      let ac = new AbortController2, abort = () => ac.abort();
      return signals.forEach((signal) => {
        validateAbortSignal(signal, "signals"), signal.addEventListener("abort", abort, {
          once: !0
        });
      }), ac.signal.addEventListener("abort", () => {
        signals.forEach((signal) => signal.removeEventListener("abort", abort));
      }, {
        once: !0
      }), ac.signal;
    }
  };
  module.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors3 = __commonJS((exports, module) => {
  var { format, inspect, AggregateError: CustomAggregateError } = require_util11(), AggregateError = globalThis.AggregateError || CustomAggregateError, kIsNodeError = Symbol("kIsNodeError"), kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
  ], classRegExp = /^([A-Z][a-z0-9]*)+$/, codes = {};
  function assert(value, message) {
    if (!value)
      throw new codes.ERR_INTERNAL_ASSERTION(message);
  }
  function addNumericalSeparator(val) {
    let res = "", i = val.length, start = val[0] === "-" ? 1 : 0;
    for (;i >= start + 4; i -= 3)
      res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
  }
  function getMessage(key, msg, args) {
    if (typeof msg === "function")
      return assert(msg.length <= args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`), msg(...args);
    let expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
    if (assert(expectedLength === args.length, `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`), args.length === 0)
      return msg;
    return format(msg, ...args);
  }
  function E(code, message, Base) {
    if (!Base)
      Base = Error;

    class NodeError extends Base {
      constructor(...args) {
        super(getMessage(code, message, args));
      }
      toString() {
        return `${this.name} [${code}]: ${this.message}`;
      }
    }
    Object.defineProperties(NodeError.prototype, {
      name: {
        value: Base.name,
        writable: !0,
        enumerable: !1,
        configurable: !0
      },
      toString: {
        value() {
          return `${this.name} [${code}]: ${this.message}`;
        },
        writable: !0,
        enumerable: !1,
        configurable: !0
      }
    }), NodeError.prototype.code = code, NodeError.prototype[kIsNodeError] = !0, codes[code] = NodeError;
  }
  function hideStackFrames(fn) {
    let hidden = "__node_internal_" + fn.name;
    return Object.defineProperty(fn, "name", {
      value: hidden
    }), fn;
  }
  function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
      if (Array.isArray(outerError.errors))
        return outerError.errors.push(innerError), outerError;
      let err = new AggregateError([outerError, innerError], outerError.message);
      return err.code = outerError.code, err;
    }
    return innerError || outerError;
  }

  class AbortError extends Error {
    constructor(message = "The operation was aborted", options = void 0) {
      if (options !== void 0 && typeof options !== "object")
        throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
      super(message, options);
      this.code = "ABORT_ERR", this.name = "AbortError";
    }
  }
  E("ERR_ASSERTION", "%s", Error);
  E("ERR_INVALID_ARG_TYPE", (name, expected, actual) => {
    if (assert(typeof name === "string", "'name' must be a string"), !Array.isArray(expected))
      expected = [expected];
    let msg = "The ";
    if (name.endsWith(" argument"))
      msg += `${name} `;
    else
      msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
    msg += "must be ";
    let types = [], instances = [], other = [];
    for (let value of expected)
      if (assert(typeof value === "string", "All expected entries have to be of type string"), kTypes.includes(value))
        types.push(value.toLowerCase());
      else if (classRegExp.test(value))
        instances.push(value);
      else
        assert(value !== "object", 'The value "object" should be written as "Object"'), other.push(value);
    if (instances.length > 0) {
      let pos = types.indexOf("object");
      if (pos !== -1)
        types.splice(types, pos, 1), instances.push("Object");
    }
    if (types.length > 0) {
      switch (types.length) {
        case 1:
          msg += `of type ${types[0]}`;
          break;
        case 2:
          msg += `one of type ${types[0]} or ${types[1]}`;
          break;
        default: {
          let last = types.pop();
          msg += `one of type ${types.join(", ")}, or ${last}`;
        }
      }
      if (instances.length > 0 || other.length > 0)
        msg += " or ";
    }
    if (instances.length > 0) {
      switch (instances.length) {
        case 1:
          msg += `an instance of ${instances[0]}`;
          break;
        case 2:
          msg += `an instance of ${instances[0]} or ${instances[1]}`;
          break;
        default: {
          let last = instances.pop();
          msg += `an instance of ${instances.join(", ")}, or ${last}`;
        }
      }
      if (other.length > 0)
        msg += " or ";
    }
    switch (other.length) {
      case 0:
        break;
      case 1:
        if (other[0].toLowerCase() !== other[0])
          msg += "an ";
        msg += `${other[0]}`;
        break;
      case 2:
        msg += `one of ${other[0]} or ${other[1]}`;
        break;
      default: {
        let last = other.pop();
        msg += `one of ${other.join(", ")}, or ${last}`;
      }
    }
    if (actual == null)
      msg += `. Received ${actual}`;
    else if (typeof actual === "function" && actual.name)
      msg += `. Received function ${actual.name}`;
    else if (typeof actual === "object") {
      var _actual$constructor;
      if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name)
        msg += `. Received an instance of ${actual.constructor.name}`;
      else {
        let inspected = inspect(actual, {
          depth: -1
        });
        msg += `. Received ${inspected}`;
      }
    } else {
      let inspected = inspect(actual, {
        colors: !1
      });
      if (inspected.length > 25)
        inspected = `${inspected.slice(0, 25)}...`;
      msg += `. Received type ${typeof actual} (${inspected})`;
    }
    return msg;
  }, TypeError);
  E("ERR_INVALID_ARG_VALUE", (name, value, reason = "is invalid") => {
    let inspected = inspect(value);
    if (inspected.length > 128)
      inspected = inspected.slice(0, 128) + "...";
    return `The ${name.includes(".") ? "property" : "argument"} '${name}' ${reason}. Received ${inspected}`;
  }, TypeError);
  E("ERR_INVALID_RETURN_VALUE", (input, name, value) => {
    var _value$constructor;
    let type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
    return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
  }, TypeError);
  E("ERR_MISSING_ARGS", (...args) => {
    assert(args.length > 0, "At least one arg needs to be specified");
    let msg, len = args.length;
    switch (args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or "), len) {
      case 1:
        msg += `The ${args[0]} argument`;
        break;
      case 2:
        msg += `The ${args[0]} and ${args[1]} arguments`;
        break;
      default:
        {
          let last = args.pop();
          msg += `The ${args.join(", ")}, and ${last} arguments`;
        }
        break;
    }
    return `${msg} must be specified`;
  }, TypeError);
  E("ERR_OUT_OF_RANGE", (str, range, input) => {
    assert(range, 'Missing "range" argument');
    let received;
    if (Number.isInteger(input) && Math.abs(input) > 4294967296)
      received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
      if (received = String(input), input > 2n ** 32n || input < -(2n ** 32n))
        received = addNumericalSeparator(received);
      received += "n";
    } else
      received = inspect(input);
    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
  }, RangeError);
  E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
  E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
  E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
  E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
  E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
  E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
  E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
  E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
  E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
  E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
  module.exports = {
    AbortError,
    aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
    hideStackFrames,
    codes
  };
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS((exports, module) => {
  var {
    ArrayIsArray,
    ArrayPrototypeIncludes,
    ArrayPrototypeJoin,
    ArrayPrototypeMap,
    NumberIsInteger,
    NumberIsNaN,
    NumberMAX_SAFE_INTEGER,
    NumberMIN_SAFE_INTEGER,
    NumberParseInt,
    ObjectPrototypeHasOwnProperty,
    RegExpPrototypeExec,
    String: String2,
    StringPrototypeToUpperCase,
    StringPrototypeTrim
  } = require_primordials(), {
    hideStackFrames,
    codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
  } = require_errors3(), { normalizeEncoding } = require_util11(), { isAsyncFunction, isArrayBufferView } = require_util11().types, signals = {};
  function isInt32(value) {
    return value === (value | 0);
  }
  function isUint32(value) {
    return value === value >>> 0;
  }
  var octalReg = /^[0-7]+$/, modeDesc = "must be a 32-bit unsigned integer or an octal string";
  function parseFileMode(value, name, def) {
    if (typeof value > "u")
      value = def;
    if (typeof value === "string") {
      if (RegExpPrototypeExec(octalReg, value) === null)
        throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
      value = NumberParseInt(value, 8);
    }
    return validateUint32(value, name), value;
  }
  var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (!NumberIsInteger(value))
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    if (value < min || value > max)
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
  }), validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (!NumberIsInteger(value))
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    if (value < min || value > max)
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
  }), validateUint32 = hideStackFrames((value, name, positive = !1) => {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (!NumberIsInteger(value))
      throw new ERR_OUT_OF_RANGE(name, "an integer", value);
    let min = positive ? 1 : 0, max = 4294967295;
    if (value < min || value > max)
      throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
  });
  function validateString(value, name) {
    if (typeof value !== "string")
      throw new ERR_INVALID_ARG_TYPE2(name, "string", value);
  }
  function validateNumber(value, name, min = void 0, max) {
    if (typeof value !== "number")
      throw new ERR_INVALID_ARG_TYPE2(name, "number", value);
    if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value))
      throw new ERR_OUT_OF_RANGE(name, `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`, value);
  }
  var validateOneOf = hideStackFrames((value, name, oneOf) => {
    if (!ArrayPrototypeIncludes(oneOf, value)) {
      let reason = "must be one of: " + ArrayPrototypeJoin(ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)), ", ");
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateBoolean(value, name) {
    if (typeof value !== "boolean")
      throw new ERR_INVALID_ARG_TYPE2(name, "boolean", value);
  }
  function getOwnPropertyValueOrDefault(options, key, defaultValue) {
    return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
  }
  var validateObject = hideStackFrames((value, name, options = null) => {
    let allowArray = getOwnPropertyValueOrDefault(options, "allowArray", !1), allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", !1);
    if (!getOwnPropertyValueOrDefault(options, "nullable", !1) && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function"))
      throw new ERR_INVALID_ARG_TYPE2(name, "Object", value);
  }), validateDictionary = hideStackFrames((value, name) => {
    if (value != null && typeof value !== "object" && typeof value !== "function")
      throw new ERR_INVALID_ARG_TYPE2(name, "a dictionary", value);
  }), validateArray = hideStackFrames((value, name, minLength = 0) => {
    if (!ArrayIsArray(value))
      throw new ERR_INVALID_ARG_TYPE2(name, "Array", value);
    if (value.length < minLength) {
      let reason = `must be longer than ${minLength}`;
      throw new ERR_INVALID_ARG_VALUE(name, value, reason);
    }
  });
  function validateStringArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++)
      validateString(value[i], `${name}[${i}]`);
  }
  function validateBooleanArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++)
      validateBoolean(value[i], `${name}[${i}]`);
  }
  function validateAbortSignalArray(value, name) {
    validateArray(value, name);
    for (let i = 0;i < value.length; i++) {
      let signal = value[i], indexedName = `${name}[${i}]`;
      if (signal == null)
        throw new ERR_INVALID_ARG_TYPE2(indexedName, "AbortSignal", signal);
      validateAbortSignal(signal, indexedName);
    }
  }
  function validateSignalName(signal, name = "signal") {
    if (validateString(signal, name), signals[signal] === void 0) {
      if (signals[StringPrototypeToUpperCase(signal)] !== void 0)
        throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
      throw new ERR_UNKNOWN_SIGNAL(signal);
    }
  }
  var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
    if (!isArrayBufferView(buffer))
      throw new ERR_INVALID_ARG_TYPE2(name, ["Buffer", "TypedArray", "DataView"], buffer);
  });
  function validateEncoding(data, encoding) {
    let normalizedEncoding = normalizeEncoding(encoding), length = data.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0)
      throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
  }
  function validatePort(port, name = "Port", allowZero = !0) {
    if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero)
      throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
    return port | 0;
  }
  var validateAbortSignal = hideStackFrames((signal, name) => {
    if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal)))
      throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
  }), validateFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function")
      throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
  }), validatePlainFunction = hideStackFrames((value, name) => {
    if (typeof value !== "function" || isAsyncFunction(value))
      throw new ERR_INVALID_ARG_TYPE2(name, "Function", value);
  }), validateUndefined = hideStackFrames((value, name) => {
    if (value !== void 0)
      throw new ERR_INVALID_ARG_TYPE2(name, "undefined", value);
  });
  function validateUnion(value, name, union) {
    if (!ArrayPrototypeIncludes(union, value))
      throw new ERR_INVALID_ARG_TYPE2(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
  }
  var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
  function validateLinkHeaderFormat(value, name) {
    if (typeof value > "u" || !RegExpPrototypeExec(linkValueRegExp, value))
      throw new ERR_INVALID_ARG_VALUE(name, value, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
  }
  function validateLinkHeaderValue(hints) {
    if (typeof hints === "string")
      return validateLinkHeaderFormat(hints, "hints"), hints;
    else if (ArrayIsArray(hints)) {
      let hintsLength = hints.length, result = "";
      if (hintsLength === 0)
        return result;
      for (let i = 0;i < hintsLength; i++) {
        let link = hints[i];
        if (validateLinkHeaderFormat(link, "hints"), result += link, i !== hintsLength - 1)
          result += ", ";
      }
      return result;
    }
    throw new ERR_INVALID_ARG_VALUE("hints", hints, 'must be an array or string of format "</styles.css>; rel=preload; as=style"');
  }
  module.exports = {
    isInt32,
    isUint32,
    parseFileMode,
    validateArray,
    validateStringArray,
    validateBooleanArray,
    validateAbortSignalArray,
    validateBoolean,
    validateBuffer,
    validateDictionary,
    validateEncoding,
    validateFunction,
    validateInt32,
    validateInteger,
    validateNumber,
    validateObject,
    validateOneOf,
    validatePlainFunction,
    validatePort,
    validateSignalName,
    validateString,
    validateUint32,
    validateUndefined,
    validateUnion,
    validateAbortSignal,
    validateLinkHeaderValue
  };
});

// node_modules/process/index.js
var require_process = __commonJS((exports, module) => {
  module.exports = global.process;
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils5 = __commonJS((exports, module) => {
  var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials(), kIsDestroyed = SymbolFor("nodejs.stream.destroyed"), kIsErrored = SymbolFor("nodejs.stream.errored"), kIsReadable = SymbolFor("nodejs.stream.readable"), kIsWritable = SymbolFor("nodejs.stream.writable"), kIsDisturbed = SymbolFor("nodejs.stream.disturbed"), kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise"), kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
  function isReadableNodeStream(obj, strict = !1) {
    var _obj$_readableState;
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== !1) && (!obj._writableState || obj._readableState));
  }
  function isWritableNodeStream(obj) {
    var _obj$_writableState;
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== !1));
  }
  function isDuplexNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
  }
  function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
  }
  function isReadableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
  }
  function isWritableStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
  }
  function isTransformStream(obj) {
    return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
  }
  function isWebStream(obj) {
    return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
  }
  function isIterable(obj, isAsync) {
    if (obj == null)
      return !1;
    if (isAsync === !0)
      return typeof obj[SymbolAsyncIterator] === "function";
    if (isAsync === !1)
      return typeof obj[SymbolIterator] === "function";
    return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
  }
  function isDestroyed(stream) {
    if (!isNodeStream(stream))
      return null;
    let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
    return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
  }
  function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableEnded === !0)
      return !0;
    let wState = stream._writableState;
    if (wState !== null && wState !== void 0 && wState.errored)
      return !1;
    if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean")
      return null;
    return wState.ended;
  }
  function isWritableFinished(stream, strict) {
    if (!isWritableNodeStream(stream))
      return null;
    if (stream.writableFinished === !0)
      return !0;
    let wState = stream._writableState;
    if (wState !== null && wState !== void 0 && wState.errored)
      return !1;
    if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean")
      return null;
    return !!(wState.finished || strict === !1 && wState.ended === !0 && wState.length === 0);
  }
  function isReadableEnded(stream) {
    if (!isReadableNodeStream(stream))
      return null;
    if (stream.readableEnded === !0)
      return !0;
    let rState = stream._readableState;
    if (!rState || rState.errored)
      return !1;
    if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean")
      return null;
    return rState.ended;
  }
  function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream))
      return null;
    let rState = stream._readableState;
    if (rState !== null && rState !== void 0 && rState.errored)
      return !1;
    if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean")
      return null;
    return !!(rState.endEmitted || strict === !1 && rState.ended === !0 && rState.length === 0);
  }
  function isReadable(stream) {
    if (stream && stream[kIsReadable] != null)
      return stream[kIsReadable];
    if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return !1;
    return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
  }
  function isWritable(stream) {
    if (stream && stream[kIsWritable] != null)
      return stream[kIsWritable];
    if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean")
      return null;
    if (isDestroyed(stream))
      return !1;
    return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
  }
  function isFinished(stream, opts) {
    if (!isNodeStream(stream))
      return null;
    if (isDestroyed(stream))
      return !0;
    if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== !1 && isReadable(stream))
      return !1;
    if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== !1 && isWritable(stream))
      return !1;
    return !0;
  }
  function isWritableErrored(stream) {
    var _stream$_writableStat, _stream$_writableStat2;
    if (!isNodeStream(stream))
      return null;
    if (stream.writableErrored)
      return stream.writableErrored;
    return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
  }
  function isReadableErrored(stream) {
    var _stream$_readableStat, _stream$_readableStat2;
    if (!isNodeStream(stream))
      return null;
    if (stream.readableErrored)
      return stream.readableErrored;
    return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
  }
  function isClosed(stream) {
    if (!isNodeStream(stream))
      return null;
    if (typeof stream.closed === "boolean")
      return stream.closed;
    let { _writableState: wState, _readableState: rState } = stream;
    if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean")
      return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
    if (typeof stream._closed === "boolean" && isOutgoingMessage(stream))
      return stream._closed;
    return null;
  }
  function isOutgoingMessage(stream) {
    return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
  }
  function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
  }
  function isServerRequest(stream) {
    var _stream$req;
    return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
  }
  function willEmitClose(stream) {
    if (!isNodeStream(stream))
      return null;
    let { _writableState: wState, _readableState: rState } = stream, state = wState || rState;
    return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === !1);
  }
  function isDisturbed(stream) {
    var _stream$kIsDisturbed;
    return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
  }
  function isErrored(stream) {
    var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
    return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
  }
  module.exports = {
    isDestroyed,
    kIsDestroyed,
    isDisturbed,
    kIsDisturbed,
    isErrored,
    kIsErrored,
    isReadable,
    kIsReadable,
    kIsClosedPromise,
    kControllerErrorFunction,
    kIsWritable,
    isClosed,
    isDuplexNodeStream,
    isFinished,
    isIterable,
    isReadableNodeStream,
    isReadableStream,
    isReadableEnded,
    isReadableFinished,
    isReadableErrored,
    isNodeStream,
    isWebStream,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableEnded,
    isWritableFinished,
    isWritableErrored,
    isServerRequest,
    isServerResponse,
    willEmitClose,
    isTransformStream
  };
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports, module) => {
  var process2 = require_process(), { AbortError, codes } = require_errors3(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_PREMATURE_CLOSE } = codes, { kEmptyObject, once } = require_util11(), { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators(), { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials(), {
    isClosed,
    isReadable,
    isReadableNodeStream,
    isReadableStream,
    isReadableFinished,
    isReadableErrored,
    isWritable,
    isWritableNodeStream,
    isWritableStream,
    isWritableFinished,
    isWritableErrored,
    isNodeStream,
    willEmitClose: _willEmitClose,
    kIsClosedPromise
  } = require_utils5(), addAbortListener;
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  var nop = () => {};
  function eos(stream, options, callback) {
    var _options$readable, _options$writable;
    if (arguments.length === 2)
      callback = options, options = kEmptyObject;
    else if (options == null)
      options = kEmptyObject;
    else
      validateObject(options, "options");
    if (validateFunction(callback, "callback"), validateAbortSignal(options.signal, "options.signal"), callback = once(callback), isReadableStream(stream) || isWritableStream(stream))
      return eosWeb(stream, options, callback);
    if (!isNodeStream(stream))
      throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    let readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream), writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream), wState = stream._writableState, rState = stream._readableState, onlegacyfinish = () => {
      if (!stream.writable)
        onfinish();
    }, willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable, writableFinished = isWritableFinished(stream, !1), onfinish = () => {
      if (writableFinished = !0, stream.destroyed)
        willEmitClose = !1;
      if (willEmitClose && (!stream.readable || readable))
        return;
      if (!readable || readableFinished)
        callback.call(stream);
    }, readableFinished = isReadableFinished(stream, !1), onend = () => {
      if (readableFinished = !0, stream.destroyed)
        willEmitClose = !1;
      if (willEmitClose && (!stream.writable || writable))
        return;
      if (!writable || writableFinished)
        callback.call(stream);
    }, onerror = (err) => {
      callback.call(stream, err);
    }, closed = isClosed(stream), onclose = () => {
      closed = !0;
      let errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean")
        return callback.call(stream, errored);
      if (readable && !readableFinished && isReadableNodeStream(stream, !0)) {
        if (!isReadableFinished(stream, !1))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      if (writable && !writableFinished) {
        if (!isWritableFinished(stream, !1))
          return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE);
      }
      callback.call(stream);
    }, onclosed = () => {
      closed = !0;
      let errored = isWritableErrored(stream) || isReadableErrored(stream);
      if (errored && typeof errored !== "boolean")
        return callback.call(stream, errored);
      callback.call(stream);
    }, onrequest = () => {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      if (stream.on("complete", onfinish), !willEmitClose)
        stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !wState)
      stream.on("end", onlegacyfinish), stream.on("close", onlegacyfinish);
    if (!willEmitClose && typeof stream.aborted === "boolean")
      stream.on("aborted", onclose);
    if (stream.on("end", onend), stream.on("finish", onfinish), options.error !== !1)
      stream.on("error", onerror);
    if (stream.on("close", onclose), closed)
      process2.nextTick(onclose);
    else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
      if (!willEmitClose)
        process2.nextTick(onclosed);
    } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === !1))
      process2.nextTick(onclosed);
    else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === !1))
      process2.nextTick(onclosed);
    else if (rState && stream.req && stream.aborted)
      process2.nextTick(onclosed);
    let cleanup = () => {
      if (callback = nop, stream.removeListener("aborted", onclose), stream.removeListener("complete", onfinish), stream.removeListener("abort", onclose), stream.removeListener("request", onrequest), stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish), stream.removeListener("close", onlegacyfinish), stream.removeListener("finish", onfinish), stream.removeListener("end", onend), stream.removeListener("error", onerror), stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
      let abort = () => {
        let endCallback = callback;
        cleanup(), endCallback.call(stream, new AbortError(void 0, {
          cause: options.signal.reason
        }));
      };
      if (options.signal.aborted)
        process2.nextTick(abort);
      else {
        addAbortListener = addAbortListener || require_util11().addAbortListener;
        let disposable = addAbortListener(options.signal, abort), originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose](), originalCallback.apply(stream, args);
        });
      }
    }
    return cleanup;
  }
  function eosWeb(stream, options, callback) {
    let isAborted = !1, abort = nop;
    if (options.signal)
      if (abort = () => {
        isAborted = !0, callback.call(stream, new AbortError(void 0, {
          cause: options.signal.reason
        }));
      }, options.signal.aborted)
        process2.nextTick(abort);
      else {
        addAbortListener = addAbortListener || require_util11().addAbortListener;
        let disposable = addAbortListener(options.signal, abort), originalCallback = callback;
        callback = once((...args) => {
          disposable[SymbolDispose](), originalCallback.apply(stream, args);
        });
      }
    let resolverFn = (...args) => {
      if (!isAborted)
        process2.nextTick(() => callback.apply(stream, args));
    };
    return PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn), nop;
  }
  function finished(stream, opts) {
    var _opts;
    let autoCleanup = !1;
    if (opts === null)
      opts = kEmptyObject;
    if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup)
      validateBoolean(opts.cleanup, "cleanup"), autoCleanup = opts.cleanup;
    return new Promise2((resolve, reject) => {
      let cleanup = eos(stream, opts, (err) => {
        if (autoCleanup)
          cleanup();
        if (err)
          reject(err);
        else
          resolve();
      });
    });
  }
  module.exports = eos;
  module.exports.finished = finished;
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS((exports, module) => {
  var process2 = require_process(), {
    aggregateTwoErrors,
    codes: { ERR_MULTIPLE_CALLBACK },
    AbortError
  } = require_errors3(), { Symbol: Symbol2 } = require_primordials(), { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils5(), kDestroy = Symbol2("kDestroy"), kConstruct = Symbol2("kConstruct");
  function checkError(err, w, r) {
    if (err) {
      if (err.stack, w && !w.errored)
        w.errored = err;
      if (r && !r.errored)
        r.errored = err;
    }
  }
  function destroy(err, cb) {
    let r = this._readableState, w = this._writableState, s = w || r;
    if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
      if (typeof cb === "function")
        cb();
      return this;
    }
    if (checkError(err, w, r), w)
      w.destroyed = !0;
    if (r)
      r.destroyed = !0;
    if (!s.constructed)
      this.once(kDestroy, function(er) {
        _destroy(this, aggregateTwoErrors(er, err), cb);
      });
    else
      _destroy(this, err, cb);
    return this;
  }
  function _destroy(self2, err, cb) {
    let called = !1;
    function onDestroy(err2) {
      if (called)
        return;
      called = !0;
      let { _readableState: r, _writableState: w } = self2;
      if (checkError(err2, w, r), w)
        w.closed = !0;
      if (r)
        r.closed = !0;
      if (typeof cb === "function")
        cb(err2);
      if (err2)
        process2.nextTick(emitErrorCloseNT, self2, err2);
      else
        process2.nextTick(emitCloseNT, self2);
    }
    try {
      self2._destroy(err || null, onDestroy);
    } catch (err2) {
      onDestroy(err2);
    }
  }
  function emitErrorCloseNT(self2, err) {
    emitErrorNT(self2, err), emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    let { _readableState: r, _writableState: w } = self2;
    if (w)
      w.closeEmitted = !0;
    if (r)
      r.closeEmitted = !0;
    if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose)
      self2.emit("close");
  }
  function emitErrorNT(self2, err) {
    let { _readableState: r, _writableState: w } = self2;
    if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted)
      return;
    if (w)
      w.errorEmitted = !0;
    if (r)
      r.errorEmitted = !0;
    self2.emit("error", err);
  }
  function undestroy() {
    let r = this._readableState, w = this._writableState;
    if (r)
      r.constructed = !0, r.closed = !1, r.closeEmitted = !1, r.destroyed = !1, r.errored = null, r.errorEmitted = !1, r.reading = !1, r.ended = r.readable === !1, r.endEmitted = r.readable === !1;
    if (w)
      w.constructed = !0, w.destroyed = !1, w.closed = !1, w.closeEmitted = !1, w.errored = null, w.errorEmitted = !1, w.finalCalled = !1, w.prefinished = !1, w.ended = w.writable === !1, w.ending = w.writable === !1, w.finished = w.writable === !1;
  }
  function errorOrDestroy(stream, err, sync) {
    let { _readableState: r, _writableState: w } = stream;
    if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed)
      return this;
    if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
      stream.destroy(err);
    else if (err) {
      if (err.stack, w && !w.errored)
        w.errored = err;
      if (r && !r.errored)
        r.errored = err;
      if (sync)
        process2.nextTick(emitErrorNT, stream, err);
      else
        emitErrorNT(stream, err);
    }
  }
  function construct(stream, cb) {
    if (typeof stream._construct !== "function")
      return;
    let { _readableState: r, _writableState: w } = stream;
    if (r)
      r.constructed = !1;
    if (w)
      w.constructed = !1;
    if (stream.once(kConstruct, cb), stream.listenerCount(kConstruct) > 1)
      return;
    process2.nextTick(constructNT, stream);
  }
  function constructNT(stream) {
    let called = !1;
    function onConstruct(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK);
        return;
      }
      called = !0;
      let { _readableState: r, _writableState: w } = stream, s = w || r;
      if (r)
        r.constructed = !0;
      if (w)
        w.constructed = !0;
      if (s.destroyed)
        stream.emit(kDestroy, err);
      else if (err)
        errorOrDestroy(stream, err, !0);
      else
        process2.nextTick(emitConstructNT, stream);
    }
    try {
      stream._construct((err) => {
        process2.nextTick(onConstruct, err);
      });
    } catch (err) {
      process2.nextTick(onConstruct, err);
    }
  }
  function emitConstructNT(stream) {
    stream.emit(kConstruct);
  }
  function isRequest(stream) {
    return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
  }
  function emitCloseLegacy(stream) {
    stream.emit("close");
  }
  function emitErrorCloseLegacy(stream, err) {
    stream.emit("error", err), process2.nextTick(emitCloseLegacy, stream);
  }
  function destroyer(stream, err) {
    if (!stream || isDestroyed(stream))
      return;
    if (!err && !isFinished(stream))
      err = new AbortError;
    if (isServerRequest(stream))
      stream.socket = null, stream.destroy(err);
    else if (isRequest(stream))
      stream.abort();
    else if (isRequest(stream.req))
      stream.req.abort();
    else if (typeof stream.destroy === "function")
      stream.destroy(err);
    else if (typeof stream.close === "function")
      stream.close();
    else if (err)
      process2.nextTick(emitErrorCloseLegacy, stream, err);
    else
      process2.nextTick(emitCloseLegacy, stream);
    if (!stream.destroyed)
      stream[kIsDestroyed] = !0;
  }
  module.exports = {
    construct,
    destroyer,
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS((exports, module) => {
  var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials(), { EventEmitter: EE } = __require("events");
  function Stream(opts) {
    EE.call(this, opts);
  }
  ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
  ObjectSetPrototypeOf(Stream, EE);
  Stream.prototype.pipe = function(dest, options) {
    let source = this;
    function ondata(chunk) {
      if (dest.writable && dest.write(chunk) === !1 && source.pause)
        source.pause();
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume)
        source.resume();
    }
    if (dest.on("drain", ondrain), !dest._isStdio && (!options || options.end !== !1))
      source.on("end", onend), source.on("close", onclose);
    let didOnEnd = !1;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = !0, dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      if (didOnEnd = !0, typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      if (cleanup(), EE.listenerCount(this, "error") === 0)
        this.emit("error", er);
    }
    prependListener(source, "error", onerror), prependListener(dest, "error", onerror);
    function cleanup() {
      source.removeListener("data", ondata), dest.removeListener("drain", ondrain), source.removeListener("end", onend), source.removeListener("close", onclose), source.removeListener("error", onerror), dest.removeListener("error", onerror), source.removeListener("end", cleanup), source.removeListener("close", cleanup), dest.removeListener("close", cleanup);
    }
    return source.on("end", cleanup), source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), dest;
  };
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (ArrayIsArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  module.exports = {
    Stream,
    prependListener
  };
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS((exports, module) => {
  var { SymbolDispose } = require_primordials(), { AbortError, codes } = require_errors3(), { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils5(), eos = require_end_of_stream(), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2 } = codes, addAbortListener, validateAbortSignal = (signal, name) => {
    if (typeof signal !== "object" || !("aborted" in signal))
      throw new ERR_INVALID_ARG_TYPE2(name, "AbortSignal", signal);
  };
  exports.addAbortSignal = function(signal, stream) {
    if (validateAbortSignal(signal, "signal"), !isNodeStream(stream) && !isWebStream(stream))
      throw new ERR_INVALID_ARG_TYPE2("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
    return exports.addAbortSignalNoValidate(signal, stream);
  };
  exports.addAbortSignalNoValidate = function(signal, stream) {
    if (typeof signal !== "object" || !("aborted" in signal))
      return stream;
    let onAbort = isNodeStream(stream) ? () => {
      stream.destroy(new AbortError(void 0, {
        cause: signal.reason
      }));
    } : () => {
      stream[kControllerErrorFunction](new AbortError(void 0, {
        cause: signal.reason
      }));
    };
    if (signal.aborted)
      onAbort();
    else {
      addAbortListener = addAbortListener || require_util11().addAbortListener;
      let disposable = addAbortListener(signal, onAbort);
      eos(stream, disposable[SymbolDispose]);
    }
    return stream;
  };
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports, module) => {
  var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials(), { Buffer: Buffer2 } = __require("buffer"), { inspect } = require_util11();
  module.exports = class {
    constructor() {
      this.head = null, this.tail = null, this.length = 0;
    }
    push(v) {
      let entry = {
        data: v,
        next: null
      };
      if (this.length > 0)
        this.tail.next = entry;
      else
        this.head = entry;
      this.tail = entry, ++this.length;
    }
    unshift(v) {
      let entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0)
        this.tail = entry;
      this.head = entry, ++this.length;
    }
    shift() {
      if (this.length === 0)
        return;
      let ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      return --this.length, ret;
    }
    clear() {
      this.head = this.tail = null, this.length = 0;
    }
    join(s) {
      if (this.length === 0)
        return "";
      let p = this.head, ret = "" + p.data;
      while ((p = p.next) !== null)
        ret += s + p.data;
      return ret;
    }
    concat(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      let ret = Buffer2.allocUnsafe(n >>> 0), p = this.head, i = 0;
      while (p)
        TypedArrayPrototypeSet(ret, p.data, i), i += p.data.length, p = p.next;
      return ret;
    }
    consume(n, hasStrings) {
      let data = this.head.data;
      if (n < data.length) {
        let slice = data.slice(0, n);
        return this.head.data = data.slice(n), slice;
      }
      if (n === data.length)
        return this.shift();
      return hasStrings ? this._getString(n) : this._getBuffer(n);
    }
    first() {
      return this.head.data;
    }
    *[SymbolIterator]() {
      for (let p = this.head;p; p = p.next)
        yield p.data;
    }
    _getString(n) {
      let ret = "", p = this.head, c = 0;
      do {
        let str = p.data;
        if (n > str.length)
          ret += str, n -= str.length;
        else {
          if (n === str.length)
            if (ret += str, ++c, p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          else
            ret += StringPrototypeSlice(str, 0, n), this.head = p, p.data = StringPrototypeSlice(str, n);
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      return this.length -= c, ret;
    }
    _getBuffer(n) {
      let ret = Buffer2.allocUnsafe(n), retLen = n, p = this.head, c = 0;
      do {
        let buf = p.data;
        if (n > buf.length)
          TypedArrayPrototypeSet(ret, buf, retLen - n), n -= buf.length;
        else {
          if (n === buf.length)
            if (TypedArrayPrototypeSet(ret, buf, retLen - n), ++c, p.next)
              this.head = p.next;
            else
              this.head = this.tail = null;
          else
            TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n), this.head = p, p.data = buf.slice(n);
          break;
        }
        ++c;
      } while ((p = p.next) !== null);
      return this.length -= c, ret;
    }
    [Symbol.for("nodejs.util.inspect.custom")](_2, options) {
      return inspect(this, {
        ...options,
        depth: 0,
        customInspect: !1
      });
    }
  };
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state4 = __commonJS((exports, module) => {
  var { MathFloor, NumberIsInteger } = require_primordials(), { validateInteger } = require_validators(), { ERR_INVALID_ARG_VALUE } = require_errors3().codes, defaultHighWaterMarkBytes = 16384, defaultHighWaterMarkObjectMode = 16;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getDefaultHighWaterMark(objectMode) {
    return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
  }
  function setDefaultHighWaterMark(objectMode, value) {
    if (validateInteger(value, "value", 0), objectMode)
      defaultHighWaterMarkObjectMode = value;
    else
      defaultHighWaterMarkBytes = value;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    let hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!NumberIsInteger(hwm) || hwm < 0) {
        let name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
        throw new ERR_INVALID_ARG_VALUE(name, hwm);
      }
      return MathFloor(hwm);
    }
    return getDefaultHighWaterMark(state.objectMode);
  }
  module.exports = {
    getHighWaterMark,
    getDefaultHighWaterMark,
    setDefaultHighWaterMark
  };
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS((exports, module) => {
  var process2 = require_process(), { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials(), { Buffer: Buffer2 } = __require("buffer"), { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_STREAM_NULL_VALUES } = require_errors3().codes;
  function from(Readable, iterable, opts) {
    let iterator;
    if (typeof iterable === "string" || iterable instanceof Buffer2)
      return new Readable({
        objectMode: !0,
        ...opts,
        read() {
          this.push(iterable), this.push(null);
        }
      });
    let isAsync;
    if (iterable && iterable[SymbolAsyncIterator])
      isAsync = !0, iterator = iterable[SymbolAsyncIterator]();
    else if (iterable && iterable[SymbolIterator])
      isAsync = !1, iterator = iterable[SymbolIterator]();
    else
      throw new ERR_INVALID_ARG_TYPE2("iterable", ["Iterable"], iterable);
    let readable = new Readable({
      objectMode: !0,
      highWaterMark: 1,
      ...opts
    }), reading = !1;
    readable._read = function() {
      if (!reading)
        reading = !0, next();
    }, readable._destroy = function(error, cb) {
      PromisePrototypeThen(close(error), () => process2.nextTick(cb, error), (e) => process2.nextTick(cb, e || error));
    };
    async function close(error) {
      let hadError = error !== void 0 && error !== null, hasThrow = typeof iterator.throw === "function";
      if (hadError && hasThrow) {
        let { value, done } = await iterator.throw(error);
        if (await value, done)
          return;
      }
      if (typeof iterator.return === "function") {
        let { value } = await iterator.return();
        await value;
      }
    }
    async function next() {
      for (;; ) {
        try {
          let { value, done } = isAsync ? await iterator.next() : iterator.next();
          if (done)
            readable.push(null);
          else {
            let res = value && typeof value.then === "function" ? await value : value;
            if (res === null)
              throw reading = !1, new ERR_STREAM_NULL_VALUES;
            else if (readable.push(res))
              continue;
            else
              reading = !1;
          }
        } catch (err) {
          readable.destroy(err);
        }
        break;
      }
    }
    return readable;
  }
  module.exports = from;
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable3 = __commonJS((exports, module) => {
  var process2 = require_process(), {
    ArrayPrototypeIndexOf,
    NumberIsInteger,
    NumberIsNaN,
    NumberParseInt,
    ObjectDefineProperties,
    ObjectKeys,
    ObjectSetPrototypeOf,
    Promise: Promise2,
    SafeSet,
    SymbolAsyncDispose,
    SymbolAsyncIterator,
    Symbol: Symbol2
  } = require_primordials();
  module.exports = Readable;
  Readable.ReadableState = ReadableState;
  var { EventEmitter: EE } = __require("events"), { Stream, prependListener } = require_legacy(), { Buffer: Buffer2 } = __require("buffer"), { addAbortSignal } = require_add_abort_signal(), eos = require_end_of_stream(), debug = require_util11().debuglog("stream", (fn) => {
    debug = fn;
  }), BufferList = require_buffer_list(), destroyImpl = require_destroy2(), { getHighWaterMark, getDefaultHighWaterMark } = require_state4(), {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_OUT_OF_RANGE,
      ERR_STREAM_PUSH_AFTER_EOF,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT
    },
    AbortError
  } = require_errors3(), { validateObject } = require_validators(), kPaused = Symbol2("kPaused"), { StringDecoder } = __require("string_decoder"), from = require_from();
  ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Readable, Stream);
  var nop = () => {}, { errorOrDestroy } = destroyImpl, kObjectMode = 1, kEnded = 2, kEndEmitted = 4, kReading = 8, kConstructed = 16, kSync = 32, kNeedReadable = 64, kEmittedReadable = 128, kReadableListening = 256, kResumeScheduled = 512, kErrorEmitted = 1024, kEmitClose = 2048, kAutoDestroy = 4096, kDestroyed = 8192, kClosed = 16384, kCloseEmitted = 32768, kMultiAwaitDrain = 65536, kReadingMore = 131072, kDataEmitted = 262144;
  function makeBitMapDescriptor(bit) {
    return {
      enumerable: !1,
      get() {
        return (this.state & bit) !== 0;
      },
      set(value) {
        if (value)
          this.state |= bit;
        else
          this.state &= ~bit;
      }
    };
  }
  ObjectDefineProperties(ReadableState.prototype, {
    objectMode: makeBitMapDescriptor(kObjectMode),
    ended: makeBitMapDescriptor(kEnded),
    endEmitted: makeBitMapDescriptor(kEndEmitted),
    reading: makeBitMapDescriptor(kReading),
    constructed: makeBitMapDescriptor(kConstructed),
    sync: makeBitMapDescriptor(kSync),
    needReadable: makeBitMapDescriptor(kNeedReadable),
    emittedReadable: makeBitMapDescriptor(kEmittedReadable),
    readableListening: makeBitMapDescriptor(kReadableListening),
    resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
    errorEmitted: makeBitMapDescriptor(kErrorEmitted),
    emitClose: makeBitMapDescriptor(kEmitClose),
    autoDestroy: makeBitMapDescriptor(kAutoDestroy),
    destroyed: makeBitMapDescriptor(kDestroyed),
    closed: makeBitMapDescriptor(kClosed),
    closeEmitted: makeBitMapDescriptor(kCloseEmitted),
    multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
    readingMore: makeBitMapDescriptor(kReadingMore),
    dataEmitted: makeBitMapDescriptor(kDataEmitted)
  });
  function ReadableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    if (this.state = kEmitClose | kAutoDestroy | kConstructed | kSync, options && options.objectMode)
      this.state |= kObjectMode;
    if (isDuplex && options && options.readableObjectMode)
      this.state |= kObjectMode;
    if (this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(!1), this.buffer = new BufferList, this.length = 0, this.pipes = [], this.flowing = null, this[kPaused] = null, options && options.emitClose === !1)
      this.state &= ~kEmitClose;
    if (options && options.autoDestroy === !1)
      this.state &= ~kAutoDestroy;
    if (this.errored = null, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.decoder = null, this.encoding = null, options && options.encoding)
      this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding;
  }
  function Readable(options) {
    if (!(this instanceof Readable))
      return new Readable(options);
    let isDuplex = this instanceof require_duplex();
    if (this._readableState = new ReadableState(options, this, isDuplex), options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal && !isDuplex)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options), destroyImpl.construct(this, () => {
      if (this._readableState.needReadable)
        maybeReadMore(this, this._readableState);
    });
  }
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype[EE.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  Readable.prototype[SymbolAsyncDispose] = function() {
    let error;
    if (!this.destroyed)
      error = this.readableEnded ? null : new AbortError, this.destroy(error);
    return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
  };
  Readable.prototype.push = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, !1);
  };
  Readable.prototype.unshift = function(chunk, encoding) {
    return readableAddChunk(this, chunk, encoding, !0);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront) {
    debug("readableAddChunk", chunk);
    let state = stream._readableState, err;
    if ((state.state & kObjectMode) === 0) {
      if (typeof chunk === "string") {
        if (encoding = encoding || state.defaultEncoding, state.encoding !== encoding)
          if (addToFront && state.encoding)
            chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
          else
            chunk = Buffer2.from(chunk, encoding), encoding = "";
      } else if (chunk instanceof Buffer2)
        encoding = "";
      else if (Stream._isUint8Array(chunk))
        chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "";
      else if (chunk != null)
        err = new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    if (err)
      errorOrDestroy(stream, err);
    else if (chunk === null)
      state.state &= ~kReading, onEofChunk(stream, state);
    else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0)
      if (addToFront)
        if ((state.state & kEndEmitted) !== 0)
          errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT);
        else if (state.destroyed || state.errored)
          return !1;
        else
          addChunk(stream, state, chunk, !0);
      else if (state.ended)
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF);
      else if (state.destroyed || state.errored)
        return !1;
      else if (state.state &= ~kReading, state.decoder && !encoding)
        if (chunk = state.decoder.write(chunk), state.objectMode || chunk.length !== 0)
          addChunk(stream, state, chunk, !1);
        else
          maybeReadMore(stream, state);
      else
        addChunk(stream, state, chunk, !1);
    else if (!addToFront)
      state.state &= ~kReading, maybeReadMore(stream, state);
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
      if ((state.state & kMultiAwaitDrain) !== 0)
        state.awaitDrainWriters.clear();
      else
        state.awaitDrainWriters = null;
      state.dataEmitted = !0, stream.emit("data", chunk);
    } else {
      if (state.length += state.objectMode ? 1 : chunk.length, addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if ((state.state & kNeedReadable) !== 0)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  Readable.prototype.isPaused = function() {
    let state = this._readableState;
    return state[kPaused] === !0 || state.flowing === !1;
  };
  Readable.prototype.setEncoding = function(enc) {
    let decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder, this._readableState.encoding = this._readableState.decoder.encoding;
    let buffer = this._readableState.buffer, content = "";
    for (let data of buffer)
      content += decoder.write(data);
    if (buffer.clear(), content !== "")
      buffer.push(content);
    return this._readableState.length = content.length, this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n > MAX_HWM)
      throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
    else
      n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, n |= n >>> 8, n |= n >>> 16, n++;
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if ((state.state & kObjectMode) !== 0)
      return 1;
    if (NumberIsNaN(n)) {
      if (state.flowing && state.length)
        return state.buffer.first().length;
      return state.length;
    }
    if (n <= state.length)
      return n;
    return state.ended ? state.length : 0;
  }
  Readable.prototype.read = function(n) {
    if (debug("read", n), n === void 0)
      n = NaN;
    else if (!NumberIsInteger(n))
      n = NumberParseInt(n, 10);
    let state = this._readableState, nOrig = n;
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n !== 0)
      state.state &= ~kEmittedReadable;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      if (debug("read: emitReadable", state.length, state.ended), state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    if (n = howMuchToRead(n, state), n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    let doRead = (state.state & kNeedReadable) !== 0;
    if (debug("need readable", doRead), state.length === 0 || state.length - n < state.highWaterMark)
      doRead = !0, debug("length less than watermark", doRead);
    if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed)
      doRead = !1, debug("reading, ended or constructing", doRead);
    else if (doRead) {
      if (debug("do read"), state.state |= kReading | kSync, state.length === 0)
        state.state |= kNeedReadable;
      try {
        this._read(state.highWaterMark);
      } catch (err) {
        errorOrDestroy(this, err);
      }
      if (state.state &= ~kSync, !state.reading)
        n = howMuchToRead(nOrig, state);
    }
    let ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null)
      state.needReadable = state.length <= state.highWaterMark, n = 0;
    else if (state.length -= n, state.multiAwaitDrain)
      state.awaitDrainWriters.clear();
    else
      state.awaitDrainWriters = null;
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = !0;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null && !state.errorEmitted && !state.closeEmitted)
      state.dataEmitted = !0, this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    if (debug("onEofChunk"), state.ended)
      return;
    if (state.decoder) {
      let chunk = state.decoder.end();
      if (chunk && chunk.length)
        state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length;
    }
    if (state.ended = !0, state.sync)
      emitReadable(stream);
    else
      state.needReadable = !1, state.emittedReadable = !0, emitReadable_(stream);
  }
  function emitReadable(stream) {
    let state = stream._readableState;
    if (debug("emitReadable", state.needReadable, state.emittedReadable), state.needReadable = !1, !state.emittedReadable)
      debug("emitReadable", state.flowing), state.emittedReadable = !0, process2.nextTick(emitReadable_, stream);
  }
  function emitReadable_(stream) {
    let state = stream._readableState;
    if (debug("emitReadable_", state.destroyed, state.length, state.ended), !state.destroyed && !state.errored && (state.length || state.ended))
      stream.emit("readable"), state.emittedReadable = !1;
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark, flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore && state.constructed)
      state.readingMore = !0, process2.nextTick(maybeReadMore_, stream, state);
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      let len = state.length;
      if (debug("maybeReadMore read 0"), stream.read(0), len === state.length)
        break;
    }
    state.readingMore = !1;
  }
  Readable.prototype._read = function(n) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    let src = this, state = this._readableState;
    if (state.pipes.length === 1) {
      if (!state.multiAwaitDrain)
        state.multiAwaitDrain = !0, state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
    }
    state.pipes.push(dest), debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
    let endFn = (!pipeOpts || pipeOpts.end !== !1) && dest !== process2.stdout && dest !== process2.stderr ? onend : unpipe;
    if (state.endEmitted)
      process2.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      if (debug("onunpipe"), readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === !1)
          unpipeInfo.hasUnpiped = !0, cleanup();
      }
    }
    function onend() {
      debug("onend"), dest.end();
    }
    let ondrain, cleanedUp = !1;
    function cleanup() {
      if (debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), ondrain)
        dest.removeListener("drain", ondrain);
      if (dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), cleanedUp = !0, ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    function pause() {
      if (!cleanedUp) {
        if (state.pipes.length === 1 && state.pipes[0] === dest)
          debug("false write response, pause", 0), state.awaitDrainWriters = dest, state.multiAwaitDrain = !1;
        else if (state.pipes.length > 1 && state.pipes.includes(dest))
          debug("false write response, pause", state.awaitDrainWriters.size), state.awaitDrainWriters.add(dest);
        src.pause();
      }
      if (!ondrain)
        ondrain = pipeOnDrain(src, dest), dest.on("drain", ondrain);
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      let ret = dest.write(chunk);
      if (debug("dest.write", ret), ret === !1)
        pause();
    }
    function onerror(er) {
      if (debug("onerror", er), unpipe(), dest.removeListener("error", onerror), dest.listenerCount("error") === 0) {
        let s = dest._writableState || dest._readableState;
        if (s && !s.errorEmitted)
          errorOrDestroy(dest, er);
        else
          dest.emit("error", er);
      }
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish), unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish"), dest.removeListener("close", onclose), unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe"), src.unpipe(dest);
    }
    if (dest.emit("pipe", src), dest.writableNeedDrain === !0)
      pause();
    else if (!state.flowing)
      debug("pipe resume"), src.resume();
    return dest;
  };
  function pipeOnDrain(src, dest) {
    return function() {
      let state = src._readableState;
      if (state.awaitDrainWriters === dest)
        debug("pipeOnDrain", 1), state.awaitDrainWriters = null;
      else if (state.multiAwaitDrain)
        debug("pipeOnDrain", state.awaitDrainWriters.size), state.awaitDrainWriters.delete(dest);
      if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data"))
        src.resume();
    };
  }
  Readable.prototype.unpipe = function(dest) {
    let state = this._readableState, unpipeInfo = {
      hasUnpiped: !1
    };
    if (state.pipes.length === 0)
      return this;
    if (!dest) {
      let dests = state.pipes;
      state.pipes = [], this.pause();
      for (let i = 0;i < dests.length; i++)
        dests[i].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    let index = ArrayPrototypeIndexOf(state.pipes, dest);
    if (index === -1)
      return this;
    if (state.pipes.splice(index, 1), state.pipes.length === 0)
      this.pause();
    return dest.emit("unpipe", this, unpipeInfo), this;
  };
  Readable.prototype.on = function(ev, fn) {
    let res = Stream.prototype.on.call(this, ev, fn), state = this._readableState;
    if (ev === "data") {
      if (state.readableListening = this.listenerCount("readable") > 0, state.flowing !== !1)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        if (state.readableListening = state.needReadable = !0, state.flowing = !1, state.emittedReadable = !1, debug("on readable", state.length, state.reading), state.length)
          emitReadable(this);
        else if (!state.reading)
          process2.nextTick(nReadingNextTick, this);
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    let res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable")
      process2.nextTick(updateReadableListening, this);
    return res;
  };
  Readable.prototype.off = Readable.prototype.removeListener;
  Readable.prototype.removeAllListeners = function(ev) {
    let res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0)
      process2.nextTick(updateReadableListening, this);
    return res;
  };
  function updateReadableListening(self2) {
    let state = self2._readableState;
    if (state.readableListening = self2.listenerCount("readable") > 0, state.resumeScheduled && state[kPaused] === !1)
      state.flowing = !0;
    else if (self2.listenerCount("data") > 0)
      self2.resume();
    else if (!state.readableListening)
      state.flowing = null;
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0"), self2.read(0);
  }
  Readable.prototype.resume = function() {
    let state = this._readableState;
    if (!state.flowing)
      debug("resume"), state.flowing = !state.readableListening, resume(this, state);
    return state[kPaused] = !1, this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled)
      state.resumeScheduled = !0, process2.nextTick(resume_, stream, state);
  }
  function resume_(stream, state) {
    if (debug("resume", state.reading), !state.reading)
      stream.read(0);
    if (state.resumeScheduled = !1, stream.emit("resume"), flow(stream), state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    if (debug("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1)
      debug("pause"), this._readableState.flowing = !1, this.emit("pause");
    return this._readableState[kPaused] = !0, this;
  };
  function flow(stream) {
    let state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null)
      ;
  }
  Readable.prototype.wrap = function(stream) {
    let paused = !1;
    stream.on("data", (chunk) => {
      if (!this.push(chunk) && stream.pause)
        paused = !0, stream.pause();
    }), stream.on("end", () => {
      this.push(null);
    }), stream.on("error", (err) => {
      errorOrDestroy(this, err);
    }), stream.on("close", () => {
      this.destroy();
    }), stream.on("destroy", () => {
      this.destroy();
    }), this._read = () => {
      if (paused && stream.resume)
        paused = !1, stream.resume();
    };
    let streamKeys = ObjectKeys(stream);
    for (let j = 1;j < streamKeys.length; j++) {
      let i = streamKeys[j];
      if (this[i] === void 0 && typeof stream[i] === "function")
        this[i] = stream[i].bind(stream);
    }
    return this;
  };
  Readable.prototype[SymbolAsyncIterator] = function() {
    return streamToAsyncIterator(this);
  };
  Readable.prototype.iterator = function(options) {
    if (options !== void 0)
      validateObject(options, "options");
    return streamToAsyncIterator(this, options);
  };
  function streamToAsyncIterator(stream, options) {
    if (typeof stream.read !== "function")
      stream = Readable.wrap(stream, {
        objectMode: !0
      });
    let iter = createAsyncIterator(stream, options);
    return iter.stream = stream, iter;
  }
  async function* createAsyncIterator(stream, options) {
    let callback = nop;
    function next(resolve) {
      if (this === stream)
        callback(), callback = nop;
      else
        callback = resolve;
    }
    stream.on("readable", next);
    let error, cleanup = eos(stream, {
      writable: !1
    }, (err) => {
      error = err ? aggregateTwoErrors(error, err) : null, callback(), callback = nop;
    });
    try {
      while (!0) {
        let chunk = stream.destroyed ? null : stream.read();
        if (chunk !== null)
          yield chunk;
        else if (error)
          throw error;
        else if (error === null)
          return;
        else
          await new Promise2(next);
      }
    } catch (err) {
      throw error = aggregateTwoErrors(error, err), error;
    } finally {
      if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== !1) && (error === void 0 || stream._readableState.autoDestroy))
        destroyImpl.destroyer(stream, null);
      else
        stream.off("readable", next), cleanup();
    }
  }
  ObjectDefineProperties(Readable.prototype, {
    readable: {
      __proto__: null,
      get() {
        let r = this._readableState;
        return !!r && r.readable !== !1 && !r.destroyed && !r.errorEmitted && !r.endEmitted;
      },
      set(val) {
        if (this._readableState)
          this._readableState.readable = !!val;
      }
    },
    readableDidRead: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.dataEmitted;
      }
    },
    readableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
      }
    },
    readableHighWaterMark: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark;
      }
    },
    readableBuffer: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer;
      }
    },
    readableFlowing: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return this._readableState.flowing;
      },
      set: function(state) {
        if (this._readableState)
          this._readableState.flowing = state;
      }
    },
    readableLength: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState.length;
      }
    },
    readableObjectMode: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.objectMode : !1;
      }
    },
    readableEncoding: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.encoding : null;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.errored : null;
      }
    },
    closed: {
      __proto__: null,
      get() {
        return this._readableState ? this._readableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.destroyed : !1;
      },
      set(value) {
        if (!this._readableState)
          return;
        this._readableState.destroyed = value;
      }
    },
    readableEnded: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._readableState ? this._readableState.endEmitted : !1;
      }
    }
  });
  ObjectDefineProperties(ReadableState.prototype, {
    pipesCount: {
      __proto__: null,
      get() {
        return this.pipes.length;
      }
    },
    paused: {
      __proto__: null,
      get() {
        return this[kPaused] !== !1;
      },
      set(value) {
        this[kPaused] = !!value;
      }
    }
  });
  Readable._fromList = fromList;
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    let ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else
      ret = state.buffer.consume(n, state.decoder);
    return ret;
  }
  function endReadable(stream) {
    let state = stream._readableState;
    if (debug("endReadable", state.endEmitted), !state.endEmitted)
      state.ended = !0, process2.nextTick(endReadableNT, state, stream);
  }
  function endReadableNT(state, stream) {
    if (debug("endReadableNT", state.endEmitted, state.length), !state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
      if (state.endEmitted = !0, stream.emit("end"), stream.writable && stream.allowHalfOpen === !1)
        process2.nextTick(endWritableNT, stream);
      else if (state.autoDestroy) {
        let wState = stream._writableState;
        if (!wState || wState.autoDestroy && (wState.finished || wState.writable === !1))
          stream.destroy();
      }
    }
  }
  function endWritableNT(stream) {
    if (stream.writable && !stream.writableEnded && !stream.destroyed)
      stream.end();
  }
  Readable.from = function(iterable, opts) {
    return from(Readable, iterable, opts);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === void 0)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Readable.fromWeb = function(readableStream, options) {
    return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
  };
  Readable.toWeb = function(streamReadable, options) {
    return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
  };
  Readable.wrap = function(src, options) {
    var _ref, _src$readableObjectMo;
    return new Readable({
      objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : !0,
      ...options,
      destroy(err, callback) {
        destroyImpl.destroyer(src, err), callback(err);
      }
    }).wrap(src);
  };
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS((exports, module) => {
  var process2 = require_process(), {
    ArrayPrototypeSlice,
    Error: Error2,
    FunctionPrototypeSymbolHasInstance,
    ObjectDefineProperty,
    ObjectDefineProperties,
    ObjectSetPrototypeOf,
    StringPrototypeToLowerCase,
    Symbol: Symbol2,
    SymbolHasInstance
  } = require_primordials();
  module.exports = Writable;
  Writable.WritableState = WritableState;
  var { EventEmitter: EE } = __require("events"), Stream = require_legacy().Stream, { Buffer: Buffer2 } = __require("buffer"), destroyImpl = require_destroy2(), { addAbortSignal } = require_add_abort_signal(), { getHighWaterMark, getDefaultHighWaterMark } = require_state4(), {
    ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
    ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED,
    ERR_STREAM_ALREADY_FINISHED,
    ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING
  } = require_errors3().codes, { errorOrDestroy } = destroyImpl;
  ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
  ObjectSetPrototypeOf(Writable, Stream);
  function nop() {}
  var kOnFinished = Symbol2("kOnFinished");
  function WritableState(options, stream, isDuplex) {
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof require_duplex();
    if (this.objectMode = !!(options && options.objectMode), isDuplex)
      this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
    this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    let noDecode = !!(options && options.decodeStrings === !1);
    this.decodeStrings = !noDecode, this.defaultEncoding = options && options.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = onwrite.bind(void 0, stream), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, resetBuffer(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !options || options.emitClose !== !1, this.autoDestroy = !options || options.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[kOnFinished] = [];
  }
  function resetBuffer(state) {
    state.buffered = [], state.bufferedIndex = 0, state.allBuffers = !0, state.allNoop = !0;
  }
  WritableState.prototype.getBuffer = function() {
    return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
  };
  ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
    __proto__: null,
    get() {
      return this.buffered.length - this.bufferedIndex;
    }
  });
  function Writable(options) {
    let isDuplex = this instanceof require_duplex();
    if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this))
      return new Writable(options);
    if (this._writableState = new WritableState(options, this, isDuplex), options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
      if (typeof options.construct === "function")
        this._construct = options.construct;
      if (options.signal)
        addAbortSignal(options.signal, this);
    }
    Stream.call(this, options), destroyImpl.construct(this, () => {
      let state = this._writableState;
      if (!state.writing)
        clearBuffer(this, state);
      finishMaybe(this, state);
    });
  }
  ObjectDefineProperty(Writable, SymbolHasInstance, {
    __proto__: null,
    value: function(object) {
      if (FunctionPrototypeSymbolHasInstance(this, object))
        return !0;
      if (this !== Writable)
        return !1;
      return object && object._writableState instanceof WritableState;
    }
  });
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE);
  };
  function _write(stream, chunk, encoding, cb) {
    let state = stream._writableState;
    if (typeof encoding === "function")
      cb = encoding, encoding = state.defaultEncoding;
    else {
      if (!encoding)
        encoding = state.defaultEncoding;
      else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      if (typeof cb !== "function")
        cb = nop;
    }
    if (chunk === null)
      throw new ERR_STREAM_NULL_VALUES;
    else if (!state.objectMode)
      if (typeof chunk === "string") {
        if (state.decodeStrings !== !1)
          chunk = Buffer2.from(chunk, encoding), encoding = "buffer";
      } else if (chunk instanceof Buffer2)
        encoding = "buffer";
      else if (Stream._isUint8Array(chunk))
        chunk = Stream._uint8ArrayToBuffer(chunk), encoding = "buffer";
      else
        throw new ERR_INVALID_ARG_TYPE2("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    let err;
    if (state.ending)
      err = new ERR_STREAM_WRITE_AFTER_END;
    else if (state.destroyed)
      err = new ERR_STREAM_DESTROYED("write");
    if (err)
      return process2.nextTick(cb, err), errorOrDestroy(stream, err, !0), err;
    return state.pendingcb++, writeOrBuffer(stream, state, chunk, encoding, cb);
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    return _write(this, chunk, encoding, cb) === !0;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    let state = this._writableState;
    if (state.corked) {
      if (state.corked--, !state.writing)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function(encoding) {
    if (typeof encoding === "string")
      encoding = StringPrototypeToLowerCase(encoding);
    if (!Buffer2.isEncoding(encoding))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    return this._writableState.defaultEncoding = encoding, this;
  };
  function writeOrBuffer(stream, state, chunk, encoding, callback) {
    let len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    let ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = !0;
    if (state.writing || state.corked || state.errored || !state.constructed) {
      if (state.buffered.push({
        chunk,
        encoding,
        callback
      }), state.allBuffers && encoding !== "buffer")
        state.allBuffers = !1;
      if (state.allNoop && callback !== nop)
        state.allNoop = !1;
    } else
      state.writelen = len, state.writecb = callback, state.writing = !0, state.sync = !0, stream._write(chunk, encoding, state.onwrite), state.sync = !1;
    return ret && !state.errored && !state.destroyed;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    if (state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = !1;
  }
  function onwriteError(stream, state, er, cb) {
    --state.pendingcb, cb(er), errorBuffer(state), errorOrDestroy(stream, er);
  }
  function onwrite(stream, er) {
    let state = stream._writableState, sync = state.sync, cb = state.writecb;
    if (typeof cb !== "function") {
      errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK);
      return;
    }
    if (state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0, er) {
      if (er.stack, !state.errored)
        state.errored = er;
      if (stream._readableState && !stream._readableState.errored)
        stream._readableState.errored = er;
      if (sync)
        process2.nextTick(onwriteError, stream, state, er, cb);
      else
        onwriteError(stream, state, er, cb);
    } else {
      if (state.buffered.length > state.bufferedIndex)
        clearBuffer(stream, state);
      if (sync)
        if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb)
          state.afterWriteTickInfo.count++;
        else
          state.afterWriteTickInfo = {
            count: 1,
            cb,
            stream,
            state
          }, process2.nextTick(afterWriteTick, state.afterWriteTickInfo);
      else
        afterWrite(stream, state, 1, cb);
    }
  }
  function afterWriteTick({ stream, state, count, cb }) {
    return state.afterWriteTickInfo = null, afterWrite(stream, state, count, cb);
  }
  function afterWrite(stream, state, count, cb) {
    if (!state.ending && !stream.destroyed && state.length === 0 && state.needDrain)
      state.needDrain = !1, stream.emit("drain");
    while (count-- > 0)
      state.pendingcb--, cb();
    if (state.destroyed)
      errorBuffer(state);
    finishMaybe(stream, state);
  }
  function errorBuffer(state) {
    if (state.writing)
      return;
    for (let n = state.bufferedIndex;n < state.buffered.length; ++n) {
      var _state$errored;
      let { chunk, callback } = state.buffered[n], len = state.objectMode ? 1 : chunk.length;
      state.length -= len, callback((_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write"));
    }
    let onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++) {
      var _state$errored2;
      onfinishCallbacks[i]((_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end"));
    }
    resetBuffer(state);
  }
  function clearBuffer(stream, state) {
    if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed)
      return;
    let { buffered, bufferedIndex, objectMode } = state, bufferedLength = buffered.length - bufferedIndex;
    if (!bufferedLength)
      return;
    let i = bufferedIndex;
    if (state.bufferProcessing = !0, bufferedLength > 1 && stream._writev) {
      state.pendingcb -= bufferedLength - 1;
      let callback = state.allNoop ? nop : (err) => {
        for (let n = i;n < buffered.length; ++n)
          buffered[n].callback(err);
      }, chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
      chunks.allBuffers = state.allBuffers, doWrite(stream, state, !0, state.length, chunks, "", callback), resetBuffer(state);
    } else {
      do {
        let { chunk, encoding, callback } = buffered[i];
        buffered[i++] = null;
        let len = objectMode ? 1 : chunk.length;
        doWrite(stream, state, !1, len, chunk, encoding, callback);
      } while (i < buffered.length && !state.writing);
      if (i === buffered.length)
        resetBuffer(state);
      else if (i > 256)
        buffered.splice(0, i), state.bufferedIndex = 0;
      else
        state.bufferedIndex = i;
    }
    state.bufferProcessing = !1;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    if (this._writev)
      this._writev([
        {
          chunk,
          encoding
        }
      ], cb);
    else
      throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    let state = this._writableState;
    if (typeof chunk === "function")
      cb = chunk, chunk = null, encoding = null;
    else if (typeof encoding === "function")
      cb = encoding, encoding = null;
    let err;
    if (chunk !== null && chunk !== void 0) {
      let ret = _write(this, chunk, encoding);
      if (ret instanceof Error2)
        err = ret;
    }
    if (state.corked)
      state.corked = 1, this.uncork();
    if (err)
      ;
    else if (!state.errored && !state.ending)
      state.ending = !0, finishMaybe(this, state, !0), state.ended = !0;
    else if (state.finished)
      err = new ERR_STREAM_ALREADY_FINISHED("end");
    else if (state.destroyed)
      err = new ERR_STREAM_DESTROYED("end");
    if (typeof cb === "function")
      if (err || state.finished)
        process2.nextTick(cb, err);
      else
        state[kOnFinished].push(cb);
    return this;
  };
  function needFinish(state) {
    return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
  }
  function callFinal(stream, state) {
    let called = !1;
    function onFinish(err) {
      if (called) {
        errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
        return;
      }
      if (called = !0, state.pendingcb--, err) {
        let onfinishCallbacks = state[kOnFinished].splice(0);
        for (let i = 0;i < onfinishCallbacks.length; i++)
          onfinishCallbacks[i](err);
        errorOrDestroy(stream, err, state.sync);
      } else if (needFinish(state))
        state.prefinished = !0, stream.emit("prefinish"), state.pendingcb++, process2.nextTick(finish, stream, state);
    }
    state.sync = !0, state.pendingcb++;
    try {
      stream._final(onFinish);
    } catch (err) {
      onFinish(err);
    }
    state.sync = !1;
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled)
      if (typeof stream._final === "function" && !state.destroyed)
        state.finalCalled = !0, callFinal(stream, state);
      else
        state.prefinished = !0, stream.emit("prefinish");
  }
  function finishMaybe(stream, state, sync) {
    if (needFinish(state)) {
      if (prefinish(stream, state), state.pendingcb === 0) {
        if (sync)
          state.pendingcb++, process2.nextTick((stream2, state2) => {
            if (needFinish(state2))
              finish(stream2, state2);
            else
              state2.pendingcb--;
          }, stream, state);
        else if (needFinish(state))
          state.pendingcb++, finish(stream, state);
      }
    }
  }
  function finish(stream, state) {
    state.pendingcb--, state.finished = !0;
    let onfinishCallbacks = state[kOnFinished].splice(0);
    for (let i = 0;i < onfinishCallbacks.length; i++)
      onfinishCallbacks[i]();
    if (stream.emit("finish"), state.autoDestroy) {
      let rState = stream._readableState;
      if (!rState || rState.autoDestroy && (rState.endEmitted || rState.readable === !1))
        stream.destroy();
    }
  }
  ObjectDefineProperties(Writable.prototype, {
    closed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.closed : !1;
      }
    },
    destroyed: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.destroyed : !1;
      },
      set(value) {
        if (this._writableState)
          this._writableState.destroyed = value;
      }
    },
    writable: {
      __proto__: null,
      get() {
        let w = this._writableState;
        return !!w && w.writable !== !1 && !w.destroyed && !w.errored && !w.ending && !w.ended;
      },
      set(val) {
        if (this._writableState)
          this._writableState.writable = !!val;
      }
    },
    writableFinished: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.finished : !1;
      }
    },
    writableObjectMode: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.objectMode : !1;
      }
    },
    writableBuffer: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.getBuffer();
      }
    },
    writableEnded: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.ending : !1;
      }
    },
    writableNeedDrain: {
      __proto__: null,
      get() {
        let wState = this._writableState;
        if (!wState)
          return !1;
        return !wState.destroyed && !wState.ending && wState.needDrain;
      }
    },
    writableHighWaterMark: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.highWaterMark;
      }
    },
    writableCorked: {
      __proto__: null,
      get() {
        return this._writableState ? this._writableState.corked : 0;
      }
    },
    writableLength: {
      __proto__: null,
      get() {
        return this._writableState && this._writableState.length;
      }
    },
    errored: {
      __proto__: null,
      enumerable: !1,
      get() {
        return this._writableState ? this._writableState.errored : null;
      }
    },
    writableAborted: {
      __proto__: null,
      enumerable: !1,
      get: function() {
        return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
      }
    }
  });
  var destroy = destroyImpl.destroy;
  Writable.prototype.destroy = function(err, cb) {
    let state = this._writableState;
    if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length))
      process2.nextTick(errorBuffer, state);
    return destroy.call(this, err, cb), this;
  };
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Writable.prototype[EE.captureRejectionSymbol] = function(err) {
    this.destroy(err);
  };
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === void 0)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Writable.fromWeb = function(writableStream, options) {
    return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
  };
  Writable.toWeb = function(streamWritable) {
    return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
  };
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS((exports, module) => {
  var process2 = require_process(), bufferModule = __require("buffer"), {
    isReadable,
    isWritable,
    isIterable,
    isNodeStream,
    isReadableNodeStream,
    isWritableNodeStream,
    isDuplexNodeStream,
    isReadableStream,
    isWritableStream
  } = require_utils5(), eos = require_end_of_stream(), {
    AbortError,
    codes: { ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_INVALID_RETURN_VALUE }
  } = require_errors3(), { destroyer } = require_destroy2(), Duplex = require_duplex(), Readable = require_readable3(), Writable = require_writable(), { createDeferredPromise } = require_util11(), from = require_from(), Blob2 = globalThis.Blob || bufferModule.Blob, isBlob = typeof Blob2 < "u" ? function(b) {
    return b instanceof Blob2;
  } : function(b) {
    return !1;
  }, AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, { FunctionPrototypeCall } = require_primordials();

  class Duplexify extends Duplex {
    constructor(options) {
      super(options);
      if ((options === null || options === void 0 ? void 0 : options.readable) === !1)
        this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0;
      if ((options === null || options === void 0 ? void 0 : options.writable) === !1)
        this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0;
    }
  }
  module.exports = function duplexify(body, name) {
    if (isDuplexNodeStream(body))
      return body;
    if (isReadableNodeStream(body))
      return _duplexify({
        readable: body
      });
    if (isWritableNodeStream(body))
      return _duplexify({
        writable: body
      });
    if (isNodeStream(body))
      return _duplexify({
        writable: !1,
        readable: !1
      });
    if (isReadableStream(body))
      return _duplexify({
        readable: Readable.fromWeb(body)
      });
    if (isWritableStream(body))
      return _duplexify({
        writable: Writable.fromWeb(body)
      });
    if (typeof body === "function") {
      let { value, write, final, destroy } = fromAsyncGen(body);
      if (isIterable(value))
        return from(Duplexify, value, {
          objectMode: !0,
          write,
          final,
          destroy
        });
      let then2 = value === null || value === void 0 ? void 0 : value.then;
      if (typeof then2 === "function") {
        let d, promise = FunctionPrototypeCall(then2, value, (val) => {
          if (val != null)
            throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
        }, (err) => {
          destroyer(d, err);
        });
        return d = new Duplexify({
          objectMode: !0,
          readable: !1,
          write,
          final(cb) {
            final(async () => {
              try {
                await promise, process2.nextTick(cb, null);
              } catch (err) {
                process2.nextTick(cb, err);
              }
            });
          },
          destroy
        });
      }
      throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
    }
    if (isBlob(body))
      return duplexify(body.arrayBuffer());
    if (isIterable(body))
      return from(Duplexify, body, {
        objectMode: !0,
        writable: !1
      });
    if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable))
      return Duplexify.fromWeb(body);
    if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
      let readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0, writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
      return _duplexify({
        readable,
        writable
      });
    }
    let then = body === null || body === void 0 ? void 0 : body.then;
    if (typeof then === "function") {
      let d;
      return FunctionPrototypeCall(then, body, (val) => {
        if (val != null)
          d.push(val);
        d.push(null);
      }, (err) => {
        destroyer(d, err);
      }), d = new Duplexify({
        objectMode: !0,
        writable: !1,
        read() {}
      });
    }
    throw new ERR_INVALID_ARG_TYPE2(name, [
      "Blob",
      "ReadableStream",
      "WritableStream",
      "Stream",
      "Iterable",
      "AsyncIterable",
      "Function",
      "{ readable, writable } pair",
      "Promise"
    ], body);
  };
  function fromAsyncGen(fn) {
    let { promise, resolve } = createDeferredPromise(), ac = new AbortController2, signal = ac.signal;
    return {
      value: fn(async function* () {
        while (!0) {
          let _promise = promise;
          promise = null;
          let { chunk, done, cb } = await _promise;
          if (process2.nextTick(cb), done)
            return;
          if (signal.aborted)
            throw new AbortError(void 0, {
              cause: signal.reason
            });
          ({ promise, resolve } = createDeferredPromise()), yield chunk;
        }
      }(), {
        signal
      }),
      write(chunk, encoding, cb) {
        let _resolve = resolve;
        resolve = null, _resolve({
          chunk,
          done: !1,
          cb
        });
      },
      final(cb) {
        let _resolve = resolve;
        resolve = null, _resolve({
          done: !0,
          cb
        });
      },
      destroy(err, cb) {
        ac.abort(), cb(err);
      }
    };
  }
  function _duplexify(pair) {
    let r = pair.readable && typeof pair.readable.read !== "function" ? Readable.wrap(pair.readable) : pair.readable, w = pair.writable, readable = !!isReadable(r), writable = !!isWritable(w), ondrain, onfinish, onreadable, onclose, d;
    function onfinished(err) {
      let cb = onclose;
      if (onclose = null, cb)
        cb(err);
      else if (err)
        d.destroy(err);
    }
    if (d = new Duplexify({
      readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
      writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
      readable,
      writable
    }), writable)
      eos(w, (err) => {
        if (writable = !1, err)
          destroyer(r, err);
        onfinished(err);
      }), d._write = function(chunk, encoding, callback) {
        if (w.write(chunk, encoding))
          callback();
        else
          ondrain = callback;
      }, d._final = function(callback) {
        w.end(), onfinish = callback;
      }, w.on("drain", function() {
        if (ondrain) {
          let cb = ondrain;
          ondrain = null, cb();
        }
      }), w.on("finish", function() {
        if (onfinish) {
          let cb = onfinish;
          onfinish = null, cb();
        }
      });
    if (readable)
      eos(r, (err) => {
        if (readable = !1, err)
          destroyer(r, err);
        onfinished(err);
      }), r.on("readable", function() {
        if (onreadable) {
          let cb = onreadable;
          onreadable = null, cb();
        }
      }), r.on("end", function() {
        d.push(null);
      }), d._read = function() {
        while (!0) {
          let buf = r.read();
          if (buf === null) {
            onreadable = d._read;
            return;
          }
          if (!d.push(buf))
            return;
        }
      };
    return d._destroy = function(err, callback) {
      if (!err && onclose !== null)
        err = new AbortError;
      if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
        callback(err);
      else
        onclose = callback, destroyer(w, err), destroyer(r, err);
    }, d;
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS((exports, module) => {
  var {
    ObjectDefineProperties,
    ObjectGetOwnPropertyDescriptor,
    ObjectKeys,
    ObjectSetPrototypeOf
  } = require_primordials();
  module.exports = Duplex;
  var Readable = require_readable3(), Writable = require_writable();
  ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
  ObjectSetPrototypeOf(Duplex, Readable);
  {
    let keys = ObjectKeys(Writable.prototype);
    for (let i = 0;i < keys.length; i++) {
      let method = keys[i];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    if (Readable.call(this, options), Writable.call(this, options), options) {
      if (this.allowHalfOpen = options.allowHalfOpen !== !1, options.readable === !1)
        this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0;
      if (options.writable === !1)
        this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0;
    } else
      this.allowHalfOpen = !0;
  }
  ObjectDefineProperties(Duplex.prototype, {
    writable: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
    },
    writableHighWaterMark: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
    },
    writableObjectMode: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
    },
    writableBuffer: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
    },
    writableLength: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
    },
    writableFinished: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
    },
    writableCorked: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
    },
    writableEnded: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
    },
    writableNeedDrain: {
      __proto__: null,
      ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
    },
    destroyed: {
      __proto__: null,
      get() {
        if (this._readableState === void 0 || this._writableState === void 0)
          return !1;
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set(value) {
        if (this._readableState && this._writableState)
          this._readableState.destroyed = value, this._writableState.destroyed = value;
      }
    }
  });
  var webStreamsAdapters;
  function lazyWebStreams() {
    if (webStreamsAdapters === void 0)
      webStreamsAdapters = {};
    return webStreamsAdapters;
  }
  Duplex.fromWeb = function(pair, options) {
    return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
  };
  Duplex.toWeb = function(duplex) {
    return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
  };
  var duplexify;
  Duplex.from = function(body) {
    if (!duplexify)
      duplexify = require_duplexify();
    return duplexify(body, "body");
  };
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
  module.exports = Transform;
  var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors3().codes, Duplex = require_duplex(), { getHighWaterMark } = require_state4();
  ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
  ObjectSetPrototypeOf(Transform, Duplex);
  var kCallback = Symbol2("kCallback");
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    let readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", !0) : null;
    if (readableHighWaterMark === 0)
      options = {
        ...options,
        highWaterMark: null,
        readableHighWaterMark,
        writableHighWaterMark: options.writableHighWaterMark || 0
      };
    if (Duplex.call(this, options), this._readableState.sync = !1, this[kCallback] = null, options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function final(cb) {
    if (typeof this._flush === "function" && !this.destroyed)
      this._flush((er, data) => {
        if (er) {
          if (cb)
            cb(er);
          else
            this.destroy(er);
          return;
        }
        if (data != null)
          this.push(data);
        if (this.push(null), cb)
          cb();
      });
    else if (this.push(null), cb)
      cb();
  }
  function prefinish() {
    if (this._final !== final)
      final.call(this);
  }
  Transform.prototype._final = final;
  Transform.prototype._transform = function(chunk, encoding, callback) {
    throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
  };
  Transform.prototype._write = function(chunk, encoding, callback) {
    let rState = this._readableState, wState = this._writableState, length = rState.length;
    this._transform(chunk, encoding, (err, val) => {
      if (err) {
        callback(err);
        return;
      }
      if (val != null)
        this.push(val);
      if (wState.ended || length === rState.length || rState.length < rState.highWaterMark)
        callback();
      else
        this[kCallback] = callback;
    });
  };
  Transform.prototype._read = function() {
    if (this[kCallback]) {
      let callback = this[kCallback];
      this[kCallback] = null, callback();
    }
  };
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough2 = __commonJS((exports, module) => {
  var { ObjectSetPrototypeOf } = require_primordials();
  module.exports = PassThrough;
  var Transform = require_transform();
  ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
  ObjectSetPrototypeOf(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline4 = __commonJS((exports, module) => {
  var process2 = require_process(), { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials(), eos = require_end_of_stream(), { once } = require_util11(), destroyImpl = require_destroy2(), Duplex = require_duplex(), {
    aggregateTwoErrors,
    codes: {
      ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2,
      ERR_INVALID_RETURN_VALUE,
      ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_PREMATURE_CLOSE
    },
    AbortError
  } = require_errors3(), { validateFunction, validateAbortSignal } = require_validators(), {
    isIterable,
    isReadable,
    isReadableNodeStream,
    isNodeStream,
    isTransformStream,
    isWebStream,
    isReadableStream,
    isReadableFinished
  } = require_utils5(), AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, PassThrough, Readable, addAbortListener;
  function destroyer(stream, reading, writing) {
    let finished = !1;
    stream.on("close", () => {
      finished = !0;
    });
    let cleanup = eos(stream, {
      readable: reading,
      writable: writing
    }, (err) => {
      finished = !err;
    });
    return {
      destroy: (err) => {
        if (finished)
          return;
        finished = !0, destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
      },
      cleanup
    };
  }
  function popCallback(streams) {
    return validateFunction(streams[streams.length - 1], "streams[stream.length - 1]"), streams.pop();
  }
  function makeAsyncIterable(val) {
    if (isIterable(val))
      return val;
    else if (isReadableNodeStream(val))
      return fromReadable(val);
    throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable"], val);
  }
  async function* fromReadable(val) {
    if (!Readable)
      Readable = require_readable3();
    yield* Readable.prototype[SymbolAsyncIterator].call(val);
  }
  async function pumpToNode(iterable, writable, finish, { end }) {
    let error, onresolve = null, resume = (err) => {
      if (err)
        error = err;
      if (onresolve) {
        let callback = onresolve;
        onresolve = null, callback();
      }
    }, wait = () => new Promise2((resolve, reject) => {
      if (error)
        reject(error);
      else
        onresolve = () => {
          if (error)
            reject(error);
          else
            resolve();
        };
    });
    writable.on("drain", resume);
    let cleanup = eos(writable, {
      readable: !1
    }, resume);
    try {
      if (writable.writableNeedDrain)
        await wait();
      for await (let chunk of iterable)
        if (!writable.write(chunk))
          await wait();
      if (end)
        writable.end(), await wait();
      finish();
    } catch (err) {
      finish(error !== err ? aggregateTwoErrors(error, err) : err);
    } finally {
      cleanup(), writable.off("drain", resume);
    }
  }
  async function pumpToWeb(readable, writable, finish, { end }) {
    if (isTransformStream(writable))
      writable = writable.writable;
    let writer = writable.getWriter();
    try {
      for await (let chunk of readable)
        await writer.ready, writer.write(chunk).catch(() => {});
      if (await writer.ready, end)
        await writer.close();
      finish();
    } catch (err) {
      try {
        await writer.abort(err), finish(err);
      } catch (err2) {
        finish(err2);
      }
    }
  }
  function pipeline(...streams) {
    return pipelineImpl(streams, once(popCallback(streams)));
  }
  function pipelineImpl(streams, callback, opts) {
    if (streams.length === 1 && ArrayIsArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2)
      throw new ERR_MISSING_ARGS("streams");
    let ac = new AbortController2, signal = ac.signal, outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal, lastStreamCleanup = [];
    validateAbortSignal(outerSignal, "options.signal");
    function abort() {
      finishImpl(new AbortError);
    }
    addAbortListener = addAbortListener || require_util11().addAbortListener;
    let disposable;
    if (outerSignal)
      disposable = addAbortListener(outerSignal, abort);
    let error, value, destroys = [], finishCount = 0;
    function finish(err) {
      finishImpl(err, --finishCount === 0);
    }
    function finishImpl(err, final) {
      var _disposable;
      if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE"))
        error = err;
      if (!error && !final)
        return;
      while (destroys.length)
        destroys.shift()(error);
      if ((_disposable = disposable) === null || _disposable === void 0 || _disposable[SymbolDispose](), ac.abort(), final) {
        if (!error)
          lastStreamCleanup.forEach((fn) => fn());
        process2.nextTick(callback, error, value);
      }
    }
    let ret;
    for (let i = 0;i < streams.length; i++) {
      let stream = streams[i], reading = i < streams.length - 1, writing = i > 0, end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== !1, isLastStream = i === streams.length - 1;
      if (isNodeStream(stream)) {
        let onError2 = function(err) {
          if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE")
            finish(err);
        };
        var onError = onError2;
        if (end) {
          let { destroy, cleanup } = destroyer(stream, reading, writing);
          if (destroys.push(destroy), isReadable(stream) && isLastStream)
            lastStreamCleanup.push(cleanup);
        }
        if (stream.on("error", onError2), isReadable(stream) && isLastStream)
          lastStreamCleanup.push(() => {
            stream.removeListener("error", onError2);
          });
      }
      if (i === 0)
        if (typeof stream === "function") {
          if (ret = stream({
            signal
          }), !isIterable(ret))
            throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
        } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream))
          ret = stream;
        else
          ret = Duplex.from(stream);
      else if (typeof stream === "function") {
        if (isTransformStream(ret)) {
          var _ret;
          ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
        } else
          ret = makeAsyncIterable(ret);
        if (ret = stream(ret, {
          signal
        }), reading) {
          if (!isIterable(ret, !0))
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
        } else {
          var _ret2;
          if (!PassThrough)
            PassThrough = require_passthrough2();
          let pt = new PassThrough({
            objectMode: !0
          }), then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
          if (typeof then === "function")
            finishCount++, then.call(ret, (val) => {
              if (value = val, val != null)
                pt.write(val);
              if (end)
                pt.end();
              process2.nextTick(finish);
            }, (err) => {
              pt.destroy(err), process2.nextTick(finish, err);
            });
          else if (isIterable(ret, !0))
            finishCount++, pumpToNode(ret, pt, finish, {
              end
            });
          else if (isReadableStream(ret) || isTransformStream(ret)) {
            let toRead = ret.readable || ret;
            finishCount++, pumpToNode(toRead, pt, finish, {
              end
            });
          } else
            throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
          ret = pt;
          let { destroy, cleanup } = destroyer(ret, !1, !0);
          if (destroys.push(destroy), isLastStream)
            lastStreamCleanup.push(cleanup);
        }
      } else if (isNodeStream(stream)) {
        if (isReadableNodeStream(ret)) {
          finishCount += 2;
          let cleanup = pipe(ret, stream, finish, {
            end
          });
          if (isReadable(stream) && isLastStream)
            lastStreamCleanup.push(cleanup);
        } else if (isTransformStream(ret) || isReadableStream(ret)) {
          let toRead = ret.readable || ret;
          finishCount++, pumpToNode(toRead, stream, finish, {
            end
          });
        } else if (isIterable(ret))
          finishCount++, pumpToNode(ret, stream, finish, {
            end
          });
        else
          throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        ret = stream;
      } else if (isWebStream(stream)) {
        if (isReadableNodeStream(ret))
          finishCount++, pumpToWeb(makeAsyncIterable(ret), stream, finish, {
            end
          });
        else if (isReadableStream(ret) || isIterable(ret))
          finishCount++, pumpToWeb(ret, stream, finish, {
            end
          });
        else if (isTransformStream(ret))
          finishCount++, pumpToWeb(ret.readable, stream, finish, {
            end
          });
        else
          throw new ERR_INVALID_ARG_TYPE2("val", ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"], ret);
        ret = stream;
      } else
        ret = Duplex.from(stream);
    }
    if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted)
      process2.nextTick(abort);
    return ret;
  }
  function pipe(src, dst, finish, { end }) {
    let ended = !1;
    if (dst.on("close", () => {
      if (!ended)
        finish(new ERR_STREAM_PREMATURE_CLOSE);
    }), src.pipe(dst, {
      end: !1
    }), end) {
      let endFn2 = function() {
        ended = !0, dst.end();
      };
      var endFn = endFn2;
      if (isReadableFinished(src))
        process2.nextTick(endFn2);
      else
        src.once("end", endFn2);
    } else
      finish();
    return eos(src, {
      readable: !0,
      writable: !1
    }, (err) => {
      let rState = src._readableState;
      if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted)
        src.once("end", finish).once("error", finish);
      else
        finish(err);
    }), eos(dst, {
      readable: !1,
      writable: !0
    }, finish);
  }
  module.exports = {
    pipelineImpl,
    pipeline
  };
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS((exports, module) => {
  var { pipeline } = require_pipeline4(), Duplex = require_duplex(), { destroyer } = require_destroy2(), {
    isNodeStream,
    isReadable,
    isWritable,
    isWebStream,
    isTransformStream,
    isWritableStream,
    isReadableStream
  } = require_utils5(), {
    AbortError,
    codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
  } = require_errors3(), eos = require_end_of_stream();
  module.exports = function(...streams) {
    if (streams.length === 0)
      throw new ERR_MISSING_ARGS("streams");
    if (streams.length === 1)
      return Duplex.from(streams[0]);
    let orgStreams = [...streams];
    if (typeof streams[0] === "function")
      streams[0] = Duplex.from(streams[0]);
    if (typeof streams[streams.length - 1] === "function") {
      let idx = streams.length - 1;
      streams[idx] = Duplex.from(streams[idx]);
    }
    for (let n = 0;n < streams.length; ++n) {
      if (!isNodeStream(streams[n]) && !isWebStream(streams[n]))
        continue;
      if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n])))
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
      if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n])))
        throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
    }
    let ondrain, onfinish, onreadable, onclose, d;
    function onfinished(err) {
      let cb = onclose;
      if (onclose = null, cb)
        cb(err);
      else if (err)
        d.destroy(err);
      else if (!readable && !writable)
        d.destroy();
    }
    let head = streams[0], tail = pipeline(streams, onfinished), writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head)), readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
    if (d = new Duplex({
      writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
      readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
      writable,
      readable
    }), writable) {
      if (isNodeStream(head))
        d._write = function(chunk, encoding, callback) {
          if (head.write(chunk, encoding))
            callback();
          else
            ondrain = callback;
        }, d._final = function(callback) {
          head.end(), onfinish = callback;
        }, head.on("drain", function() {
          if (ondrain) {
            let cb = ondrain;
            ondrain = null, cb();
          }
        });
      else if (isWebStream(head)) {
        let writer = (isTransformStream(head) ? head.writable : head).getWriter();
        d._write = async function(chunk, encoding, callback) {
          try {
            await writer.ready, writer.write(chunk).catch(() => {}), callback();
          } catch (err) {
            callback(err);
          }
        }, d._final = async function(callback) {
          try {
            await writer.ready, writer.close().catch(() => {}), onfinish = callback;
          } catch (err) {
            callback(err);
          }
        };
      }
      let toRead = isTransformStream(tail) ? tail.readable : tail;
      eos(toRead, () => {
        if (onfinish) {
          let cb = onfinish;
          onfinish = null, cb();
        }
      });
    }
    if (readable) {
      if (isNodeStream(tail))
        tail.on("readable", function() {
          if (onreadable) {
            let cb = onreadable;
            onreadable = null, cb();
          }
        }), tail.on("end", function() {
          d.push(null);
        }), d._read = function() {
          while (!0) {
            let buf = tail.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf))
              return;
          }
        };
      else if (isWebStream(tail)) {
        let reader = (isTransformStream(tail) ? tail.readable : tail).getReader();
        d._read = async function() {
          while (!0)
            try {
              let { value, done } = await reader.read();
              if (!d.push(value))
                return;
              if (done) {
                d.push(null);
                return;
              }
            } catch {
              return;
            }
        };
      }
    }
    return d._destroy = function(err, callback) {
      if (!err && onclose !== null)
        err = new AbortError;
      if (onreadable = null, ondrain = null, onfinish = null, onclose === null)
        callback(err);
      else if (onclose = callback, isNodeStream(tail))
        destroyer(tail, err);
    }, d;
  };
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS((exports, module) => {
  var AbortController2 = globalThis.AbortController || require_abort_controller().AbortController, {
    codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE: ERR_INVALID_ARG_TYPE2, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
    AbortError
  } = require_errors3(), { validateAbortSignal, validateInteger, validateObject } = require_validators(), kWeakHandler = require_primordials().Symbol("kWeak"), kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation"), { finished } = require_end_of_stream(), staticCompose = require_compose(), { addAbortSignalNoValidate } = require_add_abort_signal(), { isWritable, isNodeStream } = require_utils5(), { deprecate } = require_util11(), {
    ArrayPrototypePush,
    Boolean: Boolean2,
    MathFloor,
    Number: Number2,
    NumberIsNaN,
    Promise: Promise2,
    PromiseReject,
    PromiseResolve,
    PromisePrototypeThen,
    Symbol: Symbol2
  } = require_primordials(), kEmpty = Symbol2("kEmpty"), kEof = Symbol2("kEof");
  function compose(stream, options) {
    if (options != null)
      validateObject(options, "options");
    if ((options === null || options === void 0 ? void 0 : options.signal) != null)
      validateAbortSignal(options.signal, "options.signal");
    if (isNodeStream(stream) && !isWritable(stream))
      throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
    let composedStream = staticCompose(this, stream);
    if (options !== null && options !== void 0 && options.signal)
      addAbortSignalNoValidate(options.signal, composedStream);
    return composedStream;
  }
  function map(fn, options) {
    if (typeof fn !== "function")
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    if (options != null)
      validateObject(options, "options");
    if ((options === null || options === void 0 ? void 0 : options.signal) != null)
      validateAbortSignal(options.signal, "options.signal");
    let concurrency = 1;
    if ((options === null || options === void 0 ? void 0 : options.concurrency) != null)
      concurrency = MathFloor(options.concurrency);
    let highWaterMark = concurrency - 1;
    if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null)
      highWaterMark = MathFloor(options.highWaterMark);
    return validateInteger(concurrency, "options.concurrency", 1), validateInteger(highWaterMark, "options.highWaterMark", 0), highWaterMark += concurrency, async function* () {
      let signal = require_util11().AbortSignalAny([options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)), stream = this, queue = [], signalOpt = {
        signal
      }, next, resume, done = !1, cnt = 0;
      function onCatch() {
        done = !0, afterItemProcessed();
      }
      function afterItemProcessed() {
        cnt -= 1, maybeResume();
      }
      function maybeResume() {
        if (resume && !done && cnt < concurrency && queue.length < highWaterMark)
          resume(), resume = null;
      }
      async function pump() {
        try {
          for await (let val of stream) {
            if (done)
              return;
            if (signal.aborted)
              throw new AbortError;
            try {
              if (val = fn(val, signalOpt), val === kEmpty)
                continue;
              val = PromiseResolve(val);
            } catch (err) {
              val = PromiseReject(err);
            }
            if (cnt += 1, PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val), next)
              next(), next = null;
            if (!done && (queue.length >= highWaterMark || cnt >= concurrency))
              await new Promise2((resolve) => {
                resume = resolve;
              });
          }
          queue.push(kEof);
        } catch (err) {
          let val = PromiseReject(err);
          PromisePrototypeThen(val, afterItemProcessed, onCatch), queue.push(val);
        } finally {
          if (done = !0, next)
            next(), next = null;
        }
      }
      pump();
      try {
        while (!0) {
          while (queue.length > 0) {
            let val = await queue[0];
            if (val === kEof)
              return;
            if (signal.aborted)
              throw new AbortError;
            if (val !== kEmpty)
              yield val;
            queue.shift(), maybeResume();
          }
          await new Promise2((resolve) => {
            next = resolve;
          });
        }
      } finally {
        if (done = !0, resume)
          resume(), resume = null;
      }
    }.call(this);
  }
  function asIndexedPairs(options = void 0) {
    if (options != null)
      validateObject(options, "options");
    if ((options === null || options === void 0 ? void 0 : options.signal) != null)
      validateAbortSignal(options.signal, "options.signal");
    return async function* () {
      let index = 0;
      for await (let val of this) {
        var _options$signal;
        if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted)
          throw new AbortError({
            cause: options.signal.reason
          });
        yield [index++, val];
      }
    }.call(this);
  }
  async function some(fn, options = void 0) {
    for await (let unused of filter.call(this, fn, options))
      return !0;
    return !1;
  }
  async function every(fn, options = void 0) {
    if (typeof fn !== "function")
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    return !await some.call(this, async (...args) => {
      return !await fn(...args);
    }, options);
  }
  async function find(fn, options) {
    for await (let result of filter.call(this, fn, options))
      return result;
    return;
  }
  async function forEach(fn, options) {
    if (typeof fn !== "function")
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    async function forEachFn(value, options2) {
      return await fn(value, options2), kEmpty;
    }
    for await (let unused of map.call(this, forEachFn, options))
      ;
  }
  function filter(fn, options) {
    if (typeof fn !== "function")
      throw new ERR_INVALID_ARG_TYPE2("fn", ["Function", "AsyncFunction"], fn);
    async function filterFn(value, options2) {
      if (await fn(value, options2))
        return value;
      return kEmpty;
    }
    return map.call(this, filterFn, options);
  }

  class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
    constructor() {
      super("reduce");
      this.message = "Reduce of an empty stream requires an initial value";
    }
  }
  async function reduce(reducer, initialValue, options) {
    var _options$signal2;
    if (typeof reducer !== "function")
      throw new ERR_INVALID_ARG_TYPE2("reducer", ["Function", "AsyncFunction"], reducer);
    if (options != null)
      validateObject(options, "options");
    if ((options === null || options === void 0 ? void 0 : options.signal) != null)
      validateAbortSignal(options.signal, "options.signal");
    let hasInitialValue = arguments.length > 1;
    if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
      let err = new AbortError(void 0, {
        cause: options.signal.reason
      });
      throw this.once("error", () => {}), await finished(this.destroy(err)), err;
    }
    let ac = new AbortController2, signal = ac.signal;
    if (options !== null && options !== void 0 && options.signal) {
      let opts = {
        once: !0,
        [kWeakHandler]: this,
        [kResistStopPropagation]: !0
      };
      options.signal.addEventListener("abort", () => ac.abort(), opts);
    }
    let gotAnyItemFromStream = !1;
    try {
      for await (let value of this) {
        var _options$signal3;
        if (gotAnyItemFromStream = !0, options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted)
          throw new AbortError;
        if (!hasInitialValue)
          initialValue = value, hasInitialValue = !0;
        else
          initialValue = await reducer(initialValue, value, {
            signal
          });
      }
      if (!gotAnyItemFromStream && !hasInitialValue)
        throw new ReduceAwareErrMissingArgs;
    } finally {
      ac.abort();
    }
    return initialValue;
  }
  async function toArray(options) {
    if (options != null)
      validateObject(options, "options");
    if ((options === null || options === void 0 ? void 0 : options.signal) != null)
      validateAbortSignal(options.signal, "options.signal");
    let result = [];
    for await (let val of this) {
      var _options$signal4;
      if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted)
        throw new AbortError(void 0, {
          cause: options.signal.reason
        });
      ArrayPrototypePush(result, val);
    }
    return result;
  }
  function flatMap(fn, options) {
    let values = map.call(this, fn, options);
    return async function* () {
      for await (let val of values)
        yield* val;
    }.call(this);
  }
  function toIntegerOrInfinity(number) {
    if (number = Number2(number), NumberIsNaN(number))
      return 0;
    if (number < 0)
      throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
    return number;
  }
  function drop(number, options = void 0) {
    if (options != null)
      validateObject(options, "options");
    if ((options === null || options === void 0 ? void 0 : options.signal) != null)
      validateAbortSignal(options.signal, "options.signal");
    return number = toIntegerOrInfinity(number), async function* () {
      var _options$signal5;
      if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted)
        throw new AbortError;
      for await (let val of this) {
        var _options$signal6;
        if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted)
          throw new AbortError;
        if (number-- <= 0)
          yield val;
      }
    }.call(this);
  }
  function take(number, options = void 0) {
    if (options != null)
      validateObject(options, "options");
    if ((options === null || options === void 0 ? void 0 : options.signal) != null)
      validateAbortSignal(options.signal, "options.signal");
    return number = toIntegerOrInfinity(number), async function* () {
      var _options$signal7;
      if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted)
        throw new AbortError;
      for await (let val of this) {
        var _options$signal8;
        if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted)
          throw new AbortError;
        if (number-- > 0)
          yield val;
        if (number <= 0)
          return;
      }
    }.call(this);
  }
  exports.streamReturningOperators = {
    asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
    drop,
    filter,
    flatMap,
    map,
    take,
    compose
  };
  exports.promiseReturningOperators = {
    every,
    forEach,
    reduce,
    toArray,
    some,
    find
  };
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS((exports, module) => {
  var { ArrayPrototypePop, Promise: Promise2 } = require_primordials(), { isIterable, isNodeStream, isWebStream } = require_utils5(), { pipelineImpl: pl } = require_pipeline4(), { finished } = require_end_of_stream();
  require_stream();
  function pipeline(...streams) {
    return new Promise2((resolve, reject) => {
      let signal, end, lastArg = streams[streams.length - 1];
      if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
        let options = ArrayPrototypePop(streams);
        signal = options.signal, end = options.end;
      }
      pl(streams, (err, value) => {
        if (err)
          reject(err);
        else
          resolve(value);
      }, {
        signal,
        end
      });
    });
  }
  module.exports = {
    finished,
    pipeline
  };
});

// node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("buffer"), { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials(), {
    promisify: { custom: customPromisify }
  } = require_util11(), { streamReturningOperators, promiseReturningOperators } = require_operators(), {
    codes: { ERR_ILLEGAL_CONSTRUCTOR }
  } = require_errors3(), compose = require_compose(), { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state4(), { pipeline } = require_pipeline4(), { destroyer } = require_destroy2(), eos = require_end_of_stream(), promises = require_promises(), utils = require_utils5(), Stream = module.exports = require_legacy().Stream;
  Stream.isDestroyed = utils.isDestroyed;
  Stream.isDisturbed = utils.isDisturbed;
  Stream.isErrored = utils.isErrored;
  Stream.isReadable = utils.isReadable;
  Stream.isWritable = utils.isWritable;
  Stream.Readable = require_readable3();
  for (let key of ObjectKeys(streamReturningOperators)) {
    let fn2 = function(...args) {
      if (new.target)
        throw ERR_ILLEGAL_CONSTRUCTOR();
      return Stream.Readable.from(ReflectApply(op, this, args));
    };
    fn = fn2;
    let op = streamReturningOperators[key];
    ObjectDefineProperty(fn2, "name", {
      __proto__: null,
      value: op.name
    }), ObjectDefineProperty(fn2, "length", {
      __proto__: null,
      value: op.length
    }), ObjectDefineProperty(Stream.Readable.prototype, key, {
      __proto__: null,
      value: fn2,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  var fn;
  for (let key of ObjectKeys(promiseReturningOperators)) {
    let fn2 = function(...args) {
      if (new.target)
        throw ERR_ILLEGAL_CONSTRUCTOR();
      return ReflectApply(op, this, args);
    };
    fn = fn2;
    let op = promiseReturningOperators[key];
    ObjectDefineProperty(fn2, "name", {
      __proto__: null,
      value: op.name
    }), ObjectDefineProperty(fn2, "length", {
      __proto__: null,
      value: op.length
    }), ObjectDefineProperty(Stream.Readable.prototype, key, {
      __proto__: null,
      value: fn2,
      enumerable: !1,
      configurable: !0,
      writable: !0
    });
  }
  var fn;
  Stream.Writable = require_writable();
  Stream.Duplex = require_duplex();
  Stream.Transform = require_transform();
  Stream.PassThrough = require_passthrough2();
  Stream.pipeline = pipeline;
  var { addAbortSignal } = require_add_abort_signal();
  Stream.addAbortSignal = addAbortSignal;
  Stream.finished = eos;
  Stream.destroy = destroyer;
  Stream.compose = compose;
  Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
  Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
  ObjectDefineProperty(Stream, "promises", {
    __proto__: null,
    configurable: !0,
    enumerable: !0,
    get() {
      return promises;
    }
  });
  ObjectDefineProperty(pipeline, customPromisify, {
    __proto__: null,
    enumerable: !0,
    get() {
      return promises.pipeline;
    }
  });
  ObjectDefineProperty(eos, customPromisify, {
    __proto__: null,
    enumerable: !0,
    get() {
      return promises.finished;
    }
  });
  Stream.Stream = Stream;
  Stream._isUint8Array = function(value) {
    return value instanceof Uint8Array;
  };
  Stream._uint8ArrayToBuffer = function(chunk) {
    return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  };
});

// node_modules/readable-stream/lib/ours/index.js
var require_ours = __commonJS((exports, module) => {
  var Stream = __require("stream");
  if (Stream && process.env.READABLE_STREAM === "disable") {
    let promises = Stream.promises;
    module.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer, module.exports._isUint8Array = Stream._isUint8Array, module.exports.isDisturbed = Stream.isDisturbed, module.exports.isErrored = Stream.isErrored, module.exports.isReadable = Stream.isReadable, module.exports.Readable = Stream.Readable, module.exports.Writable = Stream.Writable, module.exports.Duplex = Stream.Duplex, module.exports.Transform = Stream.Transform, module.exports.PassThrough = Stream.PassThrough, module.exports.addAbortSignal = Stream.addAbortSignal, module.exports.finished = Stream.finished, module.exports.destroy = Stream.destroy, module.exports.pipeline = Stream.pipeline, module.exports.compose = Stream.compose, Object.defineProperty(Stream, "promises", {
      configurable: !0,
      enumerable: !0,
      get() {
        return promises;
      }
    }), module.exports.Stream = Stream.Stream;
  } else {
    let CustomStream = require_stream(), promises = require_promises(), originalDestroy = CustomStream.Readable.destroy;
    module.exports = CustomStream.Readable, module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer, module.exports._isUint8Array = CustomStream._isUint8Array, module.exports.isDisturbed = CustomStream.isDisturbed, module.exports.isErrored = CustomStream.isErrored, module.exports.isReadable = CustomStream.isReadable, module.exports.Readable = CustomStream.Readable, module.exports.Writable = CustomStream.Writable, module.exports.Duplex = CustomStream.Duplex, module.exports.Transform = CustomStream.Transform, module.exports.PassThrough = CustomStream.PassThrough, module.exports.addAbortSignal = CustomStream.addAbortSignal, module.exports.finished = CustomStream.finished, module.exports.destroy = CustomStream.destroy, module.exports.destroy = originalDestroy, module.exports.pipeline = CustomStream.pipeline, module.exports.compose = CustomStream.compose, Object.defineProperty(CustomStream, "promises", {
      configurable: !0,
      enumerable: !0,
      get() {
        return promises;
      }
    }), module.exports.Stream = CustomStream.Stream;
  }
  module.exports.default = module.exports;
});

// node_modules/lodash/_arrayPush.js
var require__arrayPush = __commonJS((exports, module) => {
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length)
      array[offset + index] = values[index];
    return array;
  }
  module.exports = arrayPush;
});

// node_modules/lodash/_isFlattenable.js
var require__isFlattenable = __commonJS((exports, module) => {
  var Symbol2 = require__Symbol(), isArguments = require_isArguments(), isArray = require_isArray(), spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  module.exports = isFlattenable;
});

// node_modules/lodash/_baseFlatten.js
var require__baseFlatten = __commonJS((exports, module) => {
  var arrayPush = require__arrayPush(), isFlattenable = require__isFlattenable();
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable), result || (result = []);
    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value))
        if (depth > 1)
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        else
          arrayPush(result, value);
      else if (!isStrict)
        result[result.length] = value;
    }
    return result;
  }
  module.exports = baseFlatten;
});

// node_modules/lodash/flatten.js
var require_flatten = __commonJS((exports, module) => {
  var baseFlatten = require__baseFlatten();
  function flatten(array) {
    var length = array == null ? 0 : array.length;
    return length ? baseFlatten(array, 1) : [];
  }
  module.exports = flatten;
});

// node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative(), nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
  }
  module.exports = hashClear;
});

// node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    return this.size -= result ? 1 : 0, result;
  }
  module.exports = hashDelete;
});

// node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate(), HASH_UNDEFINED = "__lodash_hash_undefined__", objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  module.exports = hashGet;
});

// node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate(), objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  module.exports = hashHas;
});

// node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  var nativeCreate = require__nativeCreate(), HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value, this;
  }
  module.exports = hashSet;
});

// node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  var hashClear = require__hashClear(), hashDelete = require__hashDelete(), hashGet = require__hashGet(), hashHas = require__hashHas(), hashSet = require__hashSet();
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype.delete = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  function listCacheClear() {
    this.__data__ = [], this.size = 0;
  }
  module.exports = listCacheClear;
});

// node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  var eq = require_eq();
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--)
      if (eq(array[length][0], key))
        return length;
    return -1;
  }
  module.exports = assocIndexOf;
});

// node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf(), arrayProto = Array.prototype, splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0)
      return !1;
    var lastIndex = data.length - 1;
    if (index == lastIndex)
      data.pop();
    else
      splice.call(data, index, 1);
    return --this.size, !0;
  }
  module.exports = listCacheDelete;
});

// node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  module.exports = listCacheGet;
});

// node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  module.exports = listCacheHas;
});

// node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  var assocIndexOf = require__assocIndexOf();
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0)
      ++this.size, data.push([key, value]);
    else
      data[index][1] = value;
    return this;
  }
  module.exports = listCacheSet;
});

// node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  var listCacheClear = require__listCacheClear(), listCacheDelete = require__listCacheDelete(), listCacheGet = require__listCacheGet(), listCacheHas = require__listCacheHas(), listCacheSet = require__listCacheSet();
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype.delete = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative(), root = require__root(), Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  var Hash = require__Hash(), ListCache = require__ListCache(), Map2 = require__Map();
  function mapCacheClear() {
    this.size = 0, this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  module.exports = mapCacheClear;
});

// node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  module.exports = isKeyable;
});

// node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  var isKeyable = require__isKeyable();
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  module.exports = getMapData;
});

// node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key).delete(key);
    return this.size -= result ? 1 : 0, result;
  }
  module.exports = mapCacheDelete;
});

// node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  module.exports = mapCacheGet;
});

// node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  module.exports = mapCacheHas;
});

// node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  var getMapData = require__getMapData();
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    return data.set(key, value), this.size += data.size == size ? 0 : 1, this;
  }
  module.exports = mapCacheSet;
});

// node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  var mapCacheClear = require__mapCacheClear(), mapCacheDelete = require__mapCacheDelete(), mapCacheGet = require__mapCacheGet(), mapCacheHas = require__mapCacheHas(), mapCacheSet = require__mapCacheSet();
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype.delete = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    return this.__data__.set(value, HASH_UNDEFINED), this;
  }
  module.exports = setCacheAdd;
});

// node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  module.exports = setCacheHas;
});

// node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  var MapCache = require__MapCache(), setCacheAdd = require__setCacheAdd(), setCacheHas = require__setCacheHas();
  function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length)
      this.add(values[index]);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length)
      if (predicate(array[index], index, array))
        return index;
    return -1;
  }
  module.exports = baseFindIndex;
});

// node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  function baseIsNaN(value) {
    return value !== value;
  }
  module.exports = baseIsNaN;
});

// node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length)
      if (array[index] === value)
        return index;
    return -1;
  }
  module.exports = strictIndexOf;
});

// node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  var baseFindIndex = require__baseFindIndex(), baseIsNaN = require__baseIsNaN(), strictIndexOf = require__strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  module.exports = baseIndexOf;
});

// node_modules/lodash/_arrayIncludes.js
var require__arrayIncludes = __commonJS((exports, module) => {
  var baseIndexOf = require__baseIndexOf();
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  module.exports = arrayIncludes;
});

// node_modules/lodash/_arrayIncludesWith.js
var require__arrayIncludesWith = __commonJS((exports, module) => {
  function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length)
      if (comparator(value, array[index]))
        return !0;
    return !1;
  }
  module.exports = arrayIncludesWith;
});

// node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  function arrayMap(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length)
      result[index] = iteratee(array[index], index, array);
    return result;
  }
  module.exports = arrayMap;
});

// node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  module.exports = cacheHas;
});

// node_modules/lodash/_baseDifference.js
var require__baseDifference = __commonJS((exports, module) => {
  var SetCache = require__SetCache(), arrayIncludes = require__arrayIncludes(), arrayIncludesWith = require__arrayIncludesWith(), arrayMap = require__arrayMap(), baseUnary = require__baseUnary(), cacheHas = require__cacheHas(), LARGE_ARRAY_SIZE = 200;
  function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = !0, length = array.length, result = [], valuesLength = values.length;
    if (!length)
      return result;
    if (iteratee)
      values = arrayMap(values, baseUnary(iteratee));
    if (comparator)
      includes = arrayIncludesWith, isCommon = !1;
    else if (values.length >= LARGE_ARRAY_SIZE)
      includes = cacheHas, isCommon = !1, values = new SetCache(values);
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee == null ? value : iteratee(value);
        if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--)
            if (values[valuesIndex] === computed)
              continue outer;
          result.push(value);
        } else if (!includes(values, computed, comparator))
          result.push(value);
      }
    return result;
  }
  module.exports = baseDifference;
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS((exports, module) => {
  var isArrayLike = require_isArrayLike(), isObjectLike = require_isObjectLike();
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  module.exports = isArrayLikeObject;
});

// node_modules/lodash/difference.js
var require_difference = __commonJS((exports, module) => {
  var baseDifference = require__baseDifference(), baseFlatten = require__baseFlatten(), baseRest = require__baseRest(), isArrayLikeObject = require_isArrayLikeObject(), difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : [];
  });
  module.exports = difference;
});

// node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative(), root = require__root(), Set2 = getNative(root, "Set");
  module.exports = Set2;
});

// node_modules/lodash/noop.js
var require_noop = __commonJS((exports, module) => {
  function noop() {}
  module.exports = noop;
});

// node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    return set.forEach(function(value) {
      result[++index] = value;
    }), result;
  }
  module.exports = setToArray;
});

// node_modules/lodash/_createSet.js
var require__createSet = __commonJS((exports, module) => {
  var Set2 = require__Set(), noop = require_noop(), setToArray = require__setToArray(), INFINITY = 1 / 0, createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  module.exports = createSet;
});

// node_modules/lodash/_baseUniq.js
var require__baseUniq = __commonJS((exports, module) => {
  var SetCache = require__SetCache(), arrayIncludes = require__arrayIncludes(), arrayIncludesWith = require__arrayIncludesWith(), cacheHas = require__cacheHas(), createSet = require__createSet(), setToArray = require__setToArray(), LARGE_ARRAY_SIZE = 200;
  function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = !0, result = [], seen = result;
    if (comparator)
      isCommon = !1, includes = arrayIncludesWith;
    else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set)
        return setToArray(set);
      isCommon = !1, includes = cacheHas, seen = new SetCache;
    } else
      seen = iteratee ? [] : result;
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--)
            if (seen[seenIndex] === computed)
              continue outer;
          if (iteratee)
            seen.push(computed);
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result)
            seen.push(computed);
          result.push(value);
        }
      }
    return result;
  }
  module.exports = baseUniq;
});

// node_modules/lodash/union.js
var require_union = __commonJS((exports, module) => {
  var baseFlatten = require__baseFlatten(), baseRest = require__baseRest(), baseUniq = require__baseUniq(), isArrayLikeObject = require_isArrayLikeObject(), union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0));
  });
  module.exports = union;
});

// node_modules/lodash/_overArg.js
var require__overArg = __commonJS((exports, module) => {
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  module.exports = overArg;
});

// node_modules/lodash/_getPrototype.js
var require__getPrototype = __commonJS((exports, module) => {
  var overArg = require__overArg(), getPrototype = overArg(Object.getPrototypeOf, Object);
  module.exports = getPrototype;
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS((exports, module) => {
  var baseGetTag = require__baseGetTag(), getPrototype = require__getPrototype(), isObjectLike = require_isObjectLike(), objectTag = "[object Object]", funcProto = Function.prototype, objectProto = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag)
      return !1;
    var proto = getPrototype(value);
    if (proto === null)
      return !0;
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module.exports = isPlainObject;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/assert-valid-pattern.js
var require_assert_valid_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.assertValidPattern = void 0;
  var MAX_PATTERN_LENGTH = 65536, assertValidPattern = (pattern) => {
    if (typeof pattern !== "string")
      throw TypeError("invalid pattern");
    if (pattern.length > MAX_PATTERN_LENGTH)
      throw TypeError("pattern is too long");
  };
  exports.assertValidPattern = assertValidPattern;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/brace-expressions.js
var require_brace_expressions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.parseClass = void 0;
  var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
    "[:alpha:]": ["\\p{L}\\p{Nl}", !0],
    "[:ascii:]": ["\\x00-\\x7f", !1],
    "[:blank:]": ["\\p{Zs}\\t", !0],
    "[:cntrl:]": ["\\p{Cc}", !0],
    "[:digit:]": ["\\p{Nd}", !0],
    "[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
    "[:lower:]": ["\\p{Ll}", !0],
    "[:print:]": ["\\p{C}", !0],
    "[:punct:]": ["\\p{P}", !0],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
    "[:upper:]": ["\\p{Lu}", !0],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
    "[:xdigit:]": ["A-Fa-f0-9", !1]
  }, braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&"), regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), rangesToString = (ranges) => ranges.join(""), parseClass = (glob, position) => {
    let pos = position;
    if (glob.charAt(pos) !== "[")
      throw Error("not in a brace expression");
    let ranges = [], negs = [], i = pos + 1, sawStart = !1, uflag = !1, escaping = !1, negate = !1, endPos = pos, rangeStart = "";
    WHILE:
      while (i < glob.length) {
        let c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = !0, i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        if (sawStart = !0, c === "\\") {
          if (!escaping) {
            escaping = !0, i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (let [cls, [unip, u, neg]] of Object.entries(posixClasses))
            if (glob.startsWith(cls, i)) {
              if (rangeStart)
                return ["$.", !1, glob.length - pos, !0];
              if (i += cls.length, neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
        }
        if (escaping = !1, rangeStart) {
          if (c > rangeStart)
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          else if (c === rangeStart)
            ranges.push(braceEscape(c));
          rangeStart = "", i++;
          continue;
        }
        if (glob.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-")), i += 2;
          continue;
        }
        if (glob.startsWith("-", i + 1)) {
          rangeStart = c, i += 2;
          continue;
        }
        ranges.push(braceEscape(c)), i++;
      }
    if (endPos < i)
      return ["", !1, 0, !1];
    if (!ranges.length && !negs.length)
      return ["$.", !1, glob.length - pos, !0];
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
      let r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
      return [regexpEscape(r), !1, endPos - pos, !1];
    }
    let sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]", snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    return [ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs, uflag, endPos - pos, !0];
  };
  exports.parseClass = parseClass;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/unescape.js
var require_unescape = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.unescape = void 0;
  var unescape = (s, { windowsPathsNoEscape = !1 } = {}) => {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  };
  exports.unescape = unescape;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/ast.js
var require_ast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.AST = void 0;
  var brace_expressions_js_1 = require_brace_expressions(), unescape_js_1 = require_unescape(), types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]), isExtglobType = (c) => types.has(c), startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))", startNoDot = "(?!\\.)", addPatternStart = /* @__PURE__ */ new Set(["[", "."]), justDots = /* @__PURE__ */ new Set(["..", "."]), reSpecials = new Set("().*{}+?[]^$\\!"), regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), qmark = "[^/]", star = qmark + "*?", starNoEmpty = qmark + "+?";

  class AST {
    type;
    #root;
    #hasMagic;
    #uflag = !1;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = !1;
    #options;
    #toString;
    #emptyExt = !1;
    constructor(type, parent, options = {}) {
      if (this.type = type, type)
        this.#hasMagic = !0;
      if (this.#parent = parent, this.#root = this.#parent ? this.#parent.#root : this, this.#options = this.#root === this ? options : this.#root.#options, this.#negs = this.#root === this ? [] : this.#root.#negs, type === "!" && !this.#root.#filledNegs)
        this.#negs.push(this);
      this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
      if (this.#hasMagic !== void 0)
        return this.#hasMagic;
      for (let p of this.#parts) {
        if (typeof p === "string")
          continue;
        if (p.type || p.hasMagic)
          return this.#hasMagic = !0;
      }
      return this.#hasMagic;
    }
    toString() {
      if (this.#toString !== void 0)
        return this.#toString;
      if (!this.type)
        return this.#toString = this.#parts.map((p) => String(p)).join("");
      else
        return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
    }
    #fillNegs() {
      if (this !== this.#root)
        throw Error("should only call on root");
      if (this.#filledNegs)
        return this;
      this.toString(), this.#filledNegs = !0;
      let n;
      while (n = this.#negs.pop()) {
        if (n.type !== "!")
          continue;
        let p = n, pp = p.#parent;
        while (pp) {
          for (let i = p.#parentIndex + 1;!pp.type && i < pp.#parts.length; i++)
            for (let part of n.#parts) {
              if (typeof part === "string")
                throw Error("string part in extglob AST??");
              part.copyIn(pp.#parts[i]);
            }
          p = pp, pp = p.#parent;
        }
      }
      return this;
    }
    push(...parts) {
      for (let p of parts) {
        if (p === "")
          continue;
        if (typeof p !== "string" && !(p instanceof AST && p.#parent === this))
          throw Error("invalid part: " + p);
        this.#parts.push(p);
      }
    }
    toJSON() {
      let ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
      if (this.isStart() && !this.type)
        ret.unshift([]);
      if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!"))
        ret.push({});
      return ret;
    }
    isStart() {
      if (this.#root === this)
        return !0;
      if (!this.#parent?.isStart())
        return !1;
      if (this.#parentIndex === 0)
        return !0;
      let p = this.#parent;
      for (let i = 0;i < this.#parentIndex; i++) {
        let pp = p.#parts[i];
        if (!(pp instanceof AST && pp.type === "!"))
          return !1;
      }
      return !0;
    }
    isEnd() {
      if (this.#root === this)
        return !0;
      if (this.#parent?.type === "!")
        return !0;
      if (!this.#parent?.isEnd())
        return !1;
      if (!this.type)
        return this.#parent?.isEnd();
      let pl = this.#parent ? this.#parent.#parts.length : 0;
      return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
      if (typeof part === "string")
        this.push(part);
      else
        this.push(part.clone(this));
    }
    clone(parent) {
      let c = new AST(this.type, parent);
      for (let p of this.#parts)
        c.copyIn(p);
      return c;
    }
    static #parseAST(str, ast, pos, opt) {
      let escaping = !1, inBrace = !1, braceStart = -1, braceNeg = !1;
      if (ast.type === null) {
        let i2 = pos, acc2 = "";
        while (i2 < str.length) {
          let c = str.charAt(i2++);
          if (escaping || c === "\\") {
            escaping = !escaping, acc2 += c;
            continue;
          }
          if (inBrace) {
            if (i2 === braceStart + 1) {
              if (c === "^" || c === "!")
                braceNeg = !0;
            } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg))
              inBrace = !1;
            acc2 += c;
            continue;
          } else if (c === "[") {
            inBrace = !0, braceStart = i2, braceNeg = !1, acc2 += c;
            continue;
          }
          if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
            ast.push(acc2), acc2 = "";
            let ext = new AST(c, ast);
            i2 = AST.#parseAST(str, ext, i2, opt), ast.push(ext);
            continue;
          }
          acc2 += c;
        }
        return ast.push(acc2), i2;
      }
      let i = pos + 1, part = new AST(null, ast), parts = [], acc = "";
      while (i < str.length) {
        let c = str.charAt(i++);
        if (escaping || c === "\\") {
          escaping = !escaping, acc += c;
          continue;
        }
        if (inBrace) {
          if (i === braceStart + 1) {
            if (c === "^" || c === "!")
              braceNeg = !0;
          } else if (c === "]" && !(i === braceStart + 2 && braceNeg))
            inBrace = !1;
          acc += c;
          continue;
        } else if (c === "[") {
          inBrace = !0, braceStart = i, braceNeg = !1, acc += c;
          continue;
        }
        if (isExtglobType(c) && str.charAt(i) === "(") {
          part.push(acc), acc = "";
          let ext = new AST(c, part);
          part.push(ext), i = AST.#parseAST(str, ext, i, opt);
          continue;
        }
        if (c === "|") {
          part.push(acc), acc = "", parts.push(part), part = new AST(null, ast);
          continue;
        }
        if (c === ")") {
          if (acc === "" && ast.#parts.length === 0)
            ast.#emptyExt = !0;
          return part.push(acc), acc = "", ast.push(...parts, part), i;
        }
        acc += c;
      }
      return ast.type = null, ast.#hasMagic = void 0, ast.#parts = [str.substring(pos - 1)], i;
    }
    static fromGlob(pattern, options = {}) {
      let ast = new AST(null, void 0, options);
      return AST.#parseAST(pattern, ast, 0, options), ast;
    }
    toMMPattern() {
      if (this !== this.#root)
        return this.#root.toMMPattern();
      let glob = this.toString(), [re, body, hasMagic, uflag] = this.toRegExpSource();
      if (!(hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase()))
        return body;
      let flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob
      });
    }
    get options() {
      return this.#options;
    }
    toRegExpSource(allowDot) {
      let dot = allowDot ?? !!this.#options.dot;
      if (this.#root === this)
        this.#fillNegs();
      if (!this.type) {
        let noEmpty = this.isStart() && this.isEnd(), src = this.#parts.map((p) => {
          let [re, _2, hasMagic, uflag] = typeof p === "string" ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
          return this.#hasMagic = this.#hasMagic || hasMagic, this.#uflag = this.#uflag || uflag, re;
        }).join(""), start2 = "";
        if (this.isStart()) {
          if (typeof this.#parts[0] === "string") {
            if (!(this.#parts.length === 1 && justDots.has(this.#parts[0]))) {
              let aps = addPatternStart, needNoTrav = dot && aps.has(src.charAt(0)) || src.startsWith("\\.") && aps.has(src.charAt(2)) || src.startsWith("\\.\\.") && aps.has(src.charAt(4)), needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
              start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
            }
          }
        }
        let end = "";
        if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!")
          end = "(?:$|\\/)";
        return [
          start2 + src + end,
          (0, unescape_js_1.unescape)(src),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      let repeated = this.type === "*" || this.type === "+", start = this.type === "!" ? "(?:(?!(?:" : "(?:", body = this.#partsToRegExp(dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        let s = this.toString();
        return this.#parts = [s], this.type = null, this.#hasMagic = void 0, [s, (0, unescape_js_1.unescape)(this.toString()), !1, !1];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(!0);
      if (bodyDotAllowed === body)
        bodyDotAllowed = "";
      if (bodyDotAllowed)
        body = `(?:${body})(?:${bodyDotAllowed})*?`;
      let final = "";
      if (this.type === "!" && this.#emptyExt)
        final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
      else {
        let close = this.type === "!" ? "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")" : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? ")?" : `)${this.type}`;
        final = start + body + close;
      }
      return [
        final,
        (0, unescape_js_1.unescape)(body),
        this.#hasMagic = !!this.#hasMagic,
        this.#uflag
      ];
    }
    #partsToRegExp(dot) {
      return this.#parts.map((p) => {
        if (typeof p === "string")
          throw Error("string type in extglob ast??");
        let [re, _2, _hasMagic, uflag] = p.toRegExpSource(dot);
        return this.#uflag = this.#uflag || uflag, re;
      }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
    }
    static #parseGlob(glob, hasMagic, noEmpty = !1) {
      let escaping = !1, re = "", uflag = !1;
      for (let i = 0;i < glob.length; i++) {
        let c = glob.charAt(i);
        if (escaping) {
          escaping = !1, re += (reSpecials.has(c) ? "\\" : "") + c;
          continue;
        }
        if (c === "\\") {
          if (i === glob.length - 1)
            re += "\\\\";
          else
            escaping = !0;
          continue;
        }
        if (c === "[") {
          let [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
          if (consumed) {
            re += src, uflag = uflag || needUflag, i += consumed - 1, hasMagic = hasMagic || magic;
            continue;
          }
        }
        if (c === "*") {
          if (noEmpty && glob === "*")
            re += starNoEmpty;
          else
            re += star;
          hasMagic = !0;
          continue;
        }
        if (c === "?") {
          re += qmark, hasMagic = !0;
          continue;
        }
        re += regExpEscape(c);
      }
      return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    }
  }
  exports.AST = AST;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/escape.js
var require_escape = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.escape = void 0;
  var escape = (s, { windowsPathsNoEscape = !1 } = {}) => {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
  };
  exports.escape = escape;
});

// node_modules/glob/node_modules/minimatch/dist/commonjs/index.js
var require_commonjs22 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
  var brace_expansion_1 = __importDefault(require_brace_expansion()), assert_valid_pattern_js_1 = require_assert_valid_pattern(), ast_js_1 = require_ast(), escape_js_1 = require_escape(), unescape_js_1 = require_unescape(), minimatch = (p, pattern, options = {}) => {
    if ((0, assert_valid_pattern_js_1.assertValidPattern)(pattern), !options.nocomment && pattern.charAt(0) === "#")
      return !1;
    return new Minimatch(pattern, options).match(p);
  };
  exports.minimatch = minimatch;
  var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/, starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2), starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2), starDotExtTestNocase = (ext2) => {
    return ext2 = ext2.toLowerCase(), (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
  }, starDotExtTestNocaseDot = (ext2) => {
    return ext2 = ext2.toLowerCase(), (f) => f.toLowerCase().endsWith(ext2);
  }, starDotStarRE = /^\*+\.\*+$/, starDotStarTest = (f) => !f.startsWith(".") && f.includes("."), starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes("."), dotStarRE = /^\.\*+$/, dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith("."), starRE = /^\*+$/, starTest = (f) => f.length !== 0 && !f.startsWith("."), starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..", qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/, qmarksTestNocase = ([$0, ext2 = ""]) => {
    let noext = qmarksTestNoExt([$0]);
    if (!ext2)
      return noext;
    return ext2 = ext2.toLowerCase(), (f) => noext(f) && f.toLowerCase().endsWith(ext2);
  }, qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
    let noext = qmarksTestNoExtDot([$0]);
    if (!ext2)
      return noext;
    return ext2 = ext2.toLowerCase(), (f) => noext(f) && f.toLowerCase().endsWith(ext2);
  }, qmarksTestDot = ([$0, ext2 = ""]) => {
    let noext = qmarksTestNoExtDot([$0]);
    return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
  }, qmarksTest = ([$0, ext2 = ""]) => {
    let noext = qmarksTestNoExt([$0]);
    return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
  }, qmarksTestNoExt = ([$0]) => {
    let len = $0.length;
    return (f) => f.length === len && !f.startsWith(".");
  }, qmarksTestNoExtDot = ([$0]) => {
    let len = $0.length;
    return (f) => f.length === len && f !== "." && f !== "..";
  }, defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix", path = {
    win32: { sep: "\\" },
    posix: { sep: "/" }
  };
  exports.sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
  exports.minimatch.sep = exports.sep;
  exports.GLOBSTAR = Symbol("globstar **");
  exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
  var qmark = "[^/]", star = qmark + "*?", twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?", filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
  exports.filter = filter;
  exports.minimatch.filter = exports.filter;
  var ext = (a, b = {}) => Object.assign({}, a, b), defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length)
      return exports.minimatch;
    let orig = exports.minimatch;
    return Object.assign((p, pattern, options = {}) => orig(p, pattern, ext(def, options)), {
      Minimatch: class extends orig.Minimatch {
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      },
      AST: class extends orig.AST {
        constructor(type, parent, options = {}) {
          super(type, parent, ext(def, options));
        }
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      },
      unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
      escape: (s, options = {}) => orig.escape(s, ext(def, options)),
      filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
      defaults: (options) => orig.defaults(ext(def, options)),
      makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
      braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
      match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
      sep: orig.sep,
      GLOBSTAR: exports.GLOBSTAR
    });
  };
  exports.defaults = defaults;
  exports.minimatch.defaults = exports.defaults;
  var braceExpand = (pattern, options = {}) => {
    if ((0, assert_valid_pattern_js_1.assertValidPattern)(pattern), options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern))
      return [pattern];
    return (0, brace_expansion_1.default)(pattern);
  };
  exports.braceExpand = braceExpand;
  exports.minimatch.braceExpand = exports.braceExpand;
  var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
  exports.makeRe = makeRe;
  exports.minimatch.makeRe = exports.makeRe;
  var match = (list, pattern, options = {}) => {
    let mm = new Minimatch(pattern, options);
    if (list = list.filter((f) => mm.match(f)), mm.options.nonull && !list.length)
      list.push(pattern);
    return list;
  };
  exports.match = match;
  exports.minimatch.match = exports.match;
  var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/, regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");

  class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
      if ((0, assert_valid_pattern_js_1.assertValidPattern)(pattern), options = options || {}, this.options = options, this.pattern = pattern, this.platform = options.platform || defaultPlatform, this.isWindows = this.platform === "win32", this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === !1, this.windowsPathsNoEscape)
        this.pattern = this.pattern.replace(/\\/g, "/");
      this.preserveMultipleSlashes = !!options.preserveMultipleSlashes, this.regexp = null, this.negate = !1, this.nonegate = !!options.nonegate, this.comment = !1, this.empty = !1, this.partial = !!options.partial, this.nocase = !!this.options.nocase, this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase), this.globSet = [], this.globParts = [], this.set = [], this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1)
        return !0;
      for (let pattern of this.set)
        for (let part of pattern)
          if (typeof part !== "string")
            return !0;
      return !1;
    }
    debug(..._2) {}
    make() {
      let pattern = this.pattern, options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = !0;
        return;
      }
      if (!pattern) {
        this.empty = !0;
        return;
      }
      if (this.parseNegate(), this.globSet = [...new Set(this.braceExpand())], options.debug)
        this.debug = (...args) => console.error(...args);
      this.debug(this.pattern, this.globSet);
      let rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts), this.debug(this.pattern, this.globParts);
      let set = this.globParts.map((s, _2, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          let isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]), isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC)
            return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
          else if (isDrive)
            return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
        }
        return s.map((ss) => this.parse(ss));
      });
      if (this.debug(this.pattern, set), this.set = set.filter((s) => s.indexOf(!1) === -1), this.isWindows)
        for (let i = 0;i < this.set.length; i++) {
          let p = this.set[i];
          if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3]))
            p[2] = "?";
        }
      this.debug(this.pattern, this.set);
    }
    preprocess(globParts) {
      if (this.options.noglobstar) {
        for (let i = 0;i < globParts.length; i++)
          for (let j = 0;j < globParts[i].length; j++)
            if (globParts[i][j] === "**")
              globParts[i][j] = "*";
      }
      let { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2)
        globParts = this.firstPhasePreProcess(globParts), globParts = this.secondPhasePreProcess(globParts);
      else if (optimizationLevel >= 1)
        globParts = this.levelOneOptimize(globParts);
      else
        globParts = this.adjascentGlobstarOptimize(globParts);
      return globParts;
    }
    adjascentGlobstarOptimize(globParts) {
      return globParts.map((parts) => {
        let gs = -1;
        while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
          let i = gs;
          while (parts[i + 1] === "**")
            i++;
          if (i !== gs)
            parts.splice(gs, i - gs);
        }
        return parts;
      });
    }
    levelOneOptimize(globParts) {
      return globParts.map((parts) => {
        return parts = parts.reduce((set, part) => {
          let prev = set[set.length - 1];
          if (part === "**" && prev === "**")
            return set;
          if (part === "..") {
            if (prev && prev !== ".." && prev !== "." && prev !== "**")
              return set.pop(), set;
          }
          return set.push(part), set;
        }, []), parts.length === 0 ? [""] : parts;
      });
    }
    levelTwoFileOptimize(parts) {
      if (!Array.isArray(parts))
        parts = this.slashSplit(parts);
      let didSomething = !1;
      do {
        if (didSomething = !1, !this.preserveMultipleSlashes) {
          for (let i = 1;i < parts.length - 1; i++) {
            let p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "")
              didSomething = !0, parts.splice(i, 1), i--;
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === ""))
            didSomething = !0, parts.pop();
        }
        let dd = 0;
        while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
          let p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**")
            didSomething = !0, parts.splice(dd - 1, 2), dd -= 2;
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    firstPhasePreProcess(globParts) {
      let didSomething = !1;
      do {
        didSomething = !1;
        for (let parts of globParts) {
          let gs = -1;
          while ((gs = parts.indexOf("**", gs + 1)) !== -1) {
            let gss = gs;
            while (parts[gss + 1] === "**")
              gss++;
            if (gss > gs)
              parts.splice(gs + 1, gss - gs);
            let next = parts[gs + 1], p = parts[gs + 2], p2 = parts[gs + 3];
            if (next !== "..")
              continue;
            if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..")
              continue;
            didSomething = !0, parts.splice(gs, 1);
            let other = parts.slice(0);
            other[gs] = "**", globParts.push(other), gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1;i < parts.length - 1; i++) {
              let p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "")
                didSomething = !0, parts.splice(i, 1), i--;
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === ""))
              didSomething = !0, parts.pop();
          }
          let dd = 0;
          while ((dd = parts.indexOf("..", dd + 1)) !== -1) {
            let p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = !0;
              let splin = dd === 1 && parts[dd + 1] === "**" ? ["."] : [];
              if (parts.splice(dd - 1, 2, ...splin), parts.length === 0)
                parts.push("");
              dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    secondPhasePreProcess(globParts) {
      for (let i = 0;i < globParts.length - 1; i++)
        for (let j = i + 1;j < globParts.length; j++) {
          let matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
          if (matched) {
            globParts[i] = [], globParts[j] = matched;
            break;
          }
        }
      return globParts.filter((gs) => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = !1) {
      let ai = 0, bi = 0, result = [], which = "";
      while (ai < a.length && bi < b.length)
        if (a[ai] === b[bi])
          result.push(which === "b" ? b[bi] : a[ai]), ai++, bi++;
        else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1])
          result.push(a[ai]), ai++;
        else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1])
          result.push(b[bi]), bi++;
        else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
          if (which === "b")
            return !1;
          which = "a", result.push(a[ai]), ai++, bi++;
        } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
          if (which === "a")
            return !1;
          which = "b", result.push(b[bi]), ai++, bi++;
        } else
          return !1;
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate)
        return;
      let pattern = this.pattern, negate = !1, negateOffset = 0;
      for (let i = 0;i < pattern.length && pattern.charAt(i) === "!"; i++)
        negate = !negate, negateOffset++;
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    matchOne(file, pattern, partial = !1) {
      let options = this.options;
      if (this.isWindows) {
        let fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]), fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]), patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]), patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]), fdi = fileUNC ? 3 : fileDrive ? 0 : void 0, pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
        if (typeof fdi === "number" && typeof pdi === "number") {
          let [fd, pd] = [file[fdi], pattern[pdi]];
          if (fd.toLowerCase() === pd.toLowerCase()) {
            if (pattern[pdi] = fd, pdi > fdi)
              pattern = pattern.slice(pdi);
            else if (fdi > pdi)
              file = file.slice(fdi);
          }
        }
      }
      let { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2)
        file = this.levelTwoFileOptimize(file);
      this.debug("matchOne", this, { file, pattern }), this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length;fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi], f = file[fi];
        if (this.debug(pattern, p, f), p === !1)
          return !1;
        if (p === exports.GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi, pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (;fi < fl; fi++)
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return !1;
            return !0;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            if (this.debug(`
globstar while`, file, fr, pattern, pr, swallowee), this.matchOne(file.slice(fr), pattern.slice(pr), partial))
              return this.debug("globstar found match!", fr, fl, swallowee), !0;
            else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), fr++;
            }
          }
          if (partial) {
            if (this.debug(`
>>> no match, partial?`, file, fr, pattern, pr), fr === fl)
              return !0;
          }
          return !1;
        }
        let hit;
        if (typeof p === "string")
          hit = f === p, this.debug("string match", p, f, hit);
        else
          hit = p.test(f), this.debug("pattern match", p, f, hit);
        if (!hit)
          return !1;
      }
      if (fi === fl && pi === pl)
        return !0;
      else if (fi === fl)
        return partial;
      else if (pi === pl)
        return fi === fl - 1 && file[fi] === "";
      else
        throw Error("wtf?");
    }
    braceExpand() {
      return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
      (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
      let options = this.options;
      if (pattern === "**")
        return exports.GLOBSTAR;
      if (pattern === "")
        return "";
      let m, fastTest = null;
      if (m = pattern.match(starRE))
        fastTest = options.dot ? starTestDot : starTest;
      else if (m = pattern.match(starDotExtRE))
        fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
      else if (m = pattern.match(qmarksRE))
        fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
      else if (m = pattern.match(starDotStarRE))
        fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
      else if (m = pattern.match(dotStarRE))
        fastTest = dotStarTest;
      let re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
      if (fastTest && typeof re === "object")
        Reflect.defineProperty(re, "test", { value: fastTest });
      return re;
    }
    makeRe() {
      if (this.regexp || this.regexp === !1)
        return this.regexp;
      let set = this.set;
      if (!set.length)
        return this.regexp = !1, this.regexp;
      let options = this.options, twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot, flags = new Set(options.nocase ? ["i"] : []), re = set.map((pattern) => {
        let pp = pattern.map((p) => {
          if (p instanceof RegExp)
            for (let f of p.flags.split(""))
              flags.add(f);
          return typeof p === "string" ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;
        });
        return pp.forEach((p, i) => {
          let next = pp[i + 1], prev = pp[i - 1];
          if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR)
            return;
          if (prev === void 0)
            if (next !== void 0 && next !== exports.GLOBSTAR)
              pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
            else
              pp[i] = twoStar;
          else if (next === void 0)
            pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
          else if (next !== exports.GLOBSTAR)
            pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next, pp[i + 1] = exports.GLOBSTAR;
        }), pp.filter((p) => p !== exports.GLOBSTAR).join("/");
      }).join("|"), [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
      if (re = "^" + open + re + close + "$", this.negate)
        re = "^(?!" + re + ").+$";
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch (ex) {
        this.regexp = !1;
      }
      return this.regexp;
    }
    slashSplit(p) {
      if (this.preserveMultipleSlashes)
        return p.split("/");
      else if (this.isWindows && /^\/\/[^\/]+/.test(p))
        return ["", ...p.split(/\/+/)];
      else
        return p.split(/\/+/);
    }
    match(f, partial = this.partial) {
      if (this.debug("match", f, this.pattern), this.comment)
        return !1;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return !0;
      let options = this.options;
      if (this.isWindows)
        f = f.split("\\").join("/");
      let ff = this.slashSplit(f);
      this.debug(this.pattern, "split", ff);
      let set = this.set;
      this.debug(this.pattern, "set", set);
      let filename = ff[ff.length - 1];
      if (!filename)
        for (let i = ff.length - 2;!filename && i >= 0; i--)
          filename = ff[i];
      for (let i = 0;i < set.length; i++) {
        let pattern = set[i], file = ff;
        if (options.matchBase && pattern.length === 1)
          file = [filename];
        if (this.matchOne(file, pattern, partial)) {
          if (options.flipNegate)
            return !0;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return !1;
      return this.negate;
    }
    static defaults(def) {
      return exports.minimatch.defaults(def).Minimatch;
    }
  }
  exports.Minimatch = Minimatch;
  var ast_js_2 = require_ast();
  Object.defineProperty(exports, "AST", { enumerable: !0, get: function() {
    return ast_js_2.AST;
  } });
  var escape_js_2 = require_escape();
  Object.defineProperty(exports, "escape", { enumerable: !0, get: function() {
    return escape_js_2.escape;
  } });
  var unescape_js_2 = require_unescape();
  Object.defineProperty(exports, "unescape", { enumerable: !0, get: function() {
    return unescape_js_2.unescape;
  } });
  exports.minimatch.AST = ast_js_1.AST;
  exports.minimatch.Minimatch = Minimatch;
  exports.minimatch.escape = escape_js_1.escape;
  exports.minimatch.unescape = unescape_js_1.unescape;
});

// node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs23 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.LRUCache = void 0;
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date, warned = /* @__PURE__ */ new Set, PROCESS = typeof process === "object" && !!process ? process : {}, emitWarning = (msg, type, code, fn) => {
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
  }, AC = globalThis.AbortController, AS = globalThis.AbortSignal;
  if (typeof AC > "u") {
    AS = class {
      onabort;
      _onabort = [];
      reason;
      aborted = !1;
      addEventListener(_2, fn) {
        this._onabort.push(fn);
      }
    }, AC = class {
      constructor() {
        warnACPolyfill();
      }
      signal = new AS;
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.reason = reason, this.signal.aborted = !0;
        for (let fn of this.signal._onabort)
          fn(reason);
        this.signal.onabort?.(reason);
      }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1", warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = !1, emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  var shouldWarn = (code) => !warned.has(code), TYPE = Symbol("type"), isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n), getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;

  class ZeroArray extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  }

  class Stack {
    heap;
    length;
    static #constructing = !1;
    static create(max) {
      let HeapCls = getUintArray(max);
      if (!HeapCls)
        return [];
      Stack.#constructing = !0;
      let s = new Stack(max, HeapCls);
      return Stack.#constructing = !1, s;
    }
    constructor(max, HeapCls) {
      if (!Stack.#constructing)
        throw TypeError("instantiate Stack using Stack.create(n)");
      this.heap = new HeapCls(max), this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  }

  class LRUCache {
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    #memoMethod;
    ttl;
    ttlResolution;
    ttlAutopurge;
    updateAgeOnGet;
    updateAgeOnHas;
    allowStale;
    noDisposeOnSet;
    noUpdateTTL;
    maxEntrySize;
    sizeCalculation;
    noDeleteOnFetchRejection;
    noDeleteOnStaleGet;
    allowStaleOnFetchAbort;
    allowStaleOnFetchRejection;
    ignoreFetchAbort;
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    static unsafeExposeInternals(c) {
      return {
        starts: c.#starts,
        ttls: c.#ttls,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head;
        },
        get tail() {
          return c.#tail;
        },
        free: c.#free,
        isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),
        moveToTail: (index) => c.#moveToTail(index),
        indexes: (options) => c.#indexes(options),
        rindexes: (options) => c.#rindexes(options),
        isStale: (index) => c.#isStale(index)
      };
    }
    get max() {
      return this.#max;
    }
    get maxSize() {
      return this.#maxSize;
    }
    get calculatedSize() {
      return this.#calculatedSize;
    }
    get size() {
      return this.#size;
    }
    get fetchMethod() {
      return this.#fetchMethod;
    }
    get memoMethod() {
      return this.#memoMethod;
    }
    get dispose() {
      return this.#dispose;
    }
    get disposeAfter() {
      return this.#disposeAfter;
    }
    constructor(options) {
      let { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
      if (max !== 0 && !isPosInt(max))
        throw TypeError("max option must be a nonnegative integer");
      let UintArray = max ? getUintArray(max) : Array;
      if (!UintArray)
        throw Error("invalid max value: " + max);
      if (this.#max = max, this.#maxSize = maxSize, this.maxEntrySize = maxEntrySize || this.#maxSize, this.sizeCalculation = sizeCalculation, this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize)
          throw TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        if (typeof this.sizeCalculation !== "function")
          throw TypeError("sizeCalculation set to non-function");
      }
      if (memoMethod !== void 0 && typeof memoMethod !== "function")
        throw TypeError("memoMethod must be a function if defined");
      if (this.#memoMethod = memoMethod, fetchMethod !== void 0 && typeof fetchMethod !== "function")
        throw TypeError("fetchMethod must be a function if specified");
      if (this.#fetchMethod = fetchMethod, this.#hasFetchMethod = !!fetchMethod, this.#keyMap = /* @__PURE__ */ new Map, this.#keyList = Array(max).fill(void 0), this.#valList = Array(max).fill(void 0), this.#next = new UintArray(max), this.#prev = new UintArray(max), this.#head = 0, this.#tail = 0, this.#free = Stack.create(max), this.#size = 0, this.#calculatedSize = 0, typeof dispose === "function")
        this.#dispose = dispose;
      if (typeof disposeAfter === "function")
        this.#disposeAfter = disposeAfter, this.#disposed = [];
      else
        this.#disposeAfter = void 0, this.#disposed = void 0;
      if (this.#hasDispose = !!this.#dispose, this.#hasDisposeAfter = !!this.#disposeAfter, this.noDisposeOnSet = !!noDisposeOnSet, this.noUpdateTTL = !!noUpdateTTL, this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection, this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection, this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort, this.ignoreFetchAbort = !!ignoreFetchAbort, this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize))
            throw TypeError("maxSize must be a positive integer if specified");
        }
        if (!isPosInt(this.maxEntrySize))
          throw TypeError("maxEntrySize must be a positive integer if specified");
        this.#initializeSizeTracking();
      }
      if (this.allowStale = !!allowStale, this.noDeleteOnStaleGet = !!noDeleteOnStaleGet, this.updateAgeOnGet = !!updateAgeOnGet, this.updateAgeOnHas = !!updateAgeOnHas, this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1, this.ttlAutopurge = !!ttlAutopurge, this.ttl = ttl || 0, this.ttl) {
        if (!isPosInt(this.ttl))
          throw TypeError("ttl must be a positive integer if specified");
        this.#initializeTTLTracking();
      }
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0)
        throw TypeError("At least one of max, maxSize, or ttl is required");
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        if (shouldWarn("LRU_CACHE_UNBOUNDED"))
          warned.add("LRU_CACHE_UNBOUNDED"), emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", "LRU_CACHE_UNBOUNDED", LRUCache);
      }
    }
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? 1 / 0 : 0;
    }
    #initializeTTLTracking() {
      let ttls = new ZeroArray(this.#max), starts = new ZeroArray(this.#max);
      this.#ttls = ttls, this.#starts = starts, this.#setItemTTL = (index, ttl, start = perf.now()) => {
        if (starts[index] = ttl !== 0 ? start : 0, ttls[index] = ttl, ttl !== 0 && this.ttlAutopurge) {
          let t = setTimeout(() => {
            if (this.#isStale(index))
              this.#delete(this.#keyList[index], "expire");
          }, ttl + 1);
          if (t.unref)
            t.unref();
        }
      }, this.#updateItemAge = (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      }, this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          let ttl = ttls[index], start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl, status.start = start, status.now = cachedNow || getNow();
          let age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      };
      let cachedNow = 0, getNow = () => {
        let n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          let t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref)
            t.unref();
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        let index = this.#keyMap.get(key);
        if (index === void 0)
          return 0;
        let ttl = ttls[index], start = starts[index];
        if (!ttl || !start)
          return 1 / 0;
        let age = (cachedNow || getNow()) - start;
        return ttl - age;
      }, this.#isStale = (index) => {
        let s = starts[index], t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      };
    }
    #updateItemAge = () => {};
    #statusTTL = () => {};
    #setItemTTL = () => {};
    #isStale = () => !1;
    #initializeSizeTracking() {
      let sizes = new ZeroArray(this.#max);
      this.#calculatedSize = 0, this.#sizes = sizes, this.#removeItemSize = (index) => {
        this.#calculatedSize -= sizes[index], sizes[index] = 0;
      }, this.#requireSize = (k, v, size, sizeCalculation) => {
        if (this.#isBackgroundFetch(v))
          return 0;
        if (!isPosInt(size))
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function")
              throw TypeError("sizeCalculation must be a function");
            if (size = sizeCalculation(v, k), !isPosInt(size))
              throw TypeError("sizeCalculation return invalid (expect positive integer)");
          } else
            throw TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        return size;
      }, this.#addItemSize = (index, size, status) => {
        if (sizes[index] = size, this.#maxSize) {
          let maxSize = this.#maxSize - sizes[index];
          while (this.#calculatedSize > maxSize)
            this.#evict(!0);
        }
        if (this.#calculatedSize += sizes[index], status)
          status.entrySize = size, status.totalCalculatedSize = this.#calculatedSize;
      };
    }
    #removeItemSize = (_i) => {};
    #addItemSize = (_i, _s, _st) => {};
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation)
        throw TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size)
        for (let i = this.#tail;; ) {
          if (!this.#isValidIndex(i))
            break;
          if (allowStale || !this.#isStale(i))
            yield i;
          if (i === this.#head)
            break;
          else
            i = this.#prev[i];
        }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size)
        for (let i = this.#head;; ) {
          if (!this.#isValidIndex(i))
            break;
          if (allowStale || !this.#isStale(i))
            yield i;
          if (i === this.#tail)
            break;
          else
            i = this.#next[i];
        }
    }
    #isValidIndex(index) {
      return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
    }
    *entries() {
      for (let i of this.#indexes())
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]))
          yield [this.#keyList[i], this.#valList[i]];
    }
    *rentries() {
      for (let i of this.#rindexes())
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]))
          yield [this.#keyList[i], this.#valList[i]];
    }
    *keys() {
      for (let i of this.#indexes()) {
        let k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i]))
          yield k;
      }
    }
    *rkeys() {
      for (let i of this.#rindexes()) {
        let k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i]))
          yield k;
      }
    }
    *values() {
      for (let i of this.#indexes())
        if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]))
          yield this.#valList[i];
    }
    *rvalues() {
      for (let i of this.#rindexes())
        if (this.#valList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i]))
          yield this.#valList[i];
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    [Symbol.toStringTag] = "LRUCache";
    find(fn, getOptions = {}) {
      for (let i of this.#indexes()) {
        let v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        if (fn(value, this.#keyList[i], this))
          return this.get(this.#keyList[i], getOptions);
      }
    }
    forEach(fn, thisp = this) {
      for (let i of this.#indexes()) {
        let v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    rforEach(fn, thisp = this) {
      for (let i of this.#rindexes()) {
        let v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    purgeStale() {
      let deleted = !1;
      for (let i of this.#rindexes({ allowStale: !0 }))
        if (this.#isStale(i))
          this.#delete(this.#keyList[i], "expire"), deleted = !0;
      return deleted;
    }
    info(key) {
      let i = this.#keyMap.get(key);
      if (i === void 0)
        return;
      let v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      if (value === void 0)
        return;
      let entry = { value };
      if (this.#ttls && this.#starts) {
        let ttl = this.#ttls[i], start = this.#starts[i];
        if (ttl && start) {
          let remain = ttl - (perf.now() - start);
          entry.ttl = remain, entry.start = Date.now();
        }
      }
      if (this.#sizes)
        entry.size = this.#sizes[i];
      return entry;
    }
    dump() {
      let arr = [];
      for (let i of this.#indexes({ allowStale: !0 })) {
        let key = this.#keyList[i], v = this.#valList[i], value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0 || key === void 0)
          continue;
        let entry = { value };
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i];
          let age = perf.now() - this.#starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.#sizes)
          entry.size = this.#sizes[i];
        arr.unshift([key, entry]);
      }
      return arr;
    }
    load(arr) {
      this.clear();
      for (let [key, entry] of arr) {
        if (entry.start) {
          let age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    set(k, v, setOptions = {}) {
      if (v === void 0)
        return this.delete(k), this;
      let { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions, { noUpdateTTL = this.noUpdateTTL } = setOptions, size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status)
          status.set = "miss", status.maxEntrySizeExceeded = !0;
        return this.#delete(k, "set"), this;
      }
      let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
      if (index === void 0) {
        if (index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(!1) : this.#size, this.#keyList[index] = k, this.#valList[index] = v, this.#keyMap.set(k, index), this.#next[this.#tail] = index, this.#prev[index] = this.#tail, this.#tail = index, this.#size++, this.#addItemSize(index, size, status), status)
          status.set = "add";
        noUpdateTTL = !1;
      } else {
        this.#moveToTail(index);
        let oldVal = this.#valList[index];
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(Error("replaced"));
            let { __staleWhileFetching: s } = oldVal;
            if (s !== void 0 && !noDisposeOnSet) {
              if (this.#hasDispose)
                this.#dispose?.(s, k, "set");
              if (this.#hasDisposeAfter)
                this.#disposed?.push([s, k, "set"]);
            }
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose)
              this.#dispose?.(oldVal, k, "set");
            if (this.#hasDisposeAfter)
              this.#disposed?.push([oldVal, k, "set"]);
          }
          if (this.#removeItemSize(index), this.#addItemSize(index, size, status), this.#valList[index] = v, status) {
            status.set = "replace";
            let oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== void 0)
              status.oldValue = oldValue;
          }
        } else if (status)
          status.set = "update";
      }
      if (ttl !== 0 && !this.#ttls)
        this.#initializeTTLTracking();
      if (this.#ttls) {
        if (!noUpdateTTL)
          this.#setItemTTL(index, ttl, start);
        if (status)
          this.#statusTTL(status, index);
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        let dt = this.#disposed, task;
        while (task = dt?.shift())
          this.#disposeAfter?.(...task);
      }
      return this;
    }
    pop() {
      try {
        while (this.#size) {
          let val = this.#valList[this.#head];
          if (this.#evict(!0), this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching)
              return val.__staleWhileFetching;
          } else if (val !== void 0)
            return val;
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          let dt = this.#disposed, task;
          while (task = dt?.shift())
            this.#disposeAfter?.(...task);
        }
      }
    }
    #evict(free) {
      let head = this.#head, k = this.#keyList[head], v = this.#valList[head];
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v))
        v.__abortController.abort(Error("evicted"));
      else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose)
          this.#dispose?.(v, k, "evict");
        if (this.#hasDisposeAfter)
          this.#disposed?.push([v, k, "evict"]);
      }
      if (this.#removeItemSize(head), free)
        this.#keyList[head] = void 0, this.#valList[head] = void 0, this.#free.push(head);
      if (this.#size === 1)
        this.#head = this.#tail = 0, this.#free.length = 0;
      else
        this.#head = this.#next[head];
      return this.#keyMap.delete(k), this.#size--, head;
    }
    has(k, hasOptions = {}) {
      let { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions, index = this.#keyMap.get(k);
      if (index !== void 0) {
        let v = this.#valList[index];
        if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0)
          return !1;
        if (!this.#isStale(index)) {
          if (updateAgeOnHas)
            this.#updateItemAge(index);
          if (status)
            status.has = "hit", this.#statusTTL(status, index);
          return !0;
        } else if (status)
          status.has = "stale", this.#statusTTL(status, index);
      } else if (status)
        status.has = "miss";
      return !1;
    }
    peek(k, peekOptions = {}) {
      let { allowStale = this.allowStale } = peekOptions, index = this.#keyMap.get(k);
      if (index === void 0 || !allowStale && this.#isStale(index))
        return;
      let v = this.#valList[index];
      return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
    }
    #backgroundFetch(k, index, options, context) {
      let v = index === void 0 ? void 0 : this.#valList[index];
      if (this.#isBackgroundFetch(v))
        return v;
      let ac = new AC, { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      let fetchOpts = {
        signal: ac.signal,
        options,
        context
      }, cb = (v2, updateCache = !1) => {
        let { aborted } = ac.signal, ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status)
          if (aborted && !updateCache) {
            if (options.status.fetchAborted = !0, options.status.fetchError = ac.signal.reason, ignoreAbort)
              options.status.fetchAbortIgnored = !0;
          } else
            options.status.fetchResolved = !0;
        if (aborted && !ignoreAbort && !updateCache)
          return fetchFail(ac.signal.reason);
        let bf2 = p;
        if (this.#valList[index] === p)
          if (v2 === void 0)
            if (bf2.__staleWhileFetching)
              this.#valList[index] = bf2.__staleWhileFetching;
            else
              this.#delete(k, "fetch");
          else {
            if (options.status)
              options.status.fetchUpdated = !0;
            this.set(k, v2, fetchOpts.options);
          }
        return v2;
      }, eb = (er) => {
        if (options.status)
          options.status.fetchRejected = !0, options.status.fetchError = er;
        return fetchFail(er);
      }, fetchFail = (er) => {
        let { aborted } = ac.signal, allowStaleAborted = aborted && options.allowStaleOnFetchAbort, allowStale = allowStaleAborted || options.allowStaleOnFetchRejection, noDelete = allowStale || options.noDeleteOnFetchRejection, bf2 = p;
        if (this.#valList[index] === p) {
          if (!noDelete || bf2.__staleWhileFetching === void 0)
            this.#delete(k, "fetch");
          else if (!allowStaleAborted)
            this.#valList[index] = bf2.__staleWhileFetching;
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0)
            options.status.returnedStale = !0;
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2)
          throw er;
      }, pcall = (res, rej) => {
        let fmp = this.#fetchMethod?.(k, v, fetchOpts);
        if (fmp && fmp instanceof Promise)
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            if (res(void 0), options.allowStaleOnFetchAbort)
              res = (v2) => cb(v2, !0);
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = !0;
      let p = new Promise(pcall).then(cb, eb), bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0)
        this.set(k, bf, { ...fetchOpts.options, status: void 0 }), index = this.#keyMap.get(k);
      else
        this.#valList[index] = bf;
      return bf;
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod)
        return !1;
      let b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
      let {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context,
        forceRefresh = !1,
        status,
        signal
      } = fetchOptions;
      if (!this.#hasFetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      let options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      }, index = this.#keyMap.get(k);
      if (index === void 0) {
        if (status)
          status.fetch = "miss";
        let p = this.#backgroundFetch(k, index, options, context);
        return p.__returned = p;
      } else {
        let v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          let stale = allowStale && v.__staleWhileFetching !== void 0;
          if (status) {
            if (status.fetch = "inflight", stale)
              status.returnedStale = !0;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        let isStale = this.#isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          if (this.#moveToTail(index), updateAgeOnGet)
            this.#updateItemAge(index);
          if (status)
            this.#statusTTL(status, index);
          return v;
        }
        let p = this.#backgroundFetch(k, index, options, context), staleVal = p.__staleWhileFetching !== void 0 && allowStale;
        if (status) {
          if (status.fetch = isStale ? "stale" : "refresh", staleVal && isStale)
            status.returnedStale = !0;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    async forceFetch(k, fetchOptions = {}) {
      let v = await this.fetch(k, fetchOptions);
      if (v === void 0)
        throw Error("fetch() returned undefined");
      return v;
    }
    memo(k, memoOptions = {}) {
      let memoMethod = this.#memoMethod;
      if (!memoMethod)
        throw Error("no memoMethod provided to constructor");
      let { context, forceRefresh, ...options } = memoOptions, v = this.get(k, options);
      if (!forceRefresh && v !== void 0)
        return v;
      let vv = memoMethod(k, v, {
        options,
        context
      });
      return this.set(k, vv, options), vv;
    }
    get(k, getOptions = {}) {
      let { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions, index = this.#keyMap.get(k);
      if (index !== void 0) {
        let value = this.#valList[index], fetching = this.#isBackgroundFetch(value);
        if (status)
          this.#statusTTL(status, index);
        if (this.#isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet)
              this.#delete(k, "expire");
            if (status && allowStale)
              status.returnedStale = !0;
            return allowStale ? value : void 0;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== void 0)
              status.returnedStale = !0;
            return allowStale ? value.__staleWhileFetching : void 0;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching)
            return value.__staleWhileFetching;
          if (this.#moveToTail(index), updateAgeOnGet)
            this.#updateItemAge(index);
          return value;
        }
      } else if (status)
        status.get = "miss";
    }
    #connect(p, n) {
      this.#prev[n] = p, this.#next[p] = n;
    }
    #moveToTail(index) {
      if (index !== this.#tail) {
        if (index === this.#head)
          this.#head = this.#next[index];
        else
          this.#connect(this.#prev[index], this.#next[index]);
        this.#connect(this.#tail, index), this.#tail = index;
      }
    }
    delete(k) {
      return this.#delete(k, "delete");
    }
    #delete(k, reason) {
      let deleted = !1;
      if (this.#size !== 0) {
        let index = this.#keyMap.get(k);
        if (index !== void 0)
          if (deleted = !0, this.#size === 1)
            this.#clear(reason);
          else {
            this.#removeItemSize(index);
            let v = this.#valList[index];
            if (this.#isBackgroundFetch(v))
              v.__abortController.abort(Error("deleted"));
            else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose)
                this.#dispose?.(v, k, reason);
              if (this.#hasDisposeAfter)
                this.#disposed?.push([v, k, reason]);
            }
            if (this.#keyMap.delete(k), this.#keyList[index] = void 0, this.#valList[index] = void 0, index === this.#tail)
              this.#tail = this.#prev[index];
            else if (index === this.#head)
              this.#head = this.#next[index];
            else {
              let pi = this.#prev[index];
              this.#next[pi] = this.#next[index];
              let ni = this.#next[index];
              this.#prev[ni] = this.#prev[index];
            }
            this.#size--, this.#free.push(index);
          }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        let dt = this.#disposed, task;
        while (task = dt?.shift())
          this.#disposeAfter?.(...task);
      }
      return deleted;
    }
    clear() {
      return this.#clear("delete");
    }
    #clear(reason) {
      for (let index of this.#rindexes({ allowStale: !0 })) {
        let v = this.#valList[index];
        if (this.#isBackgroundFetch(v))
          v.__abortController.abort(Error("deleted"));
        else {
          let k = this.#keyList[index];
          if (this.#hasDispose)
            this.#dispose?.(v, k, reason);
          if (this.#hasDisposeAfter)
            this.#disposed?.push([v, k, reason]);
        }
      }
      if (this.#keyMap.clear(), this.#valList.fill(void 0), this.#keyList.fill(void 0), this.#ttls && this.#starts)
        this.#ttls.fill(0), this.#starts.fill(0);
      if (this.#sizes)
        this.#sizes.fill(0);
      if (this.#head = 0, this.#tail = 0, this.#free.length = 0, this.#calculatedSize = 0, this.#size = 0, this.#hasDisposeAfter && this.#disposed) {
        let dt = this.#disposed, task;
        while (task = dt?.shift())
          this.#disposeAfter?.(...task);
      }
    }
  }
  exports.LRUCache = LRUCache;
});

// node_modules/minipass/dist/commonjs/index.js
var require_commonjs24 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  }, node_events_1 = __require("node:events"), node_stream_1 = __importDefault(__require("node:stream")), node_string_decoder_1 = __require("node:string_decoder"), isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports.isReadable)(s) || (0, exports.isWritable)(s));
  exports.isStream = isStream;
  var isReadable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.pipe === "function" && s.pipe !== node_stream_1.default.Writable.prototype.pipe;
  exports.isReadable = isReadable;
  var isWritable = (s) => !!s && typeof s === "object" && s instanceof node_events_1.EventEmitter && typeof s.write === "function" && typeof s.end === "function";
  exports.isWritable = isWritable;
  var EOF = Symbol("EOF"), MAYBE_EMIT_END = Symbol("maybeEmitEnd"), EMITTED_END = Symbol("emittedEnd"), EMITTING_END = Symbol("emittingEnd"), EMITTED_ERROR = Symbol("emittedError"), CLOSED = Symbol("closed"), READ = Symbol("read"), FLUSH = Symbol("flush"), FLUSHCHUNK = Symbol("flushChunk"), ENCODING = Symbol("encoding"), DECODER = Symbol("decoder"), FLOWING = Symbol("flowing"), PAUSED = Symbol("paused"), RESUME = Symbol("resume"), BUFFER = Symbol("buffer"), PIPES = Symbol("pipes"), BUFFERLENGTH = Symbol("bufferLength"), BUFFERPUSH = Symbol("bufferPush"), BUFFERSHIFT = Symbol("bufferShift"), OBJECTMODE = Symbol("objectMode"), DESTROYED = Symbol("destroyed"), ERROR = Symbol("error"), EMITDATA = Symbol("emitData"), EMITEND = Symbol("emitEnd"), EMITEND2 = Symbol("emitEnd2"), ASYNC = Symbol("async"), ABORT = Symbol("abort"), ABORTED = Symbol("aborted"), SIGNAL = Symbol("signal"), DATALISTENERS = Symbol("dataListeners"), DISCARDED = Symbol("discarded"), defer = (fn) => Promise.resolve().then(fn), nodefer = (fn) => fn(), isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish", isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0, isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);

  class Pipe {
    src;
    dest;
    opts;
    ondrain;
    constructor(src, dest, opts) {
      this.src = src, this.dest = dest, this.opts = opts, this.ondrain = () => src[RESUME](), this.dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    proxyErrors(_er) {}
    end() {
      if (this.unpipe(), this.opts.end)
        this.dest.end();
    }
  }

  class PipeProxyErrors extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors), super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er), src.on("error", this.proxyErrors);
    }
  }
  var isObjectModeOptions = (o) => !!o.objectMode, isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";

  class Minipass extends node_events_1.EventEmitter {
    [FLOWING] = !1;
    [PAUSED] = !1;
    [PIPES] = [];
    [BUFFER] = [];
    [OBJECTMODE];
    [ENCODING];
    [ASYNC];
    [DECODER];
    [EOF] = !1;
    [EMITTED_END] = !1;
    [EMITTING_END] = !1;
    [CLOSED] = !1;
    [EMITTED_ERROR] = null;
    [BUFFERLENGTH] = 0;
    [DESTROYED] = !1;
    [SIGNAL];
    [ABORTED] = !1;
    [DATALISTENERS] = 0;
    [DISCARDED] = !1;
    writable = !0;
    readable = !0;
    constructor(...args) {
      let options = args[0] || {};
      super();
      if (options.objectMode && typeof options.encoding === "string")
        throw TypeError("Encoding and objectMode may not be used together");
      if (isObjectModeOptions(options))
        this[OBJECTMODE] = !0, this[ENCODING] = null;
      else if (isEncodingOptions(options))
        this[ENCODING] = options.encoding, this[OBJECTMODE] = !1;
      else
        this[OBJECTMODE] = !1, this[ENCODING] = null;
      if (this[ASYNC] = !!options.async, this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null, options && options.debugExposeBuffer === !0)
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      if (options && options.debugExposePipes === !0)
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      let { signal } = options;
      if (signal)
        if (this[SIGNAL] = signal, signal.aborted)
          this[ABORT]();
        else
          signal.addEventListener("abort", () => this[ABORT]());
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(_enc) {
      throw Error("Encoding must be set at instantiation time");
    }
    setEncoding(_enc) {
      throw Error("Encoding must be set at instantiation time");
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(_om) {
      throw Error("objectMode must be set at instantiation time");
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    [ABORT]() {
      this[ABORTED] = !0, this.emit("abort", this[SIGNAL]?.reason), this.destroy(this[SIGNAL]?.reason);
    }
    get aborted() {
      return this[ABORTED];
    }
    set aborted(_2) {}
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return !1;
      if (this[EOF])
        throw Error("write after end");
      if (this[DESTROYED])
        return this.emit("error", Object.assign(Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" })), !0;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      let fn = this[ASYNC] ? defer : nodefer;
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBufferLike(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          throw Error("Non-contiguous data written to non-objectMode stream");
      }
      if (this[OBJECTMODE]) {
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](!0);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      if (typeof chunk === "string" && !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed))
        chunk = Buffer.from(chunk, encoding);
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
        this[FLUSH](!0);
      if (this[FLOWING])
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this[FLOWING];
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      if (this[DISCARDED] = !1, this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH])
        return this[MAYBE_EMIT_END](), null;
      if (this[OBJECTMODE])
        n = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE])
        this[BUFFER] = [
          this[ENCODING] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
        ];
      let ret = this[READ](n || null, this[BUFFER][0]);
      return this[MAYBE_EMIT_END](), ret;
    }
    [READ](n, chunk) {
      if (this[OBJECTMODE])
        this[BUFFERSHIFT]();
      else {
        let c = chunk;
        if (n === c.length || n === null)
          this[BUFFERSHIFT]();
        else if (typeof c === "string")
          this[BUFFER][0] = c.slice(n), chunk = c.slice(0, n), this[BUFFERLENGTH] -= n;
        else
          this[BUFFER][0] = c.subarray(n), chunk = c.subarray(0, n), this[BUFFERLENGTH] -= n;
      }
      if (this.emit("data", chunk), !this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = void 0;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk !== void 0)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      if (this[EOF] = !0, this.writable = !1, this[FLOWING] || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    [RESUME]() {
      if (this[DESTROYED])
        return;
      if (!this[DATALISTENERS] && !this[PIPES].length)
        this[DISCARDED] = !0;
      if (this[PAUSED] = !1, this[FLOWING] = !0, this.emit("resume"), this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = !1, this[PAUSED] = !0, this[DISCARDED] = !1;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain = !1) {
      do
        ;
      while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      return this.emit("data", chunk), this[FLOWING];
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return dest;
      this[DISCARDED] = !1;
      let ended = this[EMITTED_END];
      if (opts = opts || {}, dest === proc.stdout || dest === proc.stderr)
        opts.end = !1;
      else
        opts.end = opts.end !== !1;
      if (opts.proxyErrors = !!opts.proxyErrors, ended) {
        if (opts.end)
          dest.end();
      } else if (this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts)), this[ASYNC])
        defer(() => this[RESUME]());
      else
        this[RESUME]();
      return dest;
    }
    unpipe(dest) {
      let p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        if (this[PIPES].length === 1) {
          if (this[FLOWING] && this[DATALISTENERS] === 0)
            this[FLOWING] = !1;
          this[PIPES] = [];
        } else
          this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, handler) {
      return this.on(ev, handler);
    }
    on(ev, handler) {
      let ret = super.on(ev, handler);
      if (ev === "data") {
        if (this[DISCARDED] = !1, this[DATALISTENERS]++, !this[PIPES].length && !this[FLOWING])
          this[RESUME]();
      } else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
        super.emit("readable");
      else if (isEndish(ev) && this[EMITTED_END])
        super.emit(ev), this.removeAllListeners(ev);
      else if (ev === "error" && this[EMITTED_ERROR]) {
        let h = handler;
        if (this[ASYNC])
          defer(() => h.call(this, this[EMITTED_ERROR]));
        else
          h.call(this, this[EMITTED_ERROR]);
      }
      return ret;
    }
    removeListener(ev, handler) {
      return this.off(ev, handler);
    }
    off(ev, handler) {
      let ret = super.off(ev, handler);
      if (ev === "data") {
        if (this[DATALISTENERS] = this.listeners("data").length, this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length)
          this[FLOWING] = !1;
      }
      return ret;
    }
    removeAllListeners(ev) {
      let ret = super.removeAllListeners(ev);
      if (ev === "data" || ev === void 0) {
        if (this[DATALISTENERS] = 0, !this[DISCARDED] && !this[PIPES].length)
          this[FLOWING] = !1;
      }
      return ret;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        if (this[EMITTING_END] = !0, this.emit("end"), this.emit("prefinish"), this.emit("finish"), this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = !1;
      }
    }
    emit(ev, ...args) {
      let data = args[0];
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return !1;
      else if (ev === "data")
        return !this[OBJECTMODE] && !data ? !1 : this[ASYNC] ? (defer(() => this[EMITDATA](data)), !0) : this[EMITDATA](data);
      else if (ev === "end")
        return this[EMITEND]();
      else if (ev === "close") {
        if (this[CLOSED] = !0, !this[EMITTED_END] && !this[DESTROYED])
          return !1;
        let ret2 = super.emit("close");
        return this.removeAllListeners("close"), ret2;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data, super.emit(ERROR, data);
        let ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : !1;
        return this[MAYBE_EMIT_END](), ret2;
      } else if (ev === "resume") {
        let ret2 = super.emit("resume");
        return this[MAYBE_EMIT_END](), ret2;
      } else if (ev === "finish" || ev === "prefinish") {
        let ret2 = super.emit(ev);
        return this.removeAllListeners(ev), ret2;
      }
      let ret = super.emit(ev, ...args);
      return this[MAYBE_EMIT_END](), ret;
    }
    [EMITDATA](data) {
      for (let p of this[PIPES])
        if (p.dest.write(data) === !1)
          this.pause();
      let ret = this[DISCARDED] ? !1 : super.emit("data", data);
      return this[MAYBE_EMIT_END](), ret;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return !1;
      return this[EMITTED_END] = !0, this.readable = !1, this[ASYNC] ? (defer(() => this[EMITEND2]()), !0) : this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        let data = this[DECODER].end();
        if (data) {
          for (let p of this[PIPES])
            p.dest.write(data);
          if (!this[DISCARDED])
            super.emit("data", data);
        }
      }
      for (let p of this[PIPES])
        p.end();
      let ret = super.emit("end");
      return this.removeAllListeners("end"), ret;
    }
    async collect() {
      let buf = Object.assign([], {
        dataLength: 0
      });
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      let p = this.promise();
      return this.on("data", (c) => {
        if (buf.push(c), !this[OBJECTMODE])
          buf.dataLength += c.length;
      }), await p, buf;
    }
    async concat() {
      if (this[OBJECTMODE])
        throw Error("cannot concat in objectMode");
      let buf = await this.collect();
      return this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
    }
    async promise() {
      return new Promise((resolve, reject) => {
        this.on(DESTROYED, () => reject(Error("stream destroyed"))), this.on("error", (er) => reject(er)), this.on("end", () => resolve());
      });
    }
    [Symbol.asyncIterator]() {
      this[DISCARDED] = !1;
      let stopped = !1, stop = async () => {
        return this.pause(), stopped = !0, { value: void 0, done: !0 };
      };
      return {
        next: () => {
          if (stopped)
            return stop();
          let res = this.read();
          if (res !== null)
            return Promise.resolve({ done: !1, value: res });
          if (this[EOF])
            return stop();
          let resolve, reject, onerr = (er) => {
            this.off("data", ondata), this.off("end", onend), this.off(DESTROYED, ondestroy), stop(), reject(er);
          }, ondata = (value) => {
            this.off("error", onerr), this.off("end", onend), this.off(DESTROYED, ondestroy), this.pause(), resolve({ value, done: !!this[EOF] });
          }, onend = () => {
            this.off("error", onerr), this.off("data", ondata), this.off(DESTROYED, ondestroy), stop(), resolve({ done: !0, value: void 0 });
          }, ondestroy = () => onerr(Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej, resolve = res2, this.once(DESTROYED, ondestroy), this.once("error", onerr), this.once("end", onend), this.once("data", ondata);
          });
        },
        throw: stop,
        return: stop,
        [Symbol.asyncIterator]() {
          return this;
        }
      };
    }
    [Symbol.iterator]() {
      this[DISCARDED] = !1;
      let stopped = !1, stop = () => {
        return this.pause(), this.off(ERROR, stop), this.off(DESTROYED, stop), this.off("end", stop), stopped = !0, { done: !0, value: void 0 };
      }, next = () => {
        if (stopped)
          return stop();
        let value = this.read();
        return value === null ? stop() : { done: !1, value };
      };
      return this.once("end", stop), this.once(ERROR, stop), this.once(DESTROYED, stop), {
        next,
        throw: stop,
        return: stop,
        [Symbol.iterator]() {
          return this;
        }
      };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = !0, this[DISCARDED] = !0, this[BUFFER].length = 0, this[BUFFERLENGTH] = 0;
      let wc = this;
      if (typeof wc.close === "function" && !this[CLOSED])
        wc.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static get isStream() {
      return exports.isStream;
    }
  }
  exports.Minipass = Minipass;
});

// node_modules/path-scurry/dist/commonjs/index.js
var require_commonjs25 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    return __setModuleDefault(result, mod), result;
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;
  var lru_cache_1 = require_commonjs23(), node_path_1 = __require("node:path"), node_url_1 = __require("node:url"), fs_1 = __require("fs"), actualFS = __importStar(__require("node:fs")), realpathSync = fs_1.realpathSync.native, promises_1 = __require("node:fs/promises"), minipass_1 = require_commonjs24(), defaultFS = {
    lstatSync: fs_1.lstatSync,
    readdir: fs_1.readdir,
    readdirSync: fs_1.readdirSync,
    readlinkSync: fs_1.readlinkSync,
    realpathSync,
    promises: {
      lstat: promises_1.lstat,
      readdir: promises_1.readdir,
      readlink: promises_1.readlink,
      realpath: promises_1.realpath
    }
  }, fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
    ...defaultFS,
    ...fsOption,
    promises: {
      ...defaultFS.promises,
      ...fsOption.promises || {}
    }
  }, uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i, uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\"), eitherSep = /[\\\/]/, UNKNOWN = 0, IFIFO = 1, IFCHR = 2, IFDIR = 4, IFBLK = 6, IFREG = 8, IFLNK = 10, IFSOCK = 12, IFMT = 15, IFMT_UNKNOWN = ~IFMT, READDIR_CALLED = 16, LSTAT_CALLED = 32, ENOTDIR = 64, ENOENT = 128, ENOREADLINK = 256, ENOREALPATH = 512, ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH, TYPEMASK = 1023, entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN, normalizeCache = /* @__PURE__ */ new Map, normalize = (s) => {
    let c = normalizeCache.get(s);
    if (c)
      return c;
    let n = s.normalize("NFKD");
    return normalizeCache.set(s, n), n;
  }, normalizeNocaseCache = /* @__PURE__ */ new Map, normalizeNocase = (s) => {
    let c = normalizeNocaseCache.get(s);
    if (c)
      return c;
    let n = normalize(s.toLowerCase());
    return normalizeNocaseCache.set(s, n), n;
  };

  class ResolveCache extends lru_cache_1.LRUCache {
    constructor() {
      super({ max: 256 });
    }
  }
  exports.ResolveCache = ResolveCache;

  class ChildrenCache extends lru_cache_1.LRUCache {
    constructor(maxSize = 16384) {
      super({
        maxSize,
        sizeCalculation: (a) => a.length + 1
      });
    }
  }
  exports.ChildrenCache = ChildrenCache;
  var setAsCwd = Symbol("PathScurry setAsCwd");

  class PathBase {
    name;
    root;
    roots;
    parent;
    nocase;
    isCWD = !1;
    #fs;
    #dev;
    get dev() {
      return this.#dev;
    }
    #mode;
    get mode() {
      return this.#mode;
    }
    #nlink;
    get nlink() {
      return this.#nlink;
    }
    #uid;
    get uid() {
      return this.#uid;
    }
    #gid;
    get gid() {
      return this.#gid;
    }
    #rdev;
    get rdev() {
      return this.#rdev;
    }
    #blksize;
    get blksize() {
      return this.#blksize;
    }
    #ino;
    get ino() {
      return this.#ino;
    }
    #size;
    get size() {
      return this.#size;
    }
    #blocks;
    get blocks() {
      return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
      return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
      return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
      return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
      return this.#birthtimeMs;
    }
    #atime;
    get atime() {
      return this.#atime;
    }
    #mtime;
    get mtime() {
      return this.#mtime;
    }
    #ctime;
    get ctime() {
      return this.#ctime;
    }
    #birthtime;
    get birthtime() {
      return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    get parentPath() {
      return (this.parent || this).fullpath();
    }
    get path() {
      return this.parentPath;
    }
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
      if (this.name = name, this.#matchName = nocase ? normalizeNocase(name) : normalize(name), this.#type = type & TYPEMASK, this.nocase = nocase, this.roots = roots, this.root = root || this, this.#children = children, this.#fullpath = opts.fullpath, this.#relative = opts.relative, this.#relativePosix = opts.relativePosix, this.parent = opts.parent, this.parent)
        this.#fs = this.parent.#fs;
      else
        this.#fs = fsFromOption(opts.fs);
    }
    depth() {
      if (this.#depth !== void 0)
        return this.#depth;
      if (!this.parent)
        return this.#depth = 0;
      return this.#depth = this.parent.depth() + 1;
    }
    childrenCache() {
      return this.#children;
    }
    resolve(path) {
      if (!path)
        return this;
      let rootPath = this.getRootString(path), dirParts = path.substring(rootPath.length).split(this.splitSep);
      return rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
    }
    #resolveParts(dirParts) {
      let p = this;
      for (let part of dirParts)
        p = p.child(part);
      return p;
    }
    children() {
      let cached = this.#children.get(this);
      if (cached)
        return cached;
      let children = Object.assign([], { provisional: 0 });
      return this.#children.set(this, children), this.#type &= ~READDIR_CALLED, children;
    }
    child(pathPart, opts) {
      if (pathPart === "" || pathPart === ".")
        return this;
      if (pathPart === "..")
        return this.parent || this;
      let children = this.children(), name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
      for (let p of children)
        if (p.#matchName === name)
          return p;
      let s = this.parent ? this.sep : "", fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0, pchild = this.newChild(pathPart, UNKNOWN, {
        ...opts,
        parent: this,
        fullpath
      });
      if (!this.canReaddir())
        pchild.#type |= ENOENT;
      return children.push(pchild), pchild;
    }
    relative() {
      if (this.isCWD)
        return "";
      if (this.#relative !== void 0)
        return this.#relative;
      let name = this.name, p = this.parent;
      if (!p)
        return this.#relative = this.name;
      let pv = p.relative();
      return pv + (!pv || !p.parent ? "" : this.sep) + name;
    }
    relativePosix() {
      if (this.sep === "/")
        return this.relative();
      if (this.isCWD)
        return "";
      if (this.#relativePosix !== void 0)
        return this.#relativePosix;
      let name = this.name, p = this.parent;
      if (!p)
        return this.#relativePosix = this.fullpathPosix();
      let pv = p.relativePosix();
      return pv + (!pv || !p.parent ? "" : "/") + name;
    }
    fullpath() {
      if (this.#fullpath !== void 0)
        return this.#fullpath;
      let name = this.name, p = this.parent;
      if (!p)
        return this.#fullpath = this.name;
      let fp = p.fullpath() + (!p.parent ? "" : this.sep) + name;
      return this.#fullpath = fp;
    }
    fullpathPosix() {
      if (this.#fullpathPosix !== void 0)
        return this.#fullpathPosix;
      if (this.sep === "/")
        return this.#fullpathPosix = this.fullpath();
      if (!this.parent) {
        let p2 = this.fullpath().replace(/\\/g, "/");
        if (/^[a-z]:\//i.test(p2))
          return this.#fullpathPosix = `//?/${p2}`;
        else
          return this.#fullpathPosix = p2;
      }
      let p = this.parent, pfpp = p.fullpathPosix(), fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
      return this.#fullpathPosix = fpp;
    }
    isUnknown() {
      return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type) {
      return this[`is${type}`]();
    }
    getType() {
      return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : this.isSocket() ? "Socket" : "Unknown";
    }
    isFile() {
      return (this.#type & IFMT) === IFREG;
    }
    isDirectory() {
      return (this.#type & IFMT) === IFDIR;
    }
    isCharacterDevice() {
      return (this.#type & IFMT) === IFCHR;
    }
    isBlockDevice() {
      return (this.#type & IFMT) === IFBLK;
    }
    isFIFO() {
      return (this.#type & IFMT) === IFIFO;
    }
    isSocket() {
      return (this.#type & IFMT) === IFSOCK;
    }
    isSymbolicLink() {
      return (this.#type & IFLNK) === IFLNK;
    }
    lstatCached() {
      return this.#type & LSTAT_CALLED ? this : void 0;
    }
    readlinkCached() {
      return this.#linkTarget;
    }
    realpathCached() {
      return this.#realpath;
    }
    readdirCached() {
      let children = this.children();
      return children.slice(0, children.provisional);
    }
    canReadlink() {
      if (this.#linkTarget)
        return !0;
      if (!this.parent)
        return !1;
      let ifmt = this.#type & IFMT;
      return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
    }
    calledReaddir() {
      return !!(this.#type & READDIR_CALLED);
    }
    isENOENT() {
      return !!(this.#type & ENOENT);
    }
    isNamed(n) {
      return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
    }
    async readlink() {
      let target = this.#linkTarget;
      if (target)
        return target;
      if (!this.canReadlink())
        return;
      if (!this.parent)
        return;
      try {
        let read = await this.#fs.promises.readlink(this.fullpath()), linkTarget = (await this.parent.realpath())?.resolve(read);
        if (linkTarget)
          return this.#linkTarget = linkTarget;
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
    }
    readlinkSync() {
      let target = this.#linkTarget;
      if (target)
        return target;
      if (!this.canReadlink())
        return;
      if (!this.parent)
        return;
      try {
        let read = this.#fs.readlinkSync(this.fullpath()), linkTarget = this.parent.realpathSync()?.resolve(read);
        if (linkTarget)
          return this.#linkTarget = linkTarget;
      } catch (er) {
        this.#readlinkFail(er.code);
        return;
      }
    }
    #readdirSuccess(children) {
      this.#type |= READDIR_CALLED;
      for (let p = children.provisional;p < children.length; p++) {
        let c = children[p];
        if (c)
          c.#markENOENT();
      }
    }
    #markENOENT() {
      if (this.#type & ENOENT)
        return;
      this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN, this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
      let children = this.children();
      children.provisional = 0;
      for (let p of children)
        p.#markENOENT();
    }
    #markENOREALPATH() {
      this.#type |= ENOREALPATH, this.#markENOTDIR();
    }
    #markENOTDIR() {
      if (this.#type & ENOTDIR)
        return;
      let t = this.#type;
      if ((t & IFMT) === IFDIR)
        t &= IFMT_UNKNOWN;
      this.#type = t | ENOTDIR, this.#markChildrenENOENT();
    }
    #readdirFail(code = "") {
      if (code === "ENOTDIR" || code === "EPERM")
        this.#markENOTDIR();
      else if (code === "ENOENT")
        this.#markENOENT();
      else
        this.children().provisional = 0;
    }
    #lstatFail(code = "") {
      if (code === "ENOTDIR")
        this.parent.#markENOTDIR();
      else if (code === "ENOENT")
        this.#markENOENT();
    }
    #readlinkFail(code = "") {
      let ter = this.#type;
      if (ter |= ENOREADLINK, code === "ENOENT")
        ter |= ENOENT;
      if (code === "EINVAL" || code === "UNKNOWN")
        ter &= IFMT_UNKNOWN;
      if (this.#type = ter, code === "ENOTDIR" && this.parent)
        this.parent.#markENOTDIR();
    }
    #readdirAddChild(e, c) {
      return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
    }
    #readdirAddNewChild(e, c) {
      let type = entToType(e), child = this.newChild(e.name, type, { parent: this }), ifmt = child.#type & IFMT;
      if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN)
        child.#type |= ENOTDIR;
      return c.unshift(child), c.provisional++, child;
    }
    #readdirMaybePromoteChild(e, c) {
      for (let p = c.provisional;p < c.length; p++) {
        let pchild = c[p];
        if ((this.nocase ? normalizeNocase(e.name) : normalize(e.name)) !== pchild.#matchName)
          continue;
        return this.#readdirPromoteChild(e, pchild, p, c);
      }
    }
    #readdirPromoteChild(e, p, index, c) {
      let v = p.name;
      if (p.#type = p.#type & IFMT_UNKNOWN | entToType(e), v !== e.name)
        p.name = e.name;
      if (index !== c.provisional) {
        if (index === c.length - 1)
          c.pop();
        else
          c.splice(index, 1);
        c.unshift(p);
      }
      return c.provisional++, p;
    }
    async lstat() {
      if ((this.#type & ENOENT) === 0)
        try {
          return this.#applyStat(await this.#fs.promises.lstat(this.fullpath())), this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
    }
    lstatSync() {
      if ((this.#type & ENOENT) === 0)
        try {
          return this.#applyStat(this.#fs.lstatSync(this.fullpath())), this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
    }
    #applyStat(st) {
      let { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
      this.#atime = atime, this.#atimeMs = atimeMs, this.#birthtime = birthtime, this.#birthtimeMs = birthtimeMs, this.#blksize = blksize, this.#blocks = blocks, this.#ctime = ctime, this.#ctimeMs = ctimeMs, this.#dev = dev, this.#gid = gid, this.#ino = ino, this.#mode = mode, this.#mtime = mtime, this.#mtimeMs = mtimeMs, this.#nlink = nlink, this.#rdev = rdev, this.#size = size, this.#uid = uid;
      let ifmt = entToType(st);
      if (this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED, ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK)
        this.#type |= ENOTDIR;
    }
    #onReaddirCB = [];
    #readdirCBInFlight = !1;
    #callOnReaddirCB(children) {
      this.#readdirCBInFlight = !1;
      let cbs = this.#onReaddirCB.slice();
      this.#onReaddirCB.length = 0, cbs.forEach((cb) => cb(null, children));
    }
    readdirCB(cb, allowZalgo = !1) {
      if (!this.canReaddir()) {
        if (allowZalgo)
          cb(null, []);
        else
          queueMicrotask(() => cb(null, []));
        return;
      }
      let children = this.children();
      if (this.calledReaddir()) {
        let c = children.slice(0, children.provisional);
        if (allowZalgo)
          cb(null, c);
        else
          queueMicrotask(() => cb(null, c));
        return;
      }
      if (this.#onReaddirCB.push(cb), this.#readdirCBInFlight)
        return;
      this.#readdirCBInFlight = !0;
      let fullpath = this.fullpath();
      this.#fs.readdir(fullpath, { withFileTypes: !0 }, (er, entries) => {
        if (er)
          this.#readdirFail(er.code), children.provisional = 0;
        else {
          for (let e of entries)
            this.#readdirAddChild(e, children);
          this.#readdirSuccess(children);
        }
        this.#callOnReaddirCB(children.slice(0, children.provisional));
        return;
      });
    }
    #asyncReaddirInFlight;
    async readdir() {
      if (!this.canReaddir())
        return [];
      let children = this.children();
      if (this.calledReaddir())
        return children.slice(0, children.provisional);
      let fullpath = this.fullpath();
      if (this.#asyncReaddirInFlight)
        await this.#asyncReaddirInFlight;
      else {
        let resolve = () => {};
        this.#asyncReaddirInFlight = new Promise((res) => resolve = res);
        try {
          for (let e of await this.#fs.promises.readdir(fullpath, {
            withFileTypes: !0
          }))
            this.#readdirAddChild(e, children);
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code), children.provisional = 0;
        }
        this.#asyncReaddirInFlight = void 0, resolve();
      }
      return children.slice(0, children.provisional);
    }
    readdirSync() {
      if (!this.canReaddir())
        return [];
      let children = this.children();
      if (this.calledReaddir())
        return children.slice(0, children.provisional);
      let fullpath = this.fullpath();
      try {
        for (let e of this.#fs.readdirSync(fullpath, {
          withFileTypes: !0
        }))
          this.#readdirAddChild(e, children);
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code), children.provisional = 0;
      }
      return children.slice(0, children.provisional);
    }
    canReaddir() {
      if (this.#type & ENOCHILD)
        return !1;
      let ifmt = IFMT & this.#type;
      if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK))
        return !1;
      return !0;
    }
    shouldWalk(dirs, walkFilter) {
      return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
    }
    async realpath() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return;
      try {
        let rp = await this.#fs.promises.realpath(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_2) {
        this.#markENOREALPATH();
      }
    }
    realpathSync() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return;
      try {
        let rp = this.#fs.realpathSync(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_2) {
        this.#markENOREALPATH();
      }
    }
    [setAsCwd](oldCwd) {
      if (oldCwd === this)
        return;
      oldCwd.isCWD = !1, this.isCWD = !0;
      let changed = /* @__PURE__ */ new Set([]), rp = [], p = this;
      while (p && p.parent)
        changed.add(p), p.#relative = rp.join(this.sep), p.#relativePosix = rp.join("/"), p = p.parent, rp.push("..");
      p = oldCwd;
      while (p && p.parent && !changed.has(p))
        p.#relative = void 0, p.#relativePosix = void 0, p = p.parent;
    }
  }
  exports.PathBase = PathBase;

  class PathWin32 extends PathBase {
    sep = "\\";
    splitSep = eitherSep;
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type, root, roots, nocase, children, opts);
    }
    newChild(name, type = UNKNOWN, opts = {}) {
      return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    getRootString(path) {
      return node_path_1.win32.parse(path).root;
    }
    getRoot(rootPath) {
      if (rootPath = uncToDrive(rootPath.toUpperCase()), rootPath === this.root.name)
        return this.root;
      for (let [compare, root] of Object.entries(this.roots))
        if (this.sameRoot(rootPath, compare))
          return this.roots[rootPath] = root;
      return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
    }
    sameRoot(rootPath, compare = this.root.name) {
      return rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\"), rootPath === compare;
    }
  }
  exports.PathWin32 = PathWin32;

  class PathPosix extends PathBase {
    splitSep = "/";
    sep = "/";
    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type, root, roots, nocase, children, opts);
    }
    getRootString(path) {
      return path.startsWith("/") ? "/" : "";
    }
    getRoot(_rootPath) {
      return this.root;
    }
    newChild(name, type = UNKNOWN, opts = {}) {
      return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
  }
  exports.PathPosix = PathPosix;

  class PathScurryBase {
    root;
    rootPath;
    roots;
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    nocase;
    #fs;
    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16384, fs = defaultFS } = {}) {
      if (this.#fs = fsFromOption(fs), cwd instanceof URL || cwd.startsWith("file://"))
        cwd = (0, node_url_1.fileURLToPath)(cwd);
      let cwdPath = pathImpl.resolve(cwd);
      this.roots = Object.create(null), this.rootPath = this.parseRootPath(cwdPath), this.#resolveCache = new ResolveCache, this.#resolvePosixCache = new ResolveCache, this.#children = new ChildrenCache(childrenCacheSize);
      let split = cwdPath.substring(this.rootPath.length).split(sep);
      if (split.length === 1 && !split[0])
        split.pop();
      if (nocase === void 0)
        throw TypeError("must provide nocase setting to PathScurryBase ctor");
      this.nocase = nocase, this.root = this.newRoot(this.#fs), this.roots[this.rootPath] = this.root;
      let prev = this.root, len = split.length - 1, joinSep = pathImpl.sep, abs = this.rootPath, sawFirst = !1;
      for (let part of split) {
        let l = len--;
        prev = prev.child(part, {
          relative: Array(l).fill("..").join(joinSep),
          relativePosix: Array(l).fill("..").join("/"),
          fullpath: abs += (sawFirst ? "" : joinSep) + part
        }), sawFirst = !0;
      }
      this.cwd = prev;
    }
    depth(path = this.cwd) {
      if (typeof path === "string")
        path = this.cwd.resolve(path);
      return path.depth();
    }
    childrenCache() {
      return this.#children;
    }
    resolve(...paths) {
      let r = "";
      for (let i = paths.length - 1;i >= 0; i--) {
        let p = paths[i];
        if (!p || p === ".")
          continue;
        if (r = r ? `${p}/${r}` : p, this.isAbsolute(p))
          break;
      }
      let cached = this.#resolveCache.get(r);
      if (cached !== void 0)
        return cached;
      let result = this.cwd.resolve(r).fullpath();
      return this.#resolveCache.set(r, result), result;
    }
    resolvePosix(...paths) {
      let r = "";
      for (let i = paths.length - 1;i >= 0; i--) {
        let p = paths[i];
        if (!p || p === ".")
          continue;
        if (r = r ? `${p}/${r}` : p, this.isAbsolute(p))
          break;
      }
      let cached = this.#resolvePosixCache.get(r);
      if (cached !== void 0)
        return cached;
      let result = this.cwd.resolve(r).fullpathPosix();
      return this.#resolvePosixCache.set(r, result), result;
    }
    relative(entry = this.cwd) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      return entry.relative();
    }
    relativePosix(entry = this.cwd) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      return entry.relativePosix();
    }
    basename(entry = this.cwd) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      return entry.name;
    }
    dirname(entry = this.cwd) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
      withFileTypes: !0
    }) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        opts = entry, entry = this.cwd;
      let { withFileTypes } = opts;
      if (!entry.canReaddir())
        return [];
      else {
        let p = await entry.readdir();
        return withFileTypes ? p : p.map((e) => e.name);
      }
    }
    readdirSync(entry = this.cwd, opts = {
      withFileTypes: !0
    }) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        opts = entry, entry = this.cwd;
      let { withFileTypes = !0 } = opts;
      if (!entry.canReaddir())
        return [];
      else if (withFileTypes)
        return entry.readdirSync();
      else
        return entry.readdirSync().map((e) => e.name);
    }
    async lstat(entry = this.cwd) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      return entry.lstat();
    }
    lstatSync(entry = this.cwd) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
      withFileTypes: !1
    }) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        withFileTypes = entry.withFileTypes, entry = this.cwd;
      let e = await entry.readlink();
      return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: !1
    }) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        withFileTypes = entry.withFileTypes, entry = this.cwd;
      let e = entry.readlinkSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
      withFileTypes: !1
    }) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        withFileTypes = entry.withFileTypes, entry = this.cwd;
      let e = await entry.realpath();
      return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: !1
    }) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        withFileTypes = entry.withFileTypes, entry = this.cwd;
      let e = entry.realpathSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        opts = entry, entry = this.cwd;
      let { withFileTypes = !0, follow = !1, filter, walkFilter } = opts, results = [];
      if (!filter || filter(entry))
        results.push(withFileTypes ? entry : entry.fullpath());
      let dirs = /* @__PURE__ */ new Set, walk = (dir, cb) => {
        dirs.add(dir), dir.readdirCB((er, entries) => {
          if (er)
            return cb(er);
          let len = entries.length;
          if (!len)
            return cb();
          let next = () => {
            if (--len === 0)
              cb();
          };
          for (let e of entries) {
            if (!filter || filter(e))
              results.push(withFileTypes ? e : e.fullpath());
            if (follow && e.isSymbolicLink())
              e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
            else if (e.shouldWalk(dirs, walkFilter))
              walk(e, next);
            else
              next();
          }
        }, !0);
      }, start = entry;
      return new Promise((res, rej) => {
        walk(start, (er) => {
          if (er)
            return rej(er);
          res(results);
        });
      });
    }
    walkSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        opts = entry, entry = this.cwd;
      let { withFileTypes = !0, follow = !1, filter, walkFilter } = opts, results = [];
      if (!filter || filter(entry))
        results.push(withFileTypes ? entry : entry.fullpath());
      let dirs = /* @__PURE__ */ new Set([entry]);
      for (let dir of dirs) {
        let entries = dir.readdirSync();
        for (let e of entries) {
          if (!filter || filter(e))
            results.push(withFileTypes ? e : e.fullpath());
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter))
            dirs.add(r);
        }
      }
      return results;
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        options = entry, entry = this.cwd;
      return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        opts = entry, entry = this.cwd;
      let { withFileTypes = !0, follow = !1, filter, walkFilter } = opts;
      if (!filter || filter(entry))
        yield withFileTypes ? entry : entry.fullpath();
      let dirs = /* @__PURE__ */ new Set([entry]);
      for (let dir of dirs) {
        let entries = dir.readdirSync();
        for (let e of entries) {
          if (!filter || filter(e))
            yield withFileTypes ? e : e.fullpath();
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter))
            dirs.add(r);
        }
      }
    }
    stream(entry = this.cwd, opts = {}) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        opts = entry, entry = this.cwd;
      let { withFileTypes = !0, follow = !1, filter, walkFilter } = opts, results = new minipass_1.Minipass({ objectMode: !0 });
      if (!filter || filter(entry))
        results.write(withFileTypes ? entry : entry.fullpath());
      let dirs = /* @__PURE__ */ new Set, queue = [entry], processing = 0, process2 = () => {
        let paused = !1;
        while (!paused) {
          let dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++, dirs.add(dir);
          let onReaddir = (er, entries, didRealpaths = !1) => {
            if (er)
              return results.emit("error", er);
            if (follow && !didRealpaths) {
              let promises = [];
              for (let e of entries)
                if (e.isSymbolicLink())
                  promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
              if (promises.length) {
                Promise.all(promises).then(() => onReaddir(null, entries, !0));
                return;
              }
            }
            for (let e of entries)
              if (e && (!filter || filter(e))) {
                if (!results.write(withFileTypes ? e : e.fullpath()))
                  paused = !0;
              }
            processing--;
            for (let e of entries) {
              let r = e.realpathCached() || e;
              if (r.shouldWalk(dirs, walkFilter))
                queue.push(r);
            }
            if (paused && !results.flowing)
              results.once("drain", process2);
            else if (!sync)
              process2();
          }, sync = !0;
          dir.readdirCB(onReaddir, !0), sync = !1;
        }
      };
      return process2(), results;
    }
    streamSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string")
        entry = this.cwd.resolve(entry);
      else if (!(entry instanceof PathBase))
        opts = entry, entry = this.cwd;
      let { withFileTypes = !0, follow = !1, filter, walkFilter } = opts, results = new minipass_1.Minipass({ objectMode: !0 }), dirs = /* @__PURE__ */ new Set;
      if (!filter || filter(entry))
        results.write(withFileTypes ? entry : entry.fullpath());
      let queue = [entry], processing = 0, process2 = () => {
        let paused = !1;
        while (!paused) {
          let dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++, dirs.add(dir);
          let entries = dir.readdirSync();
          for (let e of entries)
            if (!filter || filter(e)) {
              if (!results.write(withFileTypes ? e : e.fullpath()))
                paused = !0;
            }
          processing--;
          for (let e of entries) {
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter))
              queue.push(r);
          }
        }
        if (paused && !results.flowing)
          results.once("drain", process2);
      };
      return process2(), results;
    }
    chdir(path = this.cwd) {
      let oldCwd = this.cwd;
      this.cwd = typeof path === "string" ? this.cwd.resolve(path) : path, this.cwd[setAsCwd](oldCwd);
    }
  }
  exports.PathScurryBase = PathScurryBase;

  class PathScurryWin32 extends PathScurryBase {
    sep = "\\";
    constructor(cwd = process.cwd(), opts = {}) {
      let { nocase = !0 } = opts;
      super(cwd, node_path_1.win32, "\\", { ...opts, nocase });
      this.nocase = nocase;
      for (let p = this.cwd;p; p = p.parent)
        p.nocase = this.nocase;
    }
    parseRootPath(dir) {
      return node_path_1.win32.parse(dir).root.toUpperCase();
    }
    newRoot(fs) {
      return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    isAbsolute(p) {
      return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
    }
  }
  exports.PathScurryWin32 = PathScurryWin32;

  class PathScurryPosix extends PathScurryBase {
    sep = "/";
    constructor(cwd = process.cwd(), opts = {}) {
      let { nocase = !1 } = opts;
      super(cwd, node_path_1.posix, "/", { ...opts, nocase });
      this.nocase = nocase;
    }
    parseRootPath(_dir) {
      return "/";
    }
    newRoot(fs) {
      return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs });
    }
    isAbsolute(p) {
      return p.startsWith("/");
    }
  }
  exports.PathScurryPosix = PathScurryPosix;

  class PathScurryDarwin extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
      let { nocase = !0 } = opts;
      super(cwd, { ...opts, nocase });
    }
  }
  exports.PathScurryDarwin = PathScurryDarwin;
  exports.Path = process.platform === "win32" ? PathWin32 : PathPosix;
  exports.PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
});

// node_modules/glob/dist/commonjs/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Pattern = void 0;
  var minimatch_1 = require_commonjs22(), isPatternList = (pl) => pl.length >= 1, isGlobList = (gl) => gl.length >= 1;

  class Pattern {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = !0;
    constructor(patternList, globList, index, platform) {
      if (!isPatternList(patternList))
        throw TypeError("empty pattern list");
      if (!isGlobList(globList))
        throw TypeError("empty glob list");
      if (globList.length !== patternList.length)
        throw TypeError("mismatched pattern list and glob list lengths");
      if (this.length = patternList.length, index < 0 || index >= this.length)
        throw TypeError("index out of range");
      if (this.#patternList = patternList, this.#globList = globList, this.#index = index, this.#platform = platform, this.#index === 0) {
        if (this.isUNC()) {
          let [p0, p1, p2, p3, ...prest] = this.#patternList, [g0, g1, g2, g3, ...grest] = this.#globList;
          if (prest[0] === "")
            prest.shift(), grest.shift();
          let p = [p0, p1, p2, p3, ""].join("/"), g = [g0, g1, g2, g3, ""].join("/");
          this.#patternList = [p, ...prest], this.#globList = [g, ...grest], this.length = this.#patternList.length;
        } else if (this.isDrive() || this.isAbsolute()) {
          let [p1, ...prest] = this.#patternList, [g1, ...grest] = this.#globList;
          if (prest[0] === "")
            prest.shift(), grest.shift();
          let p = p1 + "/", g = g1 + "/";
          this.#patternList = [p, ...prest], this.#globList = [g, ...grest], this.length = this.#patternList.length;
        }
      }
    }
    pattern() {
      return this.#patternList[this.#index];
    }
    isString() {
      return typeof this.#patternList[this.#index] === "string";
    }
    isGlobstar() {
      return this.#patternList[this.#index] === minimatch_1.GLOBSTAR;
    }
    isRegExp() {
      return this.#patternList[this.#index] instanceof RegExp;
    }
    globString() {
      return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
    }
    hasMore() {
      return this.length > this.#index + 1;
    }
    rest() {
      if (this.#rest !== void 0)
        return this.#rest;
      if (!this.hasMore())
        return this.#rest = null;
      return this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform), this.#rest.#isAbsolute = this.#isAbsolute, this.#rest.#isUNC = this.#isUNC, this.#rest.#isDrive = this.#isDrive, this.#rest;
    }
    isUNC() {
      let pl = this.#patternList;
      return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
    }
    isDrive() {
      let pl = this.#patternList;
      return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
    }
    isAbsolute() {
      let pl = this.#patternList;
      return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
    }
    root() {
      let p = this.#patternList[0];
      return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
    }
    checkFollowGlobstar() {
      return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
    }
    markFollowGlobstar() {
      if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
        return !1;
      return this.#followGlobstar = !1, !0;
    }
  }
  exports.Pattern = Pattern;
});

// node_modules/glob/dist/commonjs/ignore.js
var require_ignore = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Ignore = void 0;
  var minimatch_1 = require_commonjs22(), pattern_js_1 = require_pattern(), defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";

  class Ignore {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    platform;
    mmopts;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform }) {
      this.relative = [], this.absolute = [], this.relativeChildren = [], this.absoluteChildren = [], this.platform = platform, this.mmopts = {
        dot: !0,
        nobrace,
        nocase,
        noext,
        noglobstar,
        optimizationLevel: 2,
        platform,
        nocomment: !0,
        nonegate: !0
      };
      for (let ign of ignored)
        this.add(ign);
    }
    add(ign) {
      let mm = new minimatch_1.Minimatch(ign, this.mmopts);
      for (let i = 0;i < mm.set.length; i++) {
        let parsed = mm.set[i], globParts = mm.globParts[i];
        if (!parsed || !globParts)
          throw Error("invalid pattern object");
        while (parsed[0] === "." && globParts[0] === ".")
          parsed.shift(), globParts.shift();
        let p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform), m = new minimatch_1.Minimatch(p.globString(), this.mmopts), children = globParts[globParts.length - 1] === "**", absolute = p.isAbsolute();
        if (absolute)
          this.absolute.push(m);
        else
          this.relative.push(m);
        if (children)
          if (absolute)
            this.absoluteChildren.push(m);
          else
            this.relativeChildren.push(m);
      }
    }
    ignored(p) {
      let fullpath = p.fullpath(), fullpaths = `${fullpath}/`, relative = p.relative() || ".", relatives = `${relative}/`;
      for (let m of this.relative)
        if (m.match(relative) || m.match(relatives))
          return !0;
      for (let m of this.absolute)
        if (m.match(fullpath) || m.match(fullpaths))
          return !0;
      return !1;
    }
    childrenIgnored(p) {
      let fullpath = p.fullpath() + "/", relative = (p.relative() || ".") + "/";
      for (let m of this.relativeChildren)
        if (m.match(relative))
          return !0;
      for (let m of this.absoluteChildren)
        if (m.match(fullpath))
          return !0;
      return !1;
    }
  }
  exports.Ignore = Ignore;
});

// node_modules/glob/dist/commonjs/processor.js
var require_processor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;
  var minimatch_1 = require_commonjs22();

  class HasWalkedCache {
    store;
    constructor(store = /* @__PURE__ */ new Map) {
      this.store = store;
    }
    copy() {
      return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
      return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
      let fullpath = target.fullpath(), cached = this.store.get(fullpath);
      if (cached)
        cached.add(pattern.globString());
      else
        this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
    }
  }
  exports.HasWalkedCache = HasWalkedCache;

  class MatchRecord {
    store = /* @__PURE__ */ new Map;
    add(target, absolute, ifDir) {
      let n = (absolute ? 2 : 0) | (ifDir ? 1 : 0), current = this.store.get(target);
      this.store.set(target, current === void 0 ? n : n & current);
    }
    entries() {
      return [...this.store.entries()].map(([path, n]) => [
        path,
        !!(n & 2),
        !!(n & 1)
      ]);
    }
  }
  exports.MatchRecord = MatchRecord;

  class SubWalks {
    store = /* @__PURE__ */ new Map;
    add(target, pattern) {
      if (!target.canReaddir())
        return;
      let subs = this.store.get(target);
      if (subs) {
        if (!subs.find((p) => p.globString() === pattern.globString()))
          subs.push(pattern);
      } else
        this.store.set(target, [pattern]);
    }
    get(target) {
      let subs = this.store.get(target);
      if (!subs)
        throw Error("attempting to walk unknown path");
      return subs;
    }
    entries() {
      return this.keys().map((k) => [k, this.store.get(k)]);
    }
    keys() {
      return [...this.store.keys()].filter((t) => t.canReaddir());
    }
  }
  exports.SubWalks = SubWalks;

  class Processor {
    hasWalkedCache;
    matches = new MatchRecord;
    subwalks = new SubWalks;
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
      this.opts = opts, this.follow = !!opts.follow, this.dot = !!opts.dot, this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache;
    }
    processPatterns(target, patterns) {
      this.patterns = patterns;
      let processingSet = patterns.map((p) => [target, p]);
      for (let [t, pattern] of processingSet) {
        this.hasWalkedCache.storeWalked(t, pattern);
        let root = pattern.root(), absolute = pattern.isAbsolute() && this.opts.absolute !== !1;
        if (root) {
          t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
          let rest2 = pattern.rest();
          if (!rest2) {
            this.matches.add(t, !0, !1);
            continue;
          } else
            pattern = rest2;
        }
        if (t.isENOENT())
          continue;
        let p, rest, changed = !1;
        while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest()))
          t = t.resolve(p), pattern = rest, changed = !0;
        if (p = pattern.pattern(), rest = pattern.rest(), changed) {
          if (this.hasWalkedCache.hasWalked(t, pattern))
            continue;
          this.hasWalkedCache.storeWalked(t, pattern);
        }
        if (typeof p === "string") {
          let ifDir = p === ".." || p === "" || p === ".";
          this.matches.add(t.resolve(p), absolute, ifDir);
          continue;
        } else if (p === minimatch_1.GLOBSTAR) {
          if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar())
            this.subwalks.add(t, pattern);
          let rp = rest?.pattern(), rrest = rest?.rest();
          if (!rest || (rp === "" || rp === ".") && !rrest)
            this.matches.add(t, absolute, rp === "" || rp === ".");
          else if (rp === "..") {
            let tp = t.parent || t;
            if (!rrest)
              this.matches.add(tp, absolute, !0);
            else if (!this.hasWalkedCache.hasWalked(tp, rrest))
              this.subwalks.add(tp, rrest);
          }
        } else if (p instanceof RegExp)
          this.subwalks.add(t, pattern);
      }
      return this;
    }
    subwalkTargets() {
      return this.subwalks.keys();
    }
    child() {
      return new Processor(this.opts, this.hasWalkedCache);
    }
    filterEntries(parent, entries) {
      let patterns = this.subwalks.get(parent), results = this.child();
      for (let e of entries)
        for (let pattern of patterns) {
          let absolute = pattern.isAbsolute(), p = pattern.pattern(), rest = pattern.rest();
          if (p === minimatch_1.GLOBSTAR)
            results.testGlobstar(e, pattern, rest, absolute);
          else if (p instanceof RegExp)
            results.testRegExp(e, p, rest, absolute);
          else
            results.testString(e, p, rest, absolute);
        }
      return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
      if (this.dot || !e.name.startsWith(".")) {
        if (!pattern.hasMore())
          this.matches.add(e, absolute, !1);
        if (e.canReaddir()) {
          if (this.follow || !e.isSymbolicLink())
            this.subwalks.add(e, pattern);
          else if (e.isSymbolicLink()) {
            if (rest && pattern.checkFollowGlobstar())
              this.subwalks.add(e, rest);
            else if (pattern.markFollowGlobstar())
              this.subwalks.add(e, pattern);
          }
        }
      }
      if (rest) {
        let rp = rest.pattern();
        if (typeof rp === "string" && rp !== ".." && rp !== "" && rp !== ".")
          this.testString(e, rp, rest.rest(), absolute);
        else if (rp === "..") {
          let ep = e.parent || e;
          this.subwalks.add(ep, rest);
        } else if (rp instanceof RegExp)
          this.testRegExp(e, rp, rest.rest(), absolute);
      }
    }
    testRegExp(e, p, rest, absolute) {
      if (!p.test(e.name))
        return;
      if (!rest)
        this.matches.add(e, absolute, !1);
      else
        this.subwalks.add(e, rest);
    }
    testString(e, p, rest, absolute) {
      if (!e.isNamed(p))
        return;
      if (!rest)
        this.matches.add(e, absolute, !1);
      else
        this.subwalks.add(e, rest);
    }
  }
  exports.Processor = Processor;
});

// node_modules/glob/dist/commonjs/walker.js
var require_walker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;
  var minipass_1 = require_commonjs24(), ignore_js_1 = require_ignore(), processor_js_1 = require_processor(), makeIgnore = (ignore, opts) => typeof ignore === "string" ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;

  class GlobUtil {
    path;
    patterns;
    opts;
    seen = /* @__PURE__ */ new Set;
    paused = !1;
    aborted = !1;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    includeChildMatches;
    constructor(patterns, path, opts) {
      if (this.patterns = patterns, this.path = path, this.opts = opts, this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/", this.includeChildMatches = opts.includeChildMatches !== !1, opts.ignore || !this.includeChildMatches) {
        if (this.#ignore = makeIgnore(opts.ignore ?? [], opts), !this.includeChildMatches && typeof this.#ignore.add !== "function")
          throw Error("cannot ignore child matches, ignore lacks add() method.");
      }
      if (this.maxDepth = opts.maxDepth || 1 / 0, opts.signal)
        this.signal = opts.signal, this.signal.addEventListener("abort", () => {
          this.#onResume.length = 0;
        });
    }
    #ignored(path) {
      return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
      return !!this.#ignore?.childrenIgnored?.(path);
    }
    pause() {
      this.paused = !0;
    }
    resume() {
      if (this.signal?.aborted)
        return;
      this.paused = !1;
      let fn = void 0;
      while (!this.paused && (fn = this.#onResume.shift()))
        fn();
    }
    onResume(fn) {
      if (this.signal?.aborted)
        return;
      if (!this.paused)
        fn();
      else
        this.#onResume.push(fn);
    }
    async matchCheck(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return;
      let rpc;
      if (this.opts.realpath) {
        if (rpc = e.realpathCached() || await e.realpath(), !rpc)
          return;
        e = rpc;
      }
      let s = e.isUnknown() || this.opts.stat ? await e.lstat() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        let target = await s.realpath();
        if (target && (target.isUnknown() || this.opts.stat))
          await target.lstat();
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
      return e && (this.maxDepth === 1 / 0 || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
    }
    matchCheckSync(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return;
      let rpc;
      if (this.opts.realpath) {
        if (rpc = e.realpathCached() || e.realpathSync(), !rpc)
          return;
        e = rpc;
      }
      let s = e.isUnknown() || this.opts.stat ? e.lstatSync() : e;
      if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
        let target = s.realpathSync();
        if (target && (target?.isUnknown() || this.opts.stat))
          target.lstatSync();
      }
      return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
      if (this.#ignored(e))
        return;
      if (!this.includeChildMatches && this.#ignore?.add) {
        let ign = `${e.relativePosix()}/**`;
        this.#ignore.add(ign);
      }
      let abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
      this.seen.add(e);
      let mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
      if (this.opts.withFileTypes)
        this.matchEmit(e);
      else if (abs) {
        let abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
        this.matchEmit(abs2 + mark);
      } else {
        let rel = this.opts.posix ? e.relativePosix() : e.relative(), pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
        this.matchEmit(!rel ? "." + mark : pre + rel + mark);
      }
    }
    async match(e, absolute, ifDir) {
      let p = await this.matchCheck(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
      let p = this.matchCheckSync(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1, next = () => {
        if (--tasks === 0)
          cb();
      };
      for (let [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++, this.match(m, absolute, ifDir).then(() => next());
      }
      for (let t of processor.subwalkTargets()) {
        if (this.maxDepth !== 1 / 0 && t.depth() >= this.maxDepth)
          continue;
        tasks++;
        let childrenCached = t.readdirCached();
        if (t.calledReaddir())
          this.walkCB3(t, childrenCached, processor, next);
        else
          t.readdirCB((_2, entries) => this.walkCB3(t, entries, processor, next), !0);
      }
      next();
    }
    walkCB3(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1, next = () => {
        if (--tasks === 0)
          cb();
      };
      for (let [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++, this.match(m, absolute, ifDir).then(() => next());
      }
      for (let [target2, patterns] of processor.subwalks.entries())
        tasks++, this.walkCB2(target2, patterns, processor.child(), next);
      next();
    }
    walkCBSync(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1, next = () => {
        if (--tasks === 0)
          cb();
      };
      for (let [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (let t of processor.subwalkTargets()) {
        if (this.maxDepth !== 1 / 0 && t.depth() >= this.maxDepth)
          continue;
        tasks++;
        let children = t.readdirSync();
        this.walkCB3Sync(t, children, processor, next);
      }
      next();
    }
    walkCB3Sync(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1, next = () => {
        if (--tasks === 0)
          cb();
      };
      for (let [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (let [target2, patterns] of processor.subwalks.entries())
        tasks++, this.walkCB2Sync(target2, patterns, processor.child(), next);
      next();
    }
  }
  exports.GlobUtil = GlobUtil;

  class GlobWalker extends GlobUtil {
    matches = /* @__PURE__ */ new Set;
    constructor(patterns, path, opts) {
      super(patterns, path, opts);
    }
    matchEmit(e) {
      this.matches.add(e);
    }
    async walk() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown())
        await this.path.lstat();
      return await new Promise((res, rej) => {
        this.walkCB(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            rej(this.signal.reason);
          else
            res(this.matches);
        });
      }), this.matches;
    }
    walkSync() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown())
        this.path.lstatSync();
      return this.walkCBSync(this.path, this.patterns, () => {
        if (this.signal?.aborted)
          throw this.signal.reason;
      }), this.matches;
    }
  }
  exports.GlobWalker = GlobWalker;

  class GlobStream extends GlobUtil {
    results;
    constructor(patterns, path, opts) {
      super(patterns, path, opts);
      this.results = new minipass_1.Minipass({
        signal: this.signal,
        objectMode: !0
      }), this.results.on("drain", () => this.resume()), this.results.on("resume", () => this.resume());
    }
    matchEmit(e) {
      if (this.results.write(e), !this.results.flowing)
        this.pause();
    }
    stream() {
      let target = this.path;
      if (target.isUnknown())
        target.lstat().then(() => {
          this.walkCB(target, this.patterns, () => this.results.end());
        });
      else
        this.walkCB(target, this.patterns, () => this.results.end());
      return this.results;
    }
    streamSync() {
      if (this.path.isUnknown())
        this.path.lstatSync();
      return this.walkCBSync(this.path, this.patterns, () => this.results.end()), this.results;
    }
  }
  exports.GlobStream = GlobStream;
});

// node_modules/glob/dist/commonjs/glob.js
var require_glob = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Glob = void 0;
  var minimatch_1 = require_commonjs22(), node_url_1 = __require("node:url"), path_scurry_1 = require_commonjs25(), pattern_js_1 = require_pattern(), walker_js_1 = require_walker(), defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";

  class Glob {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    includeChildMatches;
    opts;
    patterns;
    constructor(pattern, opts) {
      if (!opts)
        throw TypeError("glob options required");
      if (this.withFileTypes = !!opts.withFileTypes, this.signal = opts.signal, this.follow = !!opts.follow, this.dot = !!opts.dot, this.dotRelative = !!opts.dotRelative, this.nodir = !!opts.nodir, this.mark = !!opts.mark, !opts.cwd)
        this.cwd = "";
      else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://"))
        opts.cwd = (0, node_url_1.fileURLToPath)(opts.cwd);
      if (this.cwd = opts.cwd || "", this.root = opts.root, this.magicalBraces = !!opts.magicalBraces, this.nobrace = !!opts.nobrace, this.noext = !!opts.noext, this.realpath = !!opts.realpath, this.absolute = opts.absolute, this.includeChildMatches = opts.includeChildMatches !== !1, this.noglobstar = !!opts.noglobstar, this.matchBase = !!opts.matchBase, this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : 1 / 0, this.stat = !!opts.stat, this.ignore = opts.ignore, this.withFileTypes && this.absolute !== void 0)
        throw Error("cannot set absolute and withFileTypes:true");
      if (typeof pattern === "string")
        pattern = [pattern];
      if (this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === !1, this.windowsPathsNoEscape)
        pattern = pattern.map((p) => p.replace(/\\/g, "/"));
      if (this.matchBase) {
        if (opts.noglobstar)
          throw TypeError("base matching requires globstar");
        pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
      }
      if (this.pattern = pattern, this.platform = opts.platform || defaultPlatform, this.opts = { ...opts, platform: this.platform }, opts.scurry) {
        if (this.scurry = opts.scurry, opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase)
          throw Error("nocase option contradicts provided scurry option");
      } else {
        let Scurry = opts.platform === "win32" ? path_scurry_1.PathScurryWin32 : opts.platform === "darwin" ? path_scurry_1.PathScurryDarwin : opts.platform ? path_scurry_1.PathScurryPosix : path_scurry_1.PathScurry;
        this.scurry = new Scurry(this.cwd, {
          nocase: opts.nocase,
          fs: opts.fs
        });
      }
      this.nocase = this.scurry.nocase;
      let nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32", mmo = {
        ...opts,
        dot: this.dot,
        matchBase: this.matchBase,
        nobrace: this.nobrace,
        nocase: this.nocase,
        nocaseMagicOnly,
        nocomment: !0,
        noext: this.noext,
        nonegate: !0,
        optimizationLevel: 2,
        platform: this.platform,
        windowsPathsNoEscape: this.windowsPathsNoEscape,
        debug: !!this.opts.debug
      }, mms = this.pattern.map((p) => new minimatch_1.Minimatch(p, mmo)), [matchSet, globParts] = mms.reduce((set, m) => {
        return set[0].push(...m.set), set[1].push(...m.globParts), set;
      }, [[], []]);
      this.patterns = matchSet.map((set, i) => {
        let g = globParts[i];
        if (!g)
          throw Error("invalid pattern object");
        return new pattern_js_1.Pattern(set, g, 0, this.platform);
      });
    }
    async walk() {
      return [
        ...await new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walk()
      ];
    }
    walkSync() {
      return [
        ...new walker_js_1.GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).walkSync()
      ];
    }
    stream() {
      return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).stream();
    }
    streamSync() {
      return new walker_js_1.GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== 1 / 0 ? this.maxDepth + this.scurry.cwd.depth() : 1 / 0,
        platform: this.platform,
        nocase: this.nocase,
        includeChildMatches: this.includeChildMatches
      }).streamSync();
    }
    iterateSync() {
      return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    iterate() {
      return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
  }
  exports.Glob = Glob;
});

// node_modules/glob/dist/commonjs/has-magic.js
var require_has_magic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.hasMagic = void 0;
  var minimatch_1 = require_commonjs22(), hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern))
      pattern = [pattern];
    for (let p of pattern)
      if (new minimatch_1.Minimatch(p, options).hasMagic())
        return !0;
    return !1;
  };
  exports.hasMagic = hasMagic;
});

// node_modules/glob/dist/commonjs/index.js
var require_commonjs26 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.glob = exports.sync = exports.iterate = exports.iterateSync = exports.stream = exports.streamSync = exports.Ignore = exports.hasMagic = exports.Glob = exports.unescape = exports.escape = void 0;
  exports.globStreamSync = globStreamSync;
  exports.globStream = globStream;
  exports.globSync = globSync;
  exports.globIterateSync = globIterateSync;
  exports.globIterate = globIterate;
  var minimatch_1 = require_commonjs22(), glob_js_1 = require_glob(), has_magic_js_1 = require_has_magic(), minimatch_2 = require_commonjs22();
  Object.defineProperty(exports, "escape", { enumerable: !0, get: function() {
    return minimatch_2.escape;
  } });
  Object.defineProperty(exports, "unescape", { enumerable: !0, get: function() {
    return minimatch_2.unescape;
  } });
  var glob_js_2 = require_glob();
  Object.defineProperty(exports, "Glob", { enumerable: !0, get: function() {
    return glob_js_2.Glob;
  } });
  var has_magic_js_2 = require_has_magic();
  Object.defineProperty(exports, "hasMagic", { enumerable: !0, get: function() {
    return has_magic_js_2.hasMagic;
  } });
  var ignore_js_1 = require_ignore();
  Object.defineProperty(exports, "Ignore", { enumerable: !0, get: function() {
    return ignore_js_1.Ignore;
  } });
  function globStreamSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).streamSync();
  }
  function globStream(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).stream();
  }
  function globSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).walkSync();
  }
  async function glob_(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).walk();
  }
  function globIterateSync(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).iterateSync();
  }
  function globIterate(pattern, options = {}) {
    return new glob_js_1.Glob(pattern, options).iterate();
  }
  exports.streamSync = globStreamSync;
  exports.stream = Object.assign(globStream, { sync: globStreamSync });
  exports.iterateSync = globIterateSync;
  exports.iterate = Object.assign(globIterate, {
    sync: globIterateSync
  });
  exports.sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync
  });
  exports.glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync: exports.sync,
    globStream,
    stream: exports.stream,
    globStreamSync,
    streamSync: exports.streamSync,
    globIterate,
    iterate: exports.iterate,
    globIterateSync,
    iterateSync: exports.iterateSync,
    Glob: glob_js_1.Glob,
    hasMagic: has_magic_js_1.hasMagic,
    escape: minimatch_1.escape,
    unescape: minimatch_1.unescape
  });
  exports.glob.glob = exports.glob;
});

// node_modules/archiver-utils/file.js
var require_file3 = __commonJS((exports, module) => {
  var fs = require_graceful_fs(), path = __require("path"), flatten = require_flatten(), difference = require_difference(), union = require_union(), isPlainObject = require_isPlainObject(), glob = require_commonjs26(), file = module.exports = {}, pathSeparatorRe = /[\/\\]/g, processPatterns = function(patterns, fn) {
    var result = [];
    return flatten(patterns).forEach(function(pattern) {
      var exclusion = pattern.indexOf("!") === 0;
      if (exclusion)
        pattern = pattern.slice(1);
      var matches = fn(pattern);
      if (exclusion)
        result = difference(result, matches);
      else
        result = union(result, matches);
    }), result;
  };
  file.exists = function() {
    var filepath = path.join.apply(path, arguments);
    return fs.existsSync(filepath);
  };
  file.expand = function(...args) {
    var options = isPlainObject(args[0]) ? args.shift() : {}, patterns = Array.isArray(args[0]) ? args[0] : args;
    if (patterns.length === 0)
      return [];
    var matches = processPatterns(patterns, function(pattern) {
      return glob.sync(pattern, options);
    });
    if (options.filter)
      matches = matches.filter(function(filepath) {
        filepath = path.join(options.cwd || "", filepath);
        try {
          if (typeof options.filter === "function")
            return options.filter(filepath);
          else
            return fs.statSync(filepath)[options.filter]();
        } catch (e) {
          return !1;
        }
      });
    return matches;
  };
  file.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
      rename: function(destBase2, destPath) {
        return path.join(destBase2 || "", destPath);
      }
    }, options);
    var files = [], fileByDest = {};
    return file.expand(options, patterns).forEach(function(src) {
      var destPath = src;
      if (options.flatten)
        destPath = path.basename(destPath);
      if (options.ext)
        destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
      var dest = options.rename(destBase, destPath, options);
      if (options.cwd)
        src = path.join(options.cwd, src);
      if (dest = dest.replace(pathSeparatorRe, "/"), src = src.replace(pathSeparatorRe, "/"), fileByDest[dest])
        fileByDest[dest].src.push(src);
      else
        files.push({
          src: [src],
          dest
        }), fileByDest[dest] = files[files.length - 1];
    }), files;
  };
  file.normalizeFilesArray = function(data) {
    var files = [];
    if (data.forEach(function(obj) {
      var prop;
      if ("src" in obj || "dest" in obj)
        files.push(obj);
    }), files.length === 0)
      return [];
    return files = _(files).chain().forEach(function(obj) {
      if (!("src" in obj) || !obj.src)
        return;
      if (Array.isArray(obj.src))
        obj.src = flatten(obj.src);
      else
        obj.src = [obj.src];
    }).map(function(obj) {
      var expandOptions = Object.assign({}, obj);
      if (delete expandOptions.src, delete expandOptions.dest, obj.expand)
        return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
          var result2 = Object.assign({}, obj);
          return result2.orig = Object.assign({}, obj), result2.src = mapObj.src, result2.dest = mapObj.dest, ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
            delete result2[prop];
          }), result2;
        });
      var result = Object.assign({}, obj);
      if (result.orig = Object.assign({}, obj), "src" in result)
        Object.defineProperty(result, "src", {
          enumerable: !0,
          get: function fn() {
            var src;
            if (!("result" in fn))
              src = obj.src, src = Array.isArray(src) ? flatten(src) : [src], fn.result = file.expand(expandOptions, src);
            return fn.result;
          }
        });
      if ("dest" in result)
        result.dest = obj.dest;
      return result;
    }).flatten().value(), files;
  };
});

// node_modules/archiver-utils/index.js
var require_archiver_utils = __commonJS((exports, module) => {
  var fs = require_graceful_fs(), path = __require("path"), isStream = require_is_stream(), lazystream = require_lazystream(), normalizePath = require_normalize_path(), defaults = require_defaults(), Stream = __require("stream").Stream, PassThrough = require_ours().PassThrough, utils = module.exports = {};
  utils.file = require_file3();
  utils.collectStream = function(source, callback) {
    var collection = [], size = 0;
    source.on("error", callback), source.on("data", function(chunk) {
      collection.push(chunk), size += chunk.length;
    }), source.on("end", function() {
      var buf = Buffer.alloc(size), offset = 0;
      collection.forEach(function(data) {
        data.copy(buf, offset), offset += data.length;
      }), callback(null, buf);
    });
  };
  utils.dateify = function(dateish) {
    if (dateish = dateish || /* @__PURE__ */ new Date, dateish instanceof Date)
      dateish = dateish;
    else if (typeof dateish === "string")
      dateish = new Date(dateish);
    else
      dateish = /* @__PURE__ */ new Date;
    return dateish;
  };
  utils.defaults = function(object, source, guard) {
    var args = arguments;
    return args[0] = args[0] || {}, defaults(...args);
  };
  utils.isStream = function(source) {
    return isStream(source);
  };
  utils.lazyReadStream = function(filepath) {
    return new lazystream.Readable(function() {
      return fs.createReadStream(filepath);
    });
  };
  utils.normalizeInputSource = function(source) {
    if (source === null)
      return Buffer.alloc(0);
    else if (typeof source === "string")
      return Buffer.from(source);
    else if (utils.isStream(source))
      return source.pipe(new PassThrough);
    return source;
  };
  utils.sanitizePath = function(filepath) {
    return normalizePath(filepath, !1).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  };
  utils.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
  };
  utils.unixifyPath = function(filepath) {
    return normalizePath(filepath, !1).replace(/^\w+:/, "");
  };
  utils.walkdir = function(dirpath, base, callback) {
    var results = [];
    if (typeof base === "function")
      callback = base, base = dirpath;
    fs.readdir(dirpath, function(err, list) {
      var i = 0, file, filepath;
      if (err)
        return callback(err);
      (function next() {
        if (file = list[i++], !file)
          return callback(null, results);
        filepath = path.join(dirpath, file), fs.stat(filepath, function(err2, stats) {
          if (results.push({
            path: filepath,
            relative: path.relative(base, filepath).replace(/\\/g, "/"),
            stats
          }), stats && stats.isDirectory())
            utils.walkdir(filepath, base, function(err3, res) {
              if (err3)
                return callback(err3);
              res.forEach(function(dirEntry) {
                results.push(dirEntry);
              }), next();
            });
          else
            next();
        });
      })();
    });
  };
});

// node_modules/archiver/lib/error.js
var require_error5 = __commonJS((exports, module) => {
  var util = __require("util"), ERROR_CODES = {
    ABORTED: "archive was aborted",
    DIRECTORYDIRPATHREQUIRED: "diretory dirpath argument must be a non-empty string value",
    DIRECTORYFUNCTIONINVALIDDATA: "invalid data returned by directory custom data function",
    ENTRYNAMEREQUIRED: "entry name must be a non-empty string value",
    FILEFILEPATHREQUIRED: "file filepath argument must be a non-empty string value",
    FINALIZING: "archive already finalizing",
    QUEUECLOSED: "queue closed",
    NOENDMETHOD: "no suitable finalize/end method defined by module",
    DIRECTORYNOTSUPPORTED: "support for directory entries not defined by module",
    FORMATSET: "archive format already set",
    INPUTSTEAMBUFFERREQUIRED: "input source must be valid Stream or Buffer instance",
    MODULESET: "module already set",
    SYMLINKNOTSUPPORTED: "support for symlink entries not defined by module",
    SYMLINKFILEPATHREQUIRED: "symlink filepath argument must be a non-empty string value",
    SYMLINKTARGETREQUIRED: "symlink target argument must be a non-empty string value",
    ENTRYNOTSUPPORTED: "entry not supported"
  };
  function ArchiverError(code, data) {
    Error.captureStackTrace(this, this.constructor), this.message = ERROR_CODES[code] || code, this.code = code, this.data = data;
  }
  util.inherits(ArchiverError, Error);
  exports = module.exports = ArchiverError;
});

// node_modules/archiver/lib/core.js
var require_core2 = __commonJS((exports, module) => {
  var fs = __require("fs"), glob = require_readdir_glob(), async = require_async(), path = __require("path"), util = require_archiver_utils(), inherits = __require("util").inherits, ArchiverError = require_error5(), Transform = require_ours().Transform, win32 = process.platform === "win32", Archiver = function(format, options) {
    if (!(this instanceof Archiver))
      return new Archiver(format, options);
    if (typeof format !== "string")
      options = format, format = "zip";
    options = this.options = util.defaults(options, {
      highWaterMark: 1048576,
      statConcurrency: 4
    }), Transform.call(this, options), this._format = !1, this._module = !1, this._pending = 0, this._pointer = 0, this._entriesCount = 0, this._entriesProcessedCount = 0, this._fsEntriesTotalBytes = 0, this._fsEntriesProcessedBytes = 0, this._queue = async.queue(this._onQueueTask.bind(this), 1), this._queue.drain(this._onQueueDrain.bind(this)), this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency), this._statQueue.drain(this._onQueueDrain.bind(this)), this._state = {
      aborted: !1,
      finalize: !1,
      finalizing: !1,
      finalized: !1,
      modulePiped: !1
    }, this._streams = [];
  };
  inherits(Archiver, Transform);
  Archiver.prototype._abort = function() {
    if (this._state.aborted = !0, this._queue.kill(), this._statQueue.kill(), this._queue.idle())
      this._shutdown();
  };
  Archiver.prototype._append = function(filepath, data) {
    data = data || {};
    var task = {
      source: null,
      filepath
    };
    if (!data.name)
      data.name = filepath;
    if (data.sourcePath = filepath, task.data = data, this._entriesCount++, data.stats && data.stats instanceof fs.Stats) {
      if (task = this._updateQueueTaskWithStats(task, data.stats), task) {
        if (data.stats.size)
          this._fsEntriesTotalBytes += data.stats.size;
        this._queue.push(task);
      }
    } else
      this._statQueue.push(task);
  };
  Archiver.prototype._finalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted)
      return;
    this._state.finalizing = !0, this._moduleFinalize(), this._state.finalizing = !1, this._state.finalized = !0;
  };
  Archiver.prototype._maybeFinalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted)
      return !1;
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle())
      return this._finalize(), !0;
    return !1;
  };
  Archiver.prototype._moduleAppend = function(source, data, callback) {
    if (this._state.aborted) {
      callback();
      return;
    }
    this._module.append(source, data, function(err) {
      if (this._task = null, this._state.aborted) {
        this._shutdown();
        return;
      }
      if (err) {
        this.emit("error", err), setImmediate(callback);
        return;
      }
      if (this.emit("entry", data), this._entriesProcessedCount++, data.stats && data.stats.size)
        this._fsEntriesProcessedBytes += data.stats.size;
      this.emit("progress", {
        entries: {
          total: this._entriesCount,
          processed: this._entriesProcessedCount
        },
        fs: {
          totalBytes: this._fsEntriesTotalBytes,
          processedBytes: this._fsEntriesProcessedBytes
        }
      }), setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._moduleFinalize = function() {
    if (typeof this._module.finalize === "function")
      this._module.finalize();
    else if (typeof this._module.end === "function")
      this._module.end();
    else
      this.emit("error", new ArchiverError("NOENDMETHOD"));
  };
  Archiver.prototype._modulePipe = function() {
    this._module.on("error", this._onModuleError.bind(this)), this._module.pipe(this), this._state.modulePiped = !0;
  };
  Archiver.prototype._moduleSupports = function(key) {
    if (!this._module.supports || !this._module.supports[key])
      return !1;
    return this._module.supports[key];
  };
  Archiver.prototype._moduleUnpipe = function() {
    this._module.unpipe(this), this._state.modulePiped = !1;
  };
  Archiver.prototype._normalizeEntryData = function(data, stats) {
    if (data = util.defaults(data, {
      type: "file",
      name: null,
      date: null,
      mode: null,
      prefix: null,
      sourcePath: null,
      stats: !1
    }), stats && data.stats === !1)
      data.stats = stats;
    var isDir = data.type === "directory";
    if (data.name) {
      if (typeof data.prefix === "string" && data.prefix !== "")
        data.name = data.prefix + "/" + data.name, data.prefix = null;
      if (data.name = util.sanitizePath(data.name), data.type !== "symlink" && data.name.slice(-1) === "/")
        isDir = !0, data.type = "directory";
      else if (isDir)
        data.name += "/";
    }
    if (typeof data.mode === "number")
      if (win32)
        data.mode &= 511;
      else
        data.mode &= 4095;
    else if (data.stats && data.mode === null) {
      if (win32)
        data.mode = data.stats.mode & 511;
      else
        data.mode = data.stats.mode & 4095;
      if (win32 && isDir)
        data.mode = 493;
    } else if (data.mode === null)
      data.mode = isDir ? 493 : 420;
    if (data.stats && data.date === null)
      data.date = data.stats.mtime;
    else
      data.date = util.dateify(data.date);
    return data;
  };
  Archiver.prototype._onModuleError = function(err) {
    this.emit("error", err);
  };
  Archiver.prototype._onQueueDrain = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted)
      return;
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle())
      this._finalize();
  };
  Archiver.prototype._onQueueTask = function(task, callback) {
    var fullCallback = () => {
      if (task.data.callback)
        task.data.callback();
      callback();
    };
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      fullCallback();
      return;
    }
    this._task = task, this._moduleAppend(task.source, task.data, fullCallback);
  };
  Archiver.prototype._onStatQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      callback();
      return;
    }
    fs.lstat(task.filepath, function(err, stats) {
      if (this._state.aborted) {
        setImmediate(callback);
        return;
      }
      if (err) {
        this._entriesCount--, this.emit("warning", err), setImmediate(callback);
        return;
      }
      if (task = this._updateQueueTaskWithStats(task, stats), task) {
        if (stats.size)
          this._fsEntriesTotalBytes += stats.size;
        this._queue.push(task);
      }
      setImmediate(callback);
    }.bind(this));
  };
  Archiver.prototype._shutdown = function() {
    this._moduleUnpipe(), this.end();
  };
  Archiver.prototype._transform = function(chunk, encoding, callback) {
    if (chunk)
      this._pointer += chunk.length;
    callback(null, chunk);
  };
  Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
    if (stats.isFile())
      task.data.type = "file", task.data.sourceType = "stream", task.source = util.lazyReadStream(task.filepath);
    else if (stats.isDirectory() && this._moduleSupports("directory"))
      task.data.name = util.trailingSlashIt(task.data.name), task.data.type = "directory", task.data.sourcePath = util.trailingSlashIt(task.filepath), task.data.sourceType = "buffer", task.source = Buffer.concat([]);
    else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
      var linkPath = fs.readlinkSync(task.filepath), dirName = path.dirname(task.filepath);
      task.data.type = "symlink", task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath)), task.data.sourceType = "buffer", task.source = Buffer.concat([]);
    } else {
      if (stats.isDirectory())
        this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
      else if (stats.isSymbolicLink())
        this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
      else
        this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
      return null;
    }
    return task.data = this._normalizeEntryData(task.data, stats), task;
  };
  Archiver.prototype.abort = function() {
    if (this._state.aborted || this._state.finalized)
      return this;
    return this._abort(), this;
  };
  Archiver.prototype.append = function(source, data) {
    if (this._state.finalize || this._state.aborted)
      return this.emit("error", new ArchiverError("QUEUECLOSED")), this;
    if (data = this._normalizeEntryData(data), typeof data.name !== "string" || data.name.length === 0)
      return this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED")), this;
    if (data.type === "directory" && !this._moduleSupports("directory"))
      return this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data.name })), this;
    if (source = util.normalizeInputSource(source), Buffer.isBuffer(source))
      data.sourceType = "buffer";
    else if (util.isStream(source))
      data.sourceType = "stream";
    else
      return this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data.name })), this;
    return this._entriesCount++, this._queue.push({
      data,
      source
    }), this;
  };
  Archiver.prototype.directory = function(dirpath, destpath, data) {
    if (this._state.finalize || this._state.aborted)
      return this.emit("error", new ArchiverError("QUEUECLOSED")), this;
    if (typeof dirpath !== "string" || dirpath.length === 0)
      return this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED")), this;
    if (this._pending++, destpath === !1)
      destpath = "";
    else if (typeof destpath !== "string")
      destpath = dirpath;
    var dataFunction = !1;
    if (typeof data === "function")
      dataFunction = data, data = {};
    else if (typeof data !== "object")
      data = {};
    var globOptions = {
      stat: !0,
      dot: !0
    };
    function onGlobEnd() {
      this._pending--, this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var ignoreMatch = !1, entryData = Object.assign({}, data);
      entryData.name = match.relative, entryData.prefix = destpath, entryData.stats = match.stat, entryData.callback = globber.resume.bind(globber);
      try {
        if (dataFunction) {
          if (entryData = dataFunction(entryData), entryData === !1)
            ignoreMatch = !0;
          else if (typeof entryData !== "object")
            throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
        }
      } catch (e) {
        this.emit("error", e);
        return;
      }
      if (ignoreMatch) {
        globber.resume();
        return;
      }
      this._append(match.absolute, entryData);
    }
    var globber = glob(dirpath, globOptions);
    return globber.on("error", onGlobError.bind(this)), globber.on("match", onGlobMatch.bind(this)), globber.on("end", onGlobEnd.bind(this)), this;
  };
  Archiver.prototype.file = function(filepath, data) {
    if (this._state.finalize || this._state.aborted)
      return this.emit("error", new ArchiverError("QUEUECLOSED")), this;
    if (typeof filepath !== "string" || filepath.length === 0)
      return this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED")), this;
    return this._append(filepath, data), this;
  };
  Archiver.prototype.glob = function(pattern, options, data) {
    this._pending++, options = util.defaults(options, {
      stat: !0,
      pattern
    });
    function onGlobEnd() {
      this._pending--, this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var entryData = Object.assign({}, data);
      entryData.callback = globber.resume.bind(globber), entryData.stats = match.stat, entryData.name = match.relative, this._append(match.absolute, entryData);
    }
    var globber = glob(options.cwd || ".", options);
    return globber.on("error", onGlobError.bind(this)), globber.on("match", onGlobMatch.bind(this)), globber.on("end", onGlobEnd.bind(this)), this;
  };
  Archiver.prototype.finalize = function() {
    if (this._state.aborted) {
      var abortedError = new ArchiverError("ABORTED");
      return this.emit("error", abortedError), Promise.reject(abortedError);
    }
    if (this._state.finalize) {
      var finalizingError = new ArchiverError("FINALIZING");
      return this.emit("error", finalizingError), Promise.reject(finalizingError);
    }
    if (this._state.finalize = !0, this._pending === 0 && this._queue.idle() && this._statQueue.idle())
      this._finalize();
    var self2 = this;
    return new Promise(function(resolve, reject) {
      var errored;
      self2._module.on("end", function() {
        if (!errored)
          resolve();
      }), self2._module.on("error", function(err) {
        errored = !0, reject(err);
      });
    });
  };
  Archiver.prototype.setFormat = function(format) {
    if (this._format)
      return this.emit("error", new ArchiverError("FORMATSET")), this;
    return this._format = format, this;
  };
  Archiver.prototype.setModule = function(module2) {
    if (this._state.aborted)
      return this.emit("error", new ArchiverError("ABORTED")), this;
    if (this._state.module)
      return this.emit("error", new ArchiverError("MODULESET")), this;
    return this._module = module2, this._modulePipe(), this;
  };
  Archiver.prototype.symlink = function(filepath, target, mode) {
    if (this._state.finalize || this._state.aborted)
      return this.emit("error", new ArchiverError("QUEUECLOSED")), this;
    if (typeof filepath !== "string" || filepath.length === 0)
      return this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED")), this;
    if (typeof target !== "string" || target.length === 0)
      return this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath })), this;
    if (!this._moduleSupports("symlink"))
      return this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath })), this;
    var data = {};
    if (data.type = "symlink", data.name = filepath.replace(/\\/g, "/"), data.linkname = target.replace(/\\/g, "/"), data.sourceType = "buffer", typeof mode === "number")
      data.mode = mode;
    return this._entriesCount++, this._queue.push({
      data,
      source: Buffer.concat([])
    }), this;
  };
  Archiver.prototype.pointer = function() {
    return this._pointer;
  };
  Archiver.prototype.use = function(plugin) {
    return this._streams.push(plugin), this;
  };
  module.exports = Archiver;
});

// node_modules/compress-commons/lib/archivers/archive-entry.js
var require_archive_entry = __commonJS((exports, module) => {
  var ArchiveEntry = module.exports = function() {};
  ArchiveEntry.prototype.getName = function() {};
  ArchiveEntry.prototype.getSize = function() {};
  ArchiveEntry.prototype.getLastModifiedDate = function() {};
  ArchiveEntry.prototype.isDirectory = function() {};
});

// node_modules/compress-commons/lib/archivers/zip/util.js
var require_util12 = __commonJS((exports, module) => {
  var util = module.exports = {};
  util.dateToDos = function(d, forceLocalTime) {
    forceLocalTime = forceLocalTime || !1;
    var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
    if (year < 1980)
      return 2162688;
    else if (year >= 2044)
      return 2141175677;
    var val = {
      year,
      month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
      date: forceLocalTime ? d.getDate() : d.getUTCDate(),
      hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
      minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
      seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
    };
    return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
  };
  util.dosToDate = function(dos) {
    return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
  };
  util.fromDosTime = function(buf) {
    return util.dosToDate(buf.readUInt32LE(0));
  };
  util.getEightBytes = function(v) {
    var buf = Buffer.alloc(8);
    return buf.writeUInt32LE(v % 4294967296, 0), buf.writeUInt32LE(v / 4294967296 | 0, 4), buf;
  };
  util.getShortBytes = function(v) {
    var buf = Buffer.alloc(2);
    return buf.writeUInt16LE((v & 65535) >>> 0, 0), buf;
  };
  util.getShortBytesValue = function(buf, offset) {
    return buf.readUInt16LE(offset);
  };
  util.getLongBytes = function(v) {
    var buf = Buffer.alloc(4);
    return buf.writeUInt32LE((v & 4294967295) >>> 0, 0), buf;
  };
  util.getLongBytesValue = function(buf, offset) {
    return buf.readUInt32LE(offset);
  };
  util.toDosTime = function(d) {
    return util.getLongBytes(util.dateToDos(d));
  };
});

// node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js
var require_general_purpose_bit = __commonJS((exports, module) => {
  var zipUtil = require_util12(), DATA_DESCRIPTOR_FLAG = 8, ENCRYPTION_FLAG = 1, NUMBER_OF_SHANNON_FANO_TREES_FLAG = 4, SLIDING_DICTIONARY_SIZE_FLAG = 2, STRONG_ENCRYPTION_FLAG = 64, UFT8_NAMES_FLAG = 2048, GeneralPurposeBit = module.exports = function() {
    if (!(this instanceof GeneralPurposeBit))
      return new GeneralPurposeBit;
    return this.descriptor = !1, this.encryption = !1, this.utf8 = !1, this.numberOfShannonFanoTrees = 0, this.strongEncryption = !1, this.slidingDictionarySize = 0, this;
  };
  GeneralPurposeBit.prototype.encode = function() {
    return zipUtil.getShortBytes((this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0));
  };
  GeneralPurposeBit.prototype.parse = function(buf, offset) {
    var flag = zipUtil.getShortBytesValue(buf, offset), gbp = new GeneralPurposeBit;
    return gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0), gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0), gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0), gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0), gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096), gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2), gbp;
  };
  GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
    this.numberOfShannonFanoTrees = n;
  };
  GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
    return this.numberOfShannonFanoTrees;
  };
  GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
    this.slidingDictionarySize = n;
  };
  GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
    return this.slidingDictionarySize;
  };
  GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
    this.descriptor = b;
  };
  GeneralPurposeBit.prototype.usesDataDescriptor = function() {
    return this.descriptor;
  };
  GeneralPurposeBit.prototype.useEncryption = function(b) {
    this.encryption = b;
  };
  GeneralPurposeBit.prototype.usesEncryption = function() {
    return this.encryption;
  };
  GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
    this.strongEncryption = b;
  };
  GeneralPurposeBit.prototype.usesStrongEncryption = function() {
    return this.strongEncryption;
  };
  GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
    this.utf8 = b;
  };
  GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
    return this.utf8;
  };
});

// node_modules/compress-commons/lib/archivers/zip/unix-stat.js
var require_unix_stat = __commonJS((exports, module) => {
  module.exports = {
    PERM_MASK: 4095,
    FILE_TYPE_FLAG: 61440,
    LINK_FLAG: 40960,
    FILE_FLAG: 32768,
    DIR_FLAG: 16384,
    DEFAULT_LINK_PERM: 511,
    DEFAULT_DIR_PERM: 493,
    DEFAULT_FILE_PERM: 420
  };
});

// node_modules/compress-commons/lib/archivers/zip/constants.js
var require_constants11 = __commonJS((exports, module) => {
  module.exports = {
    WORD: 4,
    DWORD: 8,
    EMPTY: Buffer.alloc(0),
    SHORT: 2,
    SHORT_MASK: 65535,
    SHORT_SHIFT: 16,
    SHORT_ZERO: Buffer.from(Array(2)),
    LONG: 4,
    LONG_ZERO: Buffer.from(Array(4)),
    MIN_VERSION_INITIAL: 10,
    MIN_VERSION_DATA_DESCRIPTOR: 20,
    MIN_VERSION_ZIP64: 45,
    VERSION_MADEBY: 45,
    METHOD_STORED: 0,
    METHOD_DEFLATED: 8,
    PLATFORM_UNIX: 3,
    PLATFORM_FAT: 0,
    SIG_LFH: 67324752,
    SIG_DD: 134695760,
    SIG_CFH: 33639248,
    SIG_EOCD: 101010256,
    SIG_ZIP64_EOCD: 101075792,
    SIG_ZIP64_EOCD_LOC: 117853008,
    ZIP64_MAGIC_SHORT: 65535,
    ZIP64_MAGIC: 4294967295,
    ZIP64_EXTRA_ID: 1,
    ZLIB_NO_COMPRESSION: 0,
    ZLIB_BEST_SPEED: 1,
    ZLIB_BEST_COMPRESSION: 9,
    ZLIB_DEFAULT_COMPRESSION: -1,
    MODE_MASK: 4095,
    DEFAULT_FILE_MODE: 33188,
    DEFAULT_DIR_MODE: 16877,
    EXT_FILE_ATTR_DIR: 1106051088,
    EXT_FILE_ATTR_FILE: 2175008800,
    S_IFMT: 61440,
    S_IFIFO: 4096,
    S_IFCHR: 8192,
    S_IFDIR: 16384,
    S_IFBLK: 24576,
    S_IFREG: 32768,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    S_DOS_A: 32,
    S_DOS_D: 16,
    S_DOS_V: 8,
    S_DOS_S: 4,
    S_DOS_H: 2,
    S_DOS_R: 1
  };
});

// node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js
var require_zip_archive_entry = __commonJS((exports, module) => {
  var inherits = __require("util").inherits, normalizePath = require_normalize_path(), ArchiveEntry = require_archive_entry(), GeneralPurposeBit = require_general_purpose_bit(), UnixStat = require_unix_stat(), constants = require_constants11(), zipUtil = require_util12(), ZipArchiveEntry = module.exports = function(name) {
    if (!(this instanceof ZipArchiveEntry))
      return new ZipArchiveEntry(name);
    if (ArchiveEntry.call(this), this.platform = constants.PLATFORM_FAT, this.method = -1, this.name = null, this.size = 0, this.csize = 0, this.gpb = new GeneralPurposeBit, this.crc = 0, this.time = -1, this.minver = constants.MIN_VERSION_INITIAL, this.mode = -1, this.extra = null, this.exattr = 0, this.inattr = 0, this.comment = null, name)
      this.setName(name);
  };
  inherits(ZipArchiveEntry, ArchiveEntry);
  ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getComment = function() {
    return this.comment !== null ? this.comment : "";
  };
  ZipArchiveEntry.prototype.getCompressedSize = function() {
    return this.csize;
  };
  ZipArchiveEntry.prototype.getCrc = function() {
    return this.crc;
  };
  ZipArchiveEntry.prototype.getExternalAttributes = function() {
    return this.exattr;
  };
  ZipArchiveEntry.prototype.getExtra = function() {
    return this.extra !== null ? this.extra : constants.EMPTY;
  };
  ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
    return this.gpb;
  };
  ZipArchiveEntry.prototype.getInternalAttributes = function() {
    return this.inattr;
  };
  ZipArchiveEntry.prototype.getLastModifiedDate = function() {
    return this.getTime();
  };
  ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getMethod = function() {
    return this.method;
  };
  ZipArchiveEntry.prototype.getName = function() {
    return this.name;
  };
  ZipArchiveEntry.prototype.getPlatform = function() {
    return this.platform;
  };
  ZipArchiveEntry.prototype.getSize = function() {
    return this.size;
  };
  ZipArchiveEntry.prototype.getTime = function() {
    return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
  };
  ZipArchiveEntry.prototype.getTimeDos = function() {
    return this.time !== -1 ? this.time : 0;
  };
  ZipArchiveEntry.prototype.getUnixMode = function() {
    return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
  };
  ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
    return this.minver;
  };
  ZipArchiveEntry.prototype.setComment = function(comment) {
    if (Buffer.byteLength(comment) !== comment.length)
      this.getGeneralPurposeBit().useUTF8ForNames(!0);
    this.comment = comment;
  };
  ZipArchiveEntry.prototype.setCompressedSize = function(size) {
    if (size < 0)
      throw Error("invalid entry compressed size");
    this.csize = size;
  };
  ZipArchiveEntry.prototype.setCrc = function(crc) {
    if (crc < 0)
      throw Error("invalid entry crc32");
    this.crc = crc;
  };
  ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
    this.exattr = attr >>> 0;
  };
  ZipArchiveEntry.prototype.setExtra = function(extra) {
    this.extra = extra;
  };
  ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
    if (!(gpb instanceof GeneralPurposeBit))
      throw Error("invalid entry GeneralPurposeBit");
    this.gpb = gpb;
  };
  ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
    this.inattr = attr;
  };
  ZipArchiveEntry.prototype.setMethod = function(method) {
    if (method < 0)
      throw Error("invalid entry compression method");
    this.method = method;
  };
  ZipArchiveEntry.prototype.setName = function(name, prependSlash = !1) {
    if (name = normalizePath(name, !1).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, ""), prependSlash)
      name = `/${name}`;
    if (Buffer.byteLength(name) !== name.length)
      this.getGeneralPurposeBit().useUTF8ForNames(!0);
    this.name = name;
  };
  ZipArchiveEntry.prototype.setPlatform = function(platform) {
    this.platform = platform;
  };
  ZipArchiveEntry.prototype.setSize = function(size) {
    if (size < 0)
      throw Error("invalid entry size");
    this.size = size;
  };
  ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
    if (!(time instanceof Date))
      throw Error("invalid entry time");
    this.time = zipUtil.dateToDos(time, forceLocalTime);
  };
  ZipArchiveEntry.prototype.setUnixMode = function(mode) {
    mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
    var extattr = 0;
    extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A), this.setExternalAttributes(extattr), this.mode = mode & constants.MODE_MASK, this.platform = constants.PLATFORM_UNIX;
  };
  ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
    this.minver = minver;
  };
  ZipArchiveEntry.prototype.isDirectory = function() {
    return this.getName().slice(-1) === "/";
  };
  ZipArchiveEntry.prototype.isUnixSymlink = function() {
    return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
  };
  ZipArchiveEntry.prototype.isZip64 = function() {
    return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
  };
});

// node_modules/compress-commons/lib/util/index.js
var require_util13 = __commonJS((exports, module) => {
  var Stream = __require("stream").Stream, PassThrough = require_ours().PassThrough, isStream = require_is_stream(), util = module.exports = {};
  util.normalizeInputSource = function(source) {
    if (source === null)
      return Buffer.alloc(0);
    else if (typeof source === "string")
      return Buffer.from(source);
    else if (isStream(source) && !source._readableState) {
      var normalized = new PassThrough;
      return source.pipe(normalized), normalized;
    }
    return source;
  };
});

// node_modules/compress-commons/lib/archivers/archive-output-stream.js
var require_archive_output_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits, isStream = require_is_stream(), Transform = require_ours().Transform, ArchiveEntry = require_archive_entry(), util = require_util13(), ArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ArchiveOutputStream))
      return new ArchiveOutputStream(options);
    Transform.call(this, options), this.offset = 0, this._archive = {
      finish: !1,
      finished: !1,
      processing: !1
    };
  };
  inherits(ArchiveOutputStream, Transform);
  ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {};
  ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {};
  ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
    if (err)
      this.emit("error", err);
  };
  ArchiveOutputStream.prototype._finish = function(ae) {};
  ArchiveOutputStream.prototype._normalizeEntry = function(ae) {};
  ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
    if (source = source || null, typeof callback !== "function")
      callback = this._emitErrorCallback.bind(this);
    if (!(ae instanceof ArchiveEntry)) {
      callback(Error("not a valid instance of ArchiveEntry"));
      return;
    }
    if (this._archive.finish || this._archive.finished) {
      callback(Error("unacceptable entry after finish"));
      return;
    }
    if (this._archive.processing) {
      callback(Error("already processing an entry"));
      return;
    }
    if (this._archive.processing = !0, this._normalizeEntry(ae), this._entry = ae, source = util.normalizeInputSource(source), Buffer.isBuffer(source))
      this._appendBuffer(ae, source, callback);
    else if (isStream(source))
      this._appendStream(ae, source, callback);
    else {
      this._archive.processing = !1, callback(Error("input source must be valid Stream or Buffer instance"));
      return;
    }
    return this;
  };
  ArchiveOutputStream.prototype.finish = function() {
    if (this._archive.processing) {
      this._archive.finish = !0;
      return;
    }
    this._finish();
  };
  ArchiveOutputStream.prototype.getBytesWritten = function() {
    return this.offset;
  };
  ArchiveOutputStream.prototype.write = function(chunk, cb) {
    if (chunk)
      this.offset += chunk.length;
    return Transform.prototype.write.call(this, chunk, cb);
  };
});

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS((exports) => {
  /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
  var CRC32;
  (function(factory) {
    if (typeof DO_NOT_EXPORT_CRC > "u")
      if (typeof exports === "object")
        factory(exports);
      else if (typeof define === "function" && define.amd)
        define(function() {
          var module2 = {};
          return factory(module2), module2;
        });
      else
        factory(CRC32 = {});
    else
      factory(CRC32 = {});
  })(function(CRC322) {
    CRC322.version = "1.2.2";
    function signed_crc_table() {
      var c = 0, table = Array(256);
      for (var n = 0;n != 256; ++n)
        c = n, c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1, c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1, c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1, c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1, c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1, c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1, c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1, c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1, table[n] = c;
      return typeof Int32Array < "u" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c = 0, v = 0, n = 0, table = typeof Int32Array < "u" ? new Int32Array(4096) : Array(4096);
      for (n = 0;n != 256; ++n)
        table[n] = T[n];
      for (n = 0;n != 256; ++n) {
        v = T[n];
        for (c = 256 + n;c < 4096; c += 256)
          v = table[c] = v >>> 8 ^ T[v & 255];
      }
      var out = [];
      for (n = 1;n != 16; ++n)
        out[n - 1] = typeof Int32Array < "u" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      return out;
    }
    var TT = slice_by_16_tables(T0), T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4], T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9], Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length;i < L; )
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (;i < L; )
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L)
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str.length, c = 0, d = 0;i < L; )
        if (c = str.charCodeAt(i++), c < 128)
          C = C >>> 8 ^ T0[(C ^ c) & 255];
        else if (c < 2048)
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255], C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        else if (c >= 55296 && c < 57344)
          c = (c & 1023) + 64, d = str.charCodeAt(i++) & 1023, C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255], C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255], C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255], C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        else
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255], C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255], C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
      return ~C;
    }
    CRC322.table = T0, CRC322.bstr = crc32_bstr, CRC322.buf = crc32_buf, CRC322.str = crc32_str;
  });
});

// node_modules/crc32-stream/lib/crc32-stream.js
var require_crc32_stream = __commonJS((exports, module) => {
  var { Transform } = require_ours(), crc32 = require_crc32();

  class CRC32Stream extends Transform {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4), this.checksum.writeInt32BE(0, 0), this.rawSize = 0;
    }
    _transform(chunk, encoding, callback) {
      if (chunk)
        this.checksum = crc32.buf(chunk, this.checksum) >>> 0, this.rawSize += chunk.length;
      callback(null, chunk);
    }
    digest(encoding) {
      let checksum = Buffer.allocUnsafe(4);
      return checksum.writeUInt32BE(this.checksum >>> 0, 0), encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size() {
      return this.rawSize;
    }
  }
  module.exports = CRC32Stream;
});

// node_modules/crc32-stream/lib/deflate-crc32-stream.js
var require_deflate_crc32_stream = __commonJS((exports, module) => {
  var { DeflateRaw } = __require("zlib"), crc32 = require_crc32();

  class DeflateCRC32Stream extends DeflateRaw {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4), this.checksum.writeInt32BE(0, 0), this.rawSize = 0, this.compressedSize = 0;
    }
    push(chunk, encoding) {
      if (chunk)
        this.compressedSize += chunk.length;
      return super.push(chunk, encoding);
    }
    _transform(chunk, encoding, callback) {
      if (chunk)
        this.checksum = crc32.buf(chunk, this.checksum) >>> 0, this.rawSize += chunk.length;
      super._transform(chunk, encoding, callback);
    }
    digest(encoding) {
      let checksum = Buffer.allocUnsafe(4);
      return checksum.writeUInt32BE(this.checksum >>> 0, 0), encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size(compressed = !1) {
      if (compressed)
        return this.compressedSize;
      else
        return this.rawSize;
    }
  }
  module.exports = DeflateCRC32Stream;
});

// node_modules/crc32-stream/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  module.exports = {
    CRC32Stream: require_crc32_stream(),
    DeflateCRC32Stream: require_deflate_crc32_stream()
  };
});

// node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js
var require_zip_archive_output_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits, crc32 = require_crc32(), { CRC32Stream } = require_lib2(), { DeflateCRC32Stream } = require_lib2(), ArchiveOutputStream = require_archive_output_stream(), ZipArchiveEntry = require_zip_archive_entry(), GeneralPurposeBit = require_general_purpose_bit(), constants = require_constants11(), util = require_util13(), zipUtil = require_util12(), ZipArchiveOutputStream = module.exports = function(options) {
    if (!(this instanceof ZipArchiveOutputStream))
      return new ZipArchiveOutputStream(options);
    options = this.options = this._defaults(options), ArchiveOutputStream.call(this, options), this._entry = null, this._entries = [], this._archive = {
      centralLength: 0,
      centralOffset: 0,
      comment: "",
      finish: !1,
      finished: !1,
      processing: !1,
      forceZip64: options.forceZip64,
      forceLocalTime: options.forceLocalTime
    };
  };
  inherits(ZipArchiveOutputStream, ArchiveOutputStream);
  ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
    if (this._entries.push(ae), ae.getGeneralPurposeBit().usesDataDescriptor())
      this._writeDataDescriptor(ae);
    if (this._archive.processing = !1, this._entry = null, this._archive.finish && !this._archive.finished)
      this._finish();
  };
  ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
    if (source.length === 0)
      ae.setMethod(constants.METHOD_STORED);
    var method = ae.getMethod();
    if (method === constants.METHOD_STORED)
      ae.setSize(source.length), ae.setCompressedSize(source.length), ae.setCrc(crc32.buf(source) >>> 0);
    if (this._writeLocalFileHeader(ae), method === constants.METHOD_STORED) {
      this.write(source), this._afterAppend(ae), callback(null, ae);
      return;
    } else if (method === constants.METHOD_DEFLATED) {
      this._smartStream(ae, callback).end(source);
      return;
    } else {
      callback(Error("compression method " + method + " not implemented"));
      return;
    }
  };
  ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
    ae.getGeneralPurposeBit().useDataDescriptor(!0), ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR), this._writeLocalFileHeader(ae);
    var smart = this._smartStream(ae, callback);
    source.once("error", function(err) {
      smart.emit("error", err), smart.end();
    }), source.pipe(smart);
  };
  ZipArchiveOutputStream.prototype._defaults = function(o) {
    if (typeof o !== "object")
      o = {};
    if (typeof o.zlib !== "object")
      o.zlib = {};
    if (typeof o.zlib.level !== "number")
      o.zlib.level = constants.ZLIB_BEST_SPEED;
    return o.forceZip64 = !!o.forceZip64, o.forceLocalTime = !!o.forceLocalTime, o;
  };
  ZipArchiveOutputStream.prototype._finish = function() {
    if (this._archive.centralOffset = this.offset, this._entries.forEach(function(ae) {
      this._writeCentralFileHeader(ae);
    }.bind(this)), this._archive.centralLength = this.offset - this._archive.centralOffset, this.isZip64())
      this._writeCentralDirectoryZip64();
    this._writeCentralDirectoryEnd(), this._archive.processing = !1, this._archive.finish = !0, this._archive.finished = !0, this.end();
  };
  ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    if (ae.getMethod() === -1)
      ae.setMethod(constants.METHOD_DEFLATED);
    if (ae.getMethod() === constants.METHOD_DEFLATED)
      ae.getGeneralPurposeBit().useDataDescriptor(!0), ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
    if (ae.getTime() === -1)
      ae.setTime(/* @__PURE__ */ new Date, this._archive.forceLocalTime);
    ae._offsets = {
      file: 0,
      data: 0,
      contents: 0
    };
  };
  ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
    var deflate = ae.getMethod() === constants.METHOD_DEFLATED, process2 = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream, error = null;
    function handleStuff() {
      var digest = process2.digest().readUInt32BE(0);
      ae.setCrc(digest), ae.setSize(process2.size()), ae.setCompressedSize(process2.size(!0)), this._afterAppend(ae), callback(error, ae);
    }
    return process2.once("end", handleStuff.bind(this)), process2.once("error", function(err) {
      error = err;
    }), process2.pipe(this, { end: !1 }), process2;
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
    var records = this._entries.length, size = this._archive.centralLength, offset = this._archive.centralOffset;
    if (this.isZip64())
      records = constants.ZIP64_MAGIC_SHORT, size = constants.ZIP64_MAGIC, offset = constants.ZIP64_MAGIC;
    this.write(zipUtil.getLongBytes(constants.SIG_EOCD)), this.write(constants.SHORT_ZERO), this.write(constants.SHORT_ZERO), this.write(zipUtil.getShortBytes(records)), this.write(zipUtil.getShortBytes(records)), this.write(zipUtil.getLongBytes(size)), this.write(zipUtil.getLongBytes(offset));
    var comment = this.getComment(), commentLength = Buffer.byteLength(comment);
    this.write(zipUtil.getShortBytes(commentLength)), this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
    this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD)), this.write(zipUtil.getEightBytes(44)), this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64)), this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64)), this.write(constants.LONG_ZERO), this.write(constants.LONG_ZERO), this.write(zipUtil.getEightBytes(this._entries.length)), this.write(zipUtil.getEightBytes(this._entries.length)), this.write(zipUtil.getEightBytes(this._archive.centralLength)), this.write(zipUtil.getEightBytes(this._archive.centralOffset)), this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC)), this.write(constants.LONG_ZERO), this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength)), this.write(zipUtil.getLongBytes(1));
  };
  ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit(), method = ae.getMethod(), fileOffset = ae._offsets.file, size = ae.getSize(), compressedSize = ae.getCompressedSize();
    if (ae.isZip64() || fileOffset > constants.ZIP64_MAGIC) {
      size = constants.ZIP64_MAGIC, compressedSize = constants.ZIP64_MAGIC, fileOffset = constants.ZIP64_MAGIC, ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
      var extraBuf = Buffer.concat([
        zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
        zipUtil.getShortBytes(24),
        zipUtil.getEightBytes(ae.getSize()),
        zipUtil.getEightBytes(ae.getCompressedSize()),
        zipUtil.getEightBytes(ae._offsets.file)
      ], 28);
      ae.setExtra(extraBuf);
    }
    this.write(zipUtil.getLongBytes(constants.SIG_CFH)), this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY)), this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract())), this.write(gpb.encode()), this.write(zipUtil.getShortBytes(method)), this.write(zipUtil.getLongBytes(ae.getTimeDos())), this.write(zipUtil.getLongBytes(ae.getCrc())), this.write(zipUtil.getLongBytes(compressedSize)), this.write(zipUtil.getLongBytes(size));
    var name = ae.getName(), comment = ae.getComment(), extra = ae.getCentralDirectoryExtra();
    if (gpb.usesUTF8ForNames())
      name = Buffer.from(name), comment = Buffer.from(comment);
    this.write(zipUtil.getShortBytes(name.length)), this.write(zipUtil.getShortBytes(extra.length)), this.write(zipUtil.getShortBytes(comment.length)), this.write(constants.SHORT_ZERO), this.write(zipUtil.getShortBytes(ae.getInternalAttributes())), this.write(zipUtil.getLongBytes(ae.getExternalAttributes())), this.write(zipUtil.getLongBytes(fileOffset)), this.write(name), this.write(extra), this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
    if (this.write(zipUtil.getLongBytes(constants.SIG_DD)), this.write(zipUtil.getLongBytes(ae.getCrc())), ae.isZip64())
      this.write(zipUtil.getEightBytes(ae.getCompressedSize())), this.write(zipUtil.getEightBytes(ae.getSize()));
    else
      this.write(zipUtil.getLongBytes(ae.getCompressedSize())), this.write(zipUtil.getLongBytes(ae.getSize()));
  };
  ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit(), method = ae.getMethod(), name = ae.getName(), extra = ae.getLocalFileDataExtra();
    if (ae.isZip64())
      gpb.useDataDescriptor(!0), ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
    if (gpb.usesUTF8ForNames())
      name = Buffer.from(name);
    if (ae._offsets.file = this.offset, this.write(zipUtil.getLongBytes(constants.SIG_LFH)), this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract())), this.write(gpb.encode()), this.write(zipUtil.getShortBytes(method)), this.write(zipUtil.getLongBytes(ae.getTimeDos())), ae._offsets.data = this.offset, gpb.usesDataDescriptor())
      this.write(constants.LONG_ZERO), this.write(constants.LONG_ZERO), this.write(constants.LONG_ZERO);
    else
      this.write(zipUtil.getLongBytes(ae.getCrc())), this.write(zipUtil.getLongBytes(ae.getCompressedSize())), this.write(zipUtil.getLongBytes(ae.getSize()));
    this.write(zipUtil.getShortBytes(name.length)), this.write(zipUtil.getShortBytes(extra.length)), this.write(name), this.write(extra), ae._offsets.contents = this.offset;
  };
  ZipArchiveOutputStream.prototype.getComment = function(comment) {
    return this._archive.comment !== null ? this._archive.comment : "";
  };
  ZipArchiveOutputStream.prototype.isZip64 = function() {
    return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
  };
  ZipArchiveOutputStream.prototype.setComment = function(comment) {
    this._archive.comment = comment;
  };
});

// node_modules/compress-commons/lib/compress-commons.js
var require_compress_commons = __commonJS((exports, module) => {
  module.exports = {
    ArchiveEntry: require_archive_entry(),
    ZipArchiveEntry: require_zip_archive_entry(),
    ArchiveOutputStream: require_archive_output_stream(),
    ZipArchiveOutputStream: require_zip_archive_output_stream()
  };
});

// node_modules/zip-stream/index.js
var require_zip_stream = __commonJS((exports, module) => {
  var inherits = __require("util").inherits, ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream, ZipArchiveEntry = require_compress_commons().ZipArchiveEntry, util = require_archiver_utils(), ZipStream = module.exports = function(options) {
    if (!(this instanceof ZipStream))
      return new ZipStream(options);
    if (options = this.options = options || {}, options.zlib = options.zlib || {}, ZipArchiveOutputStream.call(this, options), typeof options.level === "number" && options.level >= 0)
      options.zlib.level = options.level, delete options.level;
    if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0)
      options.store = !0;
    if (options.namePrependSlash = options.namePrependSlash || !1, options.comment && options.comment.length > 0)
      this.setComment(options.comment);
  };
  inherits(ZipStream, ZipArchiveOutputStream);
  ZipStream.prototype._normalizeFileData = function(data) {
    data = util.defaults(data, {
      type: "file",
      name: null,
      namePrependSlash: this.options.namePrependSlash,
      linkname: null,
      date: null,
      mode: null,
      store: this.options.store,
      comment: ""
    });
    var isDir = data.type === "directory", isSymlink = data.type === "symlink";
    if (data.name) {
      if (data.name = util.sanitizePath(data.name), !isSymlink && data.name.slice(-1) === "/")
        isDir = !0, data.type = "directory";
      else if (isDir)
        data.name += "/";
    }
    if (isDir || isSymlink)
      data.store = !0;
    return data.date = util.dateify(data.date), data;
  };
  ZipStream.prototype.entry = function(source, data, callback) {
    if (typeof callback !== "function")
      callback = this._emitErrorCallback.bind(this);
    if (data = this._normalizeFileData(data), data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
      callback(Error(data.type + " entries not currently supported"));
      return;
    }
    if (typeof data.name !== "string" || data.name.length === 0) {
      callback(Error("entry name must be a non-empty string value"));
      return;
    }
    if (data.type === "symlink" && typeof data.linkname !== "string") {
      callback(Error("entry linkname must be a non-empty string value when type equals symlink"));
      return;
    }
    var entry = new ZipArchiveEntry(data.name);
    if (entry.setTime(data.date, this.options.forceLocalTime), data.namePrependSlash)
      entry.setName(data.name, !0);
    if (data.store)
      entry.setMethod(0);
    if (data.comment.length > 0)
      entry.setComment(data.comment);
    if (data.type === "symlink" && typeof data.mode !== "number")
      data.mode = 40960;
    if (typeof data.mode === "number") {
      if (data.type === "symlink")
        data.mode |= 40960;
      entry.setUnixMode(data.mode);
    }
    if (data.type === "symlink" && typeof data.linkname === "string")
      source = Buffer.from(data.linkname);
    return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
  };
  ZipStream.prototype.finalize = function() {
    this.finish();
  };
});

// node_modules/archiver/lib/plugins/zip.js
var require_zip = __commonJS((exports, module) => {
  var engine = require_zip_stream(), util = require_archiver_utils(), Zip = function(options) {
    if (!(this instanceof Zip))
      return new Zip(options);
    options = this.options = util.defaults(options, {
      comment: "",
      forceUTC: !1,
      namePrependSlash: !1,
      store: !1
    }), this.supports = {
      directory: !0,
      symlink: !0
    }, this.engine = new engine(options);
  };
  Zip.prototype.append = function(source, data, callback) {
    this.engine.entry(source, data, callback);
  };
  Zip.prototype.finalize = function() {
    this.engine.finalize();
  };
  Zip.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Zip.prototype.pipe = function() {
    return this.engine.pipe.apply(this.engine, arguments);
  };
  Zip.prototype.unpipe = function() {
    return this.engine.unpipe.apply(this.engine, arguments);
  };
  module.exports = Zip;
});

// node_modules/queue-tick/queue-microtask.js
var require_queue_microtask = __commonJS((exports, module) => {
  module.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
});

// node_modules/queue-tick/process-next-tick.js
var require_process_next_tick = __commonJS((exports, module) => {
  module.exports = typeof process < "u" && typeof process.nextTick === "function" ? process.nextTick.bind(process) : require_queue_microtask();
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS((exports, module) => {
  module.exports = class {
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
        throw Error("Max size for a FixedFIFO should be a power of two");
      this.buffer = Array(hwm), this.mask = hwm - 1, this.top = 0, this.btm = 0, this.next = null;
    }
    clear() {
      this.top = this.btm = 0, this.next = null, this.buffer.fill(void 0);
    }
    push(data) {
      if (this.buffer[this.top] !== void 0)
        return !1;
      return this.buffer[this.top] = data, this.top = this.top + 1 & this.mask, !0;
    }
    shift() {
      let last = this.buffer[this.btm];
      if (last === void 0)
        return;
      return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, last;
    }
    peek() {
      return this.buffer[this.btm];
    }
    isEmpty() {
      return this.buffer[this.btm] === void 0;
    }
  };
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS((exports, module) => {
  var FixedFIFO = require_fixed_size();
  module.exports = class {
    constructor(hwm) {
      this.hwm = hwm || 16, this.head = new FixedFIFO(this.hwm), this.tail = this.head, this.length = 0;
    }
    clear() {
      this.head = this.tail, this.head.clear(), this.length = 0;
    }
    push(val) {
      if (this.length++, !this.head.push(val)) {
        let prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length), this.head.push(val);
      }
    }
    shift() {
      if (this.length !== 0)
        this.length--;
      let val = this.tail.shift();
      if (val === void 0 && this.tail.next) {
        let next = this.tail.next;
        return this.tail.next = null, this.tail = next, this.tail.shift();
      }
      return val;
    }
    peek() {
      let val = this.tail.peek();
      if (val === void 0 && this.tail.next)
        return this.tail.next.peek();
      return val;
    }
    isEmpty() {
      return this.length === 0;
    }
  };
});

// node_modules/text-decoder/lib/pass-through-decoder.js
var require_pass_through_decoder = __commonJS((exports, module) => {
  module.exports = class {
    constructor(encoding) {
      this.encoding = encoding;
    }
    get remaining() {
      return 0;
    }
    decode(tail) {
      return tail.toString(this.encoding);
    }
    flush() {
      return "";
    }
  };
});

// node_modules/text-decoder/lib/utf8-decoder.js
var require_utf8_decoder = __commonJS((exports, module) => {
  module.exports = class {
    constructor() {
      this.codePoint = 0, this.bytesSeen = 0, this.bytesNeeded = 0, this.lowerBoundary = 128, this.upperBoundary = 191;
    }
    get remaining() {
      return this.bytesSeen;
    }
    decode(data) {
      if (this.bytesNeeded === 0) {
        let isBoundary = !0;
        for (let i = Math.max(0, data.byteLength - 4), n = data.byteLength;i < n && isBoundary; i++)
          isBoundary = data[i] <= 127;
        if (isBoundary)
          return data.toString();
      }
      let result = "";
      for (let i = 0, n = data.byteLength;i < n; i++) {
        let byte = data[i];
        if (this.bytesNeeded === 0) {
          if (byte <= 127)
            result += String.fromCharCode(byte);
          else if (this.bytesSeen = 1, byte >= 194 && byte <= 223)
            this.bytesNeeded = 2, this.codePoint = byte & 31;
          else if (byte >= 224 && byte <= 239) {
            if (byte === 224)
              this.lowerBoundary = 160;
            else if (byte === 237)
              this.upperBoundary = 159;
            this.bytesNeeded = 3, this.codePoint = byte & 15;
          } else if (byte >= 240 && byte <= 244) {
            if (byte === 240)
              this.lowerBoundary = 144;
            if (byte === 244)
              this.upperBoundary = 143;
            this.bytesNeeded = 4, this.codePoint = byte & 7;
          } else
            result += "";
          continue;
        }
        if (byte < this.lowerBoundary || byte > this.upperBoundary) {
          this.codePoint = 0, this.bytesNeeded = 0, this.bytesSeen = 0, this.lowerBoundary = 128, this.upperBoundary = 191, result += "";
          continue;
        }
        if (this.lowerBoundary = 128, this.upperBoundary = 191, this.codePoint = this.codePoint << 6 | byte & 63, this.bytesSeen++, this.bytesSeen !== this.bytesNeeded)
          continue;
        result += String.fromCodePoint(this.codePoint), this.codePoint = 0, this.bytesNeeded = 0, this.bytesSeen = 0;
      }
      return result;
    }
    flush() {
      let result = this.bytesNeeded > 0 ? "" : "";
      return this.codePoint = 0, this.bytesNeeded = 0, this.bytesSeen = 0, this.lowerBoundary = 128, this.upperBoundary = 191, result;
    }
  };
});

// node_modules/text-decoder/index.js
var require_text_decoder = __commonJS((exports, module) => {
  var PassThroughDecoder = require_pass_through_decoder(), UTF8Decoder = require_utf8_decoder();
  module.exports = class {
    constructor(encoding = "utf8") {
      switch (this.encoding = normalizeEncoding(encoding), this.encoding) {
        case "utf8":
          this.decoder = new UTF8Decoder;
          break;
        case "utf16le":
        case "base64":
          throw Error("Unsupported encoding: " + this.encoding);
        default:
          this.decoder = new PassThroughDecoder(this.encoding);
      }
    }
    get remaining() {
      return this.decoder.remaining;
    }
    push(data) {
      if (typeof data === "string")
        return data;
      return this.decoder.decode(data);
    }
    write(data) {
      return this.push(data);
    }
    end(data) {
      let result = "";
      if (data)
        result = this.push(data);
      return result += this.decoder.flush(), result;
    }
  };
  function normalizeEncoding(encoding) {
    switch (encoding = encoding.toLowerCase(), encoding) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return encoding;
      default:
        throw Error("Unknown encoding: " + encoding);
    }
  }
});

// node_modules/streamx/index.js
var require_streamx = __commonJS((exports, module) => {
  var { EventEmitter } = __require("events"), STREAM_DESTROYED = Error("Stream was destroyed"), PREMATURE_CLOSE = Error("Premature close"), queueTick = require_process_next_tick(), FIFO = require_fast_fifo(), TextDecoder2 = require_text_decoder(), asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");

  class WritableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
      this.stream = stream, this.queue = new FIFO, this.highWaterMark = highWaterMark, this.buffered = 0, this.error = null, this.pipeline = null, this.drains = null, this.byteLength = byteLengthWritable || byteLength || defaultByteLength, this.map = mapWritable || map, this.afterWrite = afterWrite.bind(this), this.afterUpdateNextTick = updateWriteNT.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & 8388608) !== 0;
    }
    push(data) {
      if (this.map !== null)
        data = this.map(data);
      if (this.buffered += this.byteLength(data), this.queue.push(data), this.buffered < this.highWaterMark)
        return this.stream._duplexState |= 2097152, !0;
      return this.stream._duplexState |= 6291456, !1;
    }
    shift() {
      let data = this.queue.shift();
      if (this.buffered -= this.byteLength(data), this.buffered === 0)
        this.stream._duplexState &= 534773759;
      return data;
    }
    end(data) {
      if (typeof data === "function")
        this.stream.once("finish", data);
      else if (data !== void 0 && data !== null)
        this.push(data);
      this.stream._duplexState = (this.stream._duplexState | 134217728) & 535822335;
    }
    autoBatch(data, cb) {
      let buffer = [], stream = this.stream;
      buffer.push(data);
      while ((stream._duplexState & 270794767) === 2359296)
        buffer.push(stream._writableState.shift());
      if ((stream._duplexState & 15) !== 0)
        return cb(null);
      stream._writev(buffer, cb);
    }
    update() {
      let stream = this.stream;
      stream._duplexState |= 524288;
      do {
        while ((stream._duplexState & 270794767) === 2097152) {
          let data = this.shift();
          stream._duplexState |= 67371008, stream._write(data, this.afterWrite);
        }
        if ((stream._duplexState & 1310720) === 0)
          this.updateNonPrimary();
      } while (this.continueUpdate() === !0);
      stream._duplexState &= 536346623;
    }
    updateNonPrimary() {
      let stream = this.stream;
      if ((stream._duplexState & 144965647) === 134217728) {
        stream._duplexState = (stream._duplexState | 262144) & 402653183, stream._final(afterFinal.bind(this));
        return;
      }
      if ((stream._duplexState & 14) === 4) {
        if ((stream._duplexState & 33587200) === 0)
          stream._duplexState |= 262160, stream._destroy(afterDestroy.bind(this));
        return;
      }
      if ((stream._duplexState & 33587215) === 1)
        stream._duplexState = (stream._duplexState | 262160) & 536870910, stream._open(afterOpen.bind(this));
    }
    continueUpdate() {
      if ((this.stream._duplexState & 33554432) === 0)
        return !1;
      return this.stream._duplexState &= 503316479, !0;
    }
    updateCallback() {
      if ((this.stream._duplexState & 35127311) === 1048576)
        this.update();
      else
        this.updateNextTick();
    }
    updateNextTick() {
      if ((this.stream._duplexState & 33554432) !== 0)
        return;
      if (this.stream._duplexState |= 33554432, (this.stream._duplexState & 524288) === 0)
        queueTick(this.afterUpdateNextTick);
    }
  }

  class ReadableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
      this.stream = stream, this.queue = new FIFO, this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark, this.buffered = 0, this.readAhead = highWaterMark > 0, this.error = null, this.pipeline = null, this.byteLength = byteLengthReadable || byteLength || defaultByteLength, this.map = mapReadable || map, this.pipeTo = null, this.afterRead = afterRead.bind(this), this.afterUpdateNextTick = updateReadNT.bind(this);
    }
    get ended() {
      return (this.stream._duplexState & 16384) !== 0;
    }
    pipe(pipeTo, cb) {
      if (this.pipeTo !== null)
        throw Error("Can only pipe to one destination");
      if (typeof cb !== "function")
        cb = null;
      if (this.stream._duplexState |= 512, this.pipeTo = pipeTo, this.pipeline = new Pipeline(this.stream, pipeTo, cb), cb)
        this.stream.on("error", noop);
      if (isStreamx(pipeTo)) {
        if (pipeTo._writableState.pipeline = this.pipeline, cb)
          pipeTo.on("error", noop);
        pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
      } else {
        let onerror = this.pipeline.done.bind(this.pipeline, pipeTo), onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
        pipeTo.on("error", onerror), pipeTo.on("close", onclose), pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
      }
      pipeTo.on("drain", afterDrain.bind(this)), this.stream.emit("piping", pipeTo), pipeTo.emit("pipe", this.stream);
    }
    push(data) {
      let stream = this.stream;
      if (data === null)
        return this.highWaterMark = 0, stream._duplexState = (stream._duplexState | 1024) & 536805311, !1;
      if (this.map !== null) {
        if (data = this.map(data), data === null)
          return stream._duplexState &= 536805375, this.buffered < this.highWaterMark;
      }
      return this.buffered += this.byteLength(data), this.queue.push(data), stream._duplexState = (stream._duplexState | 128) & 536805375, this.buffered < this.highWaterMark;
    }
    shift() {
      let data = this.queue.shift();
      if (this.buffered -= this.byteLength(data), this.buffered === 0)
        this.stream._duplexState &= 536862591;
      return data;
    }
    unshift(data) {
      let pending = [this.map !== null ? this.map(data) : data];
      while (this.buffered > 0)
        pending.push(this.shift());
      for (let i = 0;i < pending.length - 1; i++) {
        let data2 = pending[i];
        this.buffered += this.byteLength(data2), this.queue.push(data2);
      }
      this.push(pending[pending.length - 1]);
    }
    read() {
      let stream = this.stream;
      if ((stream._duplexState & 16527) === 128) {
        let data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === !1)
          stream._duplexState &= 536870143;
        if ((stream._duplexState & 2048) !== 0)
          stream.emit("data", data);
        return data;
      }
      if (this.readAhead === !1)
        stream._duplexState |= 131072, this.updateNextTick();
      return null;
    }
    drain() {
      let stream = this.stream;
      while ((stream._duplexState & 16527) === 128 && (stream._duplexState & 768) !== 0) {
        let data = this.shift();
        if (this.pipeTo !== null && this.pipeTo.write(data) === !1)
          stream._duplexState &= 536870143;
        if ((stream._duplexState & 2048) !== 0)
          stream.emit("data", data);
      }
    }
    update() {
      let stream = this.stream;
      stream._duplexState |= 32;
      do {
        this.drain();
        while (this.buffered < this.highWaterMark && (stream._duplexState & 214047) === 131072)
          stream._duplexState |= 65552, stream._read(this.afterRead), this.drain();
        if ((stream._duplexState & 12431) === 4224)
          stream._duplexState |= 8192, stream.emit("readable");
        if ((stream._duplexState & 80) === 0)
          this.updateNonPrimary();
      } while (this.continueUpdate() === !0);
      stream._duplexState &= 536870879;
    }
    updateNonPrimary() {
      let stream = this.stream;
      if ((stream._duplexState & 1167) === 1024) {
        if (stream._duplexState = (stream._duplexState | 16384) & 536869887, stream.emit("end"), (stream._duplexState & 8405006) === 8404992)
          stream._duplexState |= 4;
        if (this.pipeTo !== null)
          this.pipeTo.end();
      }
      if ((stream._duplexState & 14) === 4) {
        if ((stream._duplexState & 33587200) === 0)
          stream._duplexState |= 262160, stream._destroy(afterDestroy.bind(this));
        return;
      }
      if ((stream._duplexState & 33587215) === 1)
        stream._duplexState = (stream._duplexState | 262160) & 536870910, stream._open(afterOpen.bind(this));
    }
    continueUpdate() {
      if ((this.stream._duplexState & 32768) === 0)
        return !1;
      return this.stream._duplexState &= 536838143, !0;
    }
    updateCallback() {
      if ((this.stream._duplexState & 32879) === 64)
        this.update();
      else
        this.updateNextTick();
    }
    updateNextTick() {
      if ((this.stream._duplexState & 32768) !== 0)
        return;
      if (this.stream._duplexState |= 32768, (this.stream._duplexState & 32) === 0)
        queueTick(this.afterUpdateNextTick);
    }
  }

  class TransformState {
    constructor(stream) {
      this.data = null, this.afterTransform = afterTransform.bind(stream), this.afterFinal = null;
    }
  }

  class Pipeline {
    constructor(src, dst, cb) {
      this.from = src, this.to = dst, this.afterPipe = cb, this.error = null, this.pipeToFinished = !1;
    }
    finished() {
      this.pipeToFinished = !0;
    }
    done(stream, err) {
      if (err)
        this.error = err;
      if (stream === this.to) {
        if (this.to = null, this.from !== null) {
          if ((this.from._duplexState & 16384) === 0 || !this.pipeToFinished)
            this.from.destroy(this.error || Error("Writable stream closed prematurely"));
          return;
        }
      }
      if (stream === this.from) {
        if (this.from = null, this.to !== null) {
          if ((stream._duplexState & 16384) === 0)
            this.to.destroy(this.error || Error("Readable stream closed before ending"));
          return;
        }
      }
      if (this.afterPipe !== null)
        this.afterPipe(this.error);
      this.to = this.from = this.afterPipe = null;
    }
  }
  function afterDrain() {
    this.stream._duplexState |= 512, this.updateCallback();
  }
  function afterFinal(err) {
    let stream = this.stream;
    if (err)
      stream.destroy(err);
    if ((stream._duplexState & 14) === 0)
      stream._duplexState |= 8388608, stream.emit("finish");
    if ((stream._duplexState & 8405006) === 8404992)
      stream._duplexState |= 4;
    if (stream._duplexState &= 469499903, (stream._duplexState & 524288) === 0)
      this.update();
    else
      this.updateNextTick();
  }
  function afterDestroy(err) {
    let stream = this.stream;
    if (!err && this.error !== STREAM_DESTROYED)
      err = this.error;
    if (err)
      stream.emit("error", err);
    stream._duplexState |= 8, stream.emit("close");
    let { _readableState: rs, _writableState: ws } = stream;
    if (rs !== null && rs.pipeline !== null)
      rs.pipeline.done(stream, err);
    if (ws !== null) {
      while (ws.drains !== null && ws.drains.length > 0)
        ws.drains.shift().resolve(!1);
      if (ws.pipeline !== null)
        ws.pipeline.done(stream, err);
    }
  }
  function afterWrite(err) {
    let stream = this.stream;
    if (err)
      stream.destroy(err);
    if (stream._duplexState &= 469499903, this.drains !== null)
      tickDrains(this.drains);
    if ((stream._duplexState & 6553615) === 4194304) {
      if (stream._duplexState &= 532676607, (stream._duplexState & 16777216) === 16777216)
        stream.emit("drain");
    }
    this.updateCallback();
  }
  function afterRead(err) {
    if (err)
      this.stream.destroy(err);
    if (this.stream._duplexState &= 536870895, this.readAhead === !1 && (this.stream._duplexState & 256) === 0)
      this.stream._duplexState &= 536739839;
    this.updateCallback();
  }
  function updateReadNT() {
    if ((this.stream._duplexState & 32) === 0)
      this.stream._duplexState &= 536838143, this.update();
  }
  function updateWriteNT() {
    if ((this.stream._duplexState & 524288) === 0)
      this.stream._duplexState &= 503316479, this.update();
  }
  function tickDrains(drains) {
    for (let i = 0;i < drains.length; i++)
      if (--drains[i].writes === 0)
        drains.shift().resolve(!0), i--;
  }
  function afterOpen(err) {
    let stream = this.stream;
    if (err)
      stream.destroy(err);
    if ((stream._duplexState & 4) === 0) {
      if ((stream._duplexState & 17423) === 0)
        stream._duplexState |= 64;
      if ((stream._duplexState & 142606351) === 0)
        stream._duplexState |= 1048576;
      stream.emit("open");
    }
    if (stream._duplexState &= 536608751, stream._writableState !== null)
      stream._writableState.updateCallback();
    if (stream._readableState !== null)
      stream._readableState.updateCallback();
  }
  function afterTransform(err, data) {
    if (data !== void 0 && data !== null)
      this.push(data);
    this._writableState.afterWrite(err);
  }
  function newListener(name) {
    if (this._readableState !== null) {
      if (name === "data")
        this._duplexState |= 133376, this._readableState.updateNextTick();
      if (name === "readable")
        this._duplexState |= 4096, this._readableState.updateNextTick();
    }
    if (this._writableState !== null) {
      if (name === "drain")
        this._duplexState |= 16777216, this._writableState.updateNextTick();
    }
  }

  class Stream extends EventEmitter {
    constructor(opts) {
      super();
      if (this._duplexState = 0, this._readableState = null, this._writableState = null, opts) {
        if (opts.open)
          this._open = opts.open;
        if (opts.destroy)
          this._destroy = opts.destroy;
        if (opts.predestroy)
          this._predestroy = opts.predestroy;
        if (opts.signal)
          opts.signal.addEventListener("abort", abort.bind(this));
      }
      this.on("newListener", newListener);
    }
    _open(cb) {
      cb(null);
    }
    _destroy(cb) {
      cb(null);
    }
    _predestroy() {}
    get readable() {
      return this._readableState !== null ? !0 : void 0;
    }
    get writable() {
      return this._writableState !== null ? !0 : void 0;
    }
    get destroyed() {
      return (this._duplexState & 8) !== 0;
    }
    get destroying() {
      return (this._duplexState & 14) !== 0;
    }
    destroy(err) {
      if ((this._duplexState & 14) === 0) {
        if (!err)
          err = STREAM_DESTROYED;
        if (this._duplexState = (this._duplexState | 4) & 535822271, this._readableState !== null)
          this._readableState.highWaterMark = 0, this._readableState.error = err;
        if (this._writableState !== null)
          this._writableState.highWaterMark = 0, this._writableState.error = err;
        if (this._duplexState |= 2, this._predestroy(), this._duplexState &= 536870909, this._readableState !== null)
          this._readableState.updateNextTick();
        if (this._writableState !== null)
          this._writableState.updateNextTick();
      }
    }
  }

  class Readable extends Stream {
    constructor(opts) {
      super(opts);
      if (this._duplexState |= 8519681, this._readableState = new ReadableState(this, opts), opts) {
        if (this._readableState.readAhead === !1)
          this._duplexState &= 536739839;
        if (opts.read)
          this._read = opts.read;
        if (opts.eagerOpen)
          this._readableState.updateNextTick();
        if (opts.encoding)
          this.setEncoding(opts.encoding);
      }
    }
    setEncoding(encoding) {
      let dec = new TextDecoder2(encoding), map = this._readableState.map || echo;
      return this._readableState.map = mapOrSkip, this;
      function mapOrSkip(data) {
        let next = dec.push(data);
        return next === "" && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);
      }
    }
    _read(cb) {
      cb(null);
    }
    pipe(dest, cb) {
      return this._readableState.updateNextTick(), this._readableState.pipe(dest, cb), dest;
    }
    read() {
      return this._readableState.updateNextTick(), this._readableState.read();
    }
    push(data) {
      return this._readableState.updateNextTick(), this._readableState.push(data);
    }
    unshift(data) {
      return this._readableState.updateNextTick(), this._readableState.unshift(data);
    }
    resume() {
      return this._duplexState |= 131328, this._readableState.updateNextTick(), this;
    }
    pause() {
      return this._duplexState &= this._readableState.readAhead === !1 ? 536739583 : 536870655, this;
    }
    static _fromAsyncIterator(ite, opts) {
      let destroy, rs = new Readable({
        ...opts,
        read(cb) {
          ite.next().then(push).then(cb.bind(null, null)).catch(cb);
        },
        predestroy() {
          destroy = ite.return();
        },
        destroy(cb) {
          if (!destroy)
            return cb(null);
          destroy.then(cb.bind(null, null)).catch(cb);
        }
      });
      return rs;
      function push(data) {
        if (data.done)
          rs.push(null);
        else
          rs.push(data.value);
      }
    }
    static from(data, opts) {
      if (isReadStreamx(data))
        return data;
      if (data[asyncIterator])
        return this._fromAsyncIterator(data[asyncIterator](), opts);
      if (!Array.isArray(data))
        data = data === void 0 ? [] : [data];
      let i = 0;
      return new Readable({
        ...opts,
        read(cb) {
          this.push(i === data.length ? null : data[i++]), cb(null);
        }
      });
    }
    static isBackpressured(rs) {
      return (rs._duplexState & 17422) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
    }
    static isPaused(rs) {
      return (rs._duplexState & 256) === 0;
    }
    [asyncIterator]() {
      let stream = this, error = null, promiseResolve = null, promiseReject = null;
      return this.on("error", (err) => {
        error = err;
      }), this.on("readable", onreadable), this.on("close", onclose), {
        [asyncIterator]() {
          return this;
        },
        next() {
          return new Promise(function(resolve, reject) {
            promiseResolve = resolve, promiseReject = reject;
            let data = stream.read();
            if (data !== null)
              ondata(data);
            else if ((stream._duplexState & 8) !== 0)
              ondata(null);
          });
        },
        return() {
          return destroy(null);
        },
        throw(err) {
          return destroy(err);
        }
      };
      function onreadable() {
        if (promiseResolve !== null)
          ondata(stream.read());
      }
      function onclose() {
        if (promiseResolve !== null)
          ondata(null);
      }
      function ondata(data) {
        if (promiseReject === null)
          return;
        if (error)
          promiseReject(error);
        else if (data === null && (stream._duplexState & 16384) === 0)
          promiseReject(STREAM_DESTROYED);
        else
          promiseResolve({ value: data, done: data === null });
        promiseReject = promiseResolve = null;
      }
      function destroy(err) {
        return stream.destroy(err), new Promise((resolve, reject) => {
          if (stream._duplexState & 8)
            return resolve({ value: void 0, done: !0 });
          stream.once("close", function() {
            if (err)
              reject(err);
            else
              resolve({ value: void 0, done: !0 });
          });
        });
      }
    }
  }

  class Writable extends Stream {
    constructor(opts) {
      super(opts);
      if (this._duplexState |= 16385, this._writableState = new WritableState(this, opts), opts) {
        if (opts.writev)
          this._writev = opts.writev;
        if (opts.write)
          this._write = opts.write;
        if (opts.final)
          this._final = opts.final;
        if (opts.eagerOpen)
          this._writableState.updateNextTick();
      }
    }
    cork() {
      this._duplexState |= 268435456;
    }
    uncork() {
      this._duplexState &= 268435455, this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
      cb(null);
    }
    _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
      cb(null);
    }
    static isBackpressured(ws) {
      return (ws._duplexState & 146800654) !== 0;
    }
    static drained(ws) {
      if (ws.destroyed)
        return Promise.resolve(!1);
      let state = ws._writableState, writes = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length) + (ws._duplexState & 67108864 ? 1 : 0);
      if (writes === 0)
        return Promise.resolve(!0);
      if (state.drains === null)
        state.drains = [];
      return new Promise((resolve) => {
        state.drains.push({ writes, resolve });
      });
    }
    write(data) {
      return this._writableState.updateNextTick(), this._writableState.push(data);
    }
    end(data) {
      return this._writableState.updateNextTick(), this._writableState.end(data), this;
    }
  }

  class Duplex extends Readable {
    constructor(opts) {
      super(opts);
      if (this._duplexState = 1 | this._duplexState & 131072, this._writableState = new WritableState(this, opts), opts) {
        if (opts.writev)
          this._writev = opts.writev;
        if (opts.write)
          this._write = opts.write;
        if (opts.final)
          this._final = opts.final;
      }
    }
    cork() {
      this._duplexState |= 268435456;
    }
    uncork() {
      this._duplexState &= 268435455, this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
      cb(null);
    }
    _write(data, cb) {
      this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
      cb(null);
    }
    write(data) {
      return this._writableState.updateNextTick(), this._writableState.push(data);
    }
    end(data) {
      return this._writableState.updateNextTick(), this._writableState.end(data), this;
    }
  }

  class Transform extends Duplex {
    constructor(opts) {
      super(opts);
      if (this._transformState = new TransformState(this), opts) {
        if (opts.transform)
          this._transform = opts.transform;
        if (opts.flush)
          this._flush = opts.flush;
      }
    }
    _write(data, cb) {
      if (this._readableState.buffered >= this._readableState.highWaterMark)
        this._transformState.data = data;
      else
        this._transform(data, this._transformState.afterTransform);
    }
    _read(cb) {
      if (this._transformState.data !== null) {
        let data = this._transformState.data;
        this._transformState.data = null, cb(null), this._transform(data, this._transformState.afterTransform);
      } else
        cb(null);
    }
    destroy(err) {
      if (super.destroy(err), this._transformState.data !== null)
        this._transformState.data = null, this._transformState.afterTransform();
    }
    _transform(data, cb) {
      cb(null, data);
    }
    _flush(cb) {
      cb(null);
    }
    _final(cb) {
      this._transformState.afterFinal = cb, this._flush(transformAfterFlush.bind(this));
    }
  }

  class PassThrough extends Transform {
  }
  function transformAfterFlush(err, data) {
    let cb = this._transformState.afterFinal;
    if (err)
      return cb(err);
    if (data !== null && data !== void 0)
      this.push(data);
    this.push(null), cb(null);
  }
  function pipelinePromise(...streams) {
    return new Promise((resolve, reject) => {
      return pipeline(...streams, (err) => {
        if (err)
          return reject(err);
        resolve();
      });
    });
  }
  function pipeline(stream, ...streams) {
    let all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams], done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
    if (all.length < 2)
      throw Error("Pipeline requires at least 2 streams");
    let src = all[0], dest = null, error = null;
    for (let i = 1;i < all.length; i++) {
      if (dest = all[i], isStreamx(src))
        src.pipe(dest, onerror);
      else
        errorHandle(src, !0, i > 1, onerror), src.pipe(dest);
      src = dest;
    }
    if (done) {
      let fin = !1, autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
      if (dest.on("error", (err) => {
        if (error === null)
          error = err;
      }), dest.on("finish", () => {
        if (fin = !0, !autoDestroy)
          done(error);
      }), autoDestroy)
        dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
    }
    return dest;
    function errorHandle(s, rd, wr, onerror2) {
      s.on("error", onerror2), s.on("close", onclose);
      function onclose() {
        if (rd && s._readableState && !s._readableState.ended)
          return onerror2(PREMATURE_CLOSE);
        if (wr && s._writableState && !s._writableState.ended)
          return onerror2(PREMATURE_CLOSE);
      }
    }
    function onerror(err) {
      if (!err || error)
        return;
      error = err;
      for (let s of all)
        s.destroy(err);
    }
  }
  function echo(s) {
    return s;
  }
  function isStream(stream) {
    return !!stream._readableState || !!stream._writableState;
  }
  function isStreamx(stream) {
    return typeof stream._duplexState === "number" && isStream(stream);
  }
  function isEnded(stream) {
    return !!stream._readableState && stream._readableState.ended;
  }
  function isFinished(stream) {
    return !!stream._writableState && stream._writableState.ended;
  }
  function getStreamError(stream, opts = {}) {
    let err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
    return !opts.all && err === STREAM_DESTROYED ? null : err;
  }
  function isReadStreamx(stream) {
    return isStreamx(stream) && stream.readable;
  }
  function isTypedArray(data) {
    return typeof data === "object" && data !== null && typeof data.byteLength === "number";
  }
  function defaultByteLength(data) {
    return isTypedArray(data) ? data.byteLength : 1024;
  }
  function noop() {}
  function abort() {
    this.destroy(Error("Stream aborted."));
  }
  function isWritev(s) {
    return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;
  }
  module.exports = {
    pipeline,
    pipelinePromise,
    isStream,
    isStreamx,
    isEnded,
    isFinished,
    getStreamError,
    Stream,
    Writable,
    Readable,
    Duplex,
    Transform,
    PassThrough
  };
});

// node_modules/b4a/index.js
var require_b4a = __commonJS((exports, module) => {
  function isBuffer(value) {
    return Buffer.isBuffer(value) || value instanceof Uint8Array;
  }
  function isEncoding(encoding) {
    return Buffer.isEncoding(encoding);
  }
  function alloc(size, fill2, encoding) {
    return Buffer.alloc(size, fill2, encoding);
  }
  function allocUnsafe(size) {
    return Buffer.allocUnsafe(size);
  }
  function allocUnsafeSlow(size) {
    return Buffer.allocUnsafeSlow(size);
  }
  function byteLength(string, encoding) {
    return Buffer.byteLength(string, encoding);
  }
  function compare(a, b) {
    return Buffer.compare(a, b);
  }
  function concat(buffers, totalLength) {
    return Buffer.concat(buffers, totalLength);
  }
  function copy(source, target, targetStart, start, end) {
    return toBuffer(source).copy(target, targetStart, start, end);
  }
  function equals(a, b) {
    return toBuffer(a).equals(b);
  }
  function fill(buffer, value, offset, end, encoding) {
    return toBuffer(buffer).fill(value, offset, end, encoding);
  }
  function from(value, encodingOrOffset, length) {
    return Buffer.from(value, encodingOrOffset, length);
  }
  function includes(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).includes(value, byteOffset, encoding);
  }
  function indexOf(buffer, value, byfeOffset, encoding) {
    return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
  }
  function lastIndexOf(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
  }
  function swap16(buffer) {
    return toBuffer(buffer).swap16();
  }
  function swap32(buffer) {
    return toBuffer(buffer).swap32();
  }
  function swap64(buffer) {
    return toBuffer(buffer).swap64();
  }
  function toBuffer(buffer) {
    if (Buffer.isBuffer(buffer))
      return buffer;
    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function toString(buffer, encoding, start, end) {
    return toBuffer(buffer).toString(encoding, start, end);
  }
  function write(buffer, string, offset, length, encoding) {
    return toBuffer(buffer).write(string, offset, length, encoding);
  }
  function writeDoubleLE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleLE(value, offset);
  }
  function writeFloatLE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatLE(value, offset);
  }
  function writeUInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32LE(value, offset);
  }
  function writeInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32LE(value, offset);
  }
  function readDoubleLE(buffer, offset) {
    return toBuffer(buffer).readDoubleLE(offset);
  }
  function readFloatLE(buffer, offset) {
    return toBuffer(buffer).readFloatLE(offset);
  }
  function readUInt32LE(buffer, offset) {
    return toBuffer(buffer).readUInt32LE(offset);
  }
  function readInt32LE(buffer, offset) {
    return toBuffer(buffer).readInt32LE(offset);
  }
  function writeDoubleBE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleBE(value, offset);
  }
  function writeFloatBE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatBE(value, offset);
  }
  function writeUInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32BE(value, offset);
  }
  function writeInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32BE(value, offset);
  }
  function readDoubleBE(buffer, offset) {
    return toBuffer(buffer).readDoubleBE(offset);
  }
  function readFloatBE(buffer, offset) {
    return toBuffer(buffer).readFloatBE(offset);
  }
  function readUInt32BE(buffer, offset) {
    return toBuffer(buffer).readUInt32BE(offset);
  }
  function readInt32BE(buffer, offset) {
    return toBuffer(buffer).readInt32BE(offset);
  }
  module.exports = {
    isBuffer,
    isEncoding,
    alloc,
    allocUnsafe,
    allocUnsafeSlow,
    byteLength,
    compare,
    concat,
    copy,
    equals,
    fill,
    from,
    includes,
    indexOf,
    lastIndexOf,
    swap16,
    swap32,
    swap64,
    toBuffer,
    toString,
    write,
    writeDoubleLE,
    writeFloatLE,
    writeUInt32LE,
    writeInt32LE,
    readDoubleLE,
    readFloatLE,
    readUInt32LE,
    readInt32LE,
    writeDoubleBE,
    writeFloatBE,
    writeUInt32BE,
    writeInt32BE,
    readDoubleBE,
    readFloatBE,
    readUInt32BE,
    readInt32BE
  };
});

// node_modules/tar-stream/headers.js
var require_headers2 = __commonJS((exports) => {
  var b4a = require_b4a(), USTAR_MAGIC = b4a.from([117, 115, 116, 97, 114, 0]), USTAR_VER = b4a.from([48, 48]), GNU_MAGIC = b4a.from([117, 115, 116, 97, 114, 32]), GNU_VER = b4a.from([32, 0]);
  exports.decodeLongPath = function(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
  };
  exports.encodePax = function(opts) {
    let result = "";
    if (opts.name)
      result += addLength(" path=" + opts.name + `
`);
    if (opts.linkname)
      result += addLength(" linkpath=" + opts.linkname + `
`);
    let pax = opts.pax;
    if (pax)
      for (let key in pax)
        result += addLength(" " + key + "=" + pax[key] + `
`);
    return b4a.from(result);
  };
  exports.decodePax = function(buf) {
    let result = {};
    while (buf.length) {
      let i = 0;
      while (i < buf.length && buf[i] !== 32)
        i++;
      let len = parseInt(b4a.toString(buf.subarray(0, i)), 10);
      if (!len)
        return result;
      let b = b4a.toString(buf.subarray(i + 1, len - 1)), keyIndex = b.indexOf("=");
      if (keyIndex === -1)
        return result;
      result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1), buf = buf.subarray(len);
    }
    return result;
  };
  exports.encode = function(opts) {
    let buf = b4a.alloc(512), name = opts.name, prefix = "";
    if (opts.typeflag === 5 && name[name.length - 1] !== "/")
      name += "/";
    if (b4a.byteLength(name) !== name.length)
      return null;
    while (b4a.byteLength(name) > 100) {
      let i = name.indexOf("/");
      if (i === -1)
        return null;
      prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i), name = name.slice(i + 1);
    }
    if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155)
      return null;
    if (opts.linkname && b4a.byteLength(opts.linkname) > 100)
      return null;
    if (b4a.write(buf, name), b4a.write(buf, encodeOct(opts.mode & 4095, 6), 100), b4a.write(buf, encodeOct(opts.uid, 6), 108), b4a.write(buf, encodeOct(opts.gid, 6), 116), encodeSize(opts.size, buf, 124), b4a.write(buf, encodeOct(opts.mtime.getTime() / 1000 | 0, 11), 136), buf[156] = 48 + toTypeflag(opts.type), opts.linkname)
      b4a.write(buf, opts.linkname, 157);
    if (b4a.copy(USTAR_MAGIC, buf, 257), b4a.copy(USTAR_VER, buf, 263), opts.uname)
      b4a.write(buf, opts.uname, 265);
    if (opts.gname)
      b4a.write(buf, opts.gname, 297);
    if (b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329), b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337), prefix)
      b4a.write(buf, prefix, 345);
    return b4a.write(buf, encodeOct(cksum(buf), 6), 148), buf;
  };
  exports.decode = function(buf, filenameEncoding, allowUnknownFormat) {
    let typeflag = buf[156] === 0 ? 0 : buf[156] - 48, name = decodeStr(buf, 0, 100, filenameEncoding), mode = decodeOct(buf, 100, 8), uid = decodeOct(buf, 108, 8), gid = decodeOct(buf, 116, 8), size = decodeOct(buf, 124, 12), mtime = decodeOct(buf, 136, 12), type = toType(typeflag), linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding), uname = decodeStr(buf, 265, 32), gname = decodeStr(buf, 297, 32), devmajor = decodeOct(buf, 329, 8), devminor = decodeOct(buf, 337, 8), c = cksum(buf);
    if (c === 256)
      return null;
    if (c !== decodeOct(buf, 148, 8))
      throw Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (isUSTAR(buf)) {
      if (buf[345])
        name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
    } else if (isGNU(buf))
      ;
    else if (!allowUnknownFormat)
      throw Error("Invalid tar header: unknown format.");
    if (typeflag === 0 && name && name[name.length - 1] === "/")
      typeflag = 5;
    return {
      name,
      mode,
      uid,
      gid,
      size,
      mtime: new Date(1000 * mtime),
      type,
      linkname,
      uname,
      gname,
      devmajor,
      devminor,
      pax: null
    };
  };
  function isUSTAR(buf) {
    return b4a.equals(USTAR_MAGIC, buf.subarray(257, 263));
  }
  function isGNU(buf) {
    return b4a.equals(GNU_MAGIC, buf.subarray(257, 263)) && b4a.equals(GNU_VER, buf.subarray(263, 265));
  }
  function clamp(index, len, defaultValue) {
    if (typeof index !== "number")
      return defaultValue;
    if (index = ~~index, index >= len)
      return len;
    if (index >= 0)
      return index;
    if (index += len, index >= 0)
      return index;
    return 0;
  }
  function toType(flag) {
    switch (flag) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  }
  function toTypeflag(flag) {
    switch (flag) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  }
  function indexOf(block, num, offset, end) {
    for (;offset < end; offset++)
      if (block[offset] === num)
        return offset;
    return end;
  }
  function cksum(block) {
    let sum = 256;
    for (let i = 0;i < 148; i++)
      sum += block[i];
    for (let j = 156;j < 512; j++)
      sum += block[j];
    return sum;
  }
  function encodeOct(val, n) {
    if (val = val.toString(8), val.length > n)
      return "7777777777777777777".slice(0, n) + " ";
    return "0000000000000000000".slice(0, n - val.length) + val + " ";
  }
  function encodeSizeBin(num, buf, off) {
    buf[off] = 128;
    for (let i = 11;i > 0; i--)
      buf[off + i] = num & 255, num = Math.floor(num / 256);
  }
  function encodeSize(num, buf, off) {
    if (num.toString(8).length > 11)
      encodeSizeBin(num, buf, off);
    else
      b4a.write(buf, encodeOct(num, 11), off);
  }
  function parse256(buf) {
    let positive;
    if (buf[0] === 128)
      positive = !0;
    else if (buf[0] === 255)
      positive = !1;
    else
      return null;
    let tuple = [], i;
    for (i = buf.length - 1;i > 0; i--) {
      let byte = buf[i];
      if (positive)
        tuple.push(byte);
      else
        tuple.push(255 - byte);
    }
    let sum = 0, l = tuple.length;
    for (i = 0;i < l; i++)
      sum += tuple[i] * Math.pow(256, i);
    return positive ? sum : -1 * sum;
  }
  function decodeOct(val, offset, length) {
    if (val = val.subarray(offset, offset + length), offset = 0, val[offset] & 128)
      return parse256(val);
    else {
      while (offset < val.length && val[offset] === 32)
        offset++;
      let end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
      while (offset < end && val[offset] === 0)
        offset++;
      if (end === offset)
        return 0;
      return parseInt(b4a.toString(val.subarray(offset, end)), 8);
    }
  }
  function decodeStr(val, offset, length, encoding) {
    return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
  }
  function addLength(str) {
    let len = b4a.byteLength(str), digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits))
      digits++;
    return len + digits + str;
  }
});

// node_modules/tar-stream/extract.js
var require_extract = __commonJS((exports, module) => {
  var { Writable, Readable, getStreamError } = require_streamx(), FIFO = require_fast_fifo(), b4a = require_b4a(), headers = require_headers2(), EMPTY = b4a.alloc(0);

  class BufferList {
    constructor() {
      this.buffered = 0, this.shifted = 0, this.queue = new FIFO, this._offset = 0;
    }
    push(buffer) {
      this.buffered += buffer.byteLength, this.queue.push(buffer);
    }
    shiftFirst(size) {
      return this._buffered === 0 ? null : this._next(size);
    }
    shift(size) {
      if (size > this.buffered)
        return null;
      if (size === 0)
        return EMPTY;
      let chunk = this._next(size);
      if (size === chunk.byteLength)
        return chunk;
      let chunks = [chunk];
      while ((size -= chunk.byteLength) > 0)
        chunk = this._next(size), chunks.push(chunk);
      return b4a.concat(chunks);
    }
    _next(size) {
      let buf = this.queue.peek(), rem = buf.byteLength - this._offset;
      if (size >= rem) {
        let sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
        return this.queue.shift(), this._offset = 0, this.buffered -= rem, this.shifted += rem, sub;
      }
      return this.buffered -= size, this.shifted += size, buf.subarray(this._offset, this._offset += size);
    }
  }

  class Source extends Readable {
    constructor(self2, header, offset) {
      super();
      this.header = header, this.offset = offset, this._parent = self2;
    }
    _read(cb) {
      if (this.header.size === 0)
        this.push(null);
      if (this._parent._stream === this)
        this._parent._update();
      cb(null);
    }
    _predestroy() {
      this._parent.destroy(getStreamError(this));
    }
    _detach() {
      if (this._parent._stream === this)
        this._parent._stream = null, this._parent._missing = overflow(this.header.size), this._parent._update();
    }
    _destroy(cb) {
      this._detach(), cb(null);
    }
  }

  class Extract extends Writable {
    constructor(opts) {
      super(opts);
      if (!opts)
        opts = {};
      this._buffer = new BufferList, this._offset = 0, this._header = null, this._stream = null, this._missing = 0, this._longHeader = !1, this._callback = noop, this._locked = !1, this._finished = !1, this._pax = null, this._paxGlobal = null, this._gnuLongPath = null, this._gnuLongLinkPath = null, this._filenameEncoding = opts.filenameEncoding || "utf-8", this._allowUnknownFormat = !!opts.allowUnknownFormat, this._unlockBound = this._unlock.bind(this);
    }
    _unlock(err) {
      if (this._locked = !1, err) {
        this.destroy(err), this._continueWrite(err);
        return;
      }
      this._update();
    }
    _consumeHeader() {
      if (this._locked)
        return !1;
      this._offset = this._buffer.shifted;
      try {
        this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
      } catch (err) {
        return this._continueWrite(err), !1;
      }
      if (!this._header)
        return !0;
      switch (this._header.type) {
        case "gnu-long-path":
        case "gnu-long-link-path":
        case "pax-global-header":
        case "pax-header":
          return this._longHeader = !0, this._missing = this._header.size, !0;
      }
      if (this._locked = !0, this._applyLongHeaders(), this._header.size === 0 || this._header.type === "directory")
        return this.emit("entry", this._header, this._createStream(), this._unlockBound), !0;
      return this._stream = this._createStream(), this._missing = this._header.size, this.emit("entry", this._header, this._stream, this._unlockBound), !0;
    }
    _applyLongHeaders() {
      if (this._gnuLongPath)
        this._header.name = this._gnuLongPath, this._gnuLongPath = null;
      if (this._gnuLongLinkPath)
        this._header.linkname = this._gnuLongLinkPath, this._gnuLongLinkPath = null;
      if (this._pax) {
        if (this._pax.path)
          this._header.name = this._pax.path;
        if (this._pax.linkpath)
          this._header.linkname = this._pax.linkpath;
        if (this._pax.size)
          this._header.size = parseInt(this._pax.size, 10);
        this._header.pax = this._pax, this._pax = null;
      }
    }
    _decodeLongHeader(buf) {
      switch (this._header.type) {
        case "gnu-long-path":
          this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding);
          break;
        case "gnu-long-link-path":
          this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding);
          break;
        case "pax-global-header":
          this._paxGlobal = headers.decodePax(buf);
          break;
        case "pax-header":
          this._pax = this._paxGlobal === null ? headers.decodePax(buf) : Object.assign({}, this._paxGlobal, headers.decodePax(buf));
          break;
      }
    }
    _consumeLongHeader() {
      this._longHeader = !1, this._missing = overflow(this._header.size);
      let buf = this._buffer.shift(this._header.size);
      try {
        this._decodeLongHeader(buf);
      } catch (err) {
        return this._continueWrite(err), !1;
      }
      return !0;
    }
    _consumeStream() {
      let buf = this._buffer.shiftFirst(this._missing);
      if (buf === null)
        return !1;
      this._missing -= buf.byteLength;
      let drained = this._stream.push(buf);
      if (this._missing === 0) {
        if (this._stream.push(null), drained)
          this._stream._detach();
        return drained && this._locked === !1;
      }
      return drained;
    }
    _createStream() {
      return new Source(this, this._header, this._offset);
    }
    _update() {
      while (this._buffer.buffered > 0 && !this.destroying) {
        if (this._missing > 0) {
          if (this._stream !== null) {
            if (this._consumeStream() === !1)
              return;
            continue;
          }
          if (this._longHeader === !0) {
            if (this._missing > this._buffer.buffered)
              break;
            if (this._consumeLongHeader() === !1)
              return !1;
            continue;
          }
          let ignore = this._buffer.shiftFirst(this._missing);
          if (ignore !== null)
            this._missing -= ignore.byteLength;
          continue;
        }
        if (this._buffer.buffered < 512)
          break;
        if (this._stream !== null || this._consumeHeader() === !1)
          return;
      }
      this._continueWrite(null);
    }
    _continueWrite(err) {
      let cb = this._callback;
      this._callback = noop, cb(err);
    }
    _write(data, cb) {
      this._callback = cb, this._buffer.push(data), this._update();
    }
    _final(cb) {
      this._finished = this._missing === 0 && this._buffer.buffered === 0, cb(this._finished ? null : Error("Unexpected end of data"));
    }
    _predestroy() {
      this._continueWrite(null);
    }
    _destroy(cb) {
      if (this._stream)
        this._stream.destroy(getStreamError(this));
      cb(null);
    }
    [Symbol.asyncIterator]() {
      let error = null, promiseResolve = null, promiseReject = null, entryStream = null, entryCallback = null, extract = this;
      return this.on("entry", onentry), this.on("error", (err) => {
        error = err;
      }), this.on("close", onclose), {
        [Symbol.asyncIterator]() {
          return this;
        },
        next() {
          return new Promise(onnext);
        },
        return() {
          return destroy(null);
        },
        throw(err) {
          return destroy(err);
        }
      };
      function consumeCallback(err) {
        if (!entryCallback)
          return;
        let cb = entryCallback;
        entryCallback = null, cb(err);
      }
      function onnext(resolve, reject) {
        if (error)
          return reject(error);
        if (entryStream) {
          resolve({ value: entryStream, done: !1 }), entryStream = null;
          return;
        }
        if (promiseResolve = resolve, promiseReject = reject, consumeCallback(null), extract._finished && promiseResolve)
          promiseResolve({ value: void 0, done: !0 }), promiseResolve = promiseReject = null;
      }
      function onentry(header, stream, callback) {
        if (entryCallback = callback, stream.on("error", noop), promiseResolve)
          promiseResolve({ value: stream, done: !1 }), promiseResolve = promiseReject = null;
        else
          entryStream = stream;
      }
      function onclose() {
        if (consumeCallback(error), !promiseResolve)
          return;
        if (error)
          promiseReject(error);
        else
          promiseResolve({ value: void 0, done: !0 });
        promiseResolve = promiseReject = null;
      }
      function destroy(err) {
        return extract.destroy(err), consumeCallback(err), new Promise((resolve, reject) => {
          if (extract.destroyed)
            return resolve({ value: void 0, done: !0 });
          extract.once("close", function() {
            if (err)
              reject(err);
            else
              resolve({ value: void 0, done: !0 });
          });
        });
      }
    }
  }
  module.exports = function(opts) {
    return new Extract(opts);
  };
  function noop() {}
  function overflow(size) {
    return size &= 511, size && 512 - size;
  }
});

// node_modules/tar-stream/constants.js
var require_constants12 = __commonJS((exports, module) => {
  var constants = {
    S_IFMT: 61440,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960
  };
  try {
    module.exports = __require("fs").constants || constants;
  } catch {
    module.exports = constants;
  }
});

// node_modules/tar-stream/pack.js
var require_pack = __commonJS((exports, module) => {
  var { Readable, Writable, getStreamError } = require_streamx(), b4a = require_b4a(), constants = require_constants12(), headers = require_headers2(), END_OF_TAR = b4a.alloc(1024);

  class Sink extends Writable {
    constructor(pack, header, callback) {
      super({ mapWritable, eagerOpen: !0 });
      if (this.written = 0, this.header = header, this._callback = callback, this._linkname = null, this._isLinkname = header.type === "symlink" && !header.linkname, this._isVoid = header.type !== "file" && header.type !== "contiguous-file", this._finished = !1, this._pack = pack, this._openCallback = null, this._pack._stream === null)
        this._pack._stream = this;
      else
        this._pack._pending.push(this);
    }
    _open(cb) {
      if (this._openCallback = cb, this._pack._stream === this)
        this._continueOpen();
    }
    _continuePack(err) {
      if (this._callback === null)
        return;
      let callback = this._callback;
      this._callback = null, callback(err);
    }
    _continueOpen() {
      if (this._pack._stream === null)
        this._pack._stream = this;
      let cb = this._openCallback;
      if (this._openCallback = null, cb === null)
        return;
      if (this._pack.destroying)
        return cb(Error("pack stream destroyed"));
      if (this._pack._finalized)
        return cb(Error("pack stream is already finalized"));
      if (this._pack._stream = this, !this._isLinkname)
        this._pack._encode(this.header);
      if (this._isVoid)
        this._finish(), this._continuePack(null);
      cb(null);
    }
    _write(data, cb) {
      if (this._isLinkname)
        return this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data, cb(null);
      if (this._isVoid) {
        if (data.byteLength > 0)
          return cb(Error("No body allowed for this entry"));
        return cb();
      }
      if (this.written += data.byteLength, this._pack.push(data))
        return cb();
      this._pack._drain = cb;
    }
    _finish() {
      if (this._finished)
        return;
      if (this._finished = !0, this._isLinkname)
        this.header.linkname = this._linkname ? b4a.toString(this._linkname, "utf-8") : "", this._pack._encode(this.header);
      overflow(this._pack, this.header.size), this._pack._done(this);
    }
    _final(cb) {
      if (this.written !== this.header.size)
        return cb(Error("Size mismatch"));
      this._finish(), cb(null);
    }
    _getError() {
      return getStreamError(this) || Error("tar entry destroyed");
    }
    _predestroy() {
      this._pack.destroy(this._getError());
    }
    _destroy(cb) {
      this._pack._done(this), this._continuePack(this._finished ? null : this._getError()), cb();
    }
  }

  class Pack extends Readable {
    constructor(opts) {
      super(opts);
      this._drain = noop, this._finalized = !1, this._finalizing = !1, this._pending = [], this._stream = null;
    }
    entry(header, buffer, callback) {
      if (this._finalized || this.destroying)
        throw Error("already finalized or destroyed");
      if (typeof buffer === "function")
        callback = buffer, buffer = null;
      if (!callback)
        callback = noop;
      if (!header.size || header.type === "symlink")
        header.size = 0;
      if (!header.type)
        header.type = modeToType(header.mode);
      if (!header.mode)
        header.mode = header.type === "directory" ? 493 : 420;
      if (!header.uid)
        header.uid = 0;
      if (!header.gid)
        header.gid = 0;
      if (!header.mtime)
        header.mtime = /* @__PURE__ */ new Date;
      if (typeof buffer === "string")
        buffer = b4a.from(buffer);
      let sink = new Sink(this, header, callback);
      if (b4a.isBuffer(buffer))
        return header.size = buffer.byteLength, sink.write(buffer), sink.end(), sink;
      if (sink._isVoid)
        return sink;
      return sink;
    }
    finalize() {
      if (this._stream || this._pending.length > 0) {
        this._finalizing = !0;
        return;
      }
      if (this._finalized)
        return;
      this._finalized = !0, this.push(END_OF_TAR), this.push(null);
    }
    _done(stream) {
      if (stream !== this._stream)
        return;
      if (this._stream = null, this._finalizing)
        this.finalize();
      if (this._pending.length)
        this._pending.shift()._continueOpen();
    }
    _encode(header) {
      if (!header.pax) {
        let buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    }
    _encodePax(header) {
      let paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      }), newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.byteLength,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader)), this.push(paxHeader), overflow(this, paxHeader.byteLength), newHeader.size = header.size, newHeader.type = header.type, this.push(headers.encode(newHeader));
    }
    _doDrain() {
      let drain = this._drain;
      this._drain = noop, drain();
    }
    _predestroy() {
      let err = getStreamError(this);
      if (this._stream)
        this._stream.destroy(err);
      while (this._pending.length) {
        let stream = this._pending.shift();
        stream.destroy(err), stream._continueOpen();
      }
      this._doDrain();
    }
    _read(cb) {
      this._doDrain(), cb();
    }
  }
  module.exports = function(opts) {
    return new Pack(opts);
  };
  function modeToType(mode) {
    switch (mode & constants.S_IFMT) {
      case constants.S_IFBLK:
        return "block-device";
      case constants.S_IFCHR:
        return "character-device";
      case constants.S_IFDIR:
        return "directory";
      case constants.S_IFIFO:
        return "fifo";
      case constants.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  function noop() {}
  function overflow(self2, size) {
    if (size &= 511, size)
      self2.push(END_OF_TAR.subarray(0, 512 - size));
  }
  function mapWritable(buf) {
    return b4a.isBuffer(buf) ? buf : b4a.from(buf);
  }
});

// node_modules/tar-stream/index.js
var require_tar_stream = __commonJS((exports) => {
  exports.extract = require_extract();
  exports.pack = require_pack();
});

// node_modules/archiver/lib/plugins/tar.js
var require_tar = __commonJS((exports, module) => {
  var zlib = __require("zlib"), engine = require_tar_stream(), util = require_archiver_utils(), Tar = function(options) {
    if (!(this instanceof Tar))
      return new Tar(options);
    if (options = this.options = util.defaults(options, {
      gzip: !1
    }), typeof options.gzipOptions !== "object")
      options.gzipOptions = {};
    if (this.supports = {
      directory: !0,
      symlink: !0
    }, this.engine = engine.pack(options), this.compressor = !1, options.gzip)
      this.compressor = zlib.createGzip(options.gzipOptions), this.compressor.on("error", this._onCompressorError.bind(this));
  };
  Tar.prototype._onCompressorError = function(err) {
    this.engine.emit("error", err);
  };
  Tar.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.mtime = data.date;
    function append(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      self2.engine.entry(data, sourceBuffer, function(err2) {
        callback(err2, data);
      });
    }
    if (data.sourceType === "buffer")
      append(null, source);
    else if (data.sourceType === "stream" && data.stats) {
      data.size = data.stats.size;
      var entry = self2.engine.entry(data, function(err) {
        callback(err, data);
      });
      source.pipe(entry);
    } else if (data.sourceType === "stream")
      util.collectStream(source, append);
  };
  Tar.prototype.finalize = function() {
    this.engine.finalize();
  };
  Tar.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Tar.prototype.pipe = function(destination, options) {
    if (this.compressor)
      return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
    else
      return this.engine.pipe.apply(this.engine, arguments);
  };
  Tar.prototype.unpipe = function() {
    if (this.compressor)
      return this.compressor.unpipe.apply(this.compressor, arguments);
    else
      return this.engine.unpipe.apply(this.engine, arguments);
  };
  module.exports = Tar;
});

// node_modules/buffer-crc32/dist/index.cjs
var require_dist4 = __commonJS((exports, module) => {
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
  }
  var CRC_TABLE = new Int32Array([
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918000,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ]);
  function ensureBuffer(input) {
    if (Buffer.isBuffer(input))
      return input;
    if (typeof input === "number")
      return Buffer.alloc(input);
    else if (typeof input === "string")
      return Buffer.from(input);
    else
      throw Error("input must be buffer, number, or string, received " + typeof input);
  }
  function bufferizeInt(num) {
    let tmp = ensureBuffer(4);
    return tmp.writeInt32BE(num, 0), tmp;
  }
  function _crc32(buf, previous) {
    if (buf = ensureBuffer(buf), Buffer.isBuffer(previous))
      previous = previous.readUInt32BE(0);
    let crc = ~~previous ^ -1;
    for (var n = 0;n < buf.length; n++)
      crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
    return crc ^ -1;
  }
  function crc32() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  crc32.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc32.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  var bufferCrc32 = crc32, index = /* @__PURE__ */ getDefaultExportFromCjs(bufferCrc32);
  module.exports = index;
});

// node_modules/archiver/lib/plugins/json.js
var require_json = __commonJS((exports, module) => {
  var inherits = __require("util").inherits, Transform = require_ours().Transform, crc32 = require_dist4(), util = require_archiver_utils(), Json = function(options) {
    if (!(this instanceof Json))
      return new Json(options);
    options = this.options = util.defaults(options, {}), Transform.call(this, options), this.supports = {
      directory: !0,
      symlink: !0
    }, this.files = [];
  };
  inherits(Json, Transform);
  Json.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  Json.prototype._writeStringified = function() {
    var fileString = JSON.stringify(this.files);
    this.write(fileString);
  };
  Json.prototype.append = function(source, data, callback) {
    var self2 = this;
    data.crc32 = 0;
    function onend(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      data.size = sourceBuffer.length || 0, data.crc32 = crc32.unsigned(sourceBuffer), self2.files.push(data), callback(null, data);
    }
    if (data.sourceType === "buffer")
      onend(null, source);
    else if (data.sourceType === "stream")
      util.collectStream(source, onend);
  };
  Json.prototype.finalize = function() {
    this._writeStringified(), this.end();
  };
  module.exports = Json;
});

// node_modules/archiver/index.js
var require_archiver = __commonJS((exports, module) => {
  var Archiver = require_core2(), formats = {}, vending = function(format, options) {
    return vending.create(format, options);
  };
  vending.create = function(format, options) {
    if (formats[format]) {
      var instance = new Archiver(format, options);
      return instance.setFormat(format), instance.setModule(new formats[format](options)), instance;
    } else
      throw Error("create(" + format + "): format not registered");
  };
  vending.registerFormat = function(format, module2) {
    if (formats[format])
      throw Error("register(" + format + "): format already registered");
    if (typeof module2 !== "function")
      throw Error("register(" + format + "): format module invalid");
    if (typeof module2.prototype.append !== "function" || typeof module2.prototype.finalize !== "function")
      throw Error("register(" + format + "): format module missing methods");
    formats[format] = module2;
  };
  vending.isRegisteredFormat = function(format) {
    if (formats[format])
      return !0;
    return !1;
  };
  vending.registerFormat("zip", require_zip());
  vending.registerFormat("tar", require_tar());
  vending.registerFormat("json", require_json());
  module.exports = vending;
});

// node_modules/@actions/artifact/lib/internal/upload/zip.js
var require_zip2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.ZipUploadStream = exports.DEFAULT_COMPRESSION_LEVEL = void 0;
  exports.createZipUploadStream = createZipUploadStream;
  var stream = __importStar(__require("stream")), promises_1 = __require("fs/promises"), archiver = __importStar(require_archiver()), core = __importStar(require_core()), config_1 = require_config();
  exports.DEFAULT_COMPRESSION_LEVEL = 6;

  class ZipUploadStream extends stream.Transform {
    constructor(bufferSize) {
      super({
        highWaterMark: bufferSize
      });
    }
    _transform(chunk, enc, cb) {
      cb(null, chunk);
    }
  }
  exports.ZipUploadStream = ZipUploadStream;
  function createZipUploadStream(uploadSpecification_1) {
    return __awaiter(this, arguments, void 0, function* (uploadSpecification, compressionLevel = exports.DEFAULT_COMPRESSION_LEVEL) {
      core.debug(`Creating Artifact archive with compressionLevel: ${compressionLevel}`);
      let zip = archiver.create("zip", {
        highWaterMark: (0, config_1.getUploadChunkSize)(),
        zlib: { level: compressionLevel }
      });
      zip.on("error", zipErrorCallback), zip.on("warning", zipWarningCallback), zip.on("finish", zipFinishCallback), zip.on("end", zipEndCallback);
      for (let file of uploadSpecification)
        if (file.sourcePath !== null) {
          let sourcePath = file.sourcePath;
          if (file.stats.isSymbolicLink())
            sourcePath = yield (0, promises_1.realpath)(file.sourcePath);
          zip.file(sourcePath, {
            name: file.destinationPath
          });
        } else
          zip.append("", { name: file.destinationPath });
      let bufferSize = (0, config_1.getUploadChunkSize)(), zipUploadStream = new ZipUploadStream(bufferSize);
      return core.debug(`Zip write high watermark value ${zipUploadStream.writableHighWaterMark}`), core.debug(`Zip read high watermark value ${zipUploadStream.readableHighWaterMark}`), zip.pipe(zipUploadStream), zip.finalize(), zipUploadStream;
    });
  }
  var zipErrorCallback = (error) => {
    throw core.error("An error has occurred while creating the zip file for upload"), core.info(error), Error("An error has occurred during zip creation for the artifact");
  }, zipWarningCallback = (error) => {
    if (error.code === "ENOENT")
      core.warning("ENOENT warning during artifact zip creation. No such file or directory"), core.info(error);
    else
      core.warning(`A non-blocking warning has occurred during artifact zip creation: ${error.code}`), core.info(error);
  }, zipFinishCallback = () => {
    core.debug("Zip stream for upload has finished.");
  }, zipEndCallback = () => {
    core.debug("Zip stream for upload has ended.");
  };
});

// node_modules/@actions/artifact/lib/internal/upload/upload-artifact.js
var require_upload_artifact = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.uploadArtifact = uploadArtifact;
  var core = __importStar(require_core()), retention_1 = require_retention(), path_and_artifact_name_validation_1 = require_path_and_artifact_name_validation(), artifact_twirp_client_1 = require_artifact_twirp_client2(), upload_zip_specification_1 = require_upload_zip_specification(), util_1 = require_util8(), blob_upload_1 = require_blob_upload(), zip_1 = require_zip2(), generated_1 = require_generated(), errors_1 = require_errors2();
  function uploadArtifact(name, files, rootDirectory, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, path_and_artifact_name_validation_1.validateArtifactName)(name), (0, upload_zip_specification_1.validateRootDirectory)(rootDirectory);
      let zipSpecification = (0, upload_zip_specification_1.getUploadZipSpecification)(files, rootDirectory);
      if (zipSpecification.length === 0)
        throw new errors_1.FilesNotFoundError(zipSpecification.flatMap((s) => s.sourcePath ? [s.sourcePath] : []));
      let backendIds = (0, util_1.getBackendIdsFromToken)(), artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)(), createArtifactReq = {
        workflowRunBackendId: backendIds.workflowRunBackendId,
        workflowJobRunBackendId: backendIds.workflowJobRunBackendId,
        name,
        version: 4
      }, expiresAt = (0, retention_1.getExpiration)(options === null || options === void 0 ? void 0 : options.retentionDays);
      if (expiresAt)
        createArtifactReq.expiresAt = expiresAt;
      let createArtifactResp = yield artifactClient.CreateArtifact(createArtifactReq);
      if (!createArtifactResp.ok)
        throw new errors_1.InvalidResponseError("CreateArtifact: response from backend was not ok");
      let zipUploadStream = yield (0, zip_1.createZipUploadStream)(zipSpecification, options === null || options === void 0 ? void 0 : options.compressionLevel), uploadResult = yield (0, blob_upload_1.uploadZipToBlobStorage)(createArtifactResp.signedUploadUrl, zipUploadStream), finalizeArtifactReq = {
        workflowRunBackendId: backendIds.workflowRunBackendId,
        workflowJobRunBackendId: backendIds.workflowJobRunBackendId,
        name,
        size: uploadResult.uploadSize ? uploadResult.uploadSize.toString() : "0"
      };
      if (uploadResult.sha256Hash)
        finalizeArtifactReq.hash = generated_1.StringValue.create({
          value: `sha256:${uploadResult.sha256Hash}`
        });
      core.info("Finalizing artifact upload");
      let finalizeArtifactResp = yield artifactClient.FinalizeArtifact(finalizeArtifactReq);
      if (!finalizeArtifactResp.ok)
        throw new errors_1.InvalidResponseError("FinalizeArtifact: response from backend was not ok");
      let artifactId = BigInt(finalizeArtifactResp.artifactId);
      return core.info(`Artifact ${name}.zip successfully finalized. Artifact ID ${artifactId}`), {
        size: uploadResult.uploadSize,
        digest: uploadResult.sha256Hash,
        id: Number(artifactId)
      };
    });
  }
});

// node_modules/@actions/artifact/node_modules/@actions/github/lib/context.js
var require_context = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Context = void 0;
  var fs_1 = __require("fs"), os_1 = __require("os");

  class Context {
    constructor() {
      var _a, _b, _c;
      if (this.payload = {}, process.env.GITHUB_EVENT_PATH)
        if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH))
          this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
        else {
          let path = process.env.GITHUB_EVENT_PATH;
          process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
        }
      this.eventName = process.env.GITHUB_EVENT_NAME, this.sha = process.env.GITHUB_SHA, this.ref = process.env.GITHUB_REF, this.workflow = process.env.GITHUB_WORKFLOW, this.action = process.env.GITHUB_ACTION, this.actor = process.env.GITHUB_ACTOR, this.job = process.env.GITHUB_JOB, this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10), this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10), this.runId = parseInt(process.env.GITHUB_RUN_ID, 10), this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : "https://api.github.com", this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : "https://github.com", this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : "https://api.github.com/graphql";
    }
    get issue() {
      let payload = this.payload;
      return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
      if (process.env.GITHUB_REPOSITORY) {
        let [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
        return { owner, repo };
      }
      if (this.payload.repository)
        return {
          owner: this.payload.repository.owner.login,
          repo: this.payload.repository.name
        };
      throw Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
  }
  exports.Context = Context;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/lib/proxy.js
var require_proxy2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.checkBypass = exports.getProxyUrl = void 0;
  function getProxyUrl(reqUrl) {
    let usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl))
      return;
    let proxyVar = (() => {
      if (usingSsl)
        return process.env.https_proxy || process.env.HTTPS_PROXY;
      else
        return process.env.http_proxy || process.env.HTTP_PROXY;
    })();
    if (proxyVar)
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    else
      return;
  }
  exports.getProxyUrl = getProxyUrl;
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname)
      return !1;
    let reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost))
      return !0;
    let noProxy = process.env.no_proxy || process.env.NO_PROXY || "";
    if (!noProxy)
      return !1;
    let reqPort;
    if (reqUrl.port)
      reqPort = Number(reqUrl.port);
    else if (reqUrl.protocol === "http:")
      reqPort = 80;
    else if (reqUrl.protocol === "https:")
      reqPort = 443;
    let upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number")
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    for (let upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x))
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`)))
        return !0;
    return !1;
  }
  exports.checkBypass = checkBypass;
  function isLoopbackAddress(host) {
    let hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }

  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username), this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/core/symbols.js
var require_symbols6 = __commonJS((exports, module) => {
  module.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kHeadersList: Symbol("headers list"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kHTTP2BuildRequest: Symbol("http2 build request"),
    kHTTP1BuildRequest: Symbol("http1 build request"),
    kHTTP2CopyHeaders: Symbol("http2 copy headers"),
    kHTTPConnVersion: Symbol("http connection version"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable")
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/core/errors.js
var require_errors4 = __commonJS((exports, module) => {
  class UndiciError extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError", this.code = "UND_ERR";
    }
  }

  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ConnectTimeoutError), this.name = "ConnectTimeoutError", this.message = message || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }

  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersTimeoutError), this.name = "HeadersTimeoutError", this.message = message || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }

  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersOverflowError), this.name = "HeadersOverflowError", this.message = message || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }

  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, BodyTimeoutError), this.name = "BodyTimeoutError", this.message = message || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }

  class ResponseStatusCodeError extends UndiciError {
    constructor(message, statusCode, headers, body) {
      super(message);
      Error.captureStackTrace(this, ResponseStatusCodeError), this.name = "ResponseStatusCodeError", this.message = message || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = body, this.status = statusCode, this.statusCode = statusCode, this.headers = headers;
    }
  }

  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidArgumentError), this.name = "InvalidArgumentError", this.message = message || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
    }
  }

  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidReturnValueError), this.name = "InvalidReturnValueError", this.message = message || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }

  class RequestAbortedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestAbortedError), this.name = "AbortError", this.message = message || "Request aborted", this.code = "UND_ERR_ABORTED";
    }
  }

  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InformationalError), this.name = "InformationalError", this.message = message || "Request information", this.code = "UND_ERR_INFO";
    }
  }

  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestContentLengthMismatchError), this.name = "RequestContentLengthMismatchError", this.message = message || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseContentLengthMismatchError), this.name = "ResponseContentLengthMismatchError", this.message = message || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientDestroyedError), this.name = "ClientDestroyedError", this.message = message || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
    }
  }

  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientClosedError), this.name = "ClientClosedError", this.message = message || "The client is closed", this.code = "UND_ERR_CLOSED";
    }
  }

  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      Error.captureStackTrace(this, SocketError), this.name = "SocketError", this.message = message || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = socket;
    }
  }

  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError), this.name = "NotSupportedError", this.message = message || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }

  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError), this.name = "MissingUpstreamError", this.message = message || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }

  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      Error.captureStackTrace(this, HTTPParserError), this.name = "HTTPParserError", this.code = code ? `HPE_${code}` : void 0, this.data = data ? data.toString() : void 0;
    }
  }

  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseExceededMaxSizeError), this.name = "ResponseExceededMaxSizeError", this.message = message || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }

  class RequestRetryError extends UndiciError {
    constructor(message, code, { headers, data }) {
      super(message);
      Error.captureStackTrace(this, RequestRetryError), this.name = "RequestRetryError", this.message = message || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = code, this.data = data, this.headers = headers;
    }
  }
  module.exports = {
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/core/constants.js
var require_constants13 = __commonJS((exports, module) => {
  var headerNameLowerCasedRecord = {}, wellknownHeaderNames = [
    "Accept",
    "Accept-Encoding",
    "Accept-Language",
    "Accept-Ranges",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Age",
    "Allow",
    "Alt-Svc",
    "Alt-Used",
    "Authorization",
    "Cache-Control",
    "Clear-Site-Data",
    "Connection",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-Length",
    "Content-Location",
    "Content-Range",
    "Content-Security-Policy",
    "Content-Security-Policy-Report-Only",
    "Content-Type",
    "Cookie",
    "Cross-Origin-Embedder-Policy",
    "Cross-Origin-Opener-Policy",
    "Cross-Origin-Resource-Policy",
    "Date",
    "Device-Memory",
    "Downlink",
    "ECT",
    "ETag",
    "Expect",
    "Expect-CT",
    "Expires",
    "Forwarded",
    "From",
    "Host",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Range",
    "If-Unmodified-Since",
    "Keep-Alive",
    "Last-Modified",
    "Link",
    "Location",
    "Max-Forwards",
    "Origin",
    "Permissions-Policy",
    "Pragma",
    "Proxy-Authenticate",
    "Proxy-Authorization",
    "RTT",
    "Range",
    "Referer",
    "Referrer-Policy",
    "Refresh",
    "Retry-After",
    "Sec-WebSocket-Accept",
    "Sec-WebSocket-Extensions",
    "Sec-WebSocket-Key",
    "Sec-WebSocket-Protocol",
    "Sec-WebSocket-Version",
    "Server",
    "Server-Timing",
    "Service-Worker-Allowed",
    "Service-Worker-Navigation-Preload",
    "Set-Cookie",
    "SourceMap",
    "Strict-Transport-Security",
    "Supports-Loading-Mode",
    "TE",
    "Timing-Allow-Origin",
    "Trailer",
    "Transfer-Encoding",
    "Upgrade",
    "Upgrade-Insecure-Requests",
    "User-Agent",
    "Vary",
    "Via",
    "WWW-Authenticate",
    "X-Content-Type-Options",
    "X-DNS-Prefetch-Control",
    "X-Frame-Options",
    "X-Permitted-Cross-Domain-Policies",
    "X-Powered-By",
    "X-Requested-With",
    "X-XSS-Protection"
  ];
  for (let i = 0;i < wellknownHeaderNames.length; ++i) {
    let key = wellknownHeaderNames[i], lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  module.exports = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/core/util.js
var require_util14 = __commonJS((exports, module) => {
  var assert = __require("assert"), { kDestroyed, kBodyUsed } = require_symbols6(), { IncomingMessage } = __require("http"), stream = __require("stream"), net = __require("net"), { InvalidArgumentError } = require_errors4(), { Blob: Blob2 } = __require("buffer"), nodeUtil = __require("util"), { stringify } = __require("querystring"), { headerNameLowerCasedRecord } = require_constants13(), [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
  function nop() {}
  function isStream(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object) {
    return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  }
  function buildURL(url, queryParams) {
    if (url.includes("?") || url.includes("#"))
      throw Error('Query params cannot be passed when url already contains "?" or "#".');
    let stringified = stringify(queryParams);
    if (stringified)
      url += "?" + stringified;
    return url;
  }
  function parseURL(url) {
    if (typeof url === "string") {
      if (url = new URL(url), !/^https?:/.test(url.origin || url.protocol))
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      return url;
    }
    if (!url || typeof url !== "object")
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    if (!/^https?:/.test(url.origin || url.protocol))
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port)))
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      if (url.path != null && typeof url.path !== "string")
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      if (url.pathname != null && typeof url.pathname !== "string")
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      if (url.hostname != null && typeof url.hostname !== "string")
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      if (url.origin != null && typeof url.origin !== "string")
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      let port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80, origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`, path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin.endsWith("/"))
        origin = origin.substring(0, origin.length - 1);
      if (path && !path.startsWith("/"))
        path = `/${path}`;
      url = new URL(origin + path);
    }
    return url;
  }
  function parseOrigin(url) {
    if (url = parseURL(url), url.pathname !== "/" || url.search || url.hash)
      throw new InvalidArgumentError("invalid url");
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      let idx2 = host.indexOf("]");
      return assert(idx2 !== -1), host.substring(1, idx2);
    }
    let idx = host.indexOf(":");
    if (idx === -1)
      return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host)
      return null;
    assert.strictEqual(typeof host, "string");
    let servername = getHostname(host);
    if (net.isIP(servername))
      return "";
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return obj != null && typeof obj[Symbol.asyncIterator] === "function";
  }
  function isIterable(obj) {
    return obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function");
  }
  function bodyLength(body) {
    if (body == null)
      return 0;
    else if (isStream(body)) {
      let state = body._readableState;
      return state && state.objectMode === !1 && state.ended === !0 && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body))
      return body.size != null ? body.size : null;
    else if (isBuffer(body))
      return body.byteLength;
    return null;
  }
  function isDestroyed(stream2) {
    return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
  }
  function isReadableAborted(stream2) {
    let state = stream2 && stream2._readableState;
    return isDestroyed(stream2) && state && !state.endEmitted;
  }
  function destroy(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2))
      return;
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage)
        stream2.socket = null;
      stream2.destroy(err);
    } else if (err)
      process.nextTick((stream3, err2) => {
        stream3.emit("error", err2);
      }, stream2, err);
    if (stream2.destroyed !== !0)
      stream2[kDestroyed] = !0;
  }
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    let m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1000 : null;
  }
  function headerNameToString(value) {
    return headerNameLowerCasedRecord[value] || value.toLowerCase();
  }
  function parseHeaders(headers, obj = {}) {
    if (!Array.isArray(headers))
      return headers;
    for (let i = 0;i < headers.length; i += 2) {
      let key = headers[i].toString().toLowerCase(), val = obj[key];
      if (!val)
        if (Array.isArray(headers[i + 1]))
          obj[key] = headers[i + 1].map((x) => x.toString("utf8"));
        else
          obj[key] = headers[i + 1].toString("utf8");
      else {
        if (!Array.isArray(val))
          val = [val], obj[key] = val;
        val.push(headers[i + 1].toString("utf8"));
      }
    }
    if ("content-length" in obj && "content-disposition" in obj)
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    return obj;
  }
  function parseRawHeaders(headers) {
    let ret = [], hasContentLength = !1, contentDispositionIdx = -1;
    for (let n = 0;n < headers.length; n += 2) {
      let key = headers[n + 0].toString(), val = headers[n + 1].toString("utf8");
      if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length"))
        ret.push(key, val), hasContentLength = !0;
      else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition"))
        contentDispositionIdx = ret.push(key, val) - 1;
      else
        ret.push(key, val);
    }
    if (hasContentLength && contentDispositionIdx !== -1)
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    return ret;
  }
  function isBuffer(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function validateHandler(handler, method, upgrade) {
    if (!handler || typeof handler !== "object")
      throw new InvalidArgumentError("handler must be an object");
    if (typeof handler.onConnect !== "function")
      throw new InvalidArgumentError("invalid onConnect method");
    if (typeof handler.onError !== "function")
      throw new InvalidArgumentError("invalid onError method");
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0)
      throw new InvalidArgumentError("invalid onBodySent method");
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function")
        throw new InvalidArgumentError("invalid onUpgrade method");
    } else {
      if (typeof handler.onHeaders !== "function")
        throw new InvalidArgumentError("invalid onHeaders method");
      if (typeof handler.onData !== "function")
        throw new InvalidArgumentError("invalid onData method");
      if (typeof handler.onComplete !== "function")
        throw new InvalidArgumentError("invalid onComplete method");
    }
  }
  function isDisturbed(body) {
    return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
  }
  function isErrored(body) {
    return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
  }
  function isReadable(body) {
    return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  async function* convertIterableToBuffer(iterable) {
    for await (let chunk of iterable)
      yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
  }
  var ReadableStream2;
  function ReadableStreamFrom(iterable) {
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    if (ReadableStream2.from)
      return ReadableStream2.from(convertIterableToBuffer(iterable));
    let iterator;
    return new ReadableStream2({
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      async pull(controller) {
        let { done, value } = await iterator.next();
        if (done)
          queueMicrotask(() => {
            controller.close();
          });
        else {
          let buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          controller.enqueue(new Uint8Array(buf));
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      }
    }, 0);
  }
  function isFormDataLike(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  }
  function throwIfAborted(signal) {
    if (!signal)
      return;
    if (typeof signal.throwIfAborted === "function")
      signal.throwIfAborted();
    else if (signal.aborted) {
      let err = Error("The operation was aborted");
      throw err.name = "AbortError", err;
    }
  }
  function addAbortListener(signal, listener) {
    if ("addEventListener" in signal)
      return signal.addEventListener("abort", listener, { once: !0 }), () => signal.removeEventListener("abort", listener);
    return signal.addListener("abort", listener), () => signal.removeListener("abort", listener);
  }
  var hasToWellFormed = !!String.prototype.toWellFormed;
  function toUSVString(val) {
    if (hasToWellFormed)
      return `${val}`.toWellFormed();
    else if (nodeUtil.toUSVString)
      return nodeUtil.toUSVString(val);
    return `${val}`;
  }
  function parseRangeHeader(range) {
    if (range == null || range === "")
      return { start: 0, end: null, size: null };
    let m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return m ? {
      start: parseInt(m[1]),
      end: m[2] ? parseInt(m[2]) : null,
      size: m[3] ? parseInt(m[3]) : null
    } : null;
  }
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = !0;
  module.exports = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isReadableAborted,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    parseRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    throwIfAborted,
    addAbortListener,
    parseRangeHeader,
    nodeMajor,
    nodeMinor,
    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/timers.js
var require_timers2 = __commonJS((exports, module) => {
  var fastNow = Date.now(), fastNowTimeout, fastTimers = [];
  function onTimeout() {
    fastNow = Date.now();
    let len = fastTimers.length, idx = 0;
    while (idx < len) {
      let timer = fastTimers[idx];
      if (timer.state === 0)
        timer.state = fastNow + timer.delay;
      else if (timer.state > 0 && fastNow >= timer.state)
        timer.state = -1, timer.callback(timer.opaque);
      if (timer.state === -1) {
        if (timer.state = -2, idx !== len - 1)
          fastTimers[idx] = fastTimers.pop();
        else
          fastTimers.pop();
        len -= 1;
      } else
        idx += 1;
    }
    if (fastTimers.length > 0)
      refreshTimeout();
  }
  function refreshTimeout() {
    if (fastNowTimeout && fastNowTimeout.refresh)
      fastNowTimeout.refresh();
    else if (clearTimeout(fastNowTimeout), fastNowTimeout = setTimeout(onTimeout, 1000), fastNowTimeout.unref)
      fastNowTimeout.unref();
  }

  class Timeout {
    constructor(callback, delay, opaque) {
      this.callback = callback, this.delay = delay, this.opaque = opaque, this.state = -2, this.refresh();
    }
    refresh() {
      if (this.state === -2) {
        if (fastTimers.push(this), !fastNowTimeout || fastTimers.length === 1)
          refreshTimeout();
      }
      this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  module.exports = {
    setTimeout(callback, delay, opaque) {
      return delay < 1000 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
    },
    clearTimeout(timeout) {
      if (timeout instanceof Timeout)
        timeout.clear();
      else
        clearTimeout(timeout);
    }
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/constants.js
var require_constants14 = __commonJS((exports, module) => {
  var { MessageChannel, receiveMessageOnPort } = __require("worker_threads"), corsSafeListedMethods = ["GET", "HEAD", "POST"], corsSafeListedMethodsSet = new Set(corsSafeListedMethods), nullBodyStatus = [101, 204, 205, 304], redirectStatus = [301, 302, 303, 307, 308], redirectStatusSet = new Set(redirectStatus), badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6697",
    "10080"
  ], badPortsSet = new Set(badPorts), referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ], referrerPolicySet = new Set(referrerPolicy), requestRedirect = ["follow", "manual", "error"], safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"], safeMethodsSet = new Set(safeMethods), requestMode = ["navigate", "same-origin", "no-cors", "cors"], requestCredentials = ["omit", "same-origin", "include"], requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ], requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    "content-length"
  ], requestDuplex = [
    "half"
  ], forbiddenMethods = ["CONNECT", "TRACE", "TRACK"], forbiddenMethodsSet = new Set(forbiddenMethods), subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ], subresourceSet = new Set(subresource), DOMException2 = globalThis.DOMException ?? (() => {
    try {
      atob("~");
    } catch (err) {
      return Object.getPrototypeOf(err).constructor;
    }
  })(), channel, structuredClone = globalThis.structuredClone ?? function(value, options = void 0) {
    if (arguments.length === 0)
      throw TypeError("missing argument");
    if (!channel)
      channel = new MessageChannel;
    return channel.port1.unref(), channel.port2.unref(), channel.port1.postMessage(value, options?.transfer), receiveMessageOnPort(channel.port2).message;
  };
  module.exports = {
    DOMException: DOMException2,
    structuredClone,
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicySet
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/global.js
var require_global3 = __commonJS((exports, module) => {
  var globalOrigin = Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === void 0) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: void 0,
        writable: !0,
        enumerable: !1,
        configurable: !1
      });
      return;
    }
    let parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:")
      throw TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: !0,
      enumerable: !1,
      configurable: !1
    });
  }
  module.exports = {
    getGlobalOrigin,
    setGlobalOrigin
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/util.js
var require_util15 = __commonJS((exports, module) => {
  var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants14(), { getGlobalOrigin } = require_global3(), { performance: performance2 } = __require("perf_hooks"), { isBlobLike, toUSVString, ReadableStreamFrom } = require_util14(), assert = __require("assert"), { isUint8Array } = __require("util/types"), supportedHashes = [], crypto2;
  try {
    crypto2 = __require("crypto");
    let possibleRelevantHashes = ["sha256", "sha384", "sha512"];
    supportedHashes = crypto2.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
  } catch {}
  function responseURL(response) {
    let urlList = response.urlList, length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response, requestFragment) {
    if (!redirectStatusSet.has(response.status))
      return null;
    let location = response.headersList.get("location");
    if (location !== null && isValidHeaderValue(location))
      location = new URL(location, responseURL(response));
    if (location && !location.hash)
      location.hash = requestFragment;
    return location;
  }
  function requestCurrentURL(request) {
    return request.urlList[request.urlList.length - 1];
  }
  function requestBadPort(request) {
    let url = requestCurrentURL(request);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port))
      return "blocked";
    return "allowed";
  }
  function isErrorLike(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i = 0;i < statusText.length; ++i) {
      let c = statusText.charCodeAt(i);
      if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255))
        return !1;
    }
    return !0;
  }
  function isTokenCharCode(c) {
    switch (c) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return !1;
      default:
        return c >= 33 && c <= 126;
    }
  }
  function isValidHTTPToken(characters) {
    if (characters.length === 0)
      return !1;
    for (let i = 0;i < characters.length; ++i)
      if (!isTokenCharCode(characters.charCodeAt(i)))
        return !1;
    return !0;
  }
  function isValidHeaderName(potentialValue) {
    return isValidHTTPToken(potentialValue);
  }
  function isValidHeaderValue(potentialValue) {
    if (potentialValue.startsWith("\t") || potentialValue.startsWith(" ") || potentialValue.endsWith("\t") || potentialValue.endsWith(" "))
      return !1;
    if (potentialValue.includes("\x00") || potentialValue.includes("\r") || potentialValue.includes(`
`))
      return !1;
    return !0;
  }
  function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
    let { headersList } = actualResponse, policyHeader = (headersList.get("referrer-policy") ?? "").split(","), policy = "";
    if (policyHeader.length > 0)
      for (let i = policyHeader.length;i !== 0; i--) {
        let token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    if (policy !== "")
      request.referrerPolicy = policy;
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode, httpRequest.headersList.set("sec-fetch-mode", header);
  }
  function appendRequestOriginHeader(request) {
    let serializedOrigin = request.origin;
    if (request.responseTainting === "cors" || request.mode === "websocket") {
      if (serializedOrigin)
        request.headersList.append("origin", serializedOrigin);
    } else if (request.method !== "GET" && request.method !== "HEAD") {
      switch (request.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request)))
            serializedOrigin = null;
          break;
        case "same-origin":
          if (!sameOrigin(request, requestCurrentURL(request)))
            serializedOrigin = null;
          break;
        default:
      }
      if (serializedOrigin)
        request.headersList.append("origin", serializedOrigin);
    }
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return performance2.now();
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request) {
    let policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      let globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null")
        return "no-referrer";
      referrerSource = new URL(globalOrigin);
    } else if (request.referrer instanceof URL)
      referrerSource = request.referrer;
    let referrerURL = stripURLForReferrer(referrerSource), referrerOrigin = stripURLForReferrer(referrerSource, !0);
    if (referrerURL.toString().length > 4096)
      referrerURL = referrerOrigin;
    let areSameOrigin = sameOrigin(request, referrerURL), isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, !0);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        let currentURL = requestCurrentURL(request);
        if (sameOrigin(referrerURL, currentURL))
          return referrerURL;
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL))
          return "no-referrer";
        return referrerOrigin;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  }
  function stripURLForReferrer(url, originOnly) {
    if (assert(url instanceof URL), url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:")
      return "no-referrer";
    if (url.username = "", url.password = "", url.hash = "", originOnly)
      url.pathname = "", url.search = "";
    return url;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!(url instanceof URL))
      return !1;
    if (url.href === "about:blank" || url.href === "about:srcdoc")
      return !0;
    if (url.protocol === "data:")
      return !0;
    if (url.protocol === "file:")
      return !0;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null")
        return !1;
      let originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:")
        return !0;
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost"))
        return !0;
      return !1;
    }
  }
  function bytesMatch(bytes, metadataList) {
    if (crypto2 === void 0)
      return !0;
    let parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata")
      return !0;
    if (parsedMetadata.length === 0)
      return !0;
    let strongest = getStrongestMetadata(parsedMetadata), metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
    for (let item of metadata) {
      let { algo: algorithm, hash: expectedValue } = item, actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue[actualValue.length - 1] === "=")
        if (actualValue[actualValue.length - 2] === "=")
          actualValue = actualValue.slice(0, -2);
        else
          actualValue = actualValue.slice(0, -1);
      if (compareBase64Mixed(actualValue, expectedValue))
        return !0;
    }
    return !1;
  }
  var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function parseMetadata(metadata) {
    let result = [], empty = !0;
    for (let token of metadata.split(" ")) {
      empty = !1;
      let parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0)
        continue;
      let algorithm = parsedToken.groups.algo.toLowerCase();
      if (supportedHashes.includes(algorithm))
        result.push(parsedToken.groups);
    }
    if (empty === !0)
      return "no metadata";
    return result;
  }
  function getStrongestMetadata(metadataList) {
    let algorithm = metadataList[0].algo;
    if (algorithm[3] === "5")
      return algorithm;
    for (let i = 1;i < metadataList.length; ++i) {
      let metadata = metadataList[i];
      if (metadata.algo[3] === "5") {
        algorithm = "sha512";
        break;
      } else if (algorithm[3] === "3")
        continue;
      else if (metadata.algo[3] === "3")
        algorithm = "sha384";
    }
    return algorithm;
  }
  function filterMetadataListByAlgorithm(metadataList, algorithm) {
    if (metadataList.length === 1)
      return metadataList;
    let pos = 0;
    for (let i = 0;i < metadataList.length; ++i)
      if (metadataList[i].algo === algorithm)
        metadataList[pos++] = metadataList[i];
    return metadataList.length = pos, metadataList;
  }
  function compareBase64Mixed(actualValue, expectedValue) {
    if (actualValue.length !== expectedValue.length)
      return !1;
    for (let i = 0;i < actualValue.length; ++i)
      if (actualValue[i] !== expectedValue[i]) {
        if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_")
          continue;
        return !1;
      }
    return !0;
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {}
  function sameOrigin(A, B) {
    if (A.origin === B.origin && A.origin === "null")
      return !0;
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port)
      return !0;
    return !1;
  }
  function createDeferredPromise() {
    let res, rej;
    return { promise: new Promise((resolve, reject) => {
      res = resolve, rej = reject;
    }), resolve: res, reject: rej };
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  var normalizeMethodRecord = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  Object.setPrototypeOf(normalizeMethodRecord, null);
  function normalizeMethod(method) {
    return normalizeMethodRecord[method.toLowerCase()] ?? method;
  }
  function serializeJavascriptValueToJSONString(value) {
    let result = JSON.stringify(value);
    if (result === void 0)
      throw TypeError("Value is not JSON serializable");
    return assert(typeof result === "string"), result;
  }
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function makeIterator(iterator, name, kind) {
    let object = {
      index: 0,
      kind,
      target: iterator
    }, i = {
      next() {
        if (Object.getPrototypeOf(this) !== i)
          throw TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        let { index, kind: kind2, target } = object, values = target(), len = values.length;
        if (index >= len)
          return { value: void 0, done: !0 };
        let pair = values[index];
        return object.index = index + 1, iteratorResult(pair, kind2);
      },
      [Symbol.toStringTag]: `${name} Iterator`
    };
    return Object.setPrototypeOf(i, esIteratorPrototype), Object.setPrototypeOf({}, i);
  }
  function iteratorResult(pair, kind) {
    let result;
    switch (kind) {
      case "key": {
        result = pair[0];
        break;
      }
      case "value": {
        result = pair[1];
        break;
      }
      case "key+value": {
        result = pair;
        break;
      }
    }
    return { value: result, done: !1 };
  }
  async function fullyReadBody(body, processBody, processBodyError) {
    let successSteps = processBody, errorSteps = processBodyError, reader;
    try {
      reader = body.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    try {
      let result = await readAllBytes(reader);
      successSteps(result);
    } catch (e) {
      errorSteps(e);
    }
  }
  var ReadableStream2 = globalThis.ReadableStream;
  function isReadableStreamLike(stream) {
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    return stream instanceof ReadableStream2 || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
  }
  var MAXIMUM_ARGUMENT_LENGTH = 65535;
  function isomorphicDecode(input) {
    if (input.length < MAXIMUM_ARGUMENT_LENGTH)
      return String.fromCharCode(...input);
    return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
    } catch (err) {
      if (!err.message.includes("Controller is already closed"))
        throw err;
    }
  }
  function isomorphicEncode(input) {
    for (let i = 0;i < input.length; i++)
      assert(input.charCodeAt(i) <= 255);
    return input;
  }
  async function readAllBytes(reader) {
    let bytes = [], byteLength = 0;
    while (!0) {
      let { done, value: chunk } = await reader.read();
      if (done)
        return Buffer.concat(bytes, byteLength);
      if (!isUint8Array(chunk))
        throw TypeError("Received non-Uint8Array chunk");
      bytes.push(chunk), byteLength += chunk.length;
    }
  }
  function urlIsLocal(url) {
    assert("protocol" in url);
    let protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    if (typeof url === "string")
      return url.startsWith("https:");
    return url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    let protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
  module.exports = {
    isAborted,
    isCancelled,
    createDeferredPromise,
    ReadableStreamFrom,
    toUSVString,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue,
    hasOwn,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    isomorphicDecode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    normalizeMethodRecord,
    parseMetadata
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/symbols.js
var require_symbols7 = __commonJS((exports, module) => {
  module.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm")
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/webidl.js
var require_webidl2 = __commonJS((exports, module) => {
  var { types } = __require("util"), { hasOwn, toUSVString } = require_util15(), webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    let plural = context.types.length === 1 ? "" : " one of", message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts = void 0) {
    if (opts?.strict !== !1 && !(V instanceof I))
      throw TypeError("Illegal invocation");
    else
      return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min)
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
        ...ctx
      });
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null)
          return "Null";
        return "Object";
      }
    }
  };
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
    let upperBound, lowerBound;
    if (bitLength === 64)
      if (upperBound = Math.pow(2, 53) - 1, signedness === "unsigned")
        lowerBound = 0;
      else
        lowerBound = Math.pow(-2, 53) + 1;
    else if (signedness === "unsigned")
      lowerBound = 0, upperBound = Math.pow(2, bitLength) - 1;
    else
      lowerBound = Math.pow(-2, bitLength) - 1, upperBound = Math.pow(2, bitLength - 1) - 1;
    let x = Number(V);
    if (x === 0)
      x = 0;
    if (opts.enforceRange === !0) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY)
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${V} to an integer.`
        });
      if (x = webidl.util.IntegerPart(x), x < lowerBound || x > upperBound)
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      return x;
    }
    if (!Number.isNaN(x) && opts.clamp === !0) {
      if (x = Math.min(Math.max(x, lowerBound), upperBound), Math.floor(x) % 2 === 0)
        x = Math.floor(x);
      else
        x = Math.ceil(x);
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY)
      return 0;
    if (x = webidl.util.IntegerPart(x), x = x % Math.pow(2, bitLength), signedness === "signed" && x >= Math.pow(2, bitLength) - 1)
      return x - Math.pow(2, bitLength);
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    let r = Math.floor(Math.abs(n));
    if (n < 0)
      return -1 * r;
    return r;
  };
  webidl.sequenceConverter = function(converter) {
    return (V) => {
      if (webidl.util.Type(V) !== "Object")
        throw webidl.errors.exception({
          header: "Sequence",
          message: `Value of type ${webidl.util.Type(V)} is not an Object.`
        });
      let method = V?.[Symbol.iterator]?.(), seq = [];
      if (method === void 0 || typeof method.next !== "function")
        throw webidl.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator."
        });
      while (!0) {
        let { done, value } = method.next();
        if (done)
          break;
        seq.push(converter(value));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O) => {
      if (webidl.util.Type(O) !== "Object")
        throw webidl.errors.exception({
          header: "Record",
          message: `Value of type ${webidl.util.Type(O)} is not an Object.`
        });
      let result = {};
      if (!types.isProxy(O)) {
        let keys2 = Object.keys(O);
        for (let key of keys2) {
          let typedKey = keyConverter(key), typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
        return result;
      }
      let keys = Reflect.ownKeys(O);
      for (let key of keys)
        if (Reflect.getOwnPropertyDescriptor(O, key)?.enumerable) {
          let typedKey = keyConverter(key), typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, opts = {}) => {
      if (opts.strict !== !1 && !(V instanceof i))
        throw webidl.errors.exception({
          header: i.name,
          message: `Expected ${V} to be an instance of ${i.name}.`
        });
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary) => {
      let type = webidl.util.Type(dictionary), dict = {};
      if (type === "Null" || type === "Undefined")
        return dict;
      else if (type !== "Object")
        throw webidl.errors.exception({
          header: "Dictionary",
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      for (let options of converters) {
        let { key, defaultValue, required, converter } = options;
        if (required === !0) {
          if (!hasOwn(dictionary, key))
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `Missing required key "${key}".`
            });
        }
        let value = dictionary[key], hasDefault = hasOwn(options, "defaultValue");
        if (hasDefault && value !== null)
          value = value ?? defaultValue;
        if (required || hasDefault || value !== void 0) {
          if (value = converter(value), options.allowedValues && !options.allowedValues.includes(value))
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V) => {
      if (V === null)
        return V;
      return converter(V);
    };
  };
  webidl.converters.DOMString = function(V, opts = {}) {
    if (V === null && opts.legacyNullToEmptyString)
      return "";
    if (typeof V === "symbol")
      throw TypeError("Could not convert argument of type symbol to string.");
    return String(V);
  };
  webidl.converters.ByteString = function(V) {
    let x = webidl.converters.DOMString(V);
    for (let index = 0;index < x.length; index++)
      if (x.charCodeAt(index) > 255)
        throw TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`);
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    return Boolean(V);
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V) {
    return webidl.util.ConvertToInt(V, 64, "signed");
  };
  webidl.converters["unsigned long long"] = function(V) {
    return webidl.util.ConvertToInt(V, 64, "unsigned");
  };
  webidl.converters["unsigned long"] = function(V) {
    return webidl.util.ConvertToInt(V, 32, "unsigned");
  };
  webidl.converters["unsigned short"] = function(V, opts) {
    return webidl.util.ConvertToInt(V, 16, "unsigned", opts);
  };
  webidl.converters.ArrayBuffer = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V))
      throw webidl.errors.conversionFailed({
        prefix: `${V}`,
        argument: `${V}`,
        types: ["ArrayBuffer"]
      });
    if (opts.allowShared === !1 && types.isSharedArrayBuffer(V))
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return V;
  };
  webidl.converters.TypedArray = function(V, T, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name)
      throw webidl.errors.conversionFailed({
        prefix: `${T.name}`,
        argument: `${V}`,
        types: [T.name]
      });
    if (opts.allowShared === !1 && types.isSharedArrayBuffer(V.buffer))
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return V;
  };
  webidl.converters.DataView = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V))
      throw webidl.errors.exception({
        header: "DataView",
        message: "Object is not a DataView."
      });
    if (opts.allowShared === !1 && types.isSharedArrayBuffer(V.buffer))
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return V;
  };
  webidl.converters.BufferSource = function(V, opts = {}) {
    if (types.isAnyArrayBuffer(V))
      return webidl.converters.ArrayBuffer(V, opts);
    if (types.isTypedArray(V))
      return webidl.converters.TypedArray(V, V.constructor);
    if (types.isDataView(V))
      return webidl.converters.DataView(V, opts);
    throw TypeError(`Could not convert ${V} to a BufferSource.`);
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  module.exports = {
    webidl
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/dataURL.js
var require_dataURL2 = __commonJS((exports, module) => {
  var assert = __require("assert"), { atob: atob2 } = __require("buffer"), { isomorphicDecode } = require_util15(), encoder = /* @__PURE__ */ new TextEncoder, HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/, HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/, HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, !0);
    input = input.slice(5);
    let position = { position: 0 }, mimeType = collectASequenceOfCodePointsFast(",", input, position), mimeTypeLength = mimeType.length;
    if (mimeType = removeASCIIWhitespace(mimeType, !0, !0), position.position >= input.length)
      return "failure";
    position.position++;
    let encodedBody = input.slice(mimeTypeLength + 1), body = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      let stringBody = isomorphicDecode(body);
      if (body = forgivingBase64(stringBody), body === "failure")
        return "failure";
      mimeType = mimeType.slice(0, -6), mimeType = mimeType.replace(/(\u0020)+$/, ""), mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";"))
      mimeType = "text/plain" + mimeType;
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure")
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    return { mimeType: mimeTypeRecord, body };
  }
  function URLSerializer(url, excludeFragment = !1) {
    if (!excludeFragment)
      return url.href;
    let href = url.href, hashLength = url.hash.length;
    return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
  }
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position]))
      result += input[position.position], position.position++;
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    let idx = input.indexOf(char, position.position), start = position.position;
    if (idx === -1)
      return position.position = input.length, input.slice(start);
    return position.position = idx, input.slice(start, position.position);
  }
  function stringPercentDecode(input) {
    let bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function percentDecode(input) {
    let output = [];
    for (let i = 0;i < input.length; i++) {
      let byte = input[i];
      if (byte !== 37)
        output.push(byte);
      else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2])))
        output.push(37);
      else {
        let nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]), bytePoint = Number.parseInt(nextTwoBytes, 16);
        output.push(bytePoint), i += 2;
      }
    }
    return Uint8Array.from(output);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, !0, !0);
    let position = { position: 0 }, type = collectASequenceOfCodePointsFast("/", input, position);
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type))
      return "failure";
    if (position.position > input.length)
      return "failure";
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    if (subtype = removeHTTPWhitespace(subtype, !1, !0), subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype))
      return "failure";
    let typeLowercase = type.toLowerCase(), subtypeLowercase = subtype.toLowerCase(), mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      parameters: /* @__PURE__ */ new Map,
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++, collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
      if (parameterName = parameterName.toLowerCase(), position.position < input.length) {
        if (input[position.position] === ";")
          continue;
        position.position++;
      }
      if (position.position > input.length)
        break;
      let parameterValue = null;
      if (input[position.position] === '"')
        parameterValue = collectAnHTTPQuotedString(input, position, !0), collectASequenceOfCodePointsFast(";", input, position);
      else if (parameterValue = collectASequenceOfCodePointsFast(";", input, position), parameterValue = removeHTTPWhitespace(parameterValue, !1, !0), parameterValue.length === 0)
        continue;
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName))
        mimeType.parameters.set(parameterName, parameterValue);
    }
    return mimeType;
  }
  function forgivingBase64(data) {
    if (data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, ""), data.length % 4 === 0)
      data = data.replace(/=?=$/, "");
    if (data.length % 4 === 1)
      return "failure";
    if (/[^+/0-9A-Za-z]/.test(data))
      return "failure";
    let binary = atob2(data), bytes = new Uint8Array(binary.length);
    for (let byte = 0;byte < binary.length; byte++)
      bytes[byte] = binary.charCodeAt(byte);
    return bytes;
  }
  function collectAnHTTPQuotedString(input, position, extractValue) {
    let positionStart = position.position, value = "";
    assert(input[position.position] === '"'), position.position++;
    while (!0) {
      if (value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position), position.position >= input.length)
        break;
      let quoteOrBackslash = input[position.position];
      if (position.position++, quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position], position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue)
      return value;
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    let { parameters, essence } = mimeType, serialization = essence;
    for (let [name, value] of parameters.entries()) {
      if (serialization += ";", serialization += name, serialization += "=", !HTTP_TOKEN_CODEPOINTS.test(value))
        value = value.replace(/(\\|")/g, "\\$1"), value = '"' + value, value += '"';
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === "\r" || char === `
` || char === "\t" || char === " ";
  }
  function removeHTTPWhitespace(str, leading = !0, trailing = !0) {
    let lead = 0, trail = str.length - 1;
    if (leading)
      for (;lead < str.length && isHTTPWhiteSpace(str[lead]); lead++)
        ;
    if (trailing)
      for (;trail > 0 && isHTTPWhiteSpace(str[trail]); trail--)
        ;
    return str.slice(lead, trail + 1);
  }
  function isASCIIWhitespace(char) {
    return char === "\r" || char === `
` || char === "\t" || char === "\f" || char === " ";
  }
  function removeASCIIWhitespace(str, leading = !0, trailing = !0) {
    let lead = 0, trail = str.length - 1;
    if (leading)
      for (;lead < str.length && isASCIIWhitespace(str[lead]); lead++)
        ;
    if (trailing)
      for (;trail > 0 && isASCIIWhitespace(str[trail]); trail--)
        ;
    return str.slice(lead, trail + 1);
  }
  module.exports = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/file.js
var require_file4 = __commonJS((exports, module) => {
  var { Blob: Blob2, File: NativeFile } = __require("buffer"), { types } = __require("util"), { kState } = require_symbols7(), { isBlobLike } = require_util15(), { webidl } = require_webidl2(), { parseMIMEType, serializeAMimeType } = require_dataURL2(), { kEnumerableProperty } = require_util14(), encoder = /* @__PURE__ */ new TextEncoder;

  class File2 extends Blob2 {
    constructor(fileBits, fileName, options = {}) {
      webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" }), fileBits = webidl.converters["sequence<BlobPart>"](fileBits), fileName = webidl.converters.USVString(fileName), options = webidl.converters.FilePropertyBag(options);
      let n = fileName, t = options.type, d;
      substep: {
        if (t) {
          if (t = parseMIMEType(t), t === "failure") {
            t = "";
            break substep;
          }
          t = serializeAMimeType(t).toLowerCase();
        }
        d = options.lastModified;
      }
      super(processBlobParts(fileBits, options), { type: t });
      this[kState] = {
        name: n,
        lastModified: d,
        type: t
      };
    }
    get name() {
      return webidl.brandCheck(this, File2), this[kState].name;
    }
    get lastModified() {
      return webidl.brandCheck(this, File2), this[kState].lastModified;
    }
    get type() {
      return webidl.brandCheck(this, File2), this[kState].type;
    }
  }

  class FileLike {
    constructor(blobLike, fileName, options = {}) {
      let n = fileName, t = options.type, d = options.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.slice(...args);
    }
    text(...args) {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.text(...args);
    }
    get size() {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.size;
    }
    get type() {
      return webidl.brandCheck(this, FileLike), this[kState].blobLike.type;
    }
    get name() {
      return webidl.brandCheck(this, FileLike), this[kState].name;
    }
    get lastModified() {
      return webidl.brandCheck(this, FileLike), this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(File2.prototype, {
    [Symbol.toStringTag]: {
      value: "File",
      configurable: !0
    },
    name: kEnumerableProperty,
    lastModified: kEnumerableProperty
  });
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  webidl.converters.BlobPart = function(V, opts) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V))
        return webidl.converters.Blob(V, { strict: !1 });
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V))
        return webidl.converters.BufferSource(V, opts);
    }
    return webidl.converters.USVString(V, opts);
  };
  webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(webidl.converters.BlobPart);
  webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
    {
      key: "lastModified",
      converter: webidl.converters["long long"],
      get defaultValue() {
        return Date.now();
      }
    },
    {
      key: "type",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "endings",
      converter: (value) => {
        if (value = webidl.converters.DOMString(value), value = value.toLowerCase(), value !== "native")
          value = "transparent";
        return value;
      },
      defaultValue: "transparent"
    }
  ]);
  function processBlobParts(parts, options) {
    let bytes = [];
    for (let element of parts)
      if (typeof element === "string") {
        let s = element;
        if (options.endings === "native")
          s = convertLineEndingsNative(s);
        bytes.push(encoder.encode(s));
      } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element))
        if (!element.buffer)
          bytes.push(new Uint8Array(element));
        else
          bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
      else if (isBlobLike(element))
        bytes.push(element);
    return bytes;
  }
  function convertLineEndingsNative(s) {
    let nativeLineEnding = `
`;
    if (process.platform === "win32")
      nativeLineEnding = `\r
`;
    return s.replace(/\r?\n/g, nativeLineEnding);
  }
  function isFileLike(object) {
    return NativeFile && object instanceof NativeFile || object instanceof File2 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  }
  module.exports = { File: File2, FileLike, isFileLike };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/formdata.js
var require_formdata2 = __commonJS((exports, module) => {
  var { isBlobLike, toUSVString, makeIterator } = require_util15(), { kState } = require_symbols7(), { File: UndiciFile, FileLike, isFileLike } = require_file4(), { webidl } = require_webidl2(), { Blob: Blob2, File: NativeFile } = __require("buffer"), File2 = NativeFile ?? UndiciFile;

  class FormData2 {
    constructor(form) {
      if (form !== void 0)
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      this[kState] = [];
    }
    append(name, value, filename = void 0) {
      if (webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" }), arguments.length === 3 && !isBlobLike(value))
        throw TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
      name = webidl.converters.USVString(name), value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: !1 }) : webidl.converters.USVString(value), filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
      let entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" }), name = webidl.converters.USVString(name), this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" }), name = webidl.converters.USVString(name);
      let idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1)
        return null;
      return this[kState][idx].value;
    }
    getAll(name) {
      return webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" }), name = webidl.converters.USVString(name), this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      return webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" }), name = webidl.converters.USVString(name), this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = void 0) {
      if (webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" }), arguments.length === 3 && !isBlobLike(value))
        throw TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
      name = webidl.converters.USVString(name), value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: !1 }) : webidl.converters.USVString(value), filename = arguments.length === 3 ? toUSVString(filename) : void 0;
      let entry = makeEntry(name, value, filename), idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1)
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      else
        this[kState].push(entry);
    }
    entries() {
      return webidl.brandCheck(this, FormData2), makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
    }
    keys() {
      return webidl.brandCheck(this, FormData2), makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key");
    }
    values() {
      return webidl.brandCheck(this, FormData2), makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      if (webidl.brandCheck(this, FormData2), webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" }), typeof callbackFn !== "function")
        throw TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
      for (let [key, value] of this)
        callbackFn.apply(thisArg, [value, key, this]);
    }
  }
  FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
  Object.defineProperties(FormData2.prototype, {
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: !0
    }
  });
  function makeEntry(name, value, filename) {
    if (name = Buffer.from(name).toString("utf8"), typeof value === "string")
      value = Buffer.from(value).toString("utf8");
    else {
      if (!isFileLike(value))
        value = value instanceof Blob2 ? new File2([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      if (filename !== void 0) {
        let options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File2([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return { name, value };
  }
  module.exports = { FormData: FormData2 };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/body.js
var require_body2 = __commonJS((exports, module) => {
  var Busboy = require_main(), util = require_util14(), {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody
  } = require_util15(), { FormData: FormData2 } = require_formdata2(), { kState } = require_symbols7(), { webidl } = require_webidl2(), { DOMException: DOMException2, structuredClone } = require_constants14(), { Blob: Blob2, File: NativeFile } = __require("buffer"), { kBodyUsed } = require_symbols6(), assert = __require("assert"), { isErrored } = require_util14(), { isUint8Array, isArrayBuffer } = __require("util/types"), { File: UndiciFile } = require_file4(), { parseMIMEType, serializeAMimeType } = require_dataURL2(), ReadableStream2 = globalThis.ReadableStream, File2 = NativeFile ?? UndiciFile, textEncoder = /* @__PURE__ */ new TextEncoder, textDecoder = /* @__PURE__ */ new TextDecoder;
  function extractBody(object, keepalive = !1) {
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    let stream = null;
    if (object instanceof ReadableStream2)
      stream = object;
    else if (isBlobLike(object))
      stream = object.stream();
    else
      stream = new ReadableStream2({
        async pull(controller) {
          controller.enqueue(typeof source === "string" ? textEncoder.encode(source) : source), queueMicrotask(() => readableStreamClose(controller));
        },
        start() {},
        type: void 0
      });
    assert(isReadableStreamLike(stream));
    let action = null, source = null, length = null, type = null;
    if (typeof object === "string")
      source = object, type = "text/plain;charset=UTF-8";
    else if (object instanceof URLSearchParams)
      source = object.toString(), type = "application/x-www-form-urlencoded;charset=UTF-8";
    else if (isArrayBuffer(object))
      source = new Uint8Array(object.slice());
    else if (ArrayBuffer.isView(object))
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    else if (util.isFormDataLike(object)) {
      let boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 100000000000)}`.padStart(11, "0")}`, prefix = `--${boundary}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
      let escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, `\r
`), blobParts = [], rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = !1;
      for (let [name, value] of object)
        if (typeof value === "string") {
          let chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk2), length += chunk2.byteLength;
        } else {
          let chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          if (blobParts.push(chunk2, value, rn), typeof value.size === "number")
            length += chunk2.byteLength + value.size + rn.byteLength;
          else
            hasUnknownSizeValue = !0;
        }
      let chunk = textEncoder.encode(`--${boundary}--`);
      if (blobParts.push(chunk), length += chunk.byteLength, hasUnknownSizeValue)
        length = null;
      source = object, action = async function* () {
        for (let part of blobParts)
          if (part.stream)
            yield* part.stream();
          else
            yield part;
      }, type = "multipart/form-data; boundary=" + boundary;
    } else if (isBlobLike(object)) {
      if (source = object, length = object.size, object.type)
        type = object.type;
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive)
        throw TypeError("keepalive");
      if (util.isDisturbed(object) || object.locked)
        throw TypeError("Response body object should not be disturbed or locked");
      stream = object instanceof ReadableStream2 ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util.isBuffer(source))
      length = Buffer.byteLength(source);
    if (action != null) {
      let iterator;
      stream = new ReadableStream2({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          let { value, done } = await iterator.next();
          if (done)
            queueMicrotask(() => {
              controller.close();
            });
          else if (!isErrored(stream))
            controller.enqueue(new Uint8Array(value));
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: void 0
      });
    }
    return [{ stream, source, length }, type];
  }
  function safelyExtractBody(object, keepalive = !1) {
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    if (object instanceof ReadableStream2)
      assert(!util.isDisturbed(object), "The body has already been consumed."), assert(!object.locked, "The stream is locked.");
    return extractBody(object, keepalive);
  }
  function cloneBody(body) {
    let [out1, out2] = body.stream.tee(), out2Clone = structuredClone(out2, { transfer: [out2] }), [, finalClone] = out2Clone.tee();
    return body.stream = out1, {
      stream: finalClone,
      length: body.length,
      source: body.source
    };
  }
  async function* consumeBody(body) {
    if (body)
      if (isUint8Array(body))
        yield body;
      else {
        let stream = body.stream;
        if (util.isDisturbed(stream))
          throw TypeError("The body has already been consumed.");
        if (stream.locked)
          throw TypeError("The stream is locked.");
        stream[kBodyUsed] = !0, yield* stream;
      }
  }
  function throwIfAborted(state) {
    if (state.aborted)
      throw new DOMException2("The operation was aborted.", "AbortError");
  }
  function bodyMixinMethods(instance) {
    return {
      blob() {
        return specConsumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === "failure")
            mimeType = "";
          else if (mimeType)
            mimeType = serializeAMimeType(mimeType);
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return specConsumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return specConsumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return specConsumeBody(this, parseJSONFromBytes, instance);
      },
      async formData() {
        webidl.brandCheck(this, instance), throwIfAborted(this[kState]);
        let contentType = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(contentType)) {
          let headers = {};
          for (let [key, value] of this.headers)
            headers[key.toLowerCase()] = value;
          let responseFormData = new FormData2, busboy;
          try {
            busboy = new Busboy({
              headers,
              preservePath: !0
            });
          } catch (err) {
            throw new DOMException2(`${err}`, "AbortError");
          }
          busboy.on("field", (name, value) => {
            responseFormData.append(name, value);
          }), busboy.on("file", (name, value, filename, encoding, mimeType) => {
            let chunks = [];
            if (encoding === "base64" || encoding.toLowerCase() === "base64") {
              let base64chunk = "";
              value.on("data", (chunk) => {
                base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                let end = base64chunk.length - base64chunk.length % 4;
                chunks.push(Buffer.from(base64chunk.slice(0, end), "base64")), base64chunk = base64chunk.slice(end);
              }), value.on("end", () => {
                chunks.push(Buffer.from(base64chunk, "base64")), responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
            } else
              value.on("data", (chunk) => {
                chunks.push(chunk);
              }), value.on("end", () => {
                responseFormData.append(name, new File2(chunks, filename, { type: mimeType }));
              });
          });
          let busboyResolve = new Promise((resolve, reject) => {
            busboy.on("finish", resolve), busboy.on("error", (err) => reject(TypeError(err)));
          });
          if (this.body !== null)
            for await (let chunk of consumeBody(this[kState].body))
              busboy.write(chunk);
          return busboy.end(), await busboyResolve, responseFormData;
        } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
          let entries;
          try {
            let text = "", streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: !0 });
            for await (let chunk of consumeBody(this[kState].body)) {
              if (!isUint8Array(chunk))
                throw TypeError("Expected Uint8Array chunk");
              text += streamingDecoder.decode(chunk, { stream: !0 });
            }
            text += streamingDecoder.decode(), entries = new URLSearchParams(text);
          } catch (err) {
            throw Object.assign(TypeError(), { cause: err });
          }
          let formData = new FormData2;
          for (let [name, value] of entries)
            formData.append(name, value);
          return formData;
        } else
          throw await Promise.resolve(), throwIfAborted(this[kState]), webidl.errors.exception({
            header: `${instance.name}.formData`,
            message: "Could not parse content as FormData."
          });
      }
    };
  }
  function mixinBody(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  }
  async function specConsumeBody(object, convertBytesToJSValue, instance) {
    if (webidl.brandCheck(object, instance), throwIfAborted(object[kState]), bodyUnusable(object[kState].body))
      throw TypeError("Body is unusable");
    let promise = createDeferredPromise(), errorSteps = (error) => promise.reject(error), successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null)
      return successSteps(new Uint8Array), promise.promise;
    return await fullyReadBody(object[kState].body, successSteps, errorSteps), promise.promise;
  }
  function bodyUnusable(body) {
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  }
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0)
      return "";
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191)
      buffer = buffer.subarray(3);
    return textDecoder.decode(buffer);
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function bodyMimeType(object) {
    let { headersList } = object[kState], contentType = headersList.get("content-type");
    if (contentType === null)
      return "failure";
    return parseMIMEType(contentType);
  }
  module.exports = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/core/request.js
var require_request3 = __commonJS((exports, module) => {
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors4(), assert = __require("assert"), { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols6(), util = require_util14(), tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/, headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/, invalidPathRegex = /[^\u0021-\u00ff]/, kHandler = Symbol("handler"), channels = {}, extractBody;
  try {
    let diagnosticsChannel = __require("diagnostics_channel");
    channels.create = diagnosticsChannel.channel("undici:request:create"), channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent"), channels.headers = diagnosticsChannel.channel("undici:request:headers"), channels.trailers = diagnosticsChannel.channel("undici:request:trailers"), channels.error = diagnosticsChannel.channel("undici:request:error");
  } catch {
    channels.create = { hasSubscribers: !1 }, channels.bodySent = { hasSubscribers: !1 }, channels.headers = { hasSubscribers: !1 }, channels.trailers = { hasSubscribers: !1 }, channels.error = { hasSubscribers: !1 };
  }

  class Request {
    constructor(origin, {
      path,
      method,
      body,
      headers,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      throwOnError,
      expectContinue
    }, handler) {
      if (typeof path !== "string")
        throw new InvalidArgumentError("path must be a string");
      else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT")
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      else if (invalidPathRegex.exec(path) !== null)
        throw new InvalidArgumentError("invalid request path");
      if (typeof method !== "string")
        throw new InvalidArgumentError("method must be a string");
      else if (tokenRegExp.exec(method) === null)
        throw new InvalidArgumentError("invalid request method");
      if (upgrade && typeof upgrade !== "string")
        throw new InvalidArgumentError("upgrade must be a string");
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0))
        throw new InvalidArgumentError("invalid headersTimeout");
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0))
        throw new InvalidArgumentError("invalid bodyTimeout");
      if (reset != null && typeof reset !== "boolean")
        throw new InvalidArgumentError("invalid reset");
      if (expectContinue != null && typeof expectContinue !== "boolean")
        throw new InvalidArgumentError("invalid expectContinue");
      if (this.headersTimeout = headersTimeout, this.bodyTimeout = bodyTimeout, this.throwOnError = throwOnError === !0, this.method = method, this.abort = null, body == null)
        this.body = null;
      else if (util.isStream(body)) {
        this.body = body;
        let rState = this.body._readableState;
        if (!rState || !rState.autoDestroy)
          this.endHandler = function() {
            util.destroy(this);
          }, this.body.on("end", this.endHandler);
        this.errorHandler = (err) => {
          if (this.abort)
            this.abort(err);
          else
            this.error = err;
        }, this.body.on("error", this.errorHandler);
      } else if (util.isBuffer(body))
        this.body = body.byteLength ? body : null;
      else if (ArrayBuffer.isView(body))
        this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
      else if (body instanceof ArrayBuffer)
        this.body = body.byteLength ? Buffer.from(body) : null;
      else if (typeof body === "string")
        this.body = body.length ? Buffer.from(body) : null;
      else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body))
        this.body = body;
      else
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      if (this.completed = !1, this.aborted = !1, this.upgrade = upgrade || null, this.path = query ? util.buildURL(path, query) : path, this.origin = origin, this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent, this.blocking = blocking == null ? !1 : blocking, this.reset = reset == null ? null : reset, this.host = null, this.contentLength = null, this.contentType = null, this.headers = "", this.expectContinue = expectContinue != null ? expectContinue : !1, Array.isArray(headers)) {
        if (headers.length % 2 !== 0)
          throw new InvalidArgumentError("headers array must be even");
        for (let i = 0;i < headers.length; i += 2)
          processHeader(this, headers[i], headers[i + 1]);
      } else if (headers && typeof headers === "object") {
        let keys = Object.keys(headers);
        for (let i = 0;i < keys.length; i++) {
          let key = keys[i];
          processHeader(this, key, headers[key]);
        }
      } else if (headers != null)
        throw new InvalidArgumentError("headers must be an object or an array");
      if (util.isFormDataLike(this.body)) {
        if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8)
          throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
        if (!extractBody)
          extractBody = require_body2().extractBody;
        let [bodyStream, contentType] = extractBody(body);
        if (this.contentType == null)
          this.contentType = contentType, this.headers += `content-type: ${contentType}\r
`;
        this.body = bodyStream.stream, this.contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && this.contentType == null && body.type)
        this.contentType = body.type, this.headers += `content-type: ${body.type}\r
`;
      if (util.validateHandler(handler, method, upgrade), this.servername = util.getServerName(this.host), this[kHandler] = handler, channels.create.hasSubscribers)
        channels.create.publish({ request: this });
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent)
        try {
          return this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.abort(err);
        }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers)
        channels.bodySent.publish({ request: this });
      if (this[kHandler].onRequestSent)
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
    }
    onConnect(abort) {
      if (assert(!this.aborted), assert(!this.completed), this.error)
        abort(this.error);
      else
        return this.abort = abort, this[kHandler].onConnect(abort);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      if (assert(!this.aborted), assert(!this.completed), channels.headers.hasSubscribers)
        channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
      try {
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk) {
      assert(!this.aborted), assert(!this.completed);
      try {
        return this[kHandler].onData(chunk);
      } catch (err) {
        return this.abort(err), !1;
      }
    }
    onUpgrade(statusCode, headers, socket) {
      return assert(!this.aborted), assert(!this.completed), this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      if (this.onFinally(), assert(!this.aborted), this.completed = !0, channels.trailers.hasSubscribers)
        channels.trailers.publish({ request: this, trailers });
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error) {
      if (this.onFinally(), channels.error.hasSubscribers)
        channels.error.publish({ request: this, error });
      if (this.aborted)
        return;
      return this.aborted = !0, this[kHandler].onError(error);
    }
    onFinally() {
      if (this.errorHandler)
        this.body.off("error", this.errorHandler), this.errorHandler = null;
      if (this.endHandler)
        this.body.off("end", this.endHandler), this.endHandler = null;
    }
    addHeader(key, value) {
      return processHeader(this, key, value), this;
    }
    static [kHTTP1BuildRequest](origin, opts, handler) {
      return new Request(origin, opts, handler);
    }
    static [kHTTP2BuildRequest](origin, opts, handler) {
      let headers = opts.headers;
      opts = { ...opts, headers: null };
      let request = new Request(origin, opts, handler);
      if (request.headers = {}, Array.isArray(headers)) {
        if (headers.length % 2 !== 0)
          throw new InvalidArgumentError("headers array must be even");
        for (let i = 0;i < headers.length; i += 2)
          processHeader(request, headers[i], headers[i + 1], !0);
      } else if (headers && typeof headers === "object") {
        let keys = Object.keys(headers);
        for (let i = 0;i < keys.length; i++) {
          let key = keys[i];
          processHeader(request, key, headers[key], !0);
        }
      } else if (headers != null)
        throw new InvalidArgumentError("headers must be an object or an array");
      return request;
    }
    static [kHTTP2CopyHeaders](raw) {
      let rawHeaders = raw.split(`\r
`), headers = {};
      for (let header of rawHeaders) {
        let [key, value] = header.split(": ");
        if (value == null || value.length === 0)
          continue;
        if (headers[key])
          headers[key] += `,${value}`;
        else
          headers[key] = value;
      }
      return headers;
    }
  }
  function processHeaderValue(key, val, skipAppend) {
    if (val && typeof val === "object")
      throw new InvalidArgumentError(`invalid ${key} header`);
    if (val = val != null ? `${val}` : "", headerCharRegex.exec(val) !== null)
      throw new InvalidArgumentError(`invalid ${key} header`);
    return skipAppend ? val : `${key}: ${val}\r
`;
  }
  function processHeader(request, key, val, skipAppend = !1) {
    if (val && (typeof val === "object" && !Array.isArray(val)))
      throw new InvalidArgumentError(`invalid ${key} header`);
    else if (val === void 0)
      return;
    if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
      if (headerCharRegex.exec(val) !== null)
        throw new InvalidArgumentError(`invalid ${key} header`);
      request.host = val;
    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      if (request.contentLength = parseInt(val, 10), !Number.isFinite(request.contentLength))
        throw new InvalidArgumentError("invalid content-length header");
    } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type")
      if (request.contentType = val, skipAppend)
        request.headers[key] = processHeaderValue(key, val, skipAppend);
      else
        request.headers += processHeaderValue(key, val);
    else if (key.length === 17 && key.toLowerCase() === "transfer-encoding")
      throw new InvalidArgumentError("invalid transfer-encoding header");
    else if (key.length === 10 && key.toLowerCase() === "connection") {
      let value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive")
        throw new InvalidArgumentError("invalid connection header");
      else if (value === "close")
        request.reset = !0;
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive")
      throw new InvalidArgumentError("invalid keep-alive header");
    else if (key.length === 7 && key.toLowerCase() === "upgrade")
      throw new InvalidArgumentError("invalid upgrade header");
    else if (key.length === 6 && key.toLowerCase() === "expect")
      throw new NotSupportedError("expect header not supported");
    else if (tokenRegExp.exec(key) === null)
      throw new InvalidArgumentError("invalid header key");
    else if (Array.isArray(val))
      for (let i = 0;i < val.length; i++)
        if (skipAppend)
          if (request.headers[key])
            request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
          else
            request.headers[key] = processHeaderValue(key, val[i], skipAppend);
        else
          request.headers += processHeaderValue(key, val[i]);
    else if (skipAppend)
      request.headers[key] = processHeaderValue(key, val, skipAppend);
    else
      request.headers += processHeaderValue(key, val);
  }
  module.exports = Request;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/dispatcher.js
var require_dispatcher2 = __commonJS((exports, module) => {
  var EventEmitter = __require("events");

  class Dispatcher extends EventEmitter {
    dispatch() {
      throw Error("not implemented");
    }
    close() {
      throw Error("not implemented");
    }
    destroy() {
      throw Error("not implemented");
    }
  }
  module.exports = Dispatcher;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base2 = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher2(), {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = require_errors4(), { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols6(), kDestroyed = Symbol("destroyed"), kClosed = Symbol("closed"), kOnDestroyed = Symbol("onDestroyed"), kOnClosed = Symbol("onClosed"), kInterceptedDispatch = Symbol("Intercepted Dispatch");

  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = !1, this[kOnDestroyed] = null, this[kClosed] = !1, this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i = newInterceptors.length - 1;i >= 0; i--)
          if (typeof this[kInterceptors][i] !== "function")
            throw new InvalidArgumentError("interceptor must be an function");
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === void 0)
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      if (typeof callback !== "function")
        throw new InvalidArgumentError("invalid callback");
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed])
          this[kOnClosed].push(callback);
        else
          queueMicrotask(() => callback(null, null));
        return;
      }
      this[kClosed] = !0, this[kOnClosed].push(callback);
      let onClosed = () => {
        let callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0;i < callbacks.length; i++)
          callbacks[i](null, null);
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function")
        callback = err, err = null;
      if (callback === void 0)
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      if (typeof callback !== "function")
        throw new InvalidArgumentError("invalid callback");
      if (this[kDestroyed]) {
        if (this[kOnDestroyed])
          this[kOnDestroyed].push(callback);
        else
          queueMicrotask(() => callback(null, null));
        return;
      }
      if (!err)
        err = new ClientDestroyedError;
      this[kDestroyed] = !0, this[kOnDestroyed] = this[kOnDestroyed] || [], this[kOnDestroyed].push(callback);
      let onDestroyed = () => {
        let callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0;i < callbacks.length; i++)
          callbacks[i](null, null);
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0)
        return this[kInterceptedDispatch] = this[kDispatch], this[kDispatch](opts, handler);
      let dispatch = this[kDispatch].bind(this);
      for (let i = this[kInterceptors].length - 1;i >= 0; i--)
        dispatch = this[kInterceptors][i](dispatch);
      return this[kInterceptedDispatch] = dispatch, dispatch(opts, handler);
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object")
        throw new InvalidArgumentError("handler must be an object");
      try {
        if (!opts || typeof opts !== "object")
          throw new InvalidArgumentError("opts must be an object.");
        if (this[kDestroyed] || this[kOnDestroyed])
          throw new ClientDestroyedError;
        if (this[kClosed])
          throw new ClientClosedError;
        return this[kInterceptedDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function")
          throw new InvalidArgumentError("invalid onError method");
        return handler.onError(err), !1;
      }
    }
  }
  module.exports = DispatcherBase;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/core/connect.js
var require_connect2 = __commonJS((exports, module) => {
  var net = __require("net"), assert = __require("assert"), util = require_util14(), { InvalidArgumentError, ConnectTimeoutError } = require_errors4(), tls, SessionCache;
  if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE)
    SessionCache = class {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions, this._sessionCache = /* @__PURE__ */ new Map, this._sessionRegistry = new global.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions)
            return;
          let ref = this._sessionCache.get(key);
          if (ref !== void 0 && ref.deref() === void 0)
            this._sessionCache.delete(key);
        });
      }
      get(sessionKey) {
        let ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0)
          return;
        this._sessionCache.set(sessionKey, new WeakRef(session)), this._sessionRegistry.register(session, sessionKey);
      }
    };
  else
    SessionCache = class {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions, this._sessionCache = /* @__PURE__ */ new Map;
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0)
          return;
        if (this._sessionCache.size >= this._maxCachedSessions) {
          let { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0))
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    let options = { path: socketPath, ...opts }, sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    return timeout = timeout == null ? 1e4 : timeout, allowH2 = allowH2 != null ? allowH2 : !1, function({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls)
          tls = __require("tls");
        servername = servername || options.servername || util.getServerName(host) || null;
        let sessionKey = servername || hostname, session = sessionCache.get(sessionKey) || null;
        assert(sessionKey), socket = tls.connect({
          highWaterMark: 16384,
          ...options,
          servername,
          session,
          localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          port: port || 443,
          host: hostname
        }), socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else
        assert(!httpSocket, "httpSocket can only be sent on TLS update"), socket = net.connect({
          highWaterMark: 65536,
          ...options,
          localAddress,
          port: port || 80,
          host: hostname
        });
      if (options.keepAlive == null || options.keepAlive) {
        let keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 60000 : options.keepAliveInitialDelay;
        socket.setKeepAlive(!0, keepAliveInitialDelay);
      }
      let cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
      return socket.setNoDelay(!0).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        if (cancelTimeout(), callback) {
          let cb = callback;
          callback = null, cb(null, this);
        }
      }).on("error", function(err) {
        if (cancelTimeout(), callback) {
          let cb = callback;
          callback = null, cb(err);
        }
      }), socket;
    };
  }
  function setupTimeout(onConnectTimeout2, timeout) {
    if (!timeout)
      return () => {};
    let s1 = null, s2 = null, timeoutId = setTimeout(() => {
      s1 = setImmediate(() => {
        if (process.platform === "win32")
          s2 = setImmediate(() => onConnectTimeout2());
        else
          onConnectTimeout2();
      });
    }, timeout);
    return () => {
      clearTimeout(timeoutId), clearImmediate(s1), clearImmediate(s2);
    };
  }
  function onConnectTimeout(socket) {
    util.destroy(socket, new ConnectTimeoutError);
  }
  module.exports = buildConnector;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/llhttp/utils.js
var require_utils6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.enumToMap = void 0;
  function enumToMap(obj) {
    let res = {};
    return Object.keys(obj).forEach((key) => {
      let value = obj[key];
      if (typeof value === "number")
        res[key] = value;
    }), res;
  }
  exports.enumToMap = enumToMap;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/llhttp/constants.js
var require_constants15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
  var utils_1 = require_utils6(), ERROR;
  (function(ERROR2) {
    ERROR2[ERROR2.OK = 0] = "OK", ERROR2[ERROR2.INTERNAL = 1] = "INTERNAL", ERROR2[ERROR2.STRICT = 2] = "STRICT", ERROR2[ERROR2.LF_EXPECTED = 3] = "LF_EXPECTED", ERROR2[ERROR2.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", ERROR2[ERROR2.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", ERROR2[ERROR2.INVALID_METHOD = 6] = "INVALID_METHOD", ERROR2[ERROR2.INVALID_URL = 7] = "INVALID_URL", ERROR2[ERROR2.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", ERROR2[ERROR2.INVALID_VERSION = 9] = "INVALID_VERSION", ERROR2[ERROR2.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", ERROR2[ERROR2.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", ERROR2[ERROR2.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", ERROR2[ERROR2.INVALID_STATUS = 13] = "INVALID_STATUS", ERROR2[ERROR2.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", ERROR2[ERROR2.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", ERROR2[ERROR2.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", ERROR2[ERROR2.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", ERROR2[ERROR2.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", ERROR2[ERROR2.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", ERROR2[ERROR2.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", ERROR2[ERROR2.PAUSED = 21] = "PAUSED", ERROR2[ERROR2.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", ERROR2[ERROR2.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", ERROR2[ERROR2.USER = 24] = "USER";
  })(ERROR = exports.ERROR || (exports.ERROR = {}));
  var TYPE;
  (function(TYPE2) {
    TYPE2[TYPE2.BOTH = 0] = "BOTH", TYPE2[TYPE2.REQUEST = 1] = "REQUEST", TYPE2[TYPE2.RESPONSE = 2] = "RESPONSE";
  })(TYPE = exports.TYPE || (exports.TYPE = {}));
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", FLAGS2[FLAGS2.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", FLAGS2[FLAGS2.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", FLAGS2[FLAGS2.CHUNKED = 8] = "CHUNKED", FLAGS2[FLAGS2.UPGRADE = 16] = "UPGRADE", FLAGS2[FLAGS2.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", FLAGS2[FLAGS2.SKIPBODY = 64] = "SKIPBODY", FLAGS2[FLAGS2.TRAILING = 128] = "TRAILING", FLAGS2[FLAGS2.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
  })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
  var LENIENT_FLAGS;
  (function(LENIENT_FLAGS2) {
    LENIENT_FLAGS2[LENIENT_FLAGS2.HEADERS = 1] = "HEADERS", LENIENT_FLAGS2[LENIENT_FLAGS2.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", LENIENT_FLAGS2[LENIENT_FLAGS2.KEEP_ALIVE = 4] = "KEEP_ALIVE";
  })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
  var METHODS;
  (function(METHODS2) {
    METHODS2[METHODS2.DELETE = 0] = "DELETE", METHODS2[METHODS2.GET = 1] = "GET", METHODS2[METHODS2.HEAD = 2] = "HEAD", METHODS2[METHODS2.POST = 3] = "POST", METHODS2[METHODS2.PUT = 4] = "PUT", METHODS2[METHODS2.CONNECT = 5] = "CONNECT", METHODS2[METHODS2.OPTIONS = 6] = "OPTIONS", METHODS2[METHODS2.TRACE = 7] = "TRACE", METHODS2[METHODS2.COPY = 8] = "COPY", METHODS2[METHODS2.LOCK = 9] = "LOCK", METHODS2[METHODS2.MKCOL = 10] = "MKCOL", METHODS2[METHODS2.MOVE = 11] = "MOVE", METHODS2[METHODS2.PROPFIND = 12] = "PROPFIND", METHODS2[METHODS2.PROPPATCH = 13] = "PROPPATCH", METHODS2[METHODS2.SEARCH = 14] = "SEARCH", METHODS2[METHODS2.UNLOCK = 15] = "UNLOCK", METHODS2[METHODS2.BIND = 16] = "BIND", METHODS2[METHODS2.REBIND = 17] = "REBIND", METHODS2[METHODS2.UNBIND = 18] = "UNBIND", METHODS2[METHODS2.ACL = 19] = "ACL", METHODS2[METHODS2.REPORT = 20] = "REPORT", METHODS2[METHODS2.MKACTIVITY = 21] = "MKACTIVITY", METHODS2[METHODS2.CHECKOUT = 22] = "CHECKOUT", METHODS2[METHODS2.MERGE = 23] = "MERGE", METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH", METHODS2[METHODS2.NOTIFY = 25] = "NOTIFY", METHODS2[METHODS2.SUBSCRIBE = 26] = "SUBSCRIBE", METHODS2[METHODS2.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", METHODS2[METHODS2.PATCH = 28] = "PATCH", METHODS2[METHODS2.PURGE = 29] = "PURGE", METHODS2[METHODS2.MKCALENDAR = 30] = "MKCALENDAR", METHODS2[METHODS2.LINK = 31] = "LINK", METHODS2[METHODS2.UNLINK = 32] = "UNLINK", METHODS2[METHODS2.SOURCE = 33] = "SOURCE", METHODS2[METHODS2.PRI = 34] = "PRI", METHODS2[METHODS2.DESCRIBE = 35] = "DESCRIBE", METHODS2[METHODS2.ANNOUNCE = 36] = "ANNOUNCE", METHODS2[METHODS2.SETUP = 37] = "SETUP", METHODS2[METHODS2.PLAY = 38] = "PLAY", METHODS2[METHODS2.PAUSE = 39] = "PAUSE", METHODS2[METHODS2.TEARDOWN = 40] = "TEARDOWN", METHODS2[METHODS2.GET_PARAMETER = 41] = "GET_PARAMETER", METHODS2[METHODS2.SET_PARAMETER = 42] = "SET_PARAMETER", METHODS2[METHODS2.REDIRECT = 43] = "REDIRECT", METHODS2[METHODS2.RECORD = 44] = "RECORD", METHODS2[METHODS2.FLUSH = 45] = "FLUSH";
  })(METHODS = exports.METHODS || (exports.METHODS = {}));
  exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS["M-SEARCH"],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    METHODS.SOURCE
  ];
  exports.METHODS_ICE = [
    METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    METHODS.GET,
    METHODS.POST
  ];
  exports.METHOD_MAP = utils_1.enumToMap(METHODS);
  exports.H_METHOD_MAP = {};
  Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key))
      exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
  });
  var FINISH;
  (function(FINISH2) {
    FINISH2[FINISH2.SAFE = 0] = "SAFE", FINISH2[FINISH2.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", FINISH2[FINISH2.UNSAFE = 2] = "UNSAFE";
  })(FINISH = exports.FINISH || (exports.FINISH = {}));
  exports.ALPHA = [];
  for (let i = 65;i <= 90; i++)
    exports.ALPHA.push(String.fromCharCode(i)), exports.ALPHA.push(String.fromCharCode(i + 32));
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["\t", "\f"]);
  for (let i = 128;i <= 255; i++)
    exports.URL_CHAR.push(i);
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
  exports.HEADER_CHARS = ["\t"];
  for (let i = 32;i <= 255; i++)
    if (i !== 127)
      exports.HEADER_CHARS.push(i);
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  var HEADER_STATE;
  (function(HEADER_STATE2) {
    HEADER_STATE2[HEADER_STATE2.GENERAL = 0] = "GENERAL", HEADER_STATE2[HEADER_STATE2.CONNECTION = 1] = "CONNECTION", HEADER_STATE2[HEADER_STATE2.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", HEADER_STATE2[HEADER_STATE2.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", HEADER_STATE2[HEADER_STATE2.UPGRADE = 4] = "UPGRADE", HEADER_STATE2[HEADER_STATE2.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", HEADER_STATE2[HEADER_STATE2.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", HEADER_STATE2[HEADER_STATE2.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", HEADER_STATE2[HEADER_STATE2.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
  })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
  exports.SPECIAL_HEADERS = {
    connection: HEADER_STATE.CONNECTION,
    "content-length": HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": HEADER_STATE.CONNECTION,
    "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
    upgrade: HEADER_STATE.UPGRADE
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler2 = __commonJS((exports, module) => {
  var util = require_util14(), { kBodyUsed } = require_symbols6(), assert = __require("assert"), { InvalidArgumentError } = require_errors4(), EE = __require("events"), redirectableStatusCodes = [300, 301, 302, 303, 307, 308], kBody = Symbol("body");

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body, this[kBodyUsed] = !1;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed"), this[kBodyUsed] = !0, yield* this[kBody];
    }
  }

  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0))
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      if (util.validateHandler(handler, opts.method, opts.upgrade), this.dispatch = dispatch, this.location = null, this.abort = null, this.opts = { ...opts, maxRedirections: 0 }, this.maxRedirections = maxRedirections, this.handler = handler, this.history = [], util.isStream(this.opts.body)) {
        if (util.bodyLength(this.opts.body) === 0)
          this.opts.body.on("data", function() {
            assert(!1);
          });
        if (typeof this.opts.body.readableDidRead !== "boolean")
          this.opts.body[kBodyUsed] = !1, EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = !0;
          });
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function")
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body))
        this.opts.body = new BodyAsyncIterable(this.opts.body);
    }
    onConnect(abort) {
      this.abort = abort, this.handler.onConnect(abort, { history: this.history });
    }
    onUpgrade(statusCode, headers, socket) {
      this.handler.onUpgrade(statusCode, headers, socket);
    }
    onError(error) {
      this.handler.onError(error);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      if (this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers), this.opts.origin)
        this.history.push(new URL(this.opts.path, this.opts.origin));
      if (!this.location)
        return this.handler.onHeaders(statusCode, headers, resume, statusText);
      let { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), path = search ? `${pathname}${search}` : pathname;
      if (this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin), this.opts.path = path, this.opts.origin = origin, this.opts.maxRedirections = 0, this.opts.query = null, statusCode === 303 && this.opts.method !== "HEAD")
        this.opts.method = "GET", this.opts.body = null;
    }
    onData(chunk) {
      if (this.location)
        ;
      else
        return this.handler.onData(chunk);
    }
    onComplete(trailers) {
      if (this.location)
        this.location = null, this.abort = null, this.dispatch(this.opts, this);
      else
        this.handler.onComplete(trailers);
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent)
        this.handler.onBodySent(chunk);
    }
  }
  function parseLocation(statusCode, headers) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1)
      return null;
    for (let i = 0;i < headers.length; i += 2)
      if (headers[i].toString().toLowerCase() === "location")
        return headers[i + 1];
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4)
      return util.headerNameToString(header) === "host";
    if (removeContent && util.headerNameToString(header).startsWith("content-"))
      return !0;
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      let name = util.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return !1;
  }
  function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
    let ret = [];
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2)
        if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin))
          ret.push(headers[i], headers[i + 1]);
    } else if (headers && typeof headers === "object") {
      for (let key of Object.keys(headers))
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin))
          ret.push(key, headers[key]);
    } else
      assert(headers == null, "headers must be an object or an array");
    return ret;
  }
  module.exports = RedirectHandler;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor2 = __commonJS((exports, module) => {
  var RedirectHandler = require_RedirectHandler2();
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function(opts, handler) {
        let { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections)
          return dispatch(opts, handler);
        let redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        return opts = { ...opts, maxRedirections: 0 }, dispatch(opts, redirectHandler);
      };
    };
  }
  module.exports = createRedirectInterceptor;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm2 = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm2 = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/client.js
var require_client2 = __commonJS((exports, module) => {
  var assert = __require("assert"), net = __require("net"), http = __require("http"), { pipeline } = __require("stream"), util = require_util14(), timers = require_timers2(), Request = require_request3(), DispatcherBase = require_dispatcher_base2(), {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError,
    ClientDestroyedError
  } = require_errors4(), buildConnector = require_connect2(), {
    kUrl,
    kReset,
    kServerName,
    kClient,
    kBusy,
    kParser,
    kConnect,
    kBlocking,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize,
    kHTTPConnVersion,
    kHost,
    kHTTP2Session,
    kHTTP2SessionState,
    kHTTP2BuildRequest,
    kHTTP2CopyHeaders,
    kHTTP1BuildRequest
  } = require_symbols6(), http2;
  try {
    http2 = __require("http2");
  } catch {
    http2 = { constants: {} };
  }
  var {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS
    }
  } = http2, h2ExperimentalWarned = !1, FastBuffer = Buffer[Symbol.species], kClosedResolve = Symbol("kClosedResolve"), channels = {};
  try {
    let diagnosticsChannel = __require("diagnostics_channel");
    channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders"), channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect"), channels.connectError = diagnosticsChannel.channel("undici:client:connectError"), channels.connected = diagnosticsChannel.channel("undici:client:connected");
  } catch {
    channels.sendHeaders = { hasSubscribers: !1 }, channels.beforeConnect = { hasSubscribers: !1 }, channels.connectError = { hasSubscribers: !1 }, channels.connected = { hasSubscribers: !1 };
  }

  class Client extends DispatcherBase {
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect2,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      maxConcurrentStreams
    } = {}) {
      super();
      if (keepAlive !== void 0)
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      if (socketTimeout !== void 0)
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      if (requestTimeout !== void 0)
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      if (idleTimeout !== void 0)
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      if (maxKeepAliveTimeout !== void 0)
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize))
        throw new InvalidArgumentError("invalid maxHeaderSize");
      if (socketPath != null && typeof socketPath !== "string")
        throw new InvalidArgumentError("invalid socketPath");
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0))
        throw new InvalidArgumentError("invalid connectTimeout");
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0))
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0))
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold))
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0))
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0))
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object")
        throw new InvalidArgumentError("connect must be a function or an object");
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0))
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0))
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0))
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1))
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1))
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      if (allowH2 != null && typeof allowH2 !== "boolean")
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1))
        throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
      if (typeof connect2 !== "function")
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect2
        });
      this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })], this[kUrl] = util.parseOrigin(url), this[kConnector] = connect2, this[kSocket] = null, this[kPipelining] = pipelining != null ? pipelining : 1, this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize, this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4000 : keepAliveTimeout, this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600000 : keepAliveMaxTimeout, this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1000 : keepAliveTimeoutThreshold, this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout], this[kServerName] = null, this[kLocalAddress] = localAddress != null ? localAddress : null, this[kResuming] = 0, this[kNeedDrain] = 0, this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`, this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300000, this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300000, this[kStrictContentLength] = strictContentLength == null ? !0 : strictContentLength, this[kMaxRedirections] = maxRedirections, this[kMaxRequests] = maxRequestsPerClient, this[kClosedResolve] = null, this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1, this[kHTTPConnVersion] = "h1", this[kHTTP2Session] = null, this[kHTTP2SessionState] = !allowH2 ? null : {
        openStreams: 0,
        maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
      }, this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`, this[kQueue] = [], this[kRunningIdx] = 0, this[kPendingIdx] = 0;
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value, resume(this, !0);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
    }
    get [kBusy]() {
      let socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
    }
    [kConnect](cb) {
      connect(this), this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      let origin = opts.origin || this[kUrl].origin, request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
      if (this[kQueue].push(request), this[kResuming])
        ;
      else if (util.bodyLength(request.body) == null && util.isIterable(request.body))
        this[kResuming] = 1, process.nextTick(resume, this);
      else
        resume(this, !0);
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy])
        this[kNeedDrain] = 2;
      return this[kNeedDrain] < 2;
    }
    async[kClose]() {
      return new Promise((resolve) => {
        if (!this[kSize])
          resolve(null);
        else
          this[kClosedResolve] = resolve;
      });
    }
    async[kDestroy](err) {
      return new Promise((resolve) => {
        let requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0;i < requests.length; i++) {
          let request = requests[i];
          errorRequest(this, request, err);
        }
        let callback = () => {
          if (this[kClosedResolve])
            this[kClosedResolve](), this[kClosedResolve] = null;
          resolve();
        };
        if (this[kHTTP2Session] != null)
          util.destroy(this[kHTTP2Session], err), this[kHTTP2Session] = null, this[kHTTP2SessionState] = null;
        if (!this[kSocket])
          queueMicrotask(callback);
        else
          util.destroy(this[kSocket].on("close", callback), err);
        resume(this);
      });
    }
  }
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[kSocket][kError] = err, onError(this[kClient], err);
  }
  function onHttp2FrameError(type, code, id) {
    let err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
    if (id === 0)
      this[kSocket][kError] = err, onError(this[kClient], err);
  }
  function onHttp2SessionEnd() {
    util.destroy(this, new SocketError("other side closed")), util.destroy(this[kSocket], new SocketError("other side closed"));
  }
  function onHTTP2GoAway(code) {
    let client = this[kClient], err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
    if (client[kSocket] = null, client[kHTTP2Session] = null, client.destroyed) {
      assert(this[kPending] === 0);
      let requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        let request = requests[i];
        errorRequest(this, request, err);
      }
    } else if (client[kRunning] > 0) {
      let request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null, errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx], assert(client[kRunning] === 0), client.emit("disconnect", client[kUrl], [client], err), resume(client);
  }
  var constants = require_constants15(), createRedirectInterceptor = require_redirectInterceptor2(), EMPTY_BUF = Buffer.alloc(0);
  async function lazyllhttp() {
    let llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm2() : void 0, mod;
    try {
      mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm2(), "base64"));
    } catch (e) {
      mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm2(), "base64"));
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          return assert.strictEqual(currentParser.ptr, p), currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          return assert.strictEqual(currentParser.ptr, p), currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          let start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          return assert.strictEqual(currentParser.ptr, p), currentParser.onMessageComplete() || 0;
        }
      }
    });
  }
  var llhttpInstance = null, llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null, currentBufferRef = null, currentBufferSize = 0, currentBufferPtr = null, TIMEOUT_HEADERS = 1, TIMEOUT_BODY = 2, TIMEOUT_IDLE = 3;

  class Parser {
    constructor(client, socket, { exports: exports2 }) {
      assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0), this.llhttp = exports2, this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE), this.client = client, this.socket = socket, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = !1, this.headers = [], this.headersSize = 0, this.headersMaxSize = client[kMaxHeadersSize], this.shouldKeepAlive = !1, this.paused = !1, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = client[kMaxResponseSize];
    }
    setTimeout(value, type) {
      if (this.timeoutType = type, value !== this.timeoutValue) {
        if (timers.clearTimeout(this.timeout), value) {
          if (this.timeout = timers.setTimeout(onParserTimeout, value, this), this.timeout.unref)
            this.timeout.unref();
        } else
          this.timeout = null;
        this.timeoutValue = value;
      } else if (this.timeout) {
        if (this.timeout.refresh)
          this.timeout.refresh();
      }
    }
    resume() {
      if (this.socket.destroyed || !this.paused)
        return;
      if (assert(this.ptr != null), assert(currentParser == null), this.llhttp.llhttp_resume(this.ptr), assert(this.timeoutType === TIMEOUT_BODY), this.timeout) {
        if (this.timeout.refresh)
          this.timeout.refresh();
      }
      this.paused = !1, this.execute(this.socket.read() || EMPTY_BUF), this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        let chunk = this.socket.read();
        if (chunk === null)
          break;
        this.execute(chunk);
      }
    }
    execute(data) {
      assert(this.ptr != null), assert(currentParser == null), assert(!this.paused);
      let { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr)
          llhttp.free(currentBufferPtr);
        currentBufferSize = Math.ceil(data.length / 4096) * 4096, currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data, currentParser = this, ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null, currentBufferRef = null;
        }
        let offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants.ERROR.PAUSED_UPGRADE)
          this.onUpgrade(data.slice(offset));
        else if (ret === constants.ERROR.PAUSED)
          this.paused = !0, socket.unshift(data.slice(offset));
        else if (ret !== constants.ERROR.OK) {
          let ptr = llhttp.llhttp_get_error_reason(this.ptr), message = "";
          if (ptr) {
            let len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    destroy() {
      assert(this.ptr != null), assert(currentParser == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, timers.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = !1;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      let { socket, client } = this;
      if (socket.destroyed)
        return -1;
      if (!client[kQueue][client[kRunningIdx]])
        return -1;
    }
    onHeaderField(buf) {
      let len = this.headers.length;
      if ((len & 1) === 0)
        this.headers.push(buf);
      else
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1)
        this.headers.push(buf), len += 1;
      else
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      let key = this.headers[len - 2];
      if (key.length === 10 && key.toString().toLowerCase() === "keep-alive")
        this.keepAlive += buf.toString();
      else if (key.length === 10 && key.toString().toLowerCase() === "connection")
        this.connection += buf.toString();
      else if (key.length === 14 && key.toString().toLowerCase() === "content-length")
        this.contentLength += buf.toString();
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      if (this.headersSize += len, this.headersSize >= this.headersMaxSize)
        util.destroy(this.socket, new HeadersOverflowError);
    }
    onUpgrade(head) {
      let { upgrade, client, socket, headers, statusCode } = this;
      assert(upgrade);
      let request = client[kQueue][client[kRunningIdx]];
      assert(request), assert(!socket.destroyed), assert(socket === client[kSocket]), assert(!this.paused), assert(request.upgrade || request.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, assert(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, socket.unshift(head), socket[kParser].destroy(), socket[kParser] = null, socket[kClient] = null, socket[kError] = null, socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose), client[kSocket] = null, client[kQueue][client[kRunningIdx]++] = null, client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
      try {
        request.onUpgrade(statusCode, headers, socket);
      } catch (err) {
        util.destroy(socket, err);
      }
      resume(client);
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      let { client, socket, headers, statusText } = this;
      if (socket.destroyed)
        return -1;
      let request = client[kQueue][client[kRunningIdx]];
      if (!request)
        return -1;
      if (assert(!this.upgrade), assert(this.statusCode < 200), statusCode === 100)
        return util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket))), -1;
      if (upgrade && !request.upgrade)
        return util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket))), -1;
      if (assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS), this.statusCode = statusCode, this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
        let bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh)
          this.timeout.refresh();
      }
      if (request.method === "CONNECT")
        return assert(client[kRunning] === 1), this.upgrade = !0, 2;
      if (upgrade)
        return assert(client[kRunning] === 1), this.upgrade = !0, 2;
      if (assert(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && client[kPipelining]) {
        let keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          let timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0)
            socket[kReset] = !0;
          else
            client[kKeepAliveTimeoutValue] = timeout;
        } else
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
      } else
        socket[kReset] = !0;
      let pause = request.onHeaders(statusCode, headers, this.resume, statusText) === !1;
      if (request.aborted)
        return -1;
      if (request.method === "HEAD")
        return 1;
      if (statusCode < 200)
        return 1;
      if (socket[kBlocking])
        socket[kBlocking] = !1, resume(client);
      return pause ? constants.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      let { client, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed)
        return -1;
      let request = client[kQueue][client[kRunningIdx]];
      if (assert(request), assert.strictEqual(this.timeoutType, TIMEOUT_BODY), this.timeout) {
        if (this.timeout.refresh)
          this.timeout.refresh();
      }
      if (assert(statusCode >= 200), maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize)
        return util.destroy(socket, new ResponseExceededMaxSizeError), -1;
      if (this.bytesRead += buf.length, request.onData(buf) === !1)
        return constants.ERROR.PAUSED;
    }
    onMessageComplete() {
      let { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive))
        return -1;
      if (upgrade)
        return;
      let request = client[kQueue][client[kRunningIdx]];
      if (assert(request), assert(statusCode >= 100), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", assert(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, statusCode < 200)
        return;
      if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10))
        return util.destroy(socket, new ResponseContentLengthMismatchError), -1;
      if (request.onComplete(headers), client[kQueue][client[kRunningIdx]++] = null, socket[kWriting])
        return assert.strictEqual(client[kRunning], 0), util.destroy(socket, new InformationalError("reset")), constants.ERROR.PAUSED;
      else if (!shouldKeepAlive)
        return util.destroy(socket, new InformationalError("reset")), constants.ERROR.PAUSED;
      else if (socket[kReset] && client[kRunning] === 0)
        return util.destroy(socket, new InformationalError("reset")), constants.ERROR.PAUSED;
      else if (client[kPipelining] === 1)
        setImmediate(resume, client);
      else
        resume(client);
    }
  }
  function onParserTimeout(parser) {
    let { socket, timeoutType, client } = parser;
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1)
        assert(!parser.paused, "cannot be paused while waiting for headers"), util.destroy(socket, new HeadersTimeoutError);
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!parser.paused)
        util.destroy(socket, new BodyTimeoutError);
    } else if (timeoutType === TIMEOUT_IDLE)
      assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]), util.destroy(socket, new InformationalError("socket idle timeout"));
  }
  function onSocketReadable() {
    let { [kParser]: parser } = this;
    if (parser)
      parser.readMore();
  }
  function onSocketError(err) {
    let { [kClient]: client, [kParser]: parser } = this;
    if (assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), client[kHTTPConnVersion] !== "h2") {
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    this[kError] = err, onError(this[kClient], err);
  }
  function onError(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      let requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        let request = requests[i];
        errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  }
  function onSocketEnd() {
    let { [kParser]: parser, [kClient]: client } = this;
    if (client[kHTTPConnVersion] !== "h2") {
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
        return;
      }
    }
    util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
  }
  function onSocketClose() {
    let { [kClient]: client, [kParser]: parser } = this;
    if (client[kHTTPConnVersion] === "h1" && parser) {
      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive)
        parser.onMessageComplete();
      this[kParser].destroy(), this[kParser] = null;
    }
    let err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
    if (client[kSocket] = null, client.destroyed) {
      assert(client[kPending] === 0);
      let requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        let request = requests[i];
        errorRequest(client, request, err);
      }
    } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
      let request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null, errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx], assert(client[kRunning] === 0), client.emit("disconnect", client[kUrl], [client], err), resume(client);
  }
  async function connect(client) {
    assert(!client[kConnecting]), assert(!client[kSocket]);
    let { host, hostname, protocol, port } = client[kUrl];
    if (hostname[0] === "[") {
      let idx = hostname.indexOf("]");
      assert(idx !== -1);
      let ip = hostname.substring(1, idx);
      assert(net.isIP(ip)), hostname = ip;
    }
    if (client[kConnecting] = !0, channels.beforeConnect.hasSubscribers)
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
    try {
      let socket = await new Promise((resolve, reject) => {
        client[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        }, (err, socket2) => {
          if (err)
            reject(err);
          else
            resolve(socket2);
        });
      });
      if (client.destroyed) {
        util.destroy(socket.on("error", () => {}), new ClientDestroyedError);
        return;
      }
      if (client[kConnecting] = !1, assert(socket), socket.alpnProtocol === "h2") {
        if (!h2ExperimentalWarned)
          h2ExperimentalWarned = !0, process.emitWarning("H2 support is experimental, expect them to change at any time.", {
            code: "UNDICI-H2"
          });
        let session = http2.connect(client[kUrl], {
          createConnection: () => socket,
          peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
        });
        client[kHTTPConnVersion] = "h2", session[kClient] = client, session[kSocket] = socket, session.on("error", onHttp2SessionError), session.on("frameError", onHttp2FrameError), session.on("end", onHttp2SessionEnd), session.on("goaway", onHTTP2GoAway), session.on("close", onSocketClose), session.unref(), client[kHTTP2Session] = session, socket[kHTTP2Session] = session;
      } else {
        if (!llhttpInstance)
          llhttpInstance = await llhttpPromise, llhttpPromise = null;
        socket[kNoRef] = !1, socket[kWriting] = !1, socket[kReset] = !1, socket[kBlocking] = !1, socket[kParser] = new Parser(client, socket, llhttpInstance);
      }
      if (socket[kCounter] = 0, socket[kMaxRequests] = client[kMaxRequests], socket[kClient] = client, socket[kError] = null, socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose), client[kSocket] = socket, channels.connected.hasSubscribers)
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        });
      client.emit("connect", client[kUrl], [client]);
    } catch (err) {
      if (client.destroyed)
        return;
      if (client[kConnecting] = !1, channels.connectError.hasSubscribers)
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          error: err
        });
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(client[kRunning] === 0);
        while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
          let request = client[kQueue][client[kPendingIdx]++];
          errorRequest(client, request, err);
        }
      } else
        onError(client, err);
      client.emit("connectionError", client[kUrl], [client], err);
    }
    resume(client);
  }
  function emitDrain(client) {
    client[kNeedDrain] = 0, client.emit("drain", client[kUrl], [client]);
  }
  function resume(client, sync) {
    if (client[kResuming] === 2)
      return;
    if (client[kResuming] = 2, _resume(client, sync), client[kResuming] = 0, client[kRunningIdx] > 256)
      client[kQueue].splice(0, client[kRunningIdx]), client[kPendingIdx] -= client[kRunningIdx], client[kRunningIdx] = 0;
  }
  function _resume(client, sync) {
    while (!0) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve](), client[kClosedResolve] = null;
        return;
      }
      let socket = client[kSocket];
      if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref)
            socket.unref(), socket[kNoRef] = !0;
        } else if (socket[kNoRef] && socket.ref)
          socket.ref(), socket[kNoRef] = !1;
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_IDLE)
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            let request2 = client[kQueue][client[kRunningIdx]], headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
      if (client[kBusy])
        client[kNeedDrain] = 2;
      else if (client[kNeedDrain] === 2) {
        if (sync)
          client[kNeedDrain] = 1, process.nextTick(emitDrain, client);
        else
          emitDrain(client);
        continue;
      }
      if (client[kPending] === 0)
        return;
      if (client[kRunning] >= (client[kPipelining] || 1))
        return;
      let request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0)
          return;
        if (client[kServerName] = request.servername, socket && socket.servername !== request.servername) {
          util.destroy(socket, new InformationalError("servername changed"));
          return;
        }
      }
      if (client[kConnecting])
        return;
      if (!socket && !client[kHTTP2Session]) {
        connect(client);
        return;
      }
      if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking])
        return;
      if (client[kRunning] > 0 && !request.idempotent)
        return;
      if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT"))
        return;
      if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body)))
        return;
      if (!request.aborted && write(client, request))
        client[kPendingIdx]++;
      else
        client[kQueue].splice(client[kPendingIdx], 1);
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function write(client, request) {
    if (client[kHTTPConnVersion] === "h2") {
      writeH2(client, client[kHTTP2Session], request);
      return;
    }
    let { body, method, path, host, upgrade, headers, blocking, reset } = request, expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function")
      body.read(0);
    let bodyLength = util.bodyLength(body), contentLength = bodyLength;
    if (contentLength === null)
      contentLength = request.contentLength;
    if (contentLength === 0 && !expectsPayload)
      contentLength = null;
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength])
        return errorRequest(client, request, new RequestContentLengthMismatchError), !1;
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    let socket = client[kSocket];
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed)
          return;
        errorRequest(client, request, err || new RequestAbortedError), util.destroy(socket, new InformationalError("aborted"));
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted)
      return !1;
    if (method === "HEAD")
      socket[kReset] = !0;
    if (upgrade || method === "CONNECT")
      socket[kReset] = !0;
    if (reset != null)
      socket[kReset] = reset;
    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests])
      socket[kReset] = !0;
    if (blocking)
      socket[kBlocking] = !0;
    let header = `${method} ${path} HTTP/1.1\r
`;
    if (typeof host === "string")
      header += `host: ${host}\r
`;
    else
      header += client[kHostHeader];
    if (upgrade)
      header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
    else if (client[kPipelining] && !socket[kReset])
      header += `connection: keep-alive\r
`;
    else
      header += `connection: close\r
`;
    if (headers)
      header += headers;
    if (channels.sendHeaders.hasSubscribers)
      channels.sendHeaders.publish({ request, headers: header, socket });
    if (!body || bodyLength === 0) {
      if (contentLength === 0)
        socket.write(`${header}content-length: 0\r
\r
`, "latin1");
      else
        assert(contentLength === null, "no body must not have content length"), socket.write(`${header}\r
`, "latin1");
      request.onRequestSent();
    } else if (util.isBuffer(body)) {
      if (assert(contentLength === body.byteLength, "buffer body must have content length"), socket.cork(), socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1"), socket.write(body), socket.uncork(), request.onBodySent(body), request.onRequestSent(), !expectsPayload)
        socket[kReset] = !0;
    } else if (util.isBlobLike(body))
      if (typeof body.stream === "function")
        writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
      else
        writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
    else if (util.isStream(body))
      writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
    else if (util.isIterable(body))
      writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
    else
      assert(!1);
    return !0;
  }
  function writeH2(client, session, request) {
    let { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request, headers;
    if (typeof reqHeaders === "string")
      headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
    else
      headers = reqHeaders;
    if (upgrade)
      return errorRequest(client, request, Error("Upgrade not supported for H2")), !1;
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed)
          return;
        errorRequest(client, request, err || new RequestAbortedError);
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted)
      return !1;
    let stream, h2State = client[kHTTP2SessionState];
    if (headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost], headers[HTTP2_HEADER_METHOD] = method, method === "CONNECT") {
      if (session.ref(), stream = session.request(headers, { endStream: !1, signal }), stream.id && !stream.pending)
        request.onUpgrade(null, null, stream), ++h2State.openStreams;
      else
        stream.once("ready", () => {
          request.onUpgrade(null, null, stream), ++h2State.openStreams;
        });
      return stream.once("close", () => {
        if (h2State.openStreams -= 1, h2State.openStreams === 0)
          session.unref();
      }), !0;
    }
    headers[HTTP2_HEADER_PATH] = path, headers[HTTP2_HEADER_SCHEME] = "https";
    let expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function")
      body.read(0);
    let contentLength = util.bodyLength(body);
    if (contentLength == null)
      contentLength = request.contentLength;
    if (contentLength === 0 || !expectsPayload)
      contentLength = null;
    if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength])
        return errorRequest(client, request, new RequestContentLengthMismatchError), !1;
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    if (contentLength != null)
      assert(body, "no body must not have content length"), headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    session.ref();
    let shouldEndStream = method === "GET" || method === "HEAD";
    if (expectContinue)
      headers[HTTP2_HEADER_EXPECT] = "100-continue", stream = session.request(headers, { endStream: shouldEndStream, signal }), stream.once("continue", writeBodyH2);
    else
      stream = session.request(headers, {
        endStream: shouldEndStream,
        signal
      }), writeBodyH2();
    return ++h2State.openStreams, stream.once("response", (headers2) => {
      let { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
      if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === !1)
        stream.pause();
    }), stream.once("end", () => {
      request.onComplete([]);
    }), stream.on("data", (chunk) => {
      if (request.onData(chunk) === !1)
        stream.pause();
    }), stream.once("close", () => {
      if (h2State.openStreams -= 1, h2State.openStreams === 0)
        session.unref();
    }), stream.once("error", function(err) {
      if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed)
        h2State.streams -= 1, util.destroy(stream, err);
    }), stream.once("frameError", (type, code) => {
      let err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (errorRequest(client, request, err), client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed)
        h2State.streams -= 1, util.destroy(stream, err);
    }), !0;
    function writeBodyH2() {
      if (!body)
        request.onRequestSent();
      else if (util.isBuffer(body))
        assert(contentLength === body.byteLength, "buffer body must have content length"), stream.cork(), stream.write(body), stream.uncork(), stream.end(), request.onBodySent(body), request.onRequestSent();
      else if (util.isBlobLike(body))
        if (typeof body.stream === "function")
          writeIterable({
            client,
            request,
            contentLength,
            h2stream: stream,
            expectsPayload,
            body: body.stream(),
            socket: client[kSocket],
            header: ""
          });
        else
          writeBlob({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            h2stream: stream,
            header: "",
            socket: client[kSocket]
          });
      else if (util.isStream(body))
        writeStream({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          socket: client[kSocket],
          h2stream: stream,
          header: ""
        });
      else if (util.isIterable(body))
        writeIterable({
          body,
          client,
          request,
          contentLength,
          expectsPayload,
          header: "",
          h2stream: stream,
          socket: client[kSocket]
        });
      else
        assert(!1);
    }
  }
  function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    if (assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined"), client[kHTTPConnVersion] === "h2") {
      let onPipeData = function(chunk) {
        request.onBodySent(chunk);
      }, pipe = pipeline(body, h2stream, (err) => {
        if (err)
          util.destroy(body, err), util.destroy(h2stream, err);
        else
          request.onRequestSent();
      });
      pipe.on("data", onPipeData), pipe.once("end", () => {
        pipe.removeListener("data", onPipeData), util.destroy(pipe);
      });
      return;
    }
    let finished = !1, writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header }), onData = function(chunk) {
      if (finished)
        return;
      try {
        if (!writer.write(chunk) && this.pause)
          this.pause();
      } catch (err) {
        util.destroy(this, err);
      }
    }, onDrain = function() {
      if (finished)
        return;
      if (body.resume)
        body.resume();
    }, onAbort = function() {
      if (finished)
        return;
      let err = new RequestAbortedError;
      queueMicrotask(() => onFinished(err));
    }, onFinished = function(err) {
      if (finished)
        return;
      if (finished = !0, assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1), socket.off("drain", onDrain).off("error", onFinished), body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort), !err)
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      if (writer.destroy(err), err && (err.code !== "UND_ERR_INFO" || err.message !== "reset"))
        util.destroy(body, err);
      else
        util.destroy(body);
    };
    if (body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort), body.resume)
      body.resume();
    socket.on("drain", onDrain).on("error", onFinished);
  }
  async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength === body.size, "blob body must have content length");
    let isH2 = client[kHTTPConnVersion] === "h2";
    try {
      if (contentLength != null && contentLength !== body.size)
        throw new RequestContentLengthMismatchError;
      let buffer = Buffer.from(await body.arrayBuffer());
      if (isH2)
        h2stream.cork(), h2stream.write(buffer), h2stream.uncork();
      else
        socket.cork(), socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1"), socket.write(buffer), socket.uncork();
      if (request.onBodySent(buffer), request.onRequestSent(), !expectsPayload)
        socket[kReset] = !0;
      resume(client);
    } catch (err) {
      util.destroy(isH2 ? h2stream : socket, err);
    }
  }
  async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        let cb = callback;
        callback = null, cb();
      }
    }
    let waitForDrain = () => new Promise((resolve, reject) => {
      if (assert(callback === null), socket[kError])
        reject(socket[kError]);
      else
        callback = resolve;
    });
    if (client[kHTTPConnVersion] === "h2") {
      h2stream.on("close", onDrain).on("drain", onDrain);
      try {
        for await (let chunk of body) {
          if (socket[kError])
            throw socket[kError];
          let res = h2stream.write(chunk);
          if (request.onBodySent(chunk), !res)
            await waitForDrain();
        }
      } catch (err) {
        h2stream.destroy(err);
      } finally {
        request.onRequestSent(), h2stream.end(), h2stream.off("close", onDrain).off("drain", onDrain);
      }
      return;
    }
    socket.on("close", onDrain).on("drain", onDrain);
    let writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    try {
      for await (let chunk of body) {
        if (socket[kError])
          throw socket[kError];
        if (!writer.write(chunk))
          await waitForDrain();
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }

  class AsyncWriter {
    constructor({ socket, request, contentLength, client, expectsPayload, header }) {
      this.socket = socket, this.request = request, this.contentLength = contentLength, this.client = client, this.bytesWritten = 0, this.expectsPayload = expectsPayload, this.header = header, socket[kWriting] = !0;
    }
    write(chunk) {
      let { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
      if (socket[kError])
        throw socket[kError];
      if (socket.destroyed)
        return !1;
      let len = Buffer.byteLength(chunk);
      if (!len)
        return !0;
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength])
          throw new RequestContentLengthMismatchError;
        process.emitWarning(new RequestContentLengthMismatchError);
      }
      if (socket.cork(), bytesWritten === 0) {
        if (!expectsPayload)
          socket[kReset] = !0;
        if (contentLength === null)
          socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
        else
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      }
      if (contentLength === null)
        socket.write(`\r
${len.toString(16)}\r
`, "latin1");
      this.bytesWritten += len;
      let ret = socket.write(chunk);
      if (socket.uncork(), request.onBodySent(chunk), !ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh)
            socket[kParser].timeout.refresh();
        }
      }
      return ret;
    }
    end() {
      let { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
      if (request.onRequestSent(), socket[kWriting] = !1, socket[kError])
        throw socket[kError];
      if (socket.destroyed)
        return;
      if (bytesWritten === 0)
        if (expectsPayload)
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        else
          socket.write(`${header}\r
`, "latin1");
      else if (contentLength === null)
        socket.write(`\r
0\r
\r
`, "latin1");
      if (contentLength !== null && bytesWritten !== contentLength)
        if (client[kStrictContentLength])
          throw new RequestContentLengthMismatchError;
        else
          process.emitWarning(new RequestContentLengthMismatchError);
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh)
          socket[kParser].timeout.refresh();
      }
      resume(client);
    }
    destroy(err) {
      let { socket, client } = this;
      if (socket[kWriting] = !1, err)
        assert(client[kRunning] <= 1, "pipeline should only contain this request"), util.destroy(socket, err);
    }
  }
  function errorRequest(client, request, err) {
    try {
      request.onError(err), assert(request.aborted);
    } catch (err2) {
      client.emit("error", err2);
    }
  }
  module.exports = Client;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue2 = __commonJS((exports, module) => {
  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0, this.top = 0, this.list = Array(2048), this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & 2047) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data, this.top = this.top + 1 & 2047;
    }
    shift() {
      let nextItem = this.list[this.bottom];
      if (nextItem === void 0)
        return null;
      return this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & 2047, nextItem;
    }
  }
  module.exports = class {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull())
        this.head = this.head.next = new FixedCircularBuffer;
      this.head.push(data);
    }
    shift() {
      let tail = this.tail, next = tail.shift();
      if (tail.isEmpty() && tail.next !== null)
        this.tail = tail.next;
      return next;
    }
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/pool-stats.js
var require_pool_stats2 = __commonJS((exports, module) => {
  var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols6(), kPool = Symbol("pool");

  class PoolStats {
    constructor(pool) {
      this[kPool] = pool;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  module.exports = PoolStats;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/pool-base.js
var require_pool_base2 = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base2(), FixedQueue = require_fixed_queue2(), { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols6(), PoolStats = require_pool_stats2(), kClients = Symbol("clients"), kNeedDrain = Symbol("needDrain"), kQueue = Symbol("queue"), kClosedResolve = Symbol("closed resolve"), kOnDrain = Symbol("onDrain"), kOnConnect = Symbol("onConnect"), kOnDisconnect = Symbol("onDisconnect"), kOnConnectionError = Symbol("onConnectionError"), kGetDispatcher = Symbol("get dispatcher"), kAddClient = Symbol("add client"), kRemoveClient = Symbol("remove client"), kStats = Symbol("stats");

  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue, this[kClients] = [], this[kQueued] = 0;
      let pool = this;
      this[kOnDrain] = function(origin, targets) {
        let queue = pool[kQueue], needDrain = !1;
        while (!needDrain) {
          let item = queue.shift();
          if (!item)
            break;
          pool[kQueued]--, needDrain = !this.dispatch(item.opts, item.handler);
        }
        if (this[kNeedDrain] = needDrain, !this[kNeedDrain] && pool[kNeedDrain])
          pool[kNeedDrain] = !1, pool.emit("drain", origin, [pool, ...targets]);
        if (pool[kClosedResolve] && queue.isEmpty())
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
      }, this[kOnConnect] = (origin, targets) => {
        pool.emit("connect", origin, [pool, ...targets]);
      }, this[kOnDisconnect] = (origin, targets, err) => {
        pool.emit("disconnect", origin, [pool, ...targets], err);
      }, this[kOnConnectionError] = (origin, targets, err) => {
        pool.emit("connectionError", origin, [pool, ...targets], err);
      }, this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client) => client[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (let { [kPending]: pending } of this[kClients])
        ret += pending;
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (let { [kRunning]: running } of this[kClients])
        ret += running;
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (let { [kSize]: size } of this[kClients])
        ret += size;
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose]() {
      if (this[kQueue].isEmpty())
        return Promise.all(this[kClients].map((c) => c.close()));
      else
        return new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
    }
    async[kDestroy](err) {
      while (!0) {
        let item = this[kQueue].shift();
        if (!item)
          break;
        item.handler.onError(err);
      }
      return Promise.all(this[kClients].map((c) => c.destroy(err)));
    }
    [kDispatch](opts, handler) {
      let dispatcher = this[kGetDispatcher]();
      if (!dispatcher)
        this[kNeedDrain] = !0, this[kQueue].push({ opts, handler }), this[kQueued]++;
      else if (!dispatcher.dispatch(opts, handler))
        dispatcher[kNeedDrain] = !0, this[kNeedDrain] = !this[kGetDispatcher]();
      return !this[kNeedDrain];
    }
    [kAddClient](client) {
      if (client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].push(client), this[kNeedDrain])
        process.nextTick(() => {
          if (this[kNeedDrain])
            this[kOnDrain](client[kUrl], [this, client]);
        });
      return this;
    }
    [kRemoveClient](client) {
      client.close(() => {
        let idx = this[kClients].indexOf(client);
        if (idx !== -1)
          this[kClients].splice(idx, 1);
      }), this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== !0 && dispatcher.destroyed !== !0);
    }
  }
  module.exports = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/pool.js
var require_pool2 = __commonJS((exports, module) => {
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = require_pool_base2(), Client = require_client2(), {
    InvalidArgumentError
  } = require_errors4(), util = require_util14(), { kUrl, kInterceptors } = require_symbols6(), buildConnector = require_connect2(), kOptions = Symbol("options"), kConnections = Symbol("connections"), kFactory = Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client(origin, opts);
  }

  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      ...options
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0))
        throw new InvalidArgumentError("invalid connections");
      if (typeof factory !== "function")
        throw new InvalidArgumentError("factory must be a function.");
      if (connect != null && typeof connect !== "function" && typeof connect !== "object")
        throw new InvalidArgumentError("connect must be a function or an object");
      if (typeof connect !== "function")
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect
        });
      this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [], this[kConnections] = connections || null, this[kUrl] = util.parseOrigin(origin), this[kOptions] = { ...util.deepClone(options), connect, allowH2 }, this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0, this[kFactory] = factory;
    }
    [kGetDispatcher]() {
      let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
      if (dispatcher)
        return dispatcher;
      if (!this[kConnections] || this[kClients].length < this[kConnections])
        dispatcher = this[kFactory](this[kUrl], this[kOptions]), this[kAddClient](dispatcher);
      return dispatcher;
    }
  }
  module.exports = Pool;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/balanced-pool.js
var require_balanced_pool2 = __commonJS((exports, module) => {
  var {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = require_errors4(), {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = require_pool_base2(), Pool = require_pool2(), { kUrl, kInterceptors } = require_symbols6(), { parseOrigin } = require_util14(), kFactory = Symbol("factory"), kOptions = Symbol("options"), kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor"), kCurrentWeight = Symbol("kCurrentWeight"), kIndex = Symbol("kIndex"), kWeight = Symbol("kWeight"), kMaxWeightPerServer = Symbol("kMaxWeightPerServer"), kErrorPenalty = Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a, b) {
    if (b === 0)
      return a;
    return getGreatestCommonDivisor(b, a % b);
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }

  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      if (this[kOptions] = opts, this[kIndex] = -1, this[kCurrentWeight] = 0, this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100, this[kErrorPenalty] = this[kOptions].errorPenalty || 15, !Array.isArray(upstreams))
        upstreams = [upstreams];
      if (typeof factory !== "function")
        throw new InvalidArgumentError("factory must be a function.");
      this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [], this[kFactory] = factory;
      for (let upstream of upstreams)
        this.addUpstream(upstream);
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      let upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== !0 && pool2.destroyed !== !0))
        return this;
      let pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool), pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      }), pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]), this._updateBalancedPoolStats();
      }), pool.on("disconnect", (...args) => {
        let err = args[2];
        if (err && err.code === "UND_ERR_SOCKET")
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]), this._updateBalancedPoolStats();
      });
      for (let client of this[kClients])
        client[kWeight] = this[kMaxWeightPerServer];
      return this._updateBalancedPoolStats(), this;
    }
    _updateBalancedPoolStats() {
      this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
    }
    removeUpstream(upstream) {
      let upstreamOrigin = parseOrigin(upstream).origin, pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== !0 && pool2.destroyed !== !0);
      if (pool)
        this[kRemoveClient](pool);
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher) => dispatcher.closed !== !0 && dispatcher.destroyed !== !0).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0)
        throw new BalancedPoolMissingUpstreamError;
      if (!this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== !0 && dispatcher2.destroyed !== !0))
        return;
      if (this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, !0))
        return;
      let counter = 0, maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        let pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain])
          maxWeightIndex = this[kIndex];
        if (this[kIndex] === 0) {
          if (this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor], this[kCurrentWeight] <= 0)
            this[kCurrentWeight] = this[kMaxWeightPerServer];
        }
        if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain])
          return pool;
      }
      return this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight], this[kIndex] = maxWeightIndex, this[kClients][maxWeightIndex];
    }
  }
  module.exports = BalancedPool;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref2 = __commonJS((exports, module) => {
  var { kConnected, kSize } = require_symbols6();

  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
    }
  }

  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher, key) {
      if (dispatcher.on)
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0)
            this.finalizer(key);
        });
    }
  }
  module.exports = function() {
    if (process.env.NODE_V8_COVERAGE)
      return {
        WeakRef: CompatWeakRef,
        FinalizationRegistry: CompatFinalizer
      };
    return {
      WeakRef: global.WeakRef || CompatWeakRef,
      FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
    };
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/agent.js
var require_agent2 = __commonJS((exports, module) => {
  var { InvalidArgumentError } = require_errors4(), { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols6(), DispatcherBase = require_dispatcher_base2(), Pool = require_pool2(), Client = require_client2(), util = require_util14(), createRedirectInterceptor = require_redirectInterceptor2(), { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref2()(), kOnConnect = Symbol("onConnect"), kOnDisconnect = Symbol("onDisconnect"), kOnConnectionError = Symbol("onConnectionError"), kMaxRedirections = Symbol("maxRedirections"), kOnDrain = Symbol("onDrain"), kFactory = Symbol("factory"), kFinalizer = Symbol("finalizer"), kOptions = Symbol("options");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
  }

  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
      super();
      if (typeof factory !== "function")
        throw new InvalidArgumentError("factory must be a function.");
      if (connect != null && typeof connect !== "function" && typeof connect !== "object")
        throw new InvalidArgumentError("connect must be a function or an object");
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0)
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      if (connect && typeof connect !== "function")
        connect = { ...connect };
      this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })], this[kOptions] = { ...util.deepClone(options), connect }, this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0, this[kMaxRedirections] = maxRedirections, this[kFactory] = factory, this[kClients] = /* @__PURE__ */ new Map, this[kFinalizer] = new FinalizationRegistry((key) => {
        let ref = this[kClients].get(key);
        if (ref !== void 0 && ref.deref() === void 0)
          this[kClients].delete(key);
      });
      let agent = this;
      this[kOnDrain] = (origin, targets) => {
        agent.emit("drain", origin, [agent, ...targets]);
      }, this[kOnConnect] = (origin, targets) => {
        agent.emit("connect", origin, [agent, ...targets]);
      }, this[kOnDisconnect] = (origin, targets, err) => {
        agent.emit("disconnect", origin, [agent, ...targets], err);
      }, this[kOnConnectionError] = (origin, targets, err) => {
        agent.emit("connectionError", origin, [agent, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (let ref of this[kClients].values()) {
        let client = ref.deref();
        if (client)
          ret += client[kRunning];
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL))
        key = String(opts.origin);
      else
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      let ref = this[kClients].get(key), dispatcher = ref ? ref.deref() : null;
      if (!dispatcher)
        dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]), this[kClients].set(key, new WeakRef2(dispatcher)), this[kFinalizer].register(dispatcher, key);
      return dispatcher.dispatch(opts, handler);
    }
    async[kClose]() {
      let closePromises = [];
      for (let ref of this[kClients].values()) {
        let client = ref.deref();
        if (client)
          closePromises.push(client.close());
      }
      await Promise.all(closePromises);
    }
    async[kDestroy](err) {
      let destroyPromises = [];
      for (let ref of this[kClients].values()) {
        let client = ref.deref();
        if (client)
          destroyPromises.push(client.destroy(err));
      }
      await Promise.all(destroyPromises);
    }
  }
  module.exports = Agent;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/api/readable.js
var require_readable4 = __commonJS((exports, module) => {
  var assert = __require("assert"), { Readable } = __require("stream"), { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors4(), util = require_util14(), { ReadableStreamFrom, toUSVString } = require_util14(), Blob2, kConsume = Symbol("kConsume"), kReading = Symbol("kReading"), kBody = Symbol("kBody"), kAbort = Symbol("abort"), kContentType = Symbol("kContentType"), noop = () => {};
  module.exports = class extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      highWaterMark = 65536
    }) {
      super({
        autoDestroy: !0,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = !1, this[kAbort] = abort, this[kConsume] = null, this[kBody] = null, this[kContentType] = contentType, this[kReading] = !1;
    }
    destroy(err) {
      if (this.destroyed)
        return this;
      if (!err && !this._readableState.endEmitted)
        err = new RequestAbortedError;
      if (err)
        this[kAbort]();
      return super.destroy(err);
    }
    emit(ev, ...args) {
      if (ev === "data")
        this._readableState.dataEmitted = !0;
      else if (ev === "error")
        this._readableState.errorEmitted = !0;
      return super.emit(ev, ...args);
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable")
        this[kReading] = !0;
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      let ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable")
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null && this.readableLength === 0)
        return consumePush(this[kConsume], chunk), this[kReading] ? super.push(chunk) : !0;
      return super.push(chunk);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util.isDisturbed(this);
    }
    get body() {
      if (!this[kBody]) {
        if (this[kBody] = ReadableStreamFrom(this), this[kConsume])
          this[kBody].getReader(), assert(this[kBody].locked);
      }
      return this[kBody];
    }
    dump(opts) {
      let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144, signal = opts && opts.signal;
      if (signal)
        try {
          if (typeof signal !== "object" || !("aborted" in signal))
            throw new InvalidArgumentError("signal must be an AbortSignal");
          util.throwIfAborted(signal);
        } catch (err) {
          return Promise.reject(err);
        }
      if (this.closed)
        return Promise.resolve(null);
      return new Promise((resolve, reject) => {
        let signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
          this.destroy();
        }) : noop;
        this.on("close", function() {
          if (signalListenerCleanup(), signal && signal.aborted)
            reject(signal.reason || Object.assign(Error("The operation was aborted"), { name: "AbortError" }));
          else
            resolve(null);
        }).on("error", noop).on("data", function(chunk) {
          if (limit -= chunk.length, limit <= 0)
            this.destroy();
        }).resume();
      });
    }
  };
  function isLocked(self2) {
    return self2[kBody] && self2[kBody].locked === !0 || self2[kConsume];
  }
  function isUnusable(self2) {
    return util.isDisturbed(self2) || isLocked(self2);
  }
  async function consume(stream, type) {
    if (isUnusable(stream))
      throw TypeError("unusable");
    return assert(!stream[kConsume]), new Promise((resolve, reject) => {
      stream[kConsume] = {
        type,
        stream,
        resolve,
        reject,
        length: 0,
        body: []
      }, stream.on("error", function(err) {
        consumeFinish(this[kConsume], err);
      }).on("close", function() {
        if (this[kConsume].body !== null)
          consumeFinish(this[kConsume], new RequestAbortedError);
      }), process.nextTick(consumeStart, stream[kConsume]);
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null)
      return;
    let { _readableState: state } = consume2.stream;
    for (let chunk of state.buffer)
      consumePush(consume2, chunk);
    if (state.endEmitted)
      consumeEnd(this[kConsume]);
    else
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    consume2.stream.resume();
    while (consume2.stream.read() != null)
      ;
  }
  function consumeEnd(consume2) {
    let { type, body, resolve, stream, length } = consume2;
    try {
      if (type === "text")
        resolve(toUSVString(Buffer.concat(body)));
      else if (type === "json")
        resolve(JSON.parse(Buffer.concat(body)));
      else if (type === "arrayBuffer") {
        let dst = new Uint8Array(length), pos = 0;
        for (let buf of body)
          dst.set(buf, pos), pos += buf.byteLength;
        resolve(dst.buffer);
      } else if (type === "blob") {
        if (!Blob2)
          Blob2 = __require("buffer").Blob;
        resolve(new Blob2(body, { type: stream[kContentType] }));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  }
  function consumePush(consume2, chunk) {
    consume2.length += chunk.length, consume2.body.push(chunk);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null)
      return;
    if (err)
      consume2.reject(err);
    else
      consume2.resolve();
    consume2.type = null, consume2.stream = null, consume2.resolve = null, consume2.reject = null, consume2.length = 0, consume2.body = null;
  }
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/api/util.js
var require_util16 = __commonJS((exports, module) => {
  var assert = __require("assert"), {
    ResponseStatusCodeError
  } = require_errors4(), { toUSVString } = require_util14();
  async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
    assert(body);
    let chunks = [], limit = 0;
    for await (let chunk of body)
      if (chunks.push(chunk), limit += chunk.length, limit > 131072) {
        chunks = null;
        break;
      }
    if (statusCode === 204 || !contentType || !chunks) {
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
      return;
    }
    try {
      if (contentType.startsWith("application/json")) {
        let payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
      if (contentType.startsWith("text/")) {
        let payload = toUSVString(Buffer.concat(chunks));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
    } catch (err) {}
    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
  }
  module.exports = { getResolveErrorBodyCallback };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/api/abort-signal.js
var require_abort_signal2 = __commonJS((exports, module) => {
  var { addAbortListener } = require_util14(), { RequestAbortedError } = require_errors4(), kListener = Symbol("kListener"), kSignal = Symbol("kSignal");
  function abort(self2) {
    if (self2.abort)
      self2.abort();
    else
      self2.onError(new RequestAbortedError);
  }
  function addSignal(self2, signal) {
    if (self2[kSignal] = null, self2[kListener] = null, !signal)
      return;
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal, self2[kListener] = () => {
      abort(self2);
    }, addAbortListener(self2[kSignal], self2[kListener]);
  }
  function removeSignal(self2) {
    if (!self2[kSignal])
      return;
    if ("removeEventListener" in self2[kSignal])
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    else
      self2[kSignal].removeListener("abort", self2[kListener]);
    self2[kSignal] = null, self2[kListener] = null;
  }
  module.exports = {
    addSignal,
    removeSignal
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/api/api-request.js
var require_api_request2 = __commonJS((exports, module) => {
  var Readable = require_readable4(), {
    InvalidArgumentError,
    RequestAbortedError
  } = require_errors4(), util = require_util14(), { getResolveErrorBodyCallback } = require_util16(), { AsyncResource } = __require("async_hooks"), { addSignal, removeSignal } = require_abort_signal2();

  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      let { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function")
          throw new InvalidArgumentError("invalid callback");
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0))
          throw new InvalidArgumentError("invalid highWaterMark");
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        if (method === "CONNECT")
          throw new InvalidArgumentError("invalid method");
        if (onInfo && typeof onInfo !== "function")
          throw new InvalidArgumentError("invalid onInfo callback");
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body))
          util.destroy(body.on("error", util.nop), err);
        throw err;
      }
      if (this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.callback = callback, this.res = null, this.abort = null, this.body = body, this.trailers = {}, this.context = null, this.onInfo = onInfo || null, this.throwOnError = throwOnError, this.highWaterMark = highWaterMark, util.isStream(body))
        body.on("error", (err) => {
          this.onError(err);
        });
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback)
        throw new RequestAbortedError;
      this.abort = abort, this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      let { callback, opaque, abort, context, responseHeaders, highWaterMark } = this, headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo)
          this.onInfo({ statusCode, headers });
        return;
      }
      let contentType = (responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers)["content-type"], body = new Readable({ resume, abort, contentType, highWaterMark });
      if (this.callback = null, this.res = body, callback !== null)
        if (this.throwOnError && statusCode >= 400)
          this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body, contentType, statusCode, statusMessage, headers });
        else
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body,
            context
          });
    }
    onData(chunk) {
      let { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      let { res } = this;
      removeSignal(this), util.parseHeaders(trailers, this.trailers), res.push(null);
    }
    onError(err) {
      let { res, callback, body, opaque } = this;
      if (removeSignal(this), callback)
        this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      if (res)
        this.res = null, queueMicrotask(() => {
          util.destroy(res, err);
        });
      if (body)
        this.body = null, util.destroy(body, err);
    }
  }
  function request(opts, callback) {
    if (callback === void 0)
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function")
        throw err;
      let opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = request;
  module.exports.RequestHandler = RequestHandler;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/api/api-stream.js
var require_api_stream2 = __commonJS((exports, module) => {
  var { finished, PassThrough } = __require("stream"), {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors4(), util = require_util14(), { getResolveErrorBodyCallback } = require_util16(), { AsyncResource } = __require("async_hooks"), { addSignal, removeSignal } = require_abort_signal2();

  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      let { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function")
          throw new InvalidArgumentError("invalid callback");
        if (typeof factory !== "function")
          throw new InvalidArgumentError("invalid factory");
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        if (method === "CONNECT")
          throw new InvalidArgumentError("invalid method");
        if (onInfo && typeof onInfo !== "function")
          throw new InvalidArgumentError("invalid onInfo callback");
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body))
          util.destroy(body.on("error", util.nop), err);
        throw err;
      }
      if (this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.factory = factory, this.callback = callback, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = body, this.onInfo = onInfo || null, this.throwOnError = throwOnError || !1, util.isStream(body))
        body.on("error", (err) => {
          this.onError(err);
        });
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback)
        throw new RequestAbortedError;
      this.abort = abort, this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      let { factory, opaque, context, callback, responseHeaders } = this, headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo)
          this.onInfo({ statusCode, headers });
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        let contentType = (responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers)["content-type"];
        res = new PassThrough, this.callback = null, this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
      } else {
        if (factory === null)
          return;
        if (res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        }), !res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function")
          throw new InvalidReturnValueError("expected Writable");
        finished(res, { readable: !1 }, (err) => {
          let { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          if (this.res = null, err || !res2.readable)
            util.destroy(res2, err);
          if (this.callback = null, this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers }), err)
            abort();
        });
      }
      return res.on("drain", resume), this.res = res, (res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain) !== !0;
    }
    onData(chunk) {
      let { res } = this;
      return res ? res.write(chunk) : !0;
    }
    onComplete(trailers) {
      let { res } = this;
      if (removeSignal(this), !res)
        return;
      this.trailers = util.parseHeaders(trailers), res.end();
    }
    onError(err) {
      let { res, callback, opaque, body } = this;
      if (removeSignal(this), this.factory = null, res)
        this.res = null, util.destroy(res, err);
      else if (callback)
        this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      if (body)
        this.body = null, util.destroy(body, err);
    }
  }
  function stream(opts, factory, callback) {
    if (callback === void 0)
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function")
        throw err;
      let opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = stream;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline2 = __commonJS((exports, module) => {
  var {
    Readable,
    Duplex,
    PassThrough
  } = __require("stream"), {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors4(), util = require_util14(), { AsyncResource } = __require("async_hooks"), { addSignal, removeSignal } = require_abort_signal2(), assert = __require("assert"), kResume = Symbol("resume");

  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: !0 });
      this[kResume] = null;
    }
    _read() {
      let { [kResume]: resume } = this;
      if (resume)
        this[kResume] = null, resume();
    }
    _destroy(err, callback) {
      this._read(), callback(err);
    }
  }

  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: !0 });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted)
        err = new RequestAbortedError;
      callback(err);
    }
  }

  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      if (typeof handler !== "function")
        throw new InvalidArgumentError("invalid handler");
      let { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      if (method === "CONNECT")
        throw new InvalidArgumentError("invalid method");
      if (onInfo && typeof onInfo !== "function")
        throw new InvalidArgumentError("invalid onInfo callback");
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null, this.responseHeaders = responseHeaders || null, this.handler = handler, this.abort = null, this.context = null, this.onInfo = onInfo || null, this.req = new PipelineRequest().on("error", util.nop), this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: !0,
        read: () => {
          let { body } = this;
          if (body && body.resume)
            body.resume();
        },
        write: (chunk, encoding, callback) => {
          let { req } = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed)
            callback();
          else
            req[kResume] = callback;
        },
        destroy: (err, callback) => {
          let { body, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted)
            err = new RequestAbortedError;
          if (abort && err)
            abort();
          util.destroy(body, err), util.destroy(req, err), util.destroy(res, err), removeSignal(this), callback(err);
        }
      }).on("prefinish", () => {
        let { req } = this;
        req.push(null);
      }), this.res = null, addSignal(this, signal);
    }
    onConnect(abort, context) {
      let { ret, res } = this;
      if (assert(!res, "pipeline cannot be retried"), ret.destroyed)
        throw new RequestAbortedError;
      this.abort = abort, this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      let { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        throw this.res.on("error", util.nop), err;
      }
      if (!body || typeof body.on !== "function")
        throw new InvalidReturnValueError("expected Readable");
      body.on("data", (chunk) => {
        let { ret, body: body2 } = this;
        if (!ret.push(chunk) && body2.pause)
          body2.pause();
      }).on("error", (err) => {
        let { ret } = this;
        util.destroy(ret, err);
      }).on("end", () => {
        let { ret } = this;
        ret.push(null);
      }).on("close", () => {
        let { ret } = this;
        if (!ret._readableState.ended)
          util.destroy(ret, new RequestAbortedError);
      }), this.body = body;
    }
    onData(chunk) {
      let { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      let { res } = this;
      res.push(null);
    }
    onError(err) {
      let { ret } = this;
      this.handler = null, util.destroy(ret, err);
    }
  }
  function pipeline(opts, handler) {
    try {
      let pipelineHandler = new PipelineHandler(opts, handler);
      return this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler), pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  module.exports = pipeline;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade2 = __commonJS((exports, module) => {
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors4(), { AsyncResource } = __require("async_hooks"), util = require_util14(), { addSignal, removeSignal } = require_abort_signal2(), assert = __require("assert");

  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      if (typeof callback !== "function")
        throw new InvalidArgumentError("invalid callback");
      let { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null, this.opaque = opaque || null, this.callback = callback, this.abort = null, this.context = null, addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback)
        throw new RequestAbortedError;
      this.abort = abort, this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      let { callback, opaque, context } = this;
      assert.strictEqual(statusCode, 101), removeSignal(this), this.callback = null;
      let headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      let { callback, opaque } = this;
      if (removeSignal(this), callback)
        this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
    }
  }
  function upgrade(opts, callback) {
    if (callback === void 0)
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    try {
      let upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function")
        throw err;
      let opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = upgrade;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/api/api-connect.js
var require_api_connect2 = __commonJS((exports, module) => {
  var { AsyncResource } = __require("async_hooks"), { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors4(), util = require_util14(), { addSignal, removeSignal } = require_abort_signal2();

  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      if (typeof callback !== "function")
        throw new InvalidArgumentError("invalid callback");
      let { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function")
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      super("UNDICI_CONNECT");
      this.opaque = opaque || null, this.responseHeaders = responseHeaders || null, this.callback = callback, this.abort = null, addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback)
        throw new RequestAbortedError;
      this.abort = abort, this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      let { callback, opaque, context } = this;
      removeSignal(this), this.callback = null;
      let headers = rawHeaders;
      if (headers != null)
        headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      let { callback, opaque } = this;
      if (removeSignal(this), callback)
        this.callback = null, queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
    }
  }
  function connect(opts, callback) {
    if (callback === void 0)
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    try {
      let connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function")
        throw err;
      let opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  module.exports = connect;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/api/index.js
var require_api2 = __commonJS((exports, module) => {
  exports.request = require_api_request2();
  exports.stream = require_api_stream2();
  exports.pipeline = require_api_pipeline2();
  exports.upgrade = require_api_upgrade2();
  exports.connect = require_api_connect2();
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors2 = __commonJS((exports, module) => {
  var { UndiciError } = require_errors4();

  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, MockNotMatchedError), this.name = "MockNotMatchedError", this.message = message || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  module.exports = {
    MockNotMatchedError
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols2 = __commonJS((exports, module) => {
  module.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils2 = __commonJS((exports, module) => {
  var { MockNotMatchedError } = require_mock_errors2(), {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = require_mock_symbols2(), { buildURL, nop } = require_util14(), { STATUS_CODES } = __require("http"), {
    types: {
      isPromise
    }
  } = __require("util");
  function matchValue(match, value) {
    if (typeof match === "string")
      return match === value;
    if (match instanceof RegExp)
      return match.test(value);
    if (typeof match === "function")
      return match(value) === !0;
    return !1;
  }
  function lowerCaseEntries(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    }));
  }
  function getHeaderByName(headers, key) {
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2)
        if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase())
          return headers[i + 1];
      return;
    } else if (typeof headers.get === "function")
      return headers.get(key);
    else
      return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
  }
  function buildHeadersFromArray(headers) {
    let clone = headers.slice(), entries = [];
    for (let index = 0;index < clone.length; index += 2)
      entries.push([clone[index], clone[index + 1]]);
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers))
        headers = buildHeadersFromArray(headers);
      return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
    }
    if (typeof mockDispatch2.headers > "u")
      return !0;
    if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object")
      return !1;
    for (let [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      let headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue))
        return !1;
    }
    return !0;
  }
  function safeUrl(path) {
    if (typeof path !== "string")
      return path;
    let pathSegments = path.split("?");
    if (pathSegments.length !== 2)
      return path;
    let qp = new URLSearchParams(pathSegments.pop());
    return qp.sort(), [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path, method, body, headers }) {
    let pathMatch = matchValue(mockDispatch2.path, path), methodMatch = matchValue(mockDispatch2.method, method), bodyMatch = typeof mockDispatch2.body < "u" ? matchValue(mockDispatch2.body, body) : !0, headersMatch = matchHeaders(mockDispatch2, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data) {
    if (Buffer.isBuffer(data))
      return data;
    else if (typeof data === "object")
      return JSON.stringify(data);
    else
      return data.toString();
  }
  function getMockDispatch(mockDispatches, key) {
    let basePath = key.query ? buildURL(key.path, key.query) : key.path, resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath, matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
    if (matchedMockDispatches.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    if (matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method)), matchedMockDispatches.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
    if (matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body < "u" ? matchValue(body, key.body) : !0), matchedMockDispatches.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
    if (matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers)), matchedMockDispatches.length === 0)
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data) {
    let baseData = { timesInvoked: 0, times: 1, persist: !1, consumed: !1 }, replyData = typeof data === "function" ? { callback: data } : { ...data }, newMockDispatch = { ...baseData, ...key, pending: !0, data: { error: null, ...replyData } };
    return mockDispatches.push(newMockDispatch), newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    let index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed)
        return !1;
      return matchKey(dispatch, key);
    });
    if (index !== -1)
      mockDispatches.splice(index, 1);
  }
  function buildKey(opts) {
    let { path, method, body, headers, query } = opts;
    return {
      path,
      method,
      body,
      headers,
      query
    };
  }
  function generateKeyValues(data) {
    return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
      ...keyValuePairs,
      Buffer.from(`${key}`),
      Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
    ], []);
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body) {
    let buffers = [];
    for await (let data of body)
      buffers.push(data);
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler) {
    let key = buildKey(opts), mockDispatch2 = getMockDispatch(this[kDispatches], key);
    if (mockDispatch2.timesInvoked++, mockDispatch2.data.callback)
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    let { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2, { timesInvoked, times } = mockDispatch2;
    if (mockDispatch2.consumed = !persist && timesInvoked >= times, mockDispatch2.pending = timesInvoked < times, error !== null)
      return deleteMockDispatch(this[kDispatches], key), handler.onError(error), !0;
    if (typeof delay === "number" && delay > 0)
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    else
      handleReply(this[kDispatches]);
    function handleReply(mockDispatches, _data = data) {
      let optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers, body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body)) {
        body.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      let responseData = getResponseData(body), responseHeaders = generateKeyValues(headers), responseTrailers = generateKeyValues(trailers);
      handler.abort = nop, handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode)), handler.onData(Buffer.from(responseData)), handler.onComplete(responseTrailers), deleteMockDispatch(mockDispatches, key);
    }
    function resume() {}
    return !0;
  }
  function buildMockDispatch() {
    let agent = this[kMockAgent], origin = this[kOrigin], originalDispatch = this[kOriginalDispatch];
    return function(opts, handler) {
      if (agent.isMockActive)
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error) {
          if (error instanceof MockNotMatchedError) {
            let netConnect = agent[kGetNetConnect]();
            if (netConnect === !1)
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            if (checkNetConnect(netConnect, origin))
              originalDispatch.call(this, opts, handler);
            else
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
          } else
            throw error;
        }
      else
        originalDispatch.call(this, opts, handler);
    };
  }
  function checkNetConnect(netConnect, origin) {
    let url = new URL(origin);
    if (netConnect === !0)
      return !0;
    else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host)))
      return !0;
    return !1;
  }
  function buildMockOptions(opts) {
    if (opts) {
      let { agent, ...mockOptions } = opts;
      return mockOptions;
    }
  }
  module.exports = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor2 = __commonJS((exports, module) => {
  var { getResponseData, buildKey, addMockDispatch } = require_mock_utils2(), {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = require_mock_symbols2(), { InvalidArgumentError } = require_errors4(), { buildURL } = require_util14();

  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0)
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      return this[kMockDispatch].delay = waitInMs, this;
    }
    persist() {
      return this[kMockDispatch].persist = !0, this;
    }
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0)
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      return this[kMockDispatch].times = repeatTimes, this;
    }
  }

  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object")
        throw new InvalidArgumentError("opts must be an object");
      if (typeof opts.path > "u")
        throw new InvalidArgumentError("opts.path must be defined");
      if (typeof opts.method > "u")
        opts.method = "GET";
      if (typeof opts.path === "string")
        if (opts.query)
          opts.path = buildURL(opts.path, opts.query);
        else {
          let parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      if (typeof opts.method === "string")
        opts.method = opts.method.toUpperCase();
      this[kDispatchKey] = buildKey(opts), this[kDispatches] = mockDispatches, this[kDefaultHeaders] = {}, this[kDefaultTrailers] = {}, this[kContentLength] = !1;
    }
    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
      let responseData = getResponseData(data), contentLength = this[kContentLength] ? { "content-length": responseData.length } : {}, headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }, trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers, trailers };
    }
    validateReplyParameters(statusCode, data, responseOptions) {
      if (typeof statusCode > "u")
        throw new InvalidArgumentError("statusCode must be defined");
      if (typeof data > "u")
        throw new InvalidArgumentError("data must be defined");
      if (typeof responseOptions !== "object")
        throw new InvalidArgumentError("responseOptions must be an object");
    }
    reply(replyData) {
      if (typeof replyData === "function") {
        let wrappedDefaultsCallback = (opts) => {
          let resolvedData = replyData(opts);
          if (typeof resolvedData !== "object")
            throw new InvalidArgumentError("reply options callback must return an object");
          let { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
          return this.validateReplyParameters(statusCode2, data2, responseOptions2), {
            ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
          };
        }, newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      let [statusCode, data = "", responseOptions = {}] = [...arguments];
      this.validateReplyParameters(statusCode, data, responseOptions);
      let dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions), newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    replyWithError(error) {
      if (typeof error > "u")
        throw new InvalidArgumentError("error must be defined");
      let newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
      return new MockScope(newMockDispatch);
    }
    defaultReplyHeaders(headers) {
      if (typeof headers > "u")
        throw new InvalidArgumentError("headers must be defined");
      return this[kDefaultHeaders] = headers, this;
    }
    defaultReplyTrailers(trailers) {
      if (typeof trailers > "u")
        throw new InvalidArgumentError("trailers must be defined");
      return this[kDefaultTrailers] = trailers, this;
    }
    replyContentLength() {
      return this[kContentLength] = !0, this;
    }
  }
  exports.MockInterceptor = MockInterceptor;
  exports.MockScope = MockScope;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/mock/mock-client.js
var require_mock_client2 = __commonJS((exports, module) => {
  var { promisify } = __require("util"), Client = require_client2(), { buildMockDispatch } = require_mock_utils2(), {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols2(), { MockInterceptor } = require_mock_interceptor2(), Symbols = require_symbols6(), { InvalidArgumentError } = require_errors4();

  class MockClient extends Client {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function")
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      this[kMockAgent] = opts.agent, this[kOrigin] = origin, this[kDispatches] = [], this[kConnected] = 1, this[kOriginalDispatch] = this.dispatch, this[kOriginalClose] = this.close.bind(this), this.dispatch = buildMockDispatch.call(this), this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])(), this[kConnected] = 0, this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockClient;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool2 = __commonJS((exports, module) => {
  var { promisify } = __require("util"), Pool = require_pool2(), { buildMockDispatch } = require_mock_utils2(), {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols2(), { MockInterceptor } = require_mock_interceptor2(), Symbols = require_symbols6(), { InvalidArgumentError } = require_errors4();

  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function")
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      this[kMockAgent] = opts.agent, this[kOrigin] = origin, this[kDispatches] = [], this[kConnected] = 1, this[kOriginalDispatch] = this.dispatch, this[kOriginalClose] = this.close.bind(this), this.dispatch = buildMockDispatch.call(this), this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])(), this[kConnected] = 0, this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockPool;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer2 = __commonJS((exports, module) => {
  var singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  }, plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  module.exports = class {
    constructor(singular, plural) {
      this.singular = singular, this.plural = plural;
    }
    pluralize(count) {
      let one = count === 1, keys = one ? singulars : plurals, noun = one ? this.singular : this.plural;
      return { ...keys, count, noun };
    }
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter2 = __commonJS((exports, module) => {
  var { Transform } = __require("stream"), { Console } = __require("console");
  module.exports = class {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      }), this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      let withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        "Status code": statusCode,
        Persistent: persist ? "" : "",
        Invocations: timesInvoked,
        Remaining: persist ? 1 / 0 : times - timesInvoked
      }));
      return this.logger.table(withPrettyHeaders), this.transform.read().toString();
    }
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent2 = __commonJS((exports, module) => {
  var { kClients } = require_symbols6(), Agent = require_agent2(), {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = require_mock_symbols2(), MockClient = require_mock_client2(), MockPool = require_mock_pool2(), { matchValue, buildMockOptions } = require_mock_utils2(), { InvalidArgumentError, UndiciError } = require_errors4(), Dispatcher = require_dispatcher2(), Pluralizer = require_pluralizer2(), PendingInterceptorsFormatter = require_pending_interceptors_formatter2();

  class FakeWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  }

  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      if (this[kNetConnect] = !0, this[kIsMockActive] = !0, opts && opts.agent && typeof opts.agent.dispatch !== "function")
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      let agent = opts && opts.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent, this[kClients] = agent[kClients], this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher = this[kMockAgentGet](origin);
      if (!dispatcher)
        dispatcher = this[kFactory](origin), this[kMockAgentSet](origin, dispatcher);
      return dispatcher;
    }
    dispatch(opts, handler) {
      return this.get(opts.origin), this[kAgent].dispatch(opts, handler);
    }
    async close() {
      await this[kAgent].close(), this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = !1;
    }
    activate() {
      this[kIsMockActive] = !0;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp)
        if (Array.isArray(this[kNetConnect]))
          this[kNetConnect].push(matcher);
        else
          this[kNetConnect] = [matcher];
      else if (typeof matcher > "u")
        this[kNetConnect] = !0;
      else
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
    }
    disableNetConnect() {
      this[kNetConnect] = !1;
    }
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher) {
      this[kClients].set(origin, new FakeWeakRef(dispatcher));
    }
    [kFactory](origin) {
      let mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      let ref = this[kClients].get(origin);
      if (ref)
        return ref.deref();
      if (typeof origin !== "string") {
        let dispatcher = this[kFactory]("http://localhost:9999");
        return this[kMockAgentSet](origin, dispatcher), dispatcher;
      }
      for (let [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
        let nonExplicitDispatcher = nonExplicitRef.deref();
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          let dispatcher = this[kFactory](origin);
          return this[kMockAgentSet](origin, dispatcher), dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches], dispatcher;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      let mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter } = {}) {
      let pending = this.pendingInterceptors();
      if (pending.length === 0)
        return;
      let pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
    }
  }
  module.exports = MockAgent;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/proxy-agent.js
var require_proxy_agent2 = __commonJS((exports, module) => {
  var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols6(), { URL: URL2 } = __require("url"), Agent = require_agent2(), Pool = require_pool2(), DispatcherBase = require_dispatcher_base2(), { InvalidArgumentError, RequestAbortedError } = require_errors4(), buildConnector = require_connect2(), kAgent = Symbol("proxy agent"), kClient = Symbol("proxy client"), kProxyHeaders = Symbol("proxy headers"), kRequestTls = Symbol("request tls settings"), kProxyTls = Symbol("proxy tls settings"), kConnectEndpoint = Symbol("connect endpoint function");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function buildProxyOptions(opts) {
    if (typeof opts === "string")
      opts = { uri: opts };
    if (!opts || !opts.uri)
      throw new InvalidArgumentError("Proxy opts.uri is mandatory");
    return {
      uri: opts.uri,
      protocol: opts.protocol || "https"
    };
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }

  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super(opts);
      if (this[kProxy] = buildProxyOptions(opts), this[kAgent] = new Agent(opts), this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [], typeof opts === "string")
        opts = { uri: opts };
      if (!opts || !opts.uri)
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      let { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function")
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      this[kRequestTls] = opts.requestTls, this[kProxyTls] = opts.proxyTls, this[kProxyHeaders] = opts.headers || {};
      let resolvedUrl = new URL2(opts.uri), { origin, port, host, username, password } = resolvedUrl;
      if (opts.auth && opts.token)
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      else if (opts.auth)
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      else if (opts.token)
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      else if (username && password)
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      let connect = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls }), this[kClient] = clientFactory(resolvedUrl, { connect }), this[kAgent] = new Agent({
        ...opts,
        connect: async (opts2, callback) => {
          let requestedHost = opts2.host;
          if (!opts2.port)
            requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
          try {
            let { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedHost,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host
              }
            });
            if (statusCode !== 200)
              socket.on("error", () => {}).destroy(), callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls])
              servername = this[kRequestTls].servername;
            else
              servername = opts2.servername;
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            callback(err);
          }
        }
      });
    }
    dispatch(opts, handler) {
      let { host } = new URL2(opts.origin), headers = buildHeaders(opts.headers);
      return throwIfProxyAuthIsSent(headers), this[kAgent].dispatch({
        ...opts,
        headers: {
          ...headers,
          host
        }
      }, handler);
    }
    async[kClose]() {
      await this[kAgent].close(), await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy(), await this[kClient].destroy();
    }
  }
  function buildHeaders(headers) {
    if (Array.isArray(headers)) {
      let headersPair = {};
      for (let i = 0;i < headers.length; i += 2)
        headersPair[headers[i]] = headers[i + 1];
      return headersPair;
    }
    return headers;
  }
  function throwIfProxyAuthIsSent(headers) {
    if (headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization"))
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
  }
  module.exports = ProxyAgent;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler2 = __commonJS((exports, module) => {
  var assert = __require("assert"), { kRetryHandlerDefaultRetry } = require_symbols6(), { RequestRetryError } = require_errors4(), { isDisturbed, parseHeaders, parseRangeHeader } = require_util14();
  function calculateRetryAfterHeader(retryAfter) {
    let current = Date.now();
    return new Date(retryAfter).getTime() - current;
  }

  class RetryHandler {
    constructor(opts, handlers) {
      let { retryOptions, ...dispatchOpts } = opts, {
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        methods,
        errorCodes,
        retryAfter,
        statusCodes
      } = retryOptions ?? {};
      this.dispatch = handlers.dispatch, this.handler = handlers.handler, this.opts = dispatchOpts, this.abort = null, this.aborted = !1, this.retryOpts = {
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? !0,
        maxTimeout: maxTimeout ?? 30000,
        timeout: minTimeout ?? 500,
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE"
        ]
      }, this.retryCount = 0, this.start = 0, this.end = null, this.etag = null, this.resume = null, this.handler.onConnect((reason) => {
        if (this.aborted = !0, this.abort)
          this.abort(reason);
        else
          this.reason = reason;
      });
    }
    onRequestSent() {
      if (this.handler.onRequestSent)
        this.handler.onRequestSent();
    }
    onUpgrade(statusCode, headers, socket) {
      if (this.handler.onUpgrade)
        this.handler.onUpgrade(statusCode, headers, socket);
    }
    onConnect(abort) {
      if (this.aborted)
        abort(this.reason);
      else
        this.abort = abort;
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent)
        return this.handler.onBodySent(chunk);
    }
    static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
      let { statusCode, code, headers } = err, { method, retryOptions } = opts, {
        maxRetries,
        timeout,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods
      } = retryOptions, { counter, currentTimeout } = state;
      if (currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout, code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers != null && headers["retry-after"];
      if (retryAfterHeader)
        retryAfterHeader = Number(retryAfterHeader), retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1000;
      let retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
      state.currentTimeout = retryTimeout, setTimeout(() => cb(null), retryTimeout);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      let headers = parseHeaders(rawHeaders);
      if (this.retryCount += 1, statusCode >= 300)
        return this.abort(new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        })), !1;
      if (this.resume != null) {
        if (this.resume = null, statusCode !== 206)
          return !0;
        let contentRange = parseRangeHeader(headers["content-range"]);
        if (!contentRange)
          return this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
            headers,
            count: this.retryCount
          })), !1;
        if (this.etag != null && this.etag !== headers.etag)
          return this.abort(new RequestRetryError("ETag mismatch", statusCode, {
            headers,
            count: this.retryCount
          })), !1;
        let { start, size, end = size } = contentRange;
        return assert(this.start === start, "content-range mismatch"), assert(this.end == null || this.end === end, "content-range mismatch"), this.resume = resume, !0;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          let range = parseRangeHeader(headers["content-range"]);
          if (range == null)
            return this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
          let { start, size, end = size } = range;
          assert(start != null && Number.isFinite(start) && this.start !== start, "content-range mismatch"), assert(Number.isFinite(start)), assert(end != null && Number.isFinite(end) && this.end !== end, "invalid content-length"), this.start = start, this.end = end;
        }
        if (this.end == null) {
          let contentLength = headers["content-length"];
          this.end = contentLength != null ? Number(contentLength) : null;
        }
        return assert(Number.isFinite(this.start)), assert(this.end == null || Number.isFinite(this.end), "invalid content-length"), this.resume = resume, this.etag = headers.etag != null ? headers.etag : null, this.handler.onHeaders(statusCode, rawHeaders, resume, statusMessage);
      }
      let err = new RequestRetryError("Request failed", statusCode, {
        headers,
        count: this.retryCount
      });
      return this.abort(err), !1;
    }
    onData(chunk) {
      return this.start += chunk.length, this.handler.onData(chunk);
    }
    onComplete(rawTrailers) {
      return this.retryCount = 0, this.handler.onComplete(rawTrailers);
    }
    onError(err) {
      if (this.aborted || isDisturbed(this.opts.body))
        return this.handler.onError(err);
      this.retryOpts.retry(err, {
        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      }, onRetry.bind(this));
      function onRetry(err2) {
        if (err2 != null || this.aborted || isDisturbed(this.opts.body))
          return this.handler.onError(err2);
        if (this.start !== 0)
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              range: `bytes=${this.start}-${this.end ?? ""}`
            }
          };
        try {
          this.dispatch(this.opts, this);
        } catch (err3) {
          this.handler.onError(err3);
        }
      }
    }
  }
  module.exports = RetryHandler;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/global.js
var require_global4 = __commonJS((exports, module) => {
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError } = require_errors4(), Agent = require_agent2();
  if (getGlobalDispatcher() === void 0)
    setGlobalDispatcher(new Agent);
  function setGlobalDispatcher(agent) {
    if (!agent || typeof agent.dispatch !== "function")
      throw new InvalidArgumentError("Argument agent must implement Agent");
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent,
      writable: !0,
      enumerable: !1,
      configurable: !1
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  module.exports = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler2 = __commonJS((exports, module) => {
  module.exports = class {
    constructor(handler) {
      this.handler = handler;
    }
    onConnect(...args) {
      return this.handler.onConnect(...args);
    }
    onError(...args) {
      return this.handler.onError(...args);
    }
    onUpgrade(...args) {
      return this.handler.onUpgrade(...args);
    }
    onHeaders(...args) {
      return this.handler.onHeaders(...args);
    }
    onData(...args) {
      return this.handler.onData(...args);
    }
    onComplete(...args) {
      return this.handler.onComplete(...args);
    }
    onBodySent(...args) {
      return this.handler.onBodySent(...args);
    }
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/headers.js
var require_headers3 = __commonJS((exports, module) => {
  var { kHeadersList, kConstruct } = require_symbols6(), { kGuard } = require_symbols7(), { kEnumerableProperty } = require_util14(), {
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue
  } = require_util15(), { webidl } = require_webidl2(), assert = __require("assert"), kHeadersMap = Symbol("headers map"), kHeadersSortedMap = Symbol("headers map sorted");
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i = 0, j = potentialValue.length;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1)))
      --j;
    while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i)))
      ++i;
    return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
  }
  function fill(headers, object) {
    if (Array.isArray(object))
      for (let i = 0;i < object.length; ++i) {
        let header = object[i];
        if (header.length !== 2)
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        appendHeader(headers, header[0], header[1]);
      }
    else if (typeof object === "object" && object !== null) {
      let keys = Object.keys(object);
      for (let i = 0;i < keys.length; ++i)
        appendHeader(headers, keys[i], object[keys[i]]);
    } else
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
  }
  function appendHeader(headers, name, value) {
    if (value = headerValueNormalize(value), !isValidHeaderName(name))
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    else if (!isValidHeaderValue(value))
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    if (headers[kGuard] === "immutable")
      throw TypeError("immutable");
    else if (headers[kGuard] === "request-no-cors")
      ;
    return headers[kHeadersList].append(name, value);
  }

  class HeadersList {
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList)
        this[kHeadersMap] = new Map(init[kHeadersMap]), this[kHeadersSortedMap] = init[kHeadersSortedMap], this.cookies = init.cookies === null ? null : [...init.cookies];
      else
        this[kHeadersMap] = new Map(init), this[kHeadersSortedMap] = null;
    }
    contains(name) {
      return name = name.toLowerCase(), this[kHeadersMap].has(name);
    }
    clear() {
      this[kHeadersMap].clear(), this[kHeadersSortedMap] = null, this.cookies = null;
    }
    append(name, value) {
      this[kHeadersSortedMap] = null;
      let lowercaseName = name.toLowerCase(), exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        let delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else
        this[kHeadersMap].set(lowercaseName, { name, value });
      if (lowercaseName === "set-cookie")
        this.cookies ??= [], this.cookies.push(value);
    }
    set(name, value) {
      this[kHeadersSortedMap] = null;
      let lowercaseName = name.toLowerCase();
      if (lowercaseName === "set-cookie")
        this.cookies = [value];
      this[kHeadersMap].set(lowercaseName, { name, value });
    }
    delete(name) {
      if (this[kHeadersSortedMap] = null, name = name.toLowerCase(), name === "set-cookie")
        this.cookies = null;
      this[kHeadersMap].delete(name);
    }
    get(name) {
      let value = this[kHeadersMap].get(name.toLowerCase());
      return value === void 0 ? null : value.value;
    }
    *[Symbol.iterator]() {
      for (let [name, { value }] of this[kHeadersMap])
        yield [name, value];
    }
    get entries() {
      let headers = {};
      if (this[kHeadersMap].size)
        for (let { name, value } of this[kHeadersMap].values())
          headers[name] = value;
      return headers;
    }
  }

  class Headers {
    constructor(init = void 0) {
      if (init === kConstruct)
        return;
      if (this[kHeadersList] = new HeadersList, this[kGuard] = "none", init !== void 0)
        init = webidl.converters.HeadersInit(init), fill(this, init);
    }
    append(name, value) {
      return webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" }), name = webidl.converters.ByteString(name), value = webidl.converters.ByteString(value), appendHeader(this, name, value);
    }
    delete(name) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" }), name = webidl.converters.ByteString(name), !isValidHeaderName(name))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      if (this[kGuard] === "immutable")
        throw TypeError("immutable");
      else if (this[kGuard] === "request-no-cors")
        ;
      if (!this[kHeadersList].contains(name))
        return;
      this[kHeadersList].delete(name);
    }
    get(name) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" }), name = webidl.converters.ByteString(name), !isValidHeaderName(name))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.get",
          value: name,
          type: "header name"
        });
      return this[kHeadersList].get(name);
    }
    has(name) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" }), name = webidl.converters.ByteString(name), !isValidHeaderName(name))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.has",
          value: name,
          type: "header name"
        });
      return this[kHeadersList].contains(name);
    }
    set(name, value) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" }), name = webidl.converters.ByteString(name), value = webidl.converters.ByteString(value), value = headerValueNormalize(value), !isValidHeaderName(name))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value: name,
          type: "header name"
        });
      else if (!isValidHeaderValue(value))
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value,
          type: "header value"
        });
      if (this[kGuard] === "immutable")
        throw TypeError("immutable");
      else if (this[kGuard] === "request-no-cors")
        ;
      this[kHeadersList].set(name, value);
    }
    getSetCookie() {
      webidl.brandCheck(this, Headers);
      let list = this[kHeadersList].cookies;
      if (list)
        return [...list];
      return [];
    }
    get [kHeadersSortedMap]() {
      if (this[kHeadersList][kHeadersSortedMap])
        return this[kHeadersList][kHeadersSortedMap];
      let headers = [], names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1), cookies = this[kHeadersList].cookies;
      for (let i = 0;i < names.length; ++i) {
        let [name, value] = names[i];
        if (name === "set-cookie")
          for (let j = 0;j < cookies.length; ++j)
            headers.push([name, cookies[j]]);
        else
          assert(value !== null), headers.push([name, value]);
      }
      return this[kHeadersList][kHeadersSortedMap] = headers, headers;
    }
    keys() {
      if (webidl.brandCheck(this, Headers), this[kGuard] === "immutable") {
        let value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "key");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
    }
    values() {
      if (webidl.brandCheck(this, Headers), this[kGuard] === "immutable") {
        let value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "value");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
    }
    entries() {
      if (webidl.brandCheck(this, Headers), this[kGuard] === "immutable") {
        let value = this[kHeadersSortedMap];
        return makeIterator(() => value, "Headers", "key+value");
      }
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      if (webidl.brandCheck(this, Headers), webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" }), typeof callbackFn !== "function")
        throw TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
      for (let [key, value] of this)
        callbackFn.apply(thisArg, [value, key, this]);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return webidl.brandCheck(this, Headers), this[kHeadersList];
    }
  }
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    keys: kEnumerableProperty,
    values: kEnumerableProperty,
    entries: kEnumerableProperty,
    forEach: kEnumerableProperty,
    [Symbol.iterator]: { enumerable: !1 },
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: !0
    }
  });
  webidl.converters.HeadersInit = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (V[Symbol.iterator])
        return webidl.converters["sequence<sequence<ByteString>>"](V);
      return webidl.converters["record<ByteString, ByteString>"](V);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill,
    Headers,
    HeadersList
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/response.js
var require_response3 = __commonJS((exports, module) => {
  var { Headers, HeadersList, fill } = require_headers3(), { extractBody, cloneBody, mixinBody } = require_body2(), util = require_util14(), { kEnumerableProperty } = util, {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode
  } = require_util15(), {
    redirectStatusSet,
    nullBodyStatus,
    DOMException: DOMException2
  } = require_constants14(), { kState, kHeaders, kGuard, kRealm } = require_symbols7(), { webidl } = require_webidl2(), { FormData: FormData2 } = require_formdata2(), { getGlobalOrigin } = require_global3(), { URLSerializer } = require_dataURL2(), { kHeadersList, kConstruct } = require_symbols6(), assert = __require("assert"), { types } = __require("util"), ReadableStream2 = globalThis.ReadableStream || __require("stream/web").ReadableStream, textEncoder = new TextEncoder("utf-8");

  class Response {
    static error() {
      let relevantRealm = { settingsObject: {} }, responseObject = new Response;
      return responseObject[kState] = makeNetworkError(), responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList, responseObject[kHeaders][kGuard] = "immutable", responseObject[kHeaders][kRealm] = relevantRealm, responseObject;
    }
    static json(data, init = {}) {
      if (webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" }), init !== null)
        init = webidl.converters.ResponseInit(init);
      let bytes = textEncoder.encode(serializeJavascriptValueToJSONString(data)), body = extractBody(bytes), relevantRealm = { settingsObject: {} }, responseObject = new Response;
      return responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kGuard] = "response", responseObject[kHeaders][kRealm] = relevantRealm, initializeResponse(responseObject, init, { body: body[0], type: "application/json" }), responseObject;
    }
    static redirect(url, status = 302) {
      let relevantRealm = { settingsObject: {} };
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" }), url = webidl.converters.USVString(url), status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, getGlobalOrigin());
      } catch (err) {
        throw Object.assign(TypeError("Failed to parse URL from " + url), {
          cause: err
        });
      }
      if (!redirectStatusSet.has(status))
        throw RangeError("Invalid status code " + status);
      let responseObject = new Response;
      responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kGuard] = "immutable", responseObject[kHeaders][kRealm] = relevantRealm, responseObject[kState].status = status;
      let value = isomorphicEncode(URLSerializer(parsedURL));
      return responseObject[kState].headersList.append("location", value), responseObject;
    }
    constructor(body = null, init = {}) {
      if (body !== null)
        body = webidl.converters.BodyInit(body);
      init = webidl.converters.ResponseInit(init), this[kRealm] = { settingsObject: {} }, this[kState] = makeResponse({}), this[kHeaders] = new Headers(kConstruct), this[kHeaders][kGuard] = "response", this[kHeaders][kHeadersList] = this[kState].headersList, this[kHeaders][kRealm] = this[kRealm];
      let bodyWithType = null;
      if (body != null) {
        let [extractedBody, type] = extractBody(body);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    get type() {
      return webidl.brandCheck(this, Response), this[kState].type;
    }
    get url() {
      webidl.brandCheck(this, Response);
      let urlList = this[kState].urlList, url = urlList[urlList.length - 1] ?? null;
      if (url === null)
        return "";
      return URLSerializer(url, !0);
    }
    get redirected() {
      return webidl.brandCheck(this, Response), this[kState].urlList.length > 1;
    }
    get status() {
      return webidl.brandCheck(this, Response), this[kState].status;
    }
    get ok() {
      return webidl.brandCheck(this, Response), this[kState].status >= 200 && this[kState].status <= 299;
    }
    get statusText() {
      return webidl.brandCheck(this, Response), this[kState].statusText;
    }
    get headers() {
      return webidl.brandCheck(this, Response), this[kHeaders];
    }
    get body() {
      return webidl.brandCheck(this, Response), this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      return webidl.brandCheck(this, Response), !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    clone() {
      if (webidl.brandCheck(this, Response), this.bodyUsed || this.body && this.body.locked)
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      let clonedResponse = cloneResponse(this[kState]), clonedResponseObject = new Response;
      return clonedResponseObject[kState] = clonedResponse, clonedResponseObject[kRealm] = this[kRealm], clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList, clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard], clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm], clonedResponseObject;
    }
  }
  mixinBody(Response);
  Object.defineProperties(Response.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: !0
    }
  });
  Object.defineProperties(Response, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response) {
    if (response.internalResponse)
      return filterResponse(cloneResponse(response.internalResponse), response.type);
    let newResponse = makeResponse({ ...response, body: null });
    if (response.body != null)
      newResponse.body = cloneBody(response.body);
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: !1,
      rangeRequested: !1,
      timingAllowPassed: !1,
      requestIncludesCredentials: !1,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList,
      urlList: init.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    let isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function makeFilteredResponse(response, state) {
    return state = {
      internalResponse: response,
      ...state
    }, new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        return assert(!(p in state)), target[p] = value, !0;
      }
    });
  }
  function filterResponse(response, type) {
    if (type === "basic")
      return makeFilteredResponse(response, {
        type: "basic",
        headersList: response.headersList
      });
    else if (type === "cors")
      return makeFilteredResponse(response, {
        type: "cors",
        headersList: response.headersList
      });
    else if (type === "opaque")
      return makeFilteredResponse(response, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    else if (type === "opaqueredirect")
      return makeFilteredResponse(response, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    else
      assert(!1);
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    return assert(isCancelled(fetchParams)), isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599))
      throw RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText)))
        throw TypeError("Invalid statusText");
    }
    if ("status" in init && init.status != null)
      response[kState].status = init.status;
    if ("statusText" in init && init.statusText != null)
      response[kState].statusText = init.statusText;
    if ("headers" in init && init.headers != null)
      fill(response[kHeaders], init.headers);
    if (body) {
      if (nullBodyStatus.includes(response.status))
        throw webidl.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + response.status
        });
      if (response[kState].body = body.body, body.type != null && !response[kState].headersList.contains("Content-Type"))
        response[kState].headersList.append("content-type", body.type);
    }
  }
  webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream2);
  webidl.converters.FormData = webidl.interfaceConverter(FormData2);
  webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
  webidl.converters.XMLHttpRequestBodyInit = function(V) {
    if (typeof V === "string")
      return webidl.converters.USVString(V);
    if (isBlobLike(V))
      return webidl.converters.Blob(V, { strict: !1 });
    if (types.isArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V))
      return webidl.converters.BufferSource(V);
    if (util.isFormDataLike(V))
      return webidl.converters.FormData(V, { strict: !1 });
    if (V instanceof URLSearchParams)
      return webidl.converters.URLSearchParams(V);
    return webidl.converters.DOMString(V);
  };
  webidl.converters.BodyInit = function(V) {
    if (V instanceof ReadableStream2)
      return webidl.converters.ReadableStream(V);
    if (V?.[Symbol.asyncIterator])
      return V;
    return webidl.converters.XMLHttpRequestBodyInit(V);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  module.exports = {
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response,
    cloneResponse
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/request.js
var require_request4 = __commonJS((exports, module) => {
  var { extractBody, mixinBody, cloneBody } = require_body2(), { Headers, fill: fillHeaders, HeadersList } = require_headers3(), { FinalizationRegistry } = require_dispatcher_weakref2()(), util = require_util14(), {
    isValidHTTPToken,
    sameOrigin,
    normalizeMethod,
    makePolicyContainer,
    normalizeMethodRecord
  } = require_util15(), {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = require_constants14(), { kEnumerableProperty } = util, { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols7(), { webidl } = require_webidl2(), { getGlobalOrigin } = require_global3(), { URLSerializer } = require_dataURL2(), { kHeadersList, kConstruct } = require_symbols6(), assert = __require("assert"), { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events"), TransformStream = globalThis.TransformStream, kAbortController = Symbol("abortController"), requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });

  class Request {
    constructor(input, init = {}) {
      if (input === kConstruct)
        return;
      webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" }), input = webidl.converters.RequestInfo(input), init = webidl.converters.RequestInit(init), this[kRealm] = {
        settingsObject: {
          baseUrl: getGlobalOrigin(),
          get origin() {
            return this.baseUrl?.origin;
          },
          policyContainer: makePolicyContainer()
        }
      };
      let request = null, fallbackMode = null, baseUrl = this[kRealm].settingsObject.baseUrl, signal = null;
      if (typeof input === "string") {
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password)
          throw TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
        request = makeRequest({ urlList: [parsedURL] }), fallbackMode = "cors";
      } else
        assert(input instanceof Request), request = input[kState], signal = input[kSignal];
      let origin = this[kRealm].settingsObject.origin, window2 = "client";
      if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin))
        window2 = request.window;
      if (init.window != null)
        throw TypeError(`'window' option '${window2}' must be null`);
      if ("window" in init)
        window2 = "no-window";
      request = makeRequest({
        method: request.method,
        headersList: request.headersList,
        unsafeRequest: request.unsafeRequest,
        client: this[kRealm].settingsObject,
        window: window2,
        priority: request.priority,
        origin: request.origin,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
        keepalive: request.keepalive,
        reloadNavigation: request.reloadNavigation,
        historyNavigation: request.historyNavigation,
        urlList: [...request.urlList]
      });
      let initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request.mode === "navigate")
          request.mode = "same-origin";
        request.reloadNavigation = !1, request.historyNavigation = !1, request.origin = "client", request.referrer = "client", request.referrerPolicy = "", request.url = request.urlList[request.urlList.length - 1], request.urlList = [request.url];
      }
      if (init.referrer !== void 0) {
        let referrer = init.referrer;
        if (referrer === "")
          request.referrer = "no-referrer";
        else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl))
            request.referrer = "client";
          else
            request.referrer = parsedReferrer;
        }
      }
      if (init.referrerPolicy !== void 0)
        request.referrerPolicy = init.referrerPolicy;
      let mode;
      if (init.mode !== void 0)
        mode = init.mode;
      else
        mode = fallbackMode;
      if (mode === "navigate")
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      if (mode != null)
        request.mode = mode;
      if (init.credentials !== void 0)
        request.credentials = init.credentials;
      if (init.cache !== void 0)
        request.cache = init.cache;
      if (request.cache === "only-if-cached" && request.mode !== "same-origin")
        throw TypeError("'only-if-cached' can be set only with 'same-origin' mode");
      if (init.redirect !== void 0)
        request.redirect = init.redirect;
      if (init.integrity != null)
        request.integrity = String(init.integrity);
      if (init.keepalive !== void 0)
        request.keepalive = Boolean(init.keepalive);
      if (init.method !== void 0) {
        let method = init.method;
        if (!isValidHTTPToken(method))
          throw TypeError(`'${method}' is not a valid HTTP method.`);
        if (forbiddenMethodsSet.has(method.toUpperCase()))
          throw TypeError(`'${method}' HTTP method is unsupported.`);
        method = normalizeMethodRecord[method] ?? normalizeMethod(method), request.method = method;
      }
      if (init.signal !== void 0)
        signal = init.signal;
      this[kState] = request;
      let ac = new AbortController;
      if (this[kSignal] = ac.signal, this[kSignal][kRealm] = this[kRealm], signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function")
          throw TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
        if (signal.aborted)
          ac.abort(signal.reason);
        else {
          this[kAbortController] = ac;
          let acRef = new WeakRef(ac), abort = function() {
            let ac2 = acRef.deref();
            if (ac2 !== void 0)
              ac2.abort(this.reason);
          };
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners)
              setMaxListeners(100, signal);
            else if (getEventListeners(signal, "abort").length >= defaultMaxListeners)
              setMaxListeners(100, signal);
          } catch {}
          util.addAbortListener(signal, abort), requestFinalizer.register(ac, { signal, abort });
        }
      }
      if (this[kHeaders] = new Headers(kConstruct), this[kHeaders][kHeadersList] = request.headersList, this[kHeaders][kGuard] = "request", this[kHeaders][kRealm] = this[kRealm], mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request.method))
          throw TypeError(`'${request.method} is unsupported in no-cors mode.`);
        this[kHeaders][kGuard] = "request-no-cors";
      }
      if (initHasKey) {
        let headersList = this[kHeaders][kHeadersList], headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
        if (headersList.clear(), headers instanceof HeadersList) {
          for (let [key, val] of headers)
            headersList.append(key, val);
          headersList.cookies = headers.cookies;
        } else
          fillHeaders(this[kHeaders], headers);
      }
      let inputBody = input instanceof Request ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD"))
        throw TypeError("Request with GET/HEAD method cannot have body.");
      let initBody = null;
      if (init.body != null) {
        let [extractedBody, contentType] = extractBody(init.body, request.keepalive);
        if (initBody = extractedBody, contentType && !this[kHeaders][kHeadersList].contains("content-type"))
          this[kHeaders].append("content-type", contentType);
      }
      let inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null)
          throw TypeError("RequestInit: duplex option is required when sending a body.");
        if (request.mode !== "same-origin" && request.mode !== "cors")
          throw TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
        request.useCORSPreflightFlag = !0;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked)
          throw TypeError("Cannot construct a Request with a Request object that has already been used.");
        if (!TransformStream)
          TransformStream = __require("stream/web").TransformStream;
        let identityTransform = new TransformStream;
        inputBody.stream.pipeThrough(identityTransform), finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    get method() {
      return webidl.brandCheck(this, Request), this[kState].method;
    }
    get url() {
      return webidl.brandCheck(this, Request), URLSerializer(this[kState].url);
    }
    get headers() {
      return webidl.brandCheck(this, Request), this[kHeaders];
    }
    get destination() {
      return webidl.brandCheck(this, Request), this[kState].destination;
    }
    get referrer() {
      if (webidl.brandCheck(this, Request), this[kState].referrer === "no-referrer")
        return "";
      if (this[kState].referrer === "client")
        return "about:client";
      return this[kState].referrer.toString();
    }
    get referrerPolicy() {
      return webidl.brandCheck(this, Request), this[kState].referrerPolicy;
    }
    get mode() {
      return webidl.brandCheck(this, Request), this[kState].mode;
    }
    get credentials() {
      return this[kState].credentials;
    }
    get cache() {
      return webidl.brandCheck(this, Request), this[kState].cache;
    }
    get redirect() {
      return webidl.brandCheck(this, Request), this[kState].redirect;
    }
    get integrity() {
      return webidl.brandCheck(this, Request), this[kState].integrity;
    }
    get keepalive() {
      return webidl.brandCheck(this, Request), this[kState].keepalive;
    }
    get isReloadNavigation() {
      return webidl.brandCheck(this, Request), this[kState].reloadNavigation;
    }
    get isHistoryNavigation() {
      return webidl.brandCheck(this, Request), this[kState].historyNavigation;
    }
    get signal() {
      return webidl.brandCheck(this, Request), this[kSignal];
    }
    get body() {
      return webidl.brandCheck(this, Request), this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      return webidl.brandCheck(this, Request), !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      return webidl.brandCheck(this, Request), "half";
    }
    clone() {
      if (webidl.brandCheck(this, Request), this.bodyUsed || this.body?.locked)
        throw TypeError("unusable");
      let clonedRequest = cloneRequest(this[kState]), clonedRequestObject = new Request(kConstruct);
      clonedRequestObject[kState] = clonedRequest, clonedRequestObject[kRealm] = this[kRealm], clonedRequestObject[kHeaders] = new Headers(kConstruct), clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList, clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard], clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      let ac = new AbortController;
      if (this.signal.aborted)
        ac.abort(this.signal.reason);
      else
        util.addAbortListener(this.signal, () => {
          ac.abort(this.signal.reason);
        });
      return clonedRequestObject[kSignal] = ac.signal, clonedRequestObject;
    }
  }
  mixinBody(Request);
  function makeRequest(init) {
    let request = {
      method: "GET",
      localURLsOnly: !1,
      unsafeRequest: !1,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: !1,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: !1,
      credentials: "same-origin",
      useCredentials: !1,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: !1,
      historyNavigation: !1,
      userActivation: !1,
      taintedOrigin: !1,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: !1,
      done: !1,
      timingAllowFailed: !1,
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList
    };
    return request.url = request.urlList[0], request;
  }
  function cloneRequest(request) {
    let newRequest = makeRequest({ ...request, body: null });
    if (request.body != null)
      newRequest.body = cloneBody(request.body);
    return newRequest;
  }
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: !0
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(Request);
  webidl.converters.RequestInfo = function(V) {
    if (typeof V === "string")
      return webidl.converters.USVString(V);
    if (V instanceof Request)
      return webidl.converters.Request(V);
    return webidl.converters.USVString(V);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(webidl.converters.BodyInit)
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, { strict: !1 }))
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    }
  ]);
  module.exports = { Request, makeRequest };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fetch/index.js
var require_fetch2 = __commonJS((exports, module) => {
  var {
    Response,
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse
  } = require_response3(), { Headers } = require_headers3(), { Request, makeRequest } = require_request4(), zlib = __require("zlib"), {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme
  } = require_util15(), { kState, kHeaders, kGuard, kRealm } = require_symbols7(), assert = __require("assert"), { safelyExtractBody } = require_body2(), {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet,
    DOMException: DOMException2
  } = require_constants14(), { kHeadersList } = require_symbols6(), EE = __require("events"), { Readable, pipeline } = __require("stream"), { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util14(), { dataURLProcessor, serializeAMimeType } = require_dataURL2(), { TransformStream } = __require("stream/web"), { getGlobalDispatcher } = require_global4(), { webidl } = require_webidl2(), { STATUS_CODES } = __require("http"), GET_OR_HEAD = ["GET", "HEAD"], resolveObjectURL, ReadableStream2 = globalThis.ReadableStream;

  class Fetch extends EE {
    constructor(dispatcher) {
      super();
      this.dispatcher = dispatcher, this.connection = null, this.dump = !1, this.state = "ongoing", this.setMaxListeners(21);
    }
    terminate(reason) {
      if (this.state !== "ongoing")
        return;
      this.state = "terminated", this.connection?.destroy(reason), this.emit("terminated", reason);
    }
    abort(error) {
      if (this.state !== "ongoing")
        return;
      if (this.state = "aborted", !error)
        error = new DOMException2("The operation was aborted.", "AbortError");
      this.serializedAbortReason = error, this.connection?.destroy(error), this.emit("terminated", error);
    }
  }
  function fetch(input, init = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    let p = createDeferredPromise(), requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      return p.reject(e), p.promise;
    }
    let request = requestObject[kState];
    if (requestObject.signal.aborted)
      return abortFetch(p, request, null, requestObject.signal.reason), p.promise;
    if (request.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope")
      request.serviceWorkers = "none";
    let responseObject = null, relevantRealm = null, locallyAborted = !1, controller = null;
    return addAbortListener(requestObject.signal, () => {
      locallyAborted = !0, assert(controller != null), controller.abort(requestObject.signal.reason), abortFetch(p, request, responseObject, requestObject.signal.reason);
    }), controller = fetching({
      request,
      processResponseEndOfBody: (response) => finalizeAndReportTiming(response, "fetch"),
      processResponse: (response) => {
        if (locallyAborted)
          return Promise.resolve();
        if (response.aborted)
          return abortFetch(p, request, responseObject, controller.serializedAbortReason), Promise.resolve();
        if (response.type === "error")
          return p.reject(Object.assign(TypeError("fetch failed"), { cause: response.error })), Promise.resolve();
        responseObject = new Response, responseObject[kState] = response, responseObject[kRealm] = relevantRealm, responseObject[kHeaders][kHeadersList] = response.headersList, responseObject[kHeaders][kGuard] = "immutable", responseObject[kHeaders][kRealm] = relevantRealm, p.resolve(responseObject);
      },
      dispatcher: init.dispatcher ?? getGlobalDispatcher()
    }), p.promise;
  }
  function finalizeAndReportTiming(response, initiatorType = "other") {
    if (response.type === "error" && response.aborted)
      return;
    if (!response.urlList?.length)
      return;
    let originalURL = response.urlList[0], timingInfo = response.timingInfo, cacheState = response.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL))
      return;
    if (timingInfo === null)
      return;
    if (!response.timingAllowPassed)
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      }), cacheState = "";
    timingInfo.endTime = coarsenedSharedCurrentTime(), response.timingInfo = timingInfo, markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
  }
  function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2)
      performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
  }
  function abortFetch(p, request, responseObject, error) {
    if (!error)
      error = new DOMException2("The operation was aborted.", "AbortError");
    if (p.reject(error), request.body != null && isReadable(request.body?.stream))
      request.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE")
          return;
        throw err;
      });
    if (responseObject == null)
      return;
    let response = responseObject[kState];
    if (response.body != null && isReadable(response.body?.stream))
      response.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE")
          return;
        throw err;
      });
  }
  function fetching({
    request,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = !1,
    dispatcher
  }) {
    let taskDestination = null, crossOriginIsolatedCapability = !1;
    if (request.client != null)
      taskDestination = request.client.globalObject, crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
    let currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability), timingInfo = createOpaqueTimingInfo({
      startTime: currenTime
    }), fetchParams = {
      controller: new Fetch(dispatcher),
      request,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    if (assert(!request.body || request.body.stream), request.window === "client")
      request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
    if (request.origin === "client")
      request.origin = request.client?.origin;
    if (request.policyContainer === "client")
      if (request.client != null)
        request.policyContainer = clonePolicyContainer(request.client.policyContainer);
      else
        request.policyContainer = makePolicyContainer();
    if (!request.headersList.contains("accept"))
      request.headersList.append("accept", "*/*");
    if (!request.headersList.contains("accept-language"))
      request.headersList.append("accept-language", "*");
    if (request.priority === null)
      ;
    if (subresourceSet.has(request.destination))
      ;
    return mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    }), fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive = !1) {
    let request = fetchParams.request, response = null;
    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request)))
      response = makeNetworkError("local URLs only");
    if (tryUpgradeRequestToAPotentiallyTrustworthyURL(request), requestBadPort(request) === "blocked")
      response = makeNetworkError("bad port");
    if (request.referrerPolicy === "")
      request.referrerPolicy = request.policyContainer.referrerPolicy;
    if (request.referrer !== "no-referrer")
      request.referrer = determineRequestsReferrer(request);
    if (response === null)
      response = await (async () => {
        let currentURL = requestCurrentURL(request);
        if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket"))
          return request.responseTainting = "basic", await schemeFetch(fetchParams);
        if (request.mode === "same-origin")
          return makeNetworkError('request mode cannot be "same-origin"');
        if (request.mode === "no-cors") {
          if (request.redirect !== "follow")
            return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
          return request.responseTainting = "opaque", await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request)))
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        return request.responseTainting = "cors", await httpFetch(fetchParams);
      })();
    if (recursive)
      return response;
    if (response.status !== 0 && !response.internalResponse) {
      if (request.responseTainting === "cors")
        ;
      if (request.responseTainting === "basic")
        response = filterResponse(response, "basic");
      else if (request.responseTainting === "cors")
        response = filterResponse(response, "cors");
      else if (request.responseTainting === "opaque")
        response = filterResponse(response, "opaque");
      else
        assert(!1);
    }
    let internalResponse = response.status === 0 ? response : response.internalResponse;
    if (internalResponse.urlList.length === 0)
      internalResponse.urlList.push(...request.urlList);
    if (!request.timingAllowFailed)
      response.timingAllowPassed = !0;
    if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range"))
      response = internalResponse = makeNetworkError();
    if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status)))
      internalResponse.body = null, fetchParams.controller.dump = !0;
    if (request.integrity) {
      let processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request.responseTainting === "opaque" || response.body == null) {
        processBodyError(response.error);
        return;
      }
      let processBody = (bytes) => {
        if (!bytesMatch(bytes, request.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response.body = safelyExtractBody(bytes)[0], fetchFinale(fetchParams, response);
      };
      await fullyReadBody(response.body, processBody, processBodyError);
    } else
      fetchFinale(fetchParams, response);
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0)
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    let { request } = fetchParams, { protocol: scheme } = requestCurrentURL(request);
    switch (scheme) {
      case "about:":
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      case "blob:": {
        if (!resolveObjectURL)
          resolveObjectURL = __require("buffer").resolveObjectURL;
        let blobURLEntry = requestCurrentURL(request);
        if (blobURLEntry.search.length !== 0)
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        let blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
        if (request.method !== "GET" || !isBlobLike(blobURLEntryObject))
          return Promise.resolve(makeNetworkError("invalid method"));
        let bodyWithType = safelyExtractBody(blobURLEntryObject), body = bodyWithType[0], length = isomorphicEncode(`${body.length}`), type = bodyWithType[1] ?? "", response = makeResponse({
          statusText: "OK",
          headersList: [
            ["content-length", { name: "Content-Length", value: length }],
            ["content-type", { name: "Content-Type", value: type }]
          ]
        });
        return response.body = body, Promise.resolve(response);
      }
      case "data:": {
        let currentURL = requestCurrentURL(request), dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure")
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        let mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:":
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      case "http:":
      case "https:":
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      default:
        return Promise.resolve(makeNetworkError("unknown scheme"));
    }
  }
  function finalizeResponse(fetchParams, response) {
    if (fetchParams.request.done = !0, fetchParams.processResponseDone != null)
      queueMicrotask(() => fetchParams.processResponseDone(response));
  }
  function fetchFinale(fetchParams, response) {
    if (response.type === "error")
      response.urlList = [fetchParams.request.urlList[0]], response.timingInfo = createOpaqueTimingInfo({
        startTime: fetchParams.timingInfo.startTime
      });
    let processResponseEndOfBody = () => {
      if (fetchParams.request.done = !0, fetchParams.processResponseEndOfBody != null)
        queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
    };
    if (fetchParams.processResponse != null)
      queueMicrotask(() => fetchParams.processResponse(response));
    if (response.body == null)
      processResponseEndOfBody();
    else {
      let transformStream = new TransformStream({
        start() {},
        transform: (chunk, controller) => {
          controller.enqueue(chunk);
        },
        flush: processResponseEndOfBody
      }, {
        size() {
          return 1;
        }
      }, {
        size() {
          return 1;
        }
      });
      response.body = { stream: response.body.stream.pipeThrough(transformStream) };
    }
    if (fetchParams.processResponseConsumeBody != null) {
      let processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes), processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
      if (response.body == null)
        queueMicrotask(() => processBody(null));
      else
        return fullyReadBody(response.body, processBody, processBodyError);
      return Promise.resolve();
    }
  }
  async function httpFetch(fetchParams) {
    let request = fetchParams.request, response = null, actualResponse = null, timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers === "all")
      ;
    if (response === null) {
      if (request.redirect === "follow")
        request.serviceWorkers = "none";
      if (actualResponse = response = await httpNetworkOrCacheFetch(fetchParams), request.responseTainting === "cors" && corsCheck(request, response) === "failure")
        return makeNetworkError("cors failure");
      if (TAOCheck(request, response) === "failure")
        request.timingAllowFailed = !0;
    }
    if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked")
      return makeNetworkError("blocked");
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request.redirect !== "manual")
        fetchParams.controller.connection.destroy();
      if (request.redirect === "error")
        response = makeNetworkError("unexpected redirect");
      else if (request.redirect === "manual")
        response = actualResponse;
      else if (request.redirect === "follow")
        response = await httpRedirectFetch(fetchParams, response);
      else
        assert(!1);
    }
    return response.timingInfo = timingInfo, response;
  }
  function httpRedirectFetch(fetchParams, response) {
    let request = fetchParams.request, actualResponse = response.internalResponse ? response.internalResponse : response, locationURL;
    try {
      if (locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash), locationURL == null)
        return response;
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL))
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    if (request.redirectCount === 20)
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    if (request.redirectCount += 1, request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL))
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password))
      return Promise.resolve(makeNetworkError('URL cannot contain credentials for request mode "cors"'));
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null)
      return Promise.resolve(makeNetworkError());
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
      request.method = "GET", request.body = null;
      for (let headerName of requestBodyHeader)
        request.headersList.delete(headerName);
    }
    if (!sameOrigin(requestCurrentURL(request), locationURL))
      request.headersList.delete("authorization"), request.headersList.delete("proxy-authorization", !0), request.headersList.delete("cookie"), request.headersList.delete("host");
    if (request.body != null)
      assert(request.body.source != null), request.body = safelyExtractBody(request.body.source)[0];
    let timingInfo = fetchParams.timingInfo;
    if (timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability), timingInfo.redirectStartTime === 0)
      timingInfo.redirectStartTime = timingInfo.startTime;
    return request.urlList.push(locationURL), setRequestReferrerPolicyOnRedirect(request, actualResponse), mainFetch(fetchParams, !0);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = !1, isNewConnectionFetch = !1) {
    let request = fetchParams.request, httpFetchParams = null, httpRequest = null, response = null, httpCache = null, revalidatingFlag = !1;
    if (request.window === "no-window" && request.redirect === "error")
      httpFetchParams = fetchParams, httpRequest = request;
    else
      httpRequest = makeRequest(request), httpFetchParams = { ...fetchParams }, httpFetchParams.request = httpRequest;
    let includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic", contentLength = httpRequest.body ? httpRequest.body.length : null, contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method))
      contentLengthHeaderValue = "0";
    if (contentLength != null)
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    if (contentLengthHeaderValue != null)
      httpRequest.headersList.append("content-length", contentLengthHeaderValue);
    if (contentLength != null && httpRequest.keepalive)
      ;
    if (httpRequest.referrer instanceof URL)
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
    if (appendRequestOriginHeader(httpRequest), appendFetchMetadata(httpRequest), !httpRequest.headersList.contains("user-agent"))
      httpRequest.headersList.append("user-agent", typeof esbuildDetection > "u" ? "undici" : "node");
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range")))
      httpRequest.cache = "no-store";
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control"))
      httpRequest.headersList.append("cache-control", "max-age=0");
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma"))
        httpRequest.headersList.append("pragma", "no-cache");
      if (!httpRequest.headersList.contains("cache-control"))
        httpRequest.headersList.append("cache-control", "no-cache");
    }
    if (httpRequest.headersList.contains("range"))
      httpRequest.headersList.append("accept-encoding", "identity");
    if (!httpRequest.headersList.contains("accept-encoding"))
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest)))
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
      else
        httpRequest.headersList.append("accept-encoding", "gzip, deflate");
    if (httpRequest.headersList.delete("host"), httpCache == null)
      httpRequest.cache = "no-store";
    if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload")
      ;
    if (response == null) {
      if (httpRequest.mode === "only-if-cached")
        return makeNetworkError("only if cached");
      let forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399)
        ;
      if (revalidatingFlag && forwardResponse.status === 304)
        ;
      if (response == null)
        response = forwardResponse;
    }
    if (response.urlList = [...httpRequest.urlList], httpRequest.headersList.contains("range"))
      response.rangeRequested = !0;
    if (response.requestIncludesCredentials = includeCredentials, response.status === 407) {
      if (request.window === "no-window")
        return makeNetworkError();
      if (isCancelled(fetchParams))
        return makeAppropriateNetworkError(fetchParams);
      return makeNetworkError("proxy authentication required");
    }
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams))
        return makeAppropriateNetworkError(fetchParams);
      fetchParams.controller.connection.destroy(), response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, !0);
    }
    return response;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = !1, forceNewConnection = !1) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed), fetchParams.controller.connection = {
      abort: null,
      destroyed: !1,
      destroy(err) {
        if (!this.destroyed)
          this.destroyed = !0, this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
      }
    };
    let request = fetchParams.request, response = null, timingInfo = fetchParams.timingInfo;
    if (!0)
      request.cache = "no-store";
    let newConnection = forceNewConnection ? "yes" : "no";
    if (request.mode === "websocket")
      ;
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody)
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    else if (request.body != null) {
      let processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams))
          return;
        yield bytes, fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      }, processEndOfBody = () => {
        if (isCancelled(fetchParams))
          return;
        if (fetchParams.processRequestEndOfBody)
          fetchParams.processRequestEndOfBody();
      }, processBodyError = (e) => {
        if (isCancelled(fetchParams))
          return;
        if (e.name === "AbortError")
          fetchParams.controller.abort();
        else
          fetchParams.controller.terminate(e);
      };
      requestBody = async function* () {
        try {
          for await (let bytes of request.body.stream)
            yield* processBodyChunk(bytes);
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      let { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket)
        response = makeResponse({ status, statusText, headersList, socket });
      else {
        let iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next(), response = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError")
        return fetchParams.controller.connection.destroy(), makeAppropriateNetworkError(fetchParams, err);
      return makeNetworkError(err);
    }
    let pullAlgorithm = () => {
      fetchParams.controller.resume();
    }, cancelAlgorithm = (reason) => {
      fetchParams.controller.abort(reason);
    };
    if (!ReadableStream2)
      ReadableStream2 = __require("stream/web").ReadableStream;
    let stream = new ReadableStream2({
      async start(controller) {
        fetchParams.controller.controller = controller;
      },
      async pull(controller) {
        await pullAlgorithm(controller);
      },
      async cancel(reason) {
        await cancelAlgorithm(reason);
      }
    }, {
      highWaterMark: 0,
      size() {
        return 1;
      }
    });
    response.body = { stream }, fetchParams.controller.on("terminated", onAborted), fetchParams.controller.resume = async () => {
      while (!0) {
        let bytes, isFailure;
        try {
          let { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams))
            break;
          bytes = done ? void 0 : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize)
            bytes = void 0;
          else
            bytes = err, isFailure = !0;
        }
        if (bytes === void 0) {
          readableStreamClose(fetchParams.controller.controller), finalizeResponse(fetchParams, response);
          return;
        }
        if (timingInfo.decodedBodySize += bytes?.byteLength ?? 0, isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        if (fetchParams.controller.controller.enqueue(new Uint8Array(bytes)), isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (!fetchParams.controller.controller.desiredSize)
          return;
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        if (response.aborted = !0, isReadable(stream))
          fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
      } else if (isReadable(stream))
        fetchParams.controller.controller.error(TypeError("terminated", {
          cause: isErrorLike(reason) ? reason : void 0
        }));
      fetchParams.controller.connection.destroy();
    }
    return response;
    async function dispatch({ body }) {
      let url = requestCurrentURL(request), agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : void 0
      }, {
        body: null,
        abort: null,
        onConnect(abort) {
          let { connection } = fetchParams.controller;
          if (connection.destroyed)
            abort(new DOMException2("The operation was aborted.", "AbortError"));
          else
            fetchParams.controller.on("terminated", abort), this.abort = connection.abort = abort;
        },
        onHeaders(status, headersList, resume, statusText) {
          if (status < 200)
            return;
          let codings = [], location = "", headers = new Headers;
          if (Array.isArray(headersList))
            for (let n = 0;n < headersList.length; n += 2) {
              let key = headersList[n + 0].toString("latin1"), val = headersList[n + 1].toString("latin1");
              if (key.toLowerCase() === "content-encoding")
                codings = val.toLowerCase().split(",").map((x) => x.trim());
              else if (key.toLowerCase() === "location")
                location = val;
              headers[kHeadersList].append(key, val);
            }
          else {
            let keys = Object.keys(headersList);
            for (let key of keys) {
              let val = headersList[key];
              if (key.toLowerCase() === "content-encoding")
                codings = val.toLowerCase().split(",").map((x) => x.trim()).reverse();
              else if (key.toLowerCase() === "location")
                location = val;
              headers[kHeadersList].append(key, val);
            }
          }
          this.body = new Readable({ read: resume });
          let decoders = [], willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
          if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow)
            for (let coding of codings)
              if (coding === "x-gzip" || coding === "gzip")
                decoders.push(zlib.createGunzip({
                  flush: zlib.constants.Z_SYNC_FLUSH,
                  finishFlush: zlib.constants.Z_SYNC_FLUSH
                }));
              else if (coding === "deflate")
                decoders.push(zlib.createInflate());
              else if (coding === "br")
                decoders.push(zlib.createBrotliDecompress());
              else {
                decoders.length = 0;
                break;
              }
          return resolve({
            status,
            statusText,
            headersList: headers[kHeadersList],
            body: decoders.length ? pipeline(this.body, ...decoders, () => {}) : this.body.on("error", () => {})
          }), !0;
        },
        onData(chunk) {
          if (fetchParams.controller.dump)
            return;
          let bytes = chunk;
          return timingInfo.encodedBodySize += bytes.byteLength, this.body.push(bytes);
        },
        onComplete() {
          if (this.abort)
            fetchParams.controller.off("terminated", this.abort);
          fetchParams.controller.ended = !0, this.body.push(null);
        },
        onError(error) {
          if (this.abort)
            fetchParams.controller.off("terminated", this.abort);
          this.body?.destroy(error), fetchParams.controller.terminate(error), reject(error);
        },
        onUpgrade(status, headersList, socket) {
          if (status !== 101)
            return;
          let headers = new Headers;
          for (let n = 0;n < headersList.length; n += 2) {
            let key = headersList[n + 0].toString("latin1"), val = headersList[n + 1].toString("latin1");
            headers[kHeadersList].append(key, val);
          }
          return resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList: headers[kHeadersList],
            socket
          }), !0;
        }
      }));
    }
  }
  module.exports = {
    fetch,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fileapi/symbols.js
var require_symbols8 = __commonJS((exports, module) => {
  module.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent2 = __commonJS((exports, module) => {
  var { webidl } = require_webidl2(), kState = Symbol("ProgressEvent state");

  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      return webidl.brandCheck(this, ProgressEvent), this[kState].lengthComputable;
    }
    get loaded() {
      return webidl.brandCheck(this, ProgressEvent), this[kState].loaded;
    }
    get total() {
      return webidl.brandCheck(this, ProgressEvent), this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: !1
    }
  ]);
  module.exports = {
    ProgressEvent
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fileapi/encoding.js
var require_encoding2 = __commonJS((exports, module) => {
  function getEncoding(label) {
    if (!label)
      return "failure";
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  module.exports = {
    getEncoding
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fileapi/util.js
var require_util17 = __commonJS((exports, module) => {
  var {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = require_symbols8(), { ProgressEvent } = require_progressevent2(), { getEncoding } = require_encoding2(), { DOMException: DOMException2 } = require_constants14(), { serializeAMimeType, parseMIMEType } = require_dataURL2(), { types } = __require("util"), { StringDecoder } = __require("string_decoder"), { btoa: btoa2 } = __require("buffer"), staticPropertyDescriptors = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  };
  function readOperation(fr, blob, type, encodingName) {
    if (fr[kState] === "loading")
      throw new DOMException2("Invalid state", "InvalidStateError");
    fr[kState] = "loading", fr[kResult] = null, fr[kError] = null;
    let reader = blob.stream().getReader(), bytes = [], chunkPromise = reader.read(), isFirstChunk = !0;
    (async () => {
      while (!fr[kAborted])
        try {
          let { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted])
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          if (isFirstChunk = !1, !done && types.isUint8Array(value)) {
            if (bytes.push(value), (fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted])
              fr[kLastProgressEventFired] = Date.now(), queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                let result = packageData(bytes, type, blob.type, encodingName);
                if (fr[kAborted])
                  return;
                fr[kResult] = result, fireAProgressEvent("load", fr);
              } catch (error) {
                fr[kError] = error, fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading")
                fireAProgressEvent("loadend", fr);
            });
            break;
          }
        } catch (error) {
          if (fr[kAborted])
            return;
          queueMicrotask(() => {
            if (fr[kState] = "done", fr[kError] = error, fireAProgressEvent("error", fr), fr[kState] !== "loading")
              fireAProgressEvent("loadend", fr);
          });
          break;
        }
    })();
  }
  function fireAProgressEvent(e, reader) {
    let event = new ProgressEvent(e, {
      bubbles: !1,
      cancelable: !1
    });
    reader.dispatchEvent(event);
  }
  function packageData(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL = "data:", parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure")
          dataURL += serializeAMimeType(parsed);
        dataURL += ";base64,";
        let decoder = new StringDecoder("latin1");
        for (let chunk of bytes)
          dataURL += btoa2(decoder.write(chunk));
        return dataURL += btoa2(decoder.end()), dataURL;
      }
      case "Text": {
        let encoding = "failure";
        if (encodingName)
          encoding = getEncoding(encodingName);
        if (encoding === "failure" && mimeType) {
          let type2 = parseMIMEType(mimeType);
          if (type2 !== "failure")
            encoding = getEncoding(type2.parameters.get("charset"));
        }
        if (encoding === "failure")
          encoding = "UTF-8";
        return decode(bytes, encoding);
      }
      case "ArrayBuffer":
        return combineByteSequences(bytes).buffer;
      case "BinaryString": {
        let binaryString = "", decoder = new StringDecoder("latin1");
        for (let chunk of bytes)
          binaryString += decoder.write(chunk);
        return binaryString += decoder.end(), binaryString;
      }
    }
  }
  function decode(ioQueue, encoding) {
    let bytes = combineByteSequences(ioQueue), BOMEncoding = BOMSniffing(bytes), slice = 0;
    if (BOMEncoding !== null)
      encoding = BOMEncoding, slice = BOMEncoding === "UTF-8" ? 3 : 2;
    let sliced = bytes.slice(slice);
    return new TextDecoder(encoding).decode(sliced);
  }
  function BOMSniffing(ioQueue) {
    let [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191)
      return "UTF-8";
    else if (a === 254 && b === 255)
      return "UTF-16BE";
    else if (a === 255 && b === 254)
      return "UTF-16LE";
    return null;
  }
  function combineByteSequences(sequences) {
    let size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0), offset = 0;
    return sequences.reduce((a, b) => {
      return a.set(b, offset), offset += b.byteLength, a;
    }, new Uint8Array(size));
  }
  module.exports = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/fileapi/filereader.js
var require_filereader2 = __commonJS((exports, module) => {
  var {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = require_util17(), {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = require_symbols8(), { webidl } = require_webidl2(), { kEnumerableProperty } = require_util14();

  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty", this[kResult] = null, this[kError] = null, this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" }), blob = webidl.converters.Blob(blob, { strict: !1 }), readOperation(this, blob, "ArrayBuffer");
    }
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" }), blob = webidl.converters.Blob(blob, { strict: !1 }), readOperation(this, blob, "BinaryString");
    }
    readAsText(blob, encoding = void 0) {
      if (webidl.brandCheck(this, FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" }), blob = webidl.converters.Blob(blob, { strict: !1 }), encoding !== void 0)
        encoding = webidl.converters.DOMString(encoding);
      readOperation(this, blob, "Text", encoding);
    }
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader), webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" }), blob = webidl.converters.Blob(blob, { strict: !1 }), readOperation(this, blob, "DataURL");
    }
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading")
        this[kState] = "done", this[kResult] = null;
      if (this[kAborted] = !0, fireAProgressEvent("abort", this), this[kState] !== "loading")
        fireAProgressEvent("loadend", this);
    }
    get readyState() {
      switch (webidl.brandCheck(this, FileReader), this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    get result() {
      return webidl.brandCheck(this, FileReader), this[kResult];
    }
    get error() {
      return webidl.brandCheck(this, FileReader), this[kError];
    }
    get onloadend() {
      return webidl.brandCheck(this, FileReader), this[kEvents].loadend;
    }
    set onloadend(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].loadend)
        this.removeEventListener("loadend", this[kEvents].loadend);
      if (typeof fn === "function")
        this[kEvents].loadend = fn, this.addEventListener("loadend", fn);
      else
        this[kEvents].loadend = null;
    }
    get onerror() {
      return webidl.brandCheck(this, FileReader), this[kEvents].error;
    }
    set onerror(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].error)
        this.removeEventListener("error", this[kEvents].error);
      if (typeof fn === "function")
        this[kEvents].error = fn, this.addEventListener("error", fn);
      else
        this[kEvents].error = null;
    }
    get onloadstart() {
      return webidl.brandCheck(this, FileReader), this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].loadstart)
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      if (typeof fn === "function")
        this[kEvents].loadstart = fn, this.addEventListener("loadstart", fn);
      else
        this[kEvents].loadstart = null;
    }
    get onprogress() {
      return webidl.brandCheck(this, FileReader), this[kEvents].progress;
    }
    set onprogress(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].progress)
        this.removeEventListener("progress", this[kEvents].progress);
      if (typeof fn === "function")
        this[kEvents].progress = fn, this.addEventListener("progress", fn);
      else
        this[kEvents].progress = null;
    }
    get onload() {
      return webidl.brandCheck(this, FileReader), this[kEvents].load;
    }
    set onload(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].load)
        this.removeEventListener("load", this[kEvents].load);
      if (typeof fn === "function")
        this[kEvents].load = fn, this.addEventListener("load", fn);
      else
        this[kEvents].load = null;
    }
    get onabort() {
      return webidl.brandCheck(this, FileReader), this[kEvents].abort;
    }
    set onabort(fn) {
      if (webidl.brandCheck(this, FileReader), this[kEvents].abort)
        this.removeEventListener("abort", this[kEvents].abort);
      if (typeof fn === "function")
        this[kEvents].abort = fn, this.addEventListener("abort", fn);
      else
        this[kEvents].abort = null;
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  module.exports = {
    FileReader
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/cache/symbols.js
var require_symbols9 = __commonJS((exports, module) => {
  module.exports = {
    kConstruct: require_symbols6().kConstruct
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/cache/util.js
var require_util18 = __commonJS((exports, module) => {
  var assert = __require("assert"), { URLSerializer } = require_dataURL2(), { isValidHeaderName } = require_util15();
  function urlEquals(A, B, excludeFragment = !1) {
    let serializedA = URLSerializer(A, excludeFragment), serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  }
  function fieldValues(header) {
    assert(header !== null);
    let values = [];
    for (let value of header.split(",")) {
      if (value = value.trim(), !value.length)
        continue;
      else if (!isValidHeaderName(value))
        continue;
      values.push(value);
    }
    return values;
  }
  module.exports = {
    urlEquals,
    fieldValues
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/cache/cache.js
var require_cache3 = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols9(), { urlEquals, fieldValues: getFieldValues } = require_util18(), { kEnumerableProperty, isDisturbed } = require_util14(), { kHeadersList } = require_symbols6(), { webidl } = require_webidl2(), { Response, cloneResponse } = require_response3(), { Request } = require_request4(), { kState, kHeaders, kGuard, kRealm } = require_symbols7(), { fetching } = require_fetch2(), { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util15(), assert = __require("assert"), { getGlobalDispatcher } = require_global4();

  class Cache {
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct)
        webidl.illegalConstructor();
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" }), request = webidl.converters.RequestInfo(request), options = webidl.converters.CacheQueryOptions(options);
      let p = await this.matchAll(request, options);
      if (p.length === 0)
        return;
      return p[0];
    }
    async matchAll(request = void 0, options = {}) {
      if (webidl.brandCheck(this, Cache), request !== void 0)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== void 0) {
        if (request instanceof Request) {
          if (r = request[kState], r.method !== "GET" && !options.ignoreMethod)
            return [];
        } else if (typeof request === "string")
          r = new Request(request)[kState];
      }
      let responses = [];
      if (request === void 0)
        for (let requestResponse of this.#relevantRequestResponseList)
          responses.push(requestResponse[1]);
      else {
        let requestResponses = this.#queryCache(r, options);
        for (let requestResponse of requestResponses)
          responses.push(requestResponse[1]);
      }
      let responseList = [];
      for (let response of responses) {
        let responseObject = new Response(response.body?.source ?? null), body = responseObject[kState].body;
        responseObject[kState] = response, responseObject[kState].body = body, responseObject[kHeaders][kHeadersList] = response.headersList, responseObject[kHeaders][kGuard] = "immutable", responseList.push(responseObject);
      }
      return Object.freeze(responseList);
    }
    async add(request) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" }), request = webidl.converters.RequestInfo(request);
      let requests = [request];
      return await this.addAll(requests);
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" }), requests = webidl.converters["sequence<RequestInfo>"](requests);
      let responsePromises = [], requestList = [];
      for (let request of requests) {
        if (typeof request === "string")
          continue;
        let r = request[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET")
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET."
          });
      }
      let fetchControllers = [];
      for (let request of requests) {
        let r = new Request(request)[kState];
        if (!urlIsHttpHttpsScheme(r.url))
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme."
          });
        r.initiator = "fetch", r.destination = "subresource", requestList.push(r);
        let responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          dispatcher: getGlobalDispatcher(),
          processResponse(response) {
            if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299)
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            else if (response.headersList.contains("vary")) {
              let fieldValues = getFieldValues(response.headersList.get("vary"));
              for (let fieldValue of fieldValues)
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (let controller of fetchControllers)
                    controller.abort();
                  return;
                }
            }
          },
          processResponseEndOfBody(response) {
            if (response.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response);
          }
        })), responsePromises.push(responsePromise.promise);
      }
      let responses = await Promise.all(responsePromises), operations = [], index = 0;
      for (let response of responses) {
        let operation = {
          type: "put",
          request: requestList[index],
          response
        };
        operations.push(operation), index++;
      }
      let cacheJobPromise = createDeferredPromise(), errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      return queueMicrotask(() => {
        if (errorData === null)
          cacheJobPromise.resolve(void 0);
        else
          cacheJobPromise.reject(errorData);
      }), cacheJobPromise.promise;
    }
    async put(request, response) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" }), request = webidl.converters.RequestInfo(request), response = webidl.converters.Response(response);
      let innerRequest = null;
      if (request instanceof Request)
        innerRequest = request[kState];
      else
        innerRequest = new Request(request)[kState];
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET")
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET"
        });
      let innerResponse = response[kState];
      if (innerResponse.status === 206)
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Got 206 status"
        });
      if (innerResponse.headersList.contains("vary")) {
        let fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (let fieldValue of fieldValues)
          if (fieldValue === "*")
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value"
            });
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked))
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed"
        });
      let clonedResponse = cloneResponse(innerResponse), bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        let reader = innerResponse.body.stream.getReader();
        readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
      } else
        bodyReadPromise.resolve(void 0);
      let operations = [], operation = {
        type: "put",
        request: innerRequest,
        response: clonedResponse
      };
      operations.push(operation);
      let bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null)
        clonedResponse.body.source = bytes;
      let cacheJobPromise = createDeferredPromise(), errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      return queueMicrotask(() => {
        if (errorData === null)
          cacheJobPromise.resolve();
        else
          cacheJobPromise.reject(errorData);
      }), cacheJobPromise.promise;
    }
    async delete(request, options = {}) {
      webidl.brandCheck(this, Cache), webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" }), request = webidl.converters.RequestInfo(request), options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request instanceof Request) {
        if (r = request[kState], r.method !== "GET" && !options.ignoreMethod)
          return !1;
      } else
        assert(typeof request === "string"), r = new Request(request)[kState];
      let operations = [], operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      let cacheJobPromise = createDeferredPromise(), errorData = null, requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      return queueMicrotask(() => {
        if (errorData === null)
          cacheJobPromise.resolve(!!requestResponses?.length);
        else
          cacheJobPromise.reject(errorData);
      }), cacheJobPromise.promise;
    }
    async keys(request = void 0, options = {}) {
      if (webidl.brandCheck(this, Cache), request !== void 0)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== void 0) {
        if (request instanceof Request) {
          if (r = request[kState], r.method !== "GET" && !options.ignoreMethod)
            return [];
        } else if (typeof request === "string")
          r = new Request(request)[kState];
      }
      let promise = createDeferredPromise(), requests = [];
      if (request === void 0)
        for (let requestResponse of this.#relevantRequestResponseList)
          requests.push(requestResponse[0]);
      else {
        let requestResponses = this.#queryCache(r, options);
        for (let requestResponse of requestResponses)
          requests.push(requestResponse[0]);
      }
      return queueMicrotask(() => {
        let requestList = [];
        for (let request2 of requests) {
          let requestObject = new Request("https://a");
          requestObject[kState] = request2, requestObject[kHeaders][kHeadersList] = request2.headersList, requestObject[kHeaders][kGuard] = "immutable", requestObject[kRealm] = request2.client, requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      }), promise.promise;
    }
    #batchCacheOperations(operations) {
      let cache = this.#relevantRequestResponseList, backupCache = [...cache], addedItems = [], resultList = [];
      try {
        for (let operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put")
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          if (operation.type === "delete" && operation.response != null)
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          if (this.#queryCache(operation.request, operation.options, addedItems).length)
            throw new DOMException("???", "InvalidStateError");
          let requestResponses;
          if (operation.type === "delete") {
            if (requestResponses = this.#queryCache(operation.request, operation.options), requestResponses.length === 0)
              return [];
            for (let requestResponse of requestResponses) {
              let idx = cache.indexOf(requestResponse);
              assert(idx !== -1), cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null)
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            let r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url))
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            if (r.method !== "GET")
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            if (operation.options != null)
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            requestResponses = this.#queryCache(operation.request);
            for (let requestResponse of requestResponses) {
              let idx = cache.indexOf(requestResponse);
              assert(idx !== -1), cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]), addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        throw this.#relevantRequestResponseList.length = 0, this.#relevantRequestResponseList = backupCache, e;
      }
    }
    #queryCache(requestQuery, options, targetStorage) {
      let resultList = [], storage = targetStorage ?? this.#relevantRequestResponseList;
      for (let requestResponse of storage) {
        let [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options))
          resultList.push(requestResponse);
      }
      return resultList;
    }
    #requestMatchesCachedItem(requestQuery, request, response = null, options) {
      let queryURL = new URL(requestQuery.url), cachedURL = new URL(request.url);
      if (options?.ignoreSearch)
        cachedURL.search = "", queryURL.search = "";
      if (!urlEquals(queryURL, cachedURL, !0))
        return !1;
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary"))
        return !0;
      let fieldValues = getFieldValues(response.headersList.get("vary"));
      for (let fieldValue of fieldValues) {
        if (fieldValue === "*")
          return !1;
        let requestValue = request.headersList.get(fieldValue), queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue)
          return !1;
      }
      return !0;
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: !0
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: !1
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage2 = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols9(), { Cache } = require_cache3(), { webidl } = require_webidl2(), { kEnumerableProperty } = require_util14();

  class CacheStorage {
    #caches = /* @__PURE__ */ new Map;
    constructor() {
      if (arguments[0] !== kConstruct)
        webidl.illegalConstructor();
    }
    async match(request, options = {}) {
      if (webidl.brandCheck(this, CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" }), request = webidl.converters.RequestInfo(request), options = webidl.converters.MultiCacheQueryOptions(options), options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          let cacheList = this.#caches.get(options.cacheName);
          return await new Cache(kConstruct, cacheList).match(request, options);
        }
      } else
        for (let cacheList of this.#caches.values()) {
          let response = await new Cache(kConstruct, cacheList).match(request, options);
          if (response !== void 0)
            return response;
        }
    }
    async has(cacheName) {
      return webidl.brandCheck(this, CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" }), cacheName = webidl.converters.DOMString(cacheName), this.#caches.has(cacheName);
    }
    async open(cacheName) {
      if (webidl.brandCheck(this, CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" }), cacheName = webidl.converters.DOMString(cacheName), this.#caches.has(cacheName)) {
        let cache2 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache2);
      }
      let cache = [];
      return this.#caches.set(cacheName, cache), new Cache(kConstruct, cache);
    }
    async delete(cacheName) {
      return webidl.brandCheck(this, CacheStorage), webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" }), cacheName = webidl.converters.DOMString(cacheName), this.#caches.delete(cacheName);
    }
    async keys() {
      return webidl.brandCheck(this, CacheStorage), [...this.#caches.keys()];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: !0
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/cookies/constants.js
var require_constants16 = __commonJS((exports, module) => {
  module.exports = {
    maxAttributeValueSize: 1024,
    maxNameValuePairSize: 4096
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/cookies/util.js
var require_util19 = __commonJS((exports, module) => {
  var assert = __require("assert"), { kHeadersList } = require_symbols6();
  function isCTLExcludingHtab(value) {
    if (value.length === 0)
      return !1;
    for (let char of value) {
      let code = char.charCodeAt(0);
      if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127)
        return !1;
    }
  }
  function validateCookieName(name) {
    for (let char of name) {
      let code = char.charCodeAt(0);
      if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}")
        throw Error("Invalid cookie name");
    }
  }
  function validateCookieValue(value) {
    for (let char of value) {
      let code = char.charCodeAt(0);
      if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126)
        throw Error("Invalid header value");
    }
  }
  function validateCookiePath(path) {
    for (let char of path)
      if (char.charCodeAt(0) < 33 || char === ";")
        throw Error("Invalid cookie path");
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-"))
      throw Error("Invalid cookie domain");
  }
  function toIMFDate(date) {
    if (typeof date === "number")
      date = new Date(date);
    let days = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ], months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ], dayName = days[date.getUTCDay()], day = date.getUTCDate().toString().padStart(2, "0"), month = months[date.getUTCMonth()], year = date.getUTCFullYear(), hour = date.getUTCHours().toString().padStart(2, "0"), minute = date.getUTCMinutes().toString().padStart(2, "0"), second = date.getUTCSeconds().toString().padStart(2, "0");
    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0)
      throw Error("Invalid cookie max-age");
  }
  function stringify(cookie) {
    if (cookie.name.length === 0)
      return null;
    validateCookieName(cookie.name), validateCookieValue(cookie.value);
    let out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-"))
      cookie.secure = !0;
    if (cookie.name.startsWith("__Host-"))
      cookie.secure = !0, cookie.domain = null, cookie.path = "/";
    if (cookie.secure)
      out.push("Secure");
    if (cookie.httpOnly)
      out.push("HttpOnly");
    if (typeof cookie.maxAge === "number")
      validateCookieMaxAge(cookie.maxAge), out.push(`Max-Age=${cookie.maxAge}`);
    if (cookie.domain)
      validateCookieDomain(cookie.domain), out.push(`Domain=${cookie.domain}`);
    if (cookie.path)
      validateCookiePath(cookie.path), out.push(`Path=${cookie.path}`);
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date")
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    if (cookie.sameSite)
      out.push(`SameSite=${cookie.sameSite}`);
    for (let part of cookie.unparsed) {
      if (!part.includes("="))
        throw Error("Invalid unparsed");
      let [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  var kHeadersListNode;
  function getHeadersList(headers) {
    if (headers[kHeadersList])
      return headers[kHeadersList];
    if (!kHeadersListNode)
      kHeadersListNode = Object.getOwnPropertySymbols(headers).find((symbol) => symbol.description === "headers list"), assert(kHeadersListNode, "Headers cannot be parsed");
    let headersList = headers[kHeadersListNode];
    return assert(headersList), headersList;
  }
  module.exports = {
    isCTLExcludingHtab,
    stringify,
    getHeadersList
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/cookies/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var { maxNameValuePairSize, maxAttributeValueSize } = require_constants16(), { isCTLExcludingHtab } = require_util19(), { collectASequenceOfCodePointsFast } = require_dataURL2(), assert = __require("assert");
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header))
      return null;
    let nameValuePair = "", unparsedAttributes = "", name = "", value = "";
    if (header.includes(";")) {
      let position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position), unparsedAttributes = header.slice(position.position);
    } else
      nameValuePair = header;
    if (!nameValuePair.includes("="))
      value = nameValuePair;
    else {
      let position = { position: 0 };
      name = collectASequenceOfCodePointsFast("=", nameValuePair, position), value = nameValuePair.slice(position.position + 1);
    }
    if (name = name.trim(), value = value.trim(), name.length + value.length > maxNameValuePairSize)
      return null;
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0)
      return cookieAttributeList;
    assert(unparsedAttributes[0] === ";"), unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";"))
      cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 }), unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    else
      cookieAv = unparsedAttributes, unparsedAttributes = "";
    let attributeName = "", attributeValue = "";
    if (cookieAv.includes("=")) {
      let position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position), attributeValue = cookieAv.slice(position.position + 1);
    } else
      attributeName = cookieAv;
    if (attributeName = attributeName.trim(), attributeValue = attributeValue.trim(), attributeValue.length > maxAttributeValueSize)
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    let attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      let expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      let charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-")
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      if (!/^\d+$/.test(attributeValue))
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      let deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".")
        cookieDomain = cookieDomain.slice(1);
      cookieDomain = cookieDomain.toLowerCase(), cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/")
        cookiePath = "/";
      else
        cookiePath = attributeValue;
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure")
      cookieAttributeList.secure = !0;
    else if (attributeNameLowercase === "httponly")
      cookieAttributeList.httpOnly = !0;
    else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default", attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none"))
        enforcement = "None";
      if (attributeValueLowercase.includes("strict"))
        enforcement = "Strict";
      if (attributeValueLowercase.includes("lax"))
        enforcement = "Lax";
      cookieAttributeList.sameSite = enforcement;
    } else
      cookieAttributeList.unparsed ??= [], cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  module.exports = {
    parseSetCookie,
    parseUnparsedAttributes
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/cookies/index.js
var require_cookies2 = __commonJS((exports, module) => {
  var { parseSetCookie } = require_parse2(), { stringify, getHeadersList } = require_util19(), { webidl } = require_webidl2(), { Headers } = require_headers3();
  function getCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" }), webidl.brandCheck(headers, Headers, { strict: !1 });
    let cookie = headers.get("cookie"), out = {};
    if (!cookie)
      return out;
    for (let piece of cookie.split(";")) {
      let [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers, name, attributes) {
    webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" }), webidl.brandCheck(headers, Headers, { strict: !1 }), name = webidl.converters.DOMString(name), attributes = webidl.converters.DeleteCookieAttributes(attributes), setCookie(headers, {
      name,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" }), webidl.brandCheck(headers, Headers, { strict: !1 });
    let cookies = getHeadersList(headers).cookies;
    if (!cookies)
      return [];
    return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
  }
  function setCookie(headers, cookie) {
    if (webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" }), webidl.brandCheck(headers, Headers, { strict: !1 }), cookie = webidl.converters.Cookie(cookie), stringify(cookie))
      headers.append("Set-Cookie", stringify(cookie));
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number")
          return webidl.converters["unsigned long long"](value);
        return new Date(value);
      }),
      key: "expires",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: []
    }
  ]);
  module.exports = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/websocket/constants.js
var require_constants17 = __commonJS((exports, module) => {
  var staticPropertyDescriptors = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  }, states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  }, opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  }, parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  }, emptyBuffer = Buffer.allocUnsafe(0);
  module.exports = {
    uid: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit: 65535,
    parserStates,
    emptyBuffer
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/websocket/symbols.js
var require_symbols10 = __commonJS((exports, module) => {
  module.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/websocket/events.js
var require_events2 = __commonJS((exports, module) => {
  var { webidl } = require_webidl2(), { kEnumerableProperty } = require_util14(), { MessagePort } = __require("worker_threads");

  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" }), type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get data() {
      return webidl.brandCheck(this, MessageEvent), this.#eventInit.data;
    }
    get origin() {
      return webidl.brandCheck(this, MessageEvent), this.#eventInit.origin;
    }
    get lastEventId() {
      return webidl.brandCheck(this, MessageEvent), this.#eventInit.lastEventId;
    }
    get source() {
      return webidl.brandCheck(this, MessageEvent), this.#eventInit.source;
    }
    get ports() {
      if (webidl.brandCheck(this, MessageEvent), !Object.isFrozen(this.#eventInit.ports))
        Object.freeze(this.#eventInit.ports);
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = !1, cancelable = !1, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      return webidl.brandCheck(this, MessageEvent), webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" }), new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
  }

  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" }), type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get wasClean() {
      return webidl.brandCheck(this, CloseEvent), this.#eventInit.wasClean;
    }
    get code() {
      return webidl.brandCheck(this, CloseEvent), this.#eventInit.code;
    }
    get reason() {
      return webidl.brandCheck(this, CloseEvent), this.#eventInit.reason;
    }
  }

  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
      super(type, eventInitDict);
      type = webidl.converters.DOMString(type), eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {}), this.#eventInit = eventInitDict;
    }
    get message() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.message;
    }
    get filename() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.filename;
    }
    get lineno() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.lineno;
    }
    get colno() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.colno;
    }
    get error() {
      return webidl.brandCheck(this, ErrorEvent), this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: !0
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: !0
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: !0
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
  var eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: !1
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "source",
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      }
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: !1
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    MessageEvent,
    CloseEvent,
    ErrorEvent
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/websocket/util.js
var require_util20 = __commonJS((exports, module) => {
  var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols10(), { states, opcodes } = require_constants17(), { MessageEvent, ErrorEvent } = require_events2();
  function isEstablished(ws) {
    return ws[kReadyState] === states.OPEN;
  }
  function isClosing(ws) {
    return ws[kReadyState] === states.CLOSING;
  }
  function isClosed(ws) {
    return ws[kReadyState] === states.CLOSED;
  }
  function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
    let event = new eventConstructor(e, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN)
      return;
    let dataForEvent;
    if (type === opcodes.TEXT)
      try {
        dataForEvent = new TextDecoder("utf-8", { fatal: !0 }).decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    else if (type === opcodes.BINARY)
      if (ws[kBinaryType] === "blob")
        dataForEvent = new Blob([data]);
      else
        dataForEvent = new Uint8Array(data).buffer;
    fireEvent("message", ws, MessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0)
      return !1;
    for (let char of protocol) {
      let code = char.charCodeAt(0);
      if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || code === 9)
        return !1;
    }
    return !0;
  }
  function isValidStatusCode(code) {
    if (code >= 1000 && code < 1015)
      return code !== 1004 && code !== 1005 && code !== 1006;
    return code >= 3000 && code <= 4999;
  }
  function failWebsocketConnection(ws, reason) {
    let { [kController]: controller, [kResponse]: response } = ws;
    if (controller.abort(), response?.socket && !response.socket.destroyed)
      response.socket.destroy();
    if (reason)
      fireEvent("error", ws, ErrorEvent, {
        error: Error(reason)
      });
  }
  module.exports = {
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/websocket/connection.js
var require_connection2 = __commonJS((exports, module) => {
  var diagnosticsChannel = __require("diagnostics_channel"), { uid, states } = require_constants17(), {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose
  } = require_symbols10(), { fireEvent, failWebsocketConnection } = require_util20(), { CloseEvent } = require_events2(), { makeRequest } = require_request4(), { fetching } = require_fetch2(), { Headers } = require_headers3(), { getGlobalDispatcher } = require_global4(), { kHeadersList } = require_symbols6(), channels = {};
  channels.open = diagnosticsChannel.channel("undici:websocket:open");
  channels.close = diagnosticsChannel.channel("undici:websocket:close");
  channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
  var crypto2;
  try {
    crypto2 = __require("crypto");
  } catch {}
  function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
    let requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    let request = makeRequest({
      urlList: [requestURL],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      let headersList = new Headers(options.headers)[kHeadersList];
      request.headersList = headersList;
    }
    let keyValue = crypto2.randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue), request.headersList.append("sec-websocket-version", "13");
    for (let protocol of protocols)
      request.headersList.append("sec-websocket-protocol", protocol);
    let permessageDeflate = "";
    return fetching({
      request,
      useParallelQueue: !0,
      dispatcher: options.dispatcher ?? getGlobalDispatcher(),
      processResponse(response) {
        if (response.type === "error" || response.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        let secWSAccept = response.headersList.get("Sec-WebSocket-Accept"), digest = crypto2.createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        let secExtension = response.headersList.get("Sec-WebSocket-Extensions");
        if (secExtension !== null && secExtension !== permessageDeflate) {
          failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
          return;
        }
        let secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
          return;
        }
        if (response.socket.on("data", onSocketData), response.socket.on("close", onSocketClose), response.socket.on("error", onSocketError), channels.open.hasSubscribers)
          channels.open.publish({
            address: response.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        onEstablish(response);
      }
    });
  }
  function onSocketData(chunk) {
    if (!this.ws[kByteParser].write(chunk))
      this.pause();
  }
  function onSocketClose() {
    let { ws } = this, wasClean = ws[kSentClose] && ws[kReceivedClose], code = 1005, reason = "", result = ws[kByteParser].closingInfo;
    if (result)
      code = result.code ?? 1005, reason = result.reason;
    else if (!ws[kSentClose])
      code = 1006;
    if (ws[kReadyState] = states.CLOSED, fireEvent("close", ws, CloseEvent, {
      wasClean,
      code,
      reason
    }), channels.close.hasSubscribers)
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
  }
  function onSocketError(error) {
    let { ws } = this;
    if (ws[kReadyState] = states.CLOSING, channels.socketError.hasSubscribers)
      channels.socketError.publish(error);
    this.destroy();
  }
  module.exports = {
    establishWebSocketConnection
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/websocket/frame.js
var require_frame2 = __commonJS((exports, module) => {
  var { maxUnsigned16Bit } = require_constants17(), crypto2;
  try {
    crypto2 = __require("crypto");
  } catch {}

  class WebsocketFrameSend {
    constructor(data) {
      this.frameData = data, this.maskKey = crypto2.randomBytes(4);
    }
    createFrame(opcode) {
      let bodyLength = this.frameData?.byteLength ?? 0, payloadLength = bodyLength, offset = 6;
      if (bodyLength > maxUnsigned16Bit)
        offset += 8, payloadLength = 127;
      else if (bodyLength > 125)
        offset += 2, payloadLength = 126;
      let buffer = Buffer.allocUnsafe(bodyLength + offset);
      buffer[0] = buffer[1] = 0, buffer[0] |= 128, buffer[0] = (buffer[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      if (buffer[offset - 4] = this.maskKey[0], buffer[offset - 3] = this.maskKey[1], buffer[offset - 2] = this.maskKey[2], buffer[offset - 1] = this.maskKey[3], buffer[1] = payloadLength, payloadLength === 126)
        buffer.writeUInt16BE(bodyLength, 2);
      else if (payloadLength === 127)
        buffer[2] = buffer[3] = 0, buffer.writeUIntBE(bodyLength, 4, 6);
      buffer[1] |= 128;
      for (let i = 0;i < bodyLength; i++)
        buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
      return buffer;
    }
  }
  module.exports = {
    WebsocketFrameSend
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/websocket/receiver.js
var require_receiver2 = __commonJS((exports, module) => {
  var { Writable } = __require("stream"), diagnosticsChannel = __require("diagnostics_channel"), { parserStates, opcodes, states, emptyBuffer } = require_constants17(), { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols10(), { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util20(), { WebsocketFrameSend } = require_frame2(), channels = {};
  channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
  channels.pong = diagnosticsChannel.channel("undici:websocket:pong");

  class ByteParser extends Writable {
    #buffers = [];
    #byteOffset = 0;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    constructor(ws) {
      super();
      this.ws = ws;
    }
    _write(chunk, _2, callback) {
      this.#buffers.push(chunk), this.#byteOffset += chunk.length, this.run(callback);
    }
    run(callback) {
      while (!0) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2)
            return callback();
          let buffer = this.consume(2);
          if (this.#info.fin = (buffer[0] & 128) !== 0, this.#info.opcode = buffer[0] & 15, this.#info.originalOpcode ??= this.#info.opcode, this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION, this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          let payloadLength = buffer[1] & 127;
          if (payloadLength <= 125)
            this.#info.payloadLength = payloadLength, this.#state = parserStates.READ_DATA;
          else if (payloadLength === 126)
            this.#state = parserStates.PAYLOADLENGTH_16;
          else if (payloadLength === 127)
            this.#state = parserStates.PAYLOADLENGTH_64;
          if (this.#info.fragmented && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (this.#info.opcode === opcodes.CLOSE) {
            if (payloadLength === 1) {
              failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            let body = this.consume(payloadLength);
            if (this.#info.closeInfo = this.parseCloseBody(!1, body), !this.ws[kSentClose]) {
              let body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(this.#info.closeInfo.code, 0);
              let closeFrame = new WebsocketFrameSend(body2);
              this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
                if (!err)
                  this.ws[kSentClose] = !0;
              });
            }
            this.ws[kReadyState] = states.CLOSING, this.ws[kReceivedClose] = !0, this.end();
            return;
          } else if (this.#info.opcode === opcodes.PING) {
            let body = this.consume(payloadLength);
            if (!this.ws[kReceivedClose]) {
              let frame = new WebsocketFrameSend(body);
              if (this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG)), channels.ping.hasSubscribers)
                channels.ping.publish({
                  payload: body
                });
            }
            if (this.#state = parserStates.INFO, this.#byteOffset > 0)
              continue;
            else {
              callback();
              return;
            }
          } else if (this.#info.opcode === opcodes.PONG) {
            let body = this.consume(payloadLength);
            if (channels.pong.hasSubscribers)
              channels.pong.publish({
                payload: body
              });
            if (this.#byteOffset > 0)
              continue;
            else {
              callback();
              return;
            }
          }
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2)
            return callback();
          let buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0), this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8)
            return callback();
          let buffer = this.consume(8), upper = buffer.readUInt32BE(0);
          if (upper > 2147483647) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          let lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower, this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength)
            return callback();
          else if (this.#byteOffset >= this.#info.payloadLength) {
            let body = this.consume(this.#info.payloadLength);
            if (this.#fragments.push(body), !this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
              let fullMessage = Buffer.concat(this.#fragments);
              websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage), this.#info = {}, this.#fragments.length = 0;
            }
            this.#state = parserStates.INFO;
          }
        }
        if (this.#byteOffset > 0)
          continue;
        else {
          callback();
          break;
        }
      }
    }
    consume(n) {
      if (n > this.#byteOffset)
        return null;
      else if (n === 0)
        return emptyBuffer;
      if (this.#buffers[0].length === n)
        return this.#byteOffset -= this.#buffers[0].length, this.#buffers.shift();
      let buffer = Buffer.allocUnsafe(n), offset = 0;
      while (offset !== n) {
        let next = this.#buffers[0], { length } = next;
        if (length + offset === n) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset), this.#buffers[0] = next.subarray(n - offset);
          break;
        } else
          buffer.set(this.#buffers.shift(), offset), offset += next.length;
      }
      return this.#byteOffset -= n, buffer;
    }
    parseCloseBody(onlyCode, data) {
      let code;
      if (data.length >= 2)
        code = data.readUInt16BE(0);
      if (onlyCode) {
        if (!isValidStatusCode(code))
          return null;
        return { code };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191)
        reason = reason.subarray(3);
      if (code !== void 0 && !isValidStatusCode(code))
        return null;
      try {
        reason = new TextDecoder("utf-8", { fatal: !0 }).decode(reason);
      } catch {
        return null;
      }
      return { code, reason };
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  module.exports = {
    ByteParser
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/lib/websocket/websocket.js
var require_websocket2 = __commonJS((exports, module) => {
  var { webidl } = require_webidl2(), { DOMException: DOMException2 } = require_constants14(), { URLSerializer } = require_dataURL2(), { getGlobalOrigin } = require_global3(), { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants17(), {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = require_symbols10(), { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util20(), { establishWebSocketConnection } = require_connection2(), { WebsocketFrameSend } = require_frame2(), { ByteParser } = require_receiver2(), { kEnumerableProperty, isBlobLike } = require_util14(), { getGlobalDispatcher } = require_global4(), { types } = __require("util"), experimentalWarned = !1;

  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    constructor(url, protocols = []) {
      super();
      if (webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" }), !experimentalWarned)
        experimentalWarned = !0, process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
          code: "UNDICI-WS"
        });
      let options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
      url = webidl.converters.USVString(url), protocols = options.protocols;
      let baseURL = getGlobalOrigin(), urlRecord;
      try {
        urlRecord = new URL(url, baseURL);
      } catch (e) {
        throw new DOMException2(e, "SyntaxError");
      }
      if (urlRecord.protocol === "http:")
        urlRecord.protocol = "ws:";
      else if (urlRecord.protocol === "https:")
        urlRecord.protocol = "wss:";
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:")
        throw new DOMException2(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
      if (urlRecord.hash || urlRecord.href.endsWith("#"))
        throw new DOMException2("Got fragment", "SyntaxError");
      if (typeof protocols === "string")
        protocols = [protocols];
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size)
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p)))
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      this[kWebSocketURL] = new URL(urlRecord.href), this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options), this[kReadyState] = WebSocket.CONNECTING, this[kBinaryType] = "blob";
    }
    close(code = void 0, reason = void 0) {
      if (webidl.brandCheck(this, WebSocket), code !== void 0)
        code = webidl.converters["unsigned short"](code, { clamp: !0 });
      if (reason !== void 0)
        reason = webidl.converters.USVString(reason);
      if (code !== void 0) {
        if (code !== 1000 && (code < 3000 || code > 4999))
          throw new DOMException2("invalid code", "InvalidAccessError");
      }
      let reasonByteLength = 0;
      if (reason !== void 0) {
        if (reasonByteLength = Buffer.byteLength(reason), reasonByteLength > 123)
          throw new DOMException2(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
      }
      if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED)
        ;
      else if (!isEstablished(this))
        failWebsocketConnection(this, "Connection was closed before it was established."), this[kReadyState] = WebSocket.CLOSING;
      else if (!isClosing(this)) {
        let frame = new WebsocketFrameSend;
        if (code !== void 0 && reason === void 0)
          frame.frameData = Buffer.allocUnsafe(2), frame.frameData.writeUInt16BE(code, 0);
        else if (code !== void 0 && reason !== void 0)
          frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength), frame.frameData.writeUInt16BE(code, 0), frame.frameData.write(reason, 2, "utf-8");
        else
          frame.frameData = emptyBuffer;
        this[kResponse].socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
          if (!err)
            this[kSentClose] = !0;
        }), this[kReadyState] = states.CLOSING;
      } else
        this[kReadyState] = WebSocket.CLOSING;
    }
    send(data) {
      if (webidl.brandCheck(this, WebSocket), webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" }), data = webidl.converters.WebSocketSendData(data), this[kReadyState] === WebSocket.CONNECTING)
        throw new DOMException2("Sent before connected.", "InvalidStateError");
      if (!isEstablished(this) || isClosing(this))
        return;
      let socket = this[kResponse].socket;
      if (typeof data === "string") {
        let value = Buffer.from(data), buffer = new WebsocketFrameSend(value).createFrame(opcodes.TEXT);
        this.#bufferedAmount += value.byteLength, socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (types.isArrayBuffer(data)) {
        let value = Buffer.from(data), buffer = new WebsocketFrameSend(value).createFrame(opcodes.BINARY);
        this.#bufferedAmount += value.byteLength, socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (ArrayBuffer.isView(data)) {
        let ab = Buffer.from(data, data.byteOffset, data.byteLength), buffer = new WebsocketFrameSend(ab).createFrame(opcodes.BINARY);
        this.#bufferedAmount += ab.byteLength, socket.write(buffer, () => {
          this.#bufferedAmount -= ab.byteLength;
        });
      } else if (isBlobLike(data)) {
        let frame = new WebsocketFrameSend;
        data.arrayBuffer().then((ab) => {
          let value = Buffer.from(ab);
          frame.frameData = value;
          let buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength, socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        });
      }
    }
    get readyState() {
      return webidl.brandCheck(this, WebSocket), this[kReadyState];
    }
    get bufferedAmount() {
      return webidl.brandCheck(this, WebSocket), this.#bufferedAmount;
    }
    get url() {
      return webidl.brandCheck(this, WebSocket), URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      return webidl.brandCheck(this, WebSocket), this.#extensions;
    }
    get protocol() {
      return webidl.brandCheck(this, WebSocket), this.#protocol;
    }
    get onopen() {
      return webidl.brandCheck(this, WebSocket), this.#events.open;
    }
    set onopen(fn) {
      if (webidl.brandCheck(this, WebSocket), this.#events.open)
        this.removeEventListener("open", this.#events.open);
      if (typeof fn === "function")
        this.#events.open = fn, this.addEventListener("open", fn);
      else
        this.#events.open = null;
    }
    get onerror() {
      return webidl.brandCheck(this, WebSocket), this.#events.error;
    }
    set onerror(fn) {
      if (webidl.brandCheck(this, WebSocket), this.#events.error)
        this.removeEventListener("error", this.#events.error);
      if (typeof fn === "function")
        this.#events.error = fn, this.addEventListener("error", fn);
      else
        this.#events.error = null;
    }
    get onclose() {
      return webidl.brandCheck(this, WebSocket), this.#events.close;
    }
    set onclose(fn) {
      if (webidl.brandCheck(this, WebSocket), this.#events.close)
        this.removeEventListener("close", this.#events.close);
      if (typeof fn === "function")
        this.#events.close = fn, this.addEventListener("close", fn);
      else
        this.#events.close = null;
    }
    get onmessage() {
      return webidl.brandCheck(this, WebSocket), this.#events.message;
    }
    set onmessage(fn) {
      if (webidl.brandCheck(this, WebSocket), this.#events.message)
        this.removeEventListener("message", this.#events.message);
      if (typeof fn === "function")
        this.#events.message = fn, this.addEventListener("message", fn);
      else
        this.#events.message = null;
    }
    get binaryType() {
      return webidl.brandCheck(this, WebSocket), this[kBinaryType];
    }
    set binaryType(type) {
      if (webidl.brandCheck(this, WebSocket), type !== "blob" && type !== "arraybuffer")
        this[kBinaryType] = "blob";
      else
        this[kBinaryType] = type;
    }
    #onConnectionEstablished(response) {
      this[kResponse] = response;
      let parser = new ByteParser(this);
      parser.on("drain", function() {
        this.ws[kResponse].socket.resume();
      }), response.socket.ws = this, this[kByteParser] = parser, this[kReadyState] = states.OPEN;
      let extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null)
        this.#extensions = extensions;
      let protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null)
        this.#protocol = protocol;
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
    if (webidl.util.Type(V) === "Object" && Symbol.iterator in V)
      return webidl.converters["sequence<DOMString>"](V);
    return webidl.converters.DOMString(V);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      }
    },
    {
      key: "dispatcher",
      converter: (V) => V,
      get defaultValue() {
        return getGlobalDispatcher();
      }
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V))
      return webidl.converters.WebSocketInit(V);
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V))
        return webidl.converters.Blob(V, { strict: !1 });
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V))
        return webidl.converters.BufferSource(V);
    }
    return webidl.converters.USVString(V);
  };
  module.exports = {
    WebSocket
  };
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/node_modules/undici/index.js
var require_undici2 = __commonJS((exports, module) => {
  var Client = require_client2(), Dispatcher = require_dispatcher2(), errors = require_errors4(), Pool = require_pool2(), BalancedPool = require_balanced_pool2(), Agent = require_agent2(), util = require_util14(), { InvalidArgumentError } = errors, api = require_api2(), buildConnector = require_connect2(), MockClient = require_mock_client2(), MockAgent = require_mock_agent2(), MockPool = require_mock_pool2(), mockErrors = require_mock_errors2(), ProxyAgent = require_proxy_agent2(), RetryHandler = require_RetryHandler2(), { getGlobalDispatcher, setGlobalDispatcher } = require_global4(), DecoratorHandler = require_DecoratorHandler2(), RedirectHandler = require_RedirectHandler2(), createRedirectInterceptor = require_redirectInterceptor2(), hasCrypto;
  try {
    __require("crypto"), hasCrypto = !0;
  } catch {
    hasCrypto = !1;
  }
  Object.assign(Dispatcher.prototype, api);
  exports.Dispatcher = Dispatcher;
  exports.Client = Client;
  exports.Pool = Pool;
  exports.BalancedPool = BalancedPool;
  exports.Agent = Agent;
  exports.ProxyAgent = ProxyAgent;
  exports.RetryHandler = RetryHandler;
  exports.DecoratorHandler = DecoratorHandler;
  exports.RedirectHandler = RedirectHandler;
  exports.createRedirectInterceptor = createRedirectInterceptor;
  exports.buildConnector = buildConnector;
  exports.errors = errors;
  function makeDispatcher(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function")
        handler = opts, opts = null;
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL))
        throw new InvalidArgumentError("invalid url");
      if (opts != null && typeof opts !== "object")
        throw new InvalidArgumentError("invalid opts");
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string")
          throw new InvalidArgumentError("invalid opts.path");
        let path = opts.path;
        if (!opts.path.startsWith("/"))
          path = `/${path}`;
        url = new URL(util.parseOrigin(url).origin + path);
      } else {
        if (!opts)
          opts = typeof url === "object" ? url : {};
        url = util.parseURL(url);
      }
      let { agent, dispatcher = getGlobalDispatcher() } = opts;
      if (agent)
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      return fn.call(dispatcher, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  }
  exports.setGlobalDispatcher = setGlobalDispatcher;
  exports.getGlobalDispatcher = getGlobalDispatcher;
  if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
    let fetchImpl = null;
    exports.fetch = async function(resource) {
      if (!fetchImpl)
        fetchImpl = require_fetch2().fetch;
      try {
        return await fetchImpl(...arguments);
      } catch (err) {
        if (typeof err === "object")
          Error.captureStackTrace(err, this);
        throw err;
      }
    }, exports.Headers = require_headers3().Headers, exports.Response = require_response3().Response, exports.Request = require_request4().Request, exports.FormData = require_formdata2().FormData, exports.File = require_file4().File, exports.FileReader = require_filereader2().FileReader;
    let { setGlobalOrigin, getGlobalOrigin } = require_global3();
    exports.setGlobalOrigin = setGlobalOrigin, exports.getGlobalOrigin = getGlobalOrigin;
    let { CacheStorage } = require_cachestorage2(), { kConstruct } = require_symbols9();
    exports.caches = new CacheStorage(kConstruct);
  }
  if (util.nodeMajor >= 16) {
    let { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies2();
    exports.deleteCookie = deleteCookie, exports.getCookies = getCookies, exports.getSetCookies = getSetCookies, exports.setCookie = setCookie;
    let { parseMIMEType, serializeAMimeType } = require_dataURL2();
    exports.parseMIMEType = parseMIMEType, exports.serializeAMimeType = serializeAMimeType;
  }
  if (util.nodeMajor >= 18 && hasCrypto) {
    let { WebSocket } = require_websocket2();
    exports.WebSocket = WebSocket;
  }
  exports.request = makeDispatcher(api.request);
  exports.stream = makeDispatcher(api.stream);
  exports.pipeline = makeDispatcher(api.pipeline);
  exports.connect = makeDispatcher(api.connect);
  exports.upgrade = makeDispatcher(api.upgrade);
  exports.MockClient = MockClient;
  exports.MockPool = MockPool;
  exports.MockAgent = MockAgent;
  exports.mockErrors = mockErrors;
});

// node_modules/@actions/artifact/node_modules/@actions/github/node_modules/@actions/http-client/lib/index.js
var require_lib3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    return __setModuleDefault(result, mod), result;
  }, __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
  var http = __importStar(__require("http")), https = __importStar(__require("https")), pm = __importStar(require_proxy2()), tunnel = __importStar(require_tunnel()), undici_1 = require_undici2(), HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2.OK = 200] = "OK", HttpCodes2[HttpCodes2.MultipleChoices = 300] = "MultipleChoices", HttpCodes2[HttpCodes2.MovedPermanently = 301] = "MovedPermanently", HttpCodes2[HttpCodes2.ResourceMoved = 302] = "ResourceMoved", HttpCodes2[HttpCodes2.SeeOther = 303] = "SeeOther", HttpCodes2[HttpCodes2.NotModified = 304] = "NotModified", HttpCodes2[HttpCodes2.UseProxy = 305] = "UseProxy", HttpCodes2[HttpCodes2.SwitchProxy = 306] = "SwitchProxy", HttpCodes2[HttpCodes2.TemporaryRedirect = 307] = "TemporaryRedirect", HttpCodes2[HttpCodes2.PermanentRedirect = 308] = "PermanentRedirect", HttpCodes2[HttpCodes2.BadRequest = 400] = "BadRequest", HttpCodes2[HttpCodes2.Unauthorized = 401] = "Unauthorized", HttpCodes2[HttpCodes2.PaymentRequired = 402] = "PaymentRequired", HttpCodes2[HttpCodes2.Forbidden = 403] = "Forbidden", HttpCodes2[HttpCodes2.NotFound = 404] = "NotFound", HttpCodes2[HttpCodes2.MethodNotAllowed = 405] = "MethodNotAllowed", HttpCodes2[HttpCodes2.NotAcceptable = 406] = "NotAcceptable", HttpCodes2[HttpCodes2.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", HttpCodes2[HttpCodes2.RequestTimeout = 408] = "RequestTimeout", HttpCodes2[HttpCodes2.Conflict = 409] = "Conflict", HttpCodes2[HttpCodes2.Gone = 410] = "Gone", HttpCodes2[HttpCodes2.TooManyRequests = 429] = "TooManyRequests", HttpCodes2[HttpCodes2.InternalServerError = 500] = "InternalServerError", HttpCodes2[HttpCodes2.NotImplemented = 501] = "NotImplemented", HttpCodes2[HttpCodes2.BadGateway = 502] = "BadGateway", HttpCodes2[HttpCodes2.ServiceUnavailable = 503] = "ServiceUnavailable", HttpCodes2[HttpCodes2.GatewayTimeout = 504] = "GatewayTimeout";
  })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2.Accept = "accept", Headers2.ContentType = "content-type";
  })(Headers || (exports.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2.ApplicationJson = "application/json";
  })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  exports.getProxyUrl = getProxyUrl;
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ], HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ], RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"], ExponentialBackoffCeiling = 10, ExponentialBackoffTimeSlice = 5;

  class HttpClientError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError", this.statusCode = statusCode, Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  exports.HttpClientError = HttpClientError;

  class HttpClientResponse {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          }), this.message.on("end", () => {
            resolve(output.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
          let chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          }), this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  exports.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    return new URL(requestUrl).protocol === "https:";
  }
  exports.isHttps = isHttps;

  class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
      if (this._ignoreSslError = !1, this._allowRedirects = !0, this._allowRedirectDowngrade = !1, this._maxRedirects = 50, this._allowRetries = !1, this._maxRetries = 1, this._keepAlive = !1, this._disposed = !1, this.userAgent = userAgent, this.handlers = handlers || [], this.requestOptions = requestOptions, requestOptions) {
        if (requestOptions.ignoreSslError != null)
          this._ignoreSslError = requestOptions.ignoreSslError;
        if (this._socketTimeout = requestOptions.socketTimeout, requestOptions.allowRedirects != null)
          this._allowRedirects = requestOptions.allowRedirects;
        if (requestOptions.allowRedirectDowngrade != null)
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        if (requestOptions.maxRedirects != null)
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        if (requestOptions.keepAlive != null)
          this._keepAlive = requestOptions.keepAlive;
        if (requestOptions.allowRetries != null)
          this._allowRetries = requestOptions.allowRetries;
        if (requestOptions.maxRetries != null)
          this._maxRetries = requestOptions.maxRetries;
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      });
    }
    getJson(requestUrl, additionalHeaders = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        let res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    request(verb, requestUrl, data, headers) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._disposed)
          throw Error("Client has already been disposed.");
        let parsedUrl = new URL(requestUrl), info = this._prepareRequest(verb, parsedUrl, headers), maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1, numTries = 0, response;
        do {
          if (response = yield this.requestRaw(info, data), response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (let handler of this.handlers)
              if (handler.canHandleAuthentication(response)) {
                authenticationHandler = handler;
                break;
              }
            if (authenticationHandler)
              return authenticationHandler.handleAuthentication(this, info, data);
            else
              return response;
          }
          let redirectsRemaining = this._maxRedirects;
          while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            let redirectUrl = response.message.headers.location;
            if (!redirectUrl)
              break;
            let parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade)
              throw Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            if (yield response.readBody(), parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (let header in headers)
                if (header.toLowerCase() === "authorization")
                  delete headers[header];
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers), response = yield this.requestRaw(info, data), redirectsRemaining--;
          }
          if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode))
            return response;
          if (numTries += 1, numTries < maxTries)
            yield response.readBody(), yield this._performExponentialBackoff(numTries);
        } while (numTries < maxTries);
        return response;
      });
    }
    dispose() {
      if (this._agent)
        this._agent.destroy();
      this._disposed = !0;
    }
    requestRaw(info, data) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          function callbackForResult(err, res) {
            if (err)
              reject(err);
            else if (!res)
              reject(Error("Unknown error"));
            else
              resolve(res);
          }
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      });
    }
    requestRawWithCallback(info, data, onResult) {
      if (typeof data === "string") {
        if (!info.options.headers)
          info.options.headers = {};
        info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = !1;
      function handleResult(err, res) {
        if (!callbackCalled)
          callbackCalled = !0, onResult(err, res);
      }
      let req = info.httpModule.request(info.options, (msg) => {
        let res = new HttpClientResponse(msg);
        handleResult(void 0, res);
      }), socket;
      if (req.on("socket", (sock) => {
        socket = sock;
      }), req.setTimeout(this._socketTimeout || 180000, () => {
        if (socket)
          socket.end();
        handleResult(Error(`Request timeout: ${info.options.path}`));
      }), req.on("error", function(err) {
        handleResult(err);
      }), data && typeof data === "string")
        req.write(data, "utf8");
      if (data && typeof data !== "string")
        data.on("close", function() {
          req.end();
        }), data.pipe(req);
      else
        req.end();
    }
    getAgent(serverUrl) {
      let parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      let parsedUrl = new URL(serverUrl), proxyUrl = pm.getProxyUrl(parsedUrl);
      if (!(proxyUrl && proxyUrl.hostname))
        return;
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      let info = {};
      info.parsedUrl = requestUrl;
      let usingSsl = info.parsedUrl.protocol === "https:";
      info.httpModule = usingSsl ? https : http;
      let defaultPort = usingSsl ? 443 : 80;
      if (info.options = {}, info.options.host = info.parsedUrl.hostname, info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort, info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || ""), info.options.method = method, info.options.headers = this._mergeHeaders(headers), this.userAgent != null)
        info.options.headers["user-agent"] = this.userAgent;
      if (info.options.agent = this._getAgent(info.parsedUrl), this.handlers)
        for (let handler of this.handlers)
          handler.prepareRequest(info.options);
      return info;
    }
    _mergeHeaders(headers) {
      if (this.requestOptions && this.requestOptions.headers)
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
      return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers)
        clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
      return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
      let agent, proxyUrl = pm.getProxyUrl(parsedUrl), useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy)
        agent = this._proxyAgent;
      if (!useProxy)
        agent = this._agent;
      if (agent)
        return agent;
      let usingSsl = parsedUrl.protocol === "https:", maxSockets = 100;
      if (this.requestOptions)
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      if (proxyUrl && proxyUrl.hostname) {
        let agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        }, tunnelAgent, overHttps = proxyUrl.protocol === "https:";
        if (usingSsl)
          tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
        else
          tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
        agent = tunnelAgent(agentOptions), this._proxyAgent = agent;
      }
      if (!agent) {
        let options = { keepAlive: this._keepAlive, maxSockets };
        agent = usingSsl ? new https.Agent(options) : new http.Agent(options), this._agent = agent;
      }
      if (usingSsl && this._ignoreSslError)
        agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: !1
        });
      return agent;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent;
      if (this._keepAlive)
        proxyAgent = this._proxyAgentDispatcher;
      if (proxyAgent)
        return proxyAgent;
      let usingSsl = parsedUrl.protocol === "https:";
      if (proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      })), this._proxyAgentDispatcher = proxyAgent, usingSsl && this._ignoreSslError)
        proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
          rejectUnauthorized: !1
        });
      return proxyAgent;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter(this, void 0, void 0, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        let ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      });
    }
    _processResponse(res, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          let statusCode = res.message.statusCode || 0, response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound)
            resolve(response);
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              let a = new Date(value);
              if (!isNaN(a.valueOf()))
                return a;
            }
            return value;
          }
          let obj, contents;
          try {
            if (contents = yield res.readBody(), contents && contents.length > 0) {
              if (options && options.deserializeDates)
                obj = JSON.parse(contents, dateTimeDeserializer);
              else
                obj = JSON.parse(contents);
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {}
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message)
              msg = obj.message;
            else if (contents && contents.length > 0)
              msg = contents;
            else
              msg = `Failed request: (${statusCode})`;
            let err = new HttpClientError(msg, statusCode);
            err.result = response.result, reject(err);
          } else
            resolve(response);
        }));
      });
    }
  }
  exports.HttpClient = HttpClient;
  var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
});

// node_modules/@actions/artifact/node_modules/@actions/github/lib/internal/utils.js
var require_utils7 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    return __setModuleDefault(result, mod), result;
  }, __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getApiBaseUrl = exports.getProxyFetch = exports.getProxyAgentDispatcher = exports.getProxyAgent = exports.getAuthString = void 0;
  var httpClient = __importStar(require_lib3()), undici_1 = require_undici();
  function getAuthString(token, options) {
    if (!token && !options.auth)
      throw Error("Parameter token or opts.auth is required");
    else if (token && options.auth)
      throw Error("Parameters token and opts.auth may not both be specified");
    return typeof options.auth === "string" ? options.auth : `token ${token}`;
  }
  exports.getAuthString = getAuthString;
  function getProxyAgent(destinationUrl) {
    return new httpClient.HttpClient().getAgent(destinationUrl);
  }
  exports.getProxyAgent = getProxyAgent;
  function getProxyAgentDispatcher(destinationUrl) {
    return new httpClient.HttpClient().getAgentDispatcher(destinationUrl);
  }
  exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
  function getProxyFetch(destinationUrl) {
    let httpDispatcher = getProxyAgentDispatcher(destinationUrl);
    return (url, opts) => __awaiter(this, void 0, void 0, function* () {
      return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
    });
  }
  exports.getProxyFetch = getProxyFetch;
  function getApiBaseUrl() {
    return process.env.GITHUB_API_URL || "https://api.github.com";
  }
  exports.getApiBaseUrl = getApiBaseUrl;
});

// node_modules/universal-user-agent/dist-node/index.js
var require_dist_node = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator)
      return navigator.userAgent;
    if (typeof process === "object" && process.version !== void 0)
      return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    return "<environment undetectable>";
  }
  exports.getUserAgent = getUserAgent;
});

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS((exports, module) => {
  module.exports = register;
  function register(state, name, method, options) {
    if (typeof method !== "function")
      throw Error("method for before hook must be a function");
    if (!options)
      options = {};
    if (Array.isArray(name))
      return name.reverse().reduce(function(callback, name2) {
        return register.bind(null, state, name2, callback, options);
      }, method)();
    return Promise.resolve().then(function() {
      if (!state.registry[name])
        return method(options);
      return state.registry[name].reduce(function(method2, registered) {
        return registered.hook.bind(null, method2, options);
      }, method)();
    });
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS((exports, module) => {
  module.exports = addHook;
  function addHook(state, kind, name, hook) {
    var orig = hook;
    if (!state.registry[name])
      state.registry[name] = [];
    if (kind === "before")
      hook = function(method, options) {
        return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
      };
    if (kind === "after")
      hook = function(method, options) {
        var result;
        return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
          return result = result_, orig(result, options);
        }).then(function() {
          return result;
        });
      };
    if (kind === "error")
      hook = function(method, options) {
        return Promise.resolve().then(method.bind(null, options)).catch(function(error) {
          return orig(error, options);
        });
      };
    state.registry[name].push({
      hook,
      orig
    });
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS((exports, module) => {
  module.exports = removeHook;
  function removeHook(state, name, method) {
    if (!state.registry[name])
      return;
    var index = state.registry[name].map(function(registered) {
      return registered.orig;
    }).indexOf(method);
    if (index === -1)
      return;
    state.registry[name].splice(index, 1);
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS((exports, module) => {
  var register = require_register(), addHook = require_add(), removeHook = require_remove(), bind = Function.bind, bindable = bind.bind(bind);
  function bindApi(hook, state, name) {
    var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
    hook.api = { remove: removeHookRef }, hook.remove = removeHookRef, ["before", "error", "after", "wrap"].forEach(function(kind) {
      var args = name ? [state, kind, name] : [state, kind];
      hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
    });
  }
  function HookSingular() {
    var singularHookName = "h", singularHookState = {
      registry: {}
    }, singularHook = register.bind(null, singularHookState, singularHookName);
    return bindApi(singularHook, singularHookState, singularHookName), singularHook;
  }
  function HookCollection() {
    var state = {
      registry: {}
    }, hook = register.bind(null, state);
    return bindApi(hook, state), hook;
  }
  var collectionHookDeprecationMessageDisplayed = !1;
  function Hook() {
    if (!collectionHookDeprecationMessageDisplayed)
      console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'), collectionHookDeprecationMessageDisplayed = !0;
    return HookCollection();
  }
  Hook.Singular = HookSingular.bind();
  Hook.Collection = HookCollection.bind();
  module.exports = Hook;
  module.exports.Hook = Hook;
  module.exports.Singular = Hook.Singular;
  module.exports.Collection = Hook.Collection;
});

// node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node2 = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    endpoint: () => endpoint
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_universal_user_agent = require_dist_node(), VERSION = "9.0.6", userAgent = `octokit-endpoint.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`, DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
      accept: "application/vnd.github.v3+json",
      "user-agent": userAgent
    },
    mediaType: {
      format: ""
    }
  };
  function lowercaseKeys(object) {
    if (!object)
      return {};
    return Object.keys(object).reduce((newObj, key) => {
      return newObj[key.toLowerCase()] = object[key], newObj;
    }, {});
  }
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
      return !1;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return !1;
    let proto = Object.getPrototypeOf(value);
    if (proto === null)
      return !0;
    let Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  function mergeDeep(defaults, options) {
    let result = Object.assign({}, defaults);
    return Object.keys(options).forEach((key) => {
      if (isPlainObject(options[key]))
        if (!(key in defaults))
          Object.assign(result, { [key]: options[key] });
        else
          result[key] = mergeDeep(defaults[key], options[key]);
      else
        Object.assign(result, { [key]: options[key] });
    }), result;
  }
  function removeUndefinedProperties(obj) {
    for (let key in obj)
      if (obj[key] === void 0)
        delete obj[key];
    return obj;
  }
  function merge(defaults, route, options) {
    if (typeof route === "string") {
      let [method, url] = route.split(" ");
      options = Object.assign(url ? { method, url } : { url: method }, options);
    } else
      options = Object.assign({}, route);
    options.headers = lowercaseKeys(options.headers), removeUndefinedProperties(options), removeUndefinedProperties(options.headers);
    let mergedOptions = mergeDeep(defaults || {}, options);
    if (options.url === "/graphql") {
      if (defaults && defaults.mediaType.previews?.length)
        mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
      mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
    }
    return mergedOptions;
  }
  function addQueryParameters(url, parameters) {
    let separator = /\?/.test(url) ? "&" : "?", names = Object.keys(parameters);
    if (names.length === 0)
      return url;
    return url + separator + names.map((name) => {
      if (name === "q")
        return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
      return `${name}=${encodeURIComponent(parameters[name])}`;
    }).join("&");
  }
  var urlVariableRegex = /\{[^{}}]+\}/g;
  function removeNonChars(variableName) {
    return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
  }
  function extractUrlVariableNames(url) {
    let matches = url.match(urlVariableRegex);
    if (!matches)
      return [];
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
  }
  function omit(object, keysToOmit) {
    let result = { __proto__: null };
    for (let key of Object.keys(object))
      if (keysToOmit.indexOf(key) === -1)
        result[key] = object[key];
    return result;
  }
  function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
      if (!/%[0-9A-Fa-f]/.test(part))
        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
      return part;
    }).join("");
  }
  function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeValue(operator, value, key) {
    if (value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value), key)
      return encodeUnreserved(key) + "=" + value;
    else
      return value;
  }
  function isDefined(value) {
    return value !== void 0 && value !== null;
  }
  function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
  }
  function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "")
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        if (value = value.toString(), modifier && modifier !== "*")
          value = value.substring(0, parseInt(modifier, 10));
        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
      } else if (modifier === "*")
        if (Array.isArray(value))
          value.filter(isDefined).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        else
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k]))
              result.push(encodeValue(operator, value[k], k));
          });
      else {
        let tmp = [];
        if (Array.isArray(value))
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        else
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k]))
              tmp.push(encodeUnreserved(k)), tmp.push(encodeValue(operator, value[k].toString()));
          });
        if (isKeyOperator(operator))
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        else if (tmp.length !== 0)
          result.push(tmp.join(","));
      }
    else if (operator === ";") {
      if (isDefined(value))
        result.push(encodeUnreserved(key));
    } else if (value === "" && (operator === "&" || operator === "?"))
      result.push(encodeUnreserved(key) + "=");
    else if (value === "")
      result.push("");
    return result;
  }
  function parseUrl(template) {
    return {
      expand: expand.bind(null, template)
    };
  }
  function expand(template, context) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    if (template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
      if (expression) {
        let operator = "", values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1)
          operator = expression.charAt(0), expression = expression.substr(1);
        if (expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        }), operator && operator !== "+") {
          var separator = ",";
          if (operator === "?")
            separator = "&";
          else if (operator !== "#")
            separator = operator;
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else
          return values.join(",");
      } else
        return encodeReserved(literal);
    }), template === "/")
      return template;
    else
      return template.replace(/\/$/, "");
  }
  function parse(options) {
    let method = options.method.toUpperCase(), url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}"), headers = Object.assign({}, options.headers), body, parameters = omit(options, [
      "method",
      "baseUrl",
      "url",
      "headers",
      "request",
      "mediaType"
    ]), urlVariableNames = extractUrlVariableNames(url);
    if (url = parseUrl(url).expand(parameters), !/^http/.test(url))
      url = options.baseUrl + url;
    let omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl"), remainingParameters = omit(parameters, omittedParameters);
    if (!/application\/octet-stream/i.test(headers.accept)) {
      if (options.mediaType.format)
        headers.accept = headers.accept.split(/,/).map((format) => format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
      if (url.endsWith("/graphql")) {
        if (options.mediaType.previews?.length) {
          let previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
          headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
            let format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
            return `application/vnd.github.${preview}-preview${format}`;
          }).join(",");
        }
      }
    }
    if (["GET", "HEAD"].includes(method))
      url = addQueryParameters(url, remainingParameters);
    else if ("data" in remainingParameters)
      body = remainingParameters.data;
    else if (Object.keys(remainingParameters).length)
      body = remainingParameters;
    if (!headers["content-type"] && typeof body < "u")
      headers["content-type"] = "application/json; charset=utf-8";
    if (["PATCH", "PUT"].includes(method) && typeof body > "u")
      body = "";
    return Object.assign({ method, url, headers }, typeof body < "u" ? { body } : null, options.request ? { request: options.request } : null);
  }
  function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
  }
  function withDefaults(oldDefaults, newDefaults) {
    let DEFAULTS2 = merge(oldDefaults, newDefaults), endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
    return Object.assign(endpoint2, {
      DEFAULTS: DEFAULTS2,
      defaults: withDefaults.bind(null, DEFAULTS2),
      merge: merge.bind(null, DEFAULTS2),
      parse
    });
  }
  var endpoint = withDefaults(null, DEFAULTS);
});

// node_modules/deprecation/dist-node/index.js
var require_dist_node3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });

  class Deprecation extends Error {
    constructor(message) {
      super(message);
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, this.constructor);
      this.name = "Deprecation";
    }
  }
  exports.Deprecation = Deprecation;
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports, module) => {
  module.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw TypeError("need wrapper function");
    return Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    }), wrapper;
    function wrapper() {
      var args = Array(arguments.length);
      for (var i = 0;i < args.length; i++)
        args[i] = arguments[i];
      var ret = fn.apply(this, args), cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2)
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      return ret;
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS((exports, module) => {
  var wrappy = require_wrappy();
  module.exports = wrappy(once);
  module.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: !0
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      return f.called = !0, f.value = fn.apply(this, arguments);
    };
    return f.called = !1, f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw Error(f.onceError);
      return f.called = !0, f.value = fn.apply(this, arguments);
    }, name = fn.name || "Function wrapped with `once`";
    return f.onceError = name + " shouldn't be called more than once", f.called = !1, f;
  }
});

// node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node4 = __commonJS((exports, module) => {
  var { create: __create2, defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2, getPrototypeOf: __getProtoOf2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: !0 }) : target, mod)), __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    RequestError: () => RequestError
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_deprecation = require_dist_node3(), import_once = __toESM2(require_once()), logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation)), logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation)), RequestError = class extends Error {
    constructor(message, statusCode, options) {
      super(message);
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, this.constructor);
      this.name = "HttpError", this.status = statusCode;
      let headers;
      if ("headers" in options && typeof options.headers < "u")
        headers = options.headers;
      if ("response" in options)
        this.response = options.response, headers = options.response.headers;
      let requestCopy = Object.assign({}, options.request);
      if (options.request.headers.authorization)
        requestCopy.headers = Object.assign({}, options.request.headers, {
          authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
        });
      requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]"), this.request = requestCopy, Object.defineProperty(this, "code", {
        get() {
          return logOnceCode(new import_deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`.")), statusCode;
        }
      }), Object.defineProperty(this, "headers", {
        get() {
          return logOnceHeaders(new import_deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`.")), headers || {};
        }
      });
    }
  };
});

// node_modules/@octokit/request/dist-node/index.js
var require_dist_node5 = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    request: () => request
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_endpoint = require_dist_node2(), import_universal_user_agent = require_dist_node(), VERSION = "8.4.1";
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
      return !1;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return !1;
    let proto = Object.getPrototypeOf(value);
    if (proto === null)
      return !0;
    let Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  var import_request_error = require_dist_node4();
  function getBufferResponse(response) {
    return response.arrayBuffer();
  }
  function fetchWrapper(requestOptions) {
    var _a, _b, _c, _d;
    let log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console, parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== !1;
    if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body))
      requestOptions.body = JSON.stringify(requestOptions.body);
    let headers = {}, status, url, { fetch } = globalThis;
    if ((_b = requestOptions.request) == null ? void 0 : _b.fetch)
      fetch = requestOptions.request.fetch;
    if (!fetch)
      throw Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
    return fetch(requestOptions.url, {
      method: requestOptions.method,
      body: requestOptions.body,
      redirect: (_c = requestOptions.request) == null ? void 0 : _c.redirect,
      headers: requestOptions.headers,
      signal: (_d = requestOptions.request) == null ? void 0 : _d.signal,
      ...requestOptions.body && { duplex: "half" }
    }).then(async (response) => {
      url = response.url, status = response.status;
      for (let keyAndValue of response.headers)
        headers[keyAndValue[0]] = keyAndValue[1];
      if ("deprecation" in headers) {
        let matches = headers.link && headers.link.match(/<([^<>]+)>; rel="deprecation"/), deprecationLink = matches && matches.pop();
        log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
      }
      if (status === 204 || status === 205)
        return;
      if (requestOptions.method === "HEAD") {
        if (status < 400)
          return;
        throw new import_request_error.RequestError(response.statusText, status, {
          response: {
            url,
            status,
            headers,
            data: void 0
          },
          request: requestOptions
        });
      }
      if (status === 304)
        throw new import_request_error.RequestError("Not modified", status, {
          response: {
            url,
            status,
            headers,
            data: await getResponseData(response)
          },
          request: requestOptions
        });
      if (status >= 400) {
        let data = await getResponseData(response);
        throw new import_request_error.RequestError(toErrorMessage(data), status, {
          response: {
            url,
            status,
            headers,
            data
          },
          request: requestOptions
        });
      }
      return parseSuccessResponseBody ? await getResponseData(response) : response.body;
    }).then((data) => {
      return {
        status,
        url,
        headers,
        data
      };
    }).catch((error) => {
      if (error instanceof import_request_error.RequestError)
        throw error;
      else if (error.name === "AbortError")
        throw error;
      let message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error)
          message = error.cause.message;
        else if (typeof error.cause === "string")
          message = error.cause;
      }
      throw new import_request_error.RequestError(message, 500, {
        request: requestOptions
      });
    });
  }
  async function getResponseData(response) {
    let contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType))
      return response.json().catch(() => response.text()).catch(() => "");
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType))
      return response.text();
    return getBufferResponse(response);
  }
  function toErrorMessage(data) {
    if (typeof data === "string")
      return data;
    let suffix;
    if ("documentation_url" in data)
      suffix = ` - ${data.documentation_url}`;
    else
      suffix = "";
    if ("message" in data) {
      if (Array.isArray(data.errors))
        return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
      return `${data.message}${suffix}`;
    }
    return `Unknown error: ${JSON.stringify(data)}`;
  }
  function withDefaults(oldEndpoint, newDefaults) {
    let endpoint2 = oldEndpoint.defaults(newDefaults);
    return Object.assign(function(route, parameters) {
      let endpointOptions = endpoint2.merge(route, parameters);
      if (!endpointOptions.request || !endpointOptions.request.hook)
        return fetchWrapper(endpoint2.parse(endpointOptions));
      let request2 = (route2, parameters2) => {
        return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
      };
      return Object.assign(request2, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
      }), endpointOptions.request.hook(request2, endpointOptions);
    }, {
      endpoint: endpoint2,
      defaults: withDefaults.bind(null, endpoint2)
    });
  }
  var request = withDefaults(import_endpoint.endpoint, {
    headers: {
      "user-agent": `octokit-request.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`
    }
  });
});

// node_modules/@octokit/graphql/node_modules/@octokit/request/node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node6 = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    endpoint: () => endpoint
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_universal_user_agent = require_dist_node(), VERSION = "9.0.5", userAgent = `octokit-endpoint.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`, DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
      accept: "application/vnd.github.v3+json",
      "user-agent": userAgent
    },
    mediaType: {
      format: ""
    }
  };
  function lowercaseKeys(object) {
    if (!object)
      return {};
    return Object.keys(object).reduce((newObj, key) => {
      return newObj[key.toLowerCase()] = object[key], newObj;
    }, {});
  }
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
      return !1;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return !1;
    let proto = Object.getPrototypeOf(value);
    if (proto === null)
      return !0;
    let Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  function mergeDeep(defaults, options) {
    let result = Object.assign({}, defaults);
    return Object.keys(options).forEach((key) => {
      if (isPlainObject(options[key]))
        if (!(key in defaults))
          Object.assign(result, { [key]: options[key] });
        else
          result[key] = mergeDeep(defaults[key], options[key]);
      else
        Object.assign(result, { [key]: options[key] });
    }), result;
  }
  function removeUndefinedProperties(obj) {
    for (let key in obj)
      if (obj[key] === void 0)
        delete obj[key];
    return obj;
  }
  function merge(defaults, route, options) {
    if (typeof route === "string") {
      let [method, url] = route.split(" ");
      options = Object.assign(url ? { method, url } : { url: method }, options);
    } else
      options = Object.assign({}, route);
    options.headers = lowercaseKeys(options.headers), removeUndefinedProperties(options), removeUndefinedProperties(options.headers);
    let mergedOptions = mergeDeep(defaults || {}, options);
    if (options.url === "/graphql") {
      if (defaults && defaults.mediaType.previews?.length)
        mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
      mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
    }
    return mergedOptions;
  }
  function addQueryParameters(url, parameters) {
    let separator = /\?/.test(url) ? "&" : "?", names = Object.keys(parameters);
    if (names.length === 0)
      return url;
    return url + separator + names.map((name) => {
      if (name === "q")
        return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
      return `${name}=${encodeURIComponent(parameters[name])}`;
    }).join("&");
  }
  var urlVariableRegex = /\{[^}]+\}/g;
  function removeNonChars(variableName) {
    return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
  }
  function extractUrlVariableNames(url) {
    let matches = url.match(urlVariableRegex);
    if (!matches)
      return [];
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
  }
  function omit(object, keysToOmit) {
    let result = { __proto__: null };
    for (let key of Object.keys(object))
      if (keysToOmit.indexOf(key) === -1)
        result[key] = object[key];
    return result;
  }
  function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
      if (!/%[0-9A-Fa-f]/.test(part))
        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
      return part;
    }).join("");
  }
  function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeValue(operator, value, key) {
    if (value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value), key)
      return encodeUnreserved(key) + "=" + value;
    else
      return value;
  }
  function isDefined(value) {
    return value !== void 0 && value !== null;
  }
  function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
  }
  function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "")
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        if (value = value.toString(), modifier && modifier !== "*")
          value = value.substring(0, parseInt(modifier, 10));
        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
      } else if (modifier === "*")
        if (Array.isArray(value))
          value.filter(isDefined).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        else
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k]))
              result.push(encodeValue(operator, value[k], k));
          });
      else {
        let tmp = [];
        if (Array.isArray(value))
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        else
          Object.keys(value).forEach(function(k) {
            if (isDefined(value[k]))
              tmp.push(encodeUnreserved(k)), tmp.push(encodeValue(operator, value[k].toString()));
          });
        if (isKeyOperator(operator))
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        else if (tmp.length !== 0)
          result.push(tmp.join(","));
      }
    else if (operator === ";") {
      if (isDefined(value))
        result.push(encodeUnreserved(key));
    } else if (value === "" && (operator === "&" || operator === "?"))
      result.push(encodeUnreserved(key) + "=");
    else if (value === "")
      result.push("");
    return result;
  }
  function parseUrl(template) {
    return {
      expand: expand.bind(null, template)
    };
  }
  function expand(template, context) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    if (template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal) {
      if (expression) {
        let operator = "", values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1)
          operator = expression.charAt(0), expression = expression.substr(1);
        if (expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
        }), operator && operator !== "+") {
          var separator = ",";
          if (operator === "?")
            separator = "&";
          else if (operator !== "#")
            separator = operator;
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else
          return values.join(",");
      } else
        return encodeReserved(literal);
    }), template === "/")
      return template;
    else
      return template.replace(/\/$/, "");
  }
  function parse(options) {
    let method = options.method.toUpperCase(), url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}"), headers = Object.assign({}, options.headers), body, parameters = omit(options, [
      "method",
      "baseUrl",
      "url",
      "headers",
      "request",
      "mediaType"
    ]), urlVariableNames = extractUrlVariableNames(url);
    if (url = parseUrl(url).expand(parameters), !/^http/.test(url))
      url = options.baseUrl + url;
    let omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl"), remainingParameters = omit(parameters, omittedParameters);
    if (!/application\/octet-stream/i.test(headers.accept)) {
      if (options.mediaType.format)
        headers.accept = headers.accept.split(/,/).map((format) => format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
      if (url.endsWith("/graphql")) {
        if (options.mediaType.previews?.length) {
          let previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
          headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
            let format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
            return `application/vnd.github.${preview}-preview${format}`;
          }).join(",");
        }
      }
    }
    if (["GET", "HEAD"].includes(method))
      url = addQueryParameters(url, remainingParameters);
    else if ("data" in remainingParameters)
      body = remainingParameters.data;
    else if (Object.keys(remainingParameters).length)
      body = remainingParameters;
    if (!headers["content-type"] && typeof body < "u")
      headers["content-type"] = "application/json; charset=utf-8";
    if (["PATCH", "PUT"].includes(method) && typeof body > "u")
      body = "";
    return Object.assign({ method, url, headers }, typeof body < "u" ? { body } : null, options.request ? { request: options.request } : null);
  }
  function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
  }
  function withDefaults(oldDefaults, newDefaults) {
    let DEFAULTS2 = merge(oldDefaults, newDefaults), endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
    return Object.assign(endpoint2, {
      DEFAULTS: DEFAULTS2,
      defaults: withDefaults.bind(null, DEFAULTS2),
      merge: merge.bind(null, DEFAULTS2),
      parse
    });
  }
  var endpoint = withDefaults(null, DEFAULTS);
});

// node_modules/@octokit/graphql/node_modules/@octokit/request/node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node7 = __commonJS((exports, module) => {
  var { create: __create2, defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2, getPrototypeOf: __getProtoOf2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: !0 }) : target, mod)), __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    RequestError: () => RequestError
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_deprecation = require_dist_node3(), import_once = __toESM2(require_once()), logOnceCode = (0, import_once.default)((deprecation) => console.warn(deprecation)), logOnceHeaders = (0, import_once.default)((deprecation) => console.warn(deprecation)), RequestError = class extends Error {
    constructor(message, statusCode, options) {
      super(message);
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, this.constructor);
      this.name = "HttpError", this.status = statusCode;
      let headers;
      if ("headers" in options && typeof options.headers < "u")
        headers = options.headers;
      if ("response" in options)
        this.response = options.response, headers = options.response.headers;
      let requestCopy = Object.assign({}, options.request);
      if (options.request.headers.authorization)
        requestCopy.headers = Object.assign({}, options.request.headers, {
          authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
        });
      requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]"), this.request = requestCopy, Object.defineProperty(this, "code", {
        get() {
          return logOnceCode(new import_deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`.")), statusCode;
        }
      }), Object.defineProperty(this, "headers", {
        get() {
          return logOnceHeaders(new import_deprecation.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`.")), headers || {};
        }
      });
    }
  };
});

// node_modules/@octokit/graphql/node_modules/@octokit/request/dist-node/index.js
var require_dist_node8 = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    request: () => request
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_endpoint = require_dist_node6(), import_universal_user_agent = require_dist_node(), VERSION = "8.4.0";
  function isPlainObject(value) {
    if (typeof value !== "object" || value === null)
      return !1;
    if (Object.prototype.toString.call(value) !== "[object Object]")
      return !1;
    let proto = Object.getPrototypeOf(value);
    if (proto === null)
      return !0;
    let Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
  }
  var import_request_error = require_dist_node7();
  function getBufferResponse(response) {
    return response.arrayBuffer();
  }
  function fetchWrapper(requestOptions) {
    var _a, _b, _c, _d;
    let log = requestOptions.request && requestOptions.request.log ? requestOptions.request.log : console, parseSuccessResponseBody = ((_a = requestOptions.request) == null ? void 0 : _a.parseSuccessResponseBody) !== !1;
    if (isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body))
      requestOptions.body = JSON.stringify(requestOptions.body);
    let headers = {}, status, url, { fetch } = globalThis;
    if ((_b = requestOptions.request) == null ? void 0 : _b.fetch)
      fetch = requestOptions.request.fetch;
    if (!fetch)
      throw Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
    return fetch(requestOptions.url, {
      method: requestOptions.method,
      body: requestOptions.body,
      redirect: (_c = requestOptions.request) == null ? void 0 : _c.redirect,
      headers: requestOptions.headers,
      signal: (_d = requestOptions.request) == null ? void 0 : _d.signal,
      ...requestOptions.body && { duplex: "half" }
    }).then(async (response) => {
      url = response.url, status = response.status;
      for (let keyAndValue of response.headers)
        headers[keyAndValue[0]] = keyAndValue[1];
      if ("deprecation" in headers) {
        let matches = headers.link && headers.link.match(/<([^>]+)>; rel="deprecation"/), deprecationLink = matches && matches.pop();
        log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
      }
      if (status === 204 || status === 205)
        return;
      if (requestOptions.method === "HEAD") {
        if (status < 400)
          return;
        throw new import_request_error.RequestError(response.statusText, status, {
          response: {
            url,
            status,
            headers,
            data: void 0
          },
          request: requestOptions
        });
      }
      if (status === 304)
        throw new import_request_error.RequestError("Not modified", status, {
          response: {
            url,
            status,
            headers,
            data: await getResponseData(response)
          },
          request: requestOptions
        });
      if (status >= 400) {
        let data = await getResponseData(response);
        throw new import_request_error.RequestError(toErrorMessage(data), status, {
          response: {
            url,
            status,
            headers,
            data
          },
          request: requestOptions
        });
      }
      return parseSuccessResponseBody ? await getResponseData(response) : response.body;
    }).then((data) => {
      return {
        status,
        url,
        headers,
        data
      };
    }).catch((error) => {
      if (error instanceof import_request_error.RequestError)
        throw error;
      else if (error.name === "AbortError")
        throw error;
      let message = error.message;
      if (error.name === "TypeError" && "cause" in error) {
        if (error.cause instanceof Error)
          message = error.cause.message;
        else if (typeof error.cause === "string")
          message = error.cause;
      }
      throw new import_request_error.RequestError(message, 500, {
        request: requestOptions
      });
    });
  }
  async function getResponseData(response) {
    let contentType = response.headers.get("content-type");
    if (/application\/json/.test(contentType))
      return response.json().catch(() => response.text()).catch(() => "");
    if (!contentType || /^text\/|charset=utf-8$/.test(contentType))
      return response.text();
    return getBufferResponse(response);
  }
  function toErrorMessage(data) {
    if (typeof data === "string")
      return data;
    let suffix;
    if ("documentation_url" in data)
      suffix = ` - ${data.documentation_url}`;
    else
      suffix = "";
    if ("message" in data) {
      if (Array.isArray(data.errors))
        return `${data.message}: ${data.errors.map(JSON.stringify).join(", ")}${suffix}`;
      return `${data.message}${suffix}`;
    }
    return `Unknown error: ${JSON.stringify(data)}`;
  }
  function withDefaults(oldEndpoint, newDefaults) {
    let endpoint2 = oldEndpoint.defaults(newDefaults);
    return Object.assign(function(route, parameters) {
      let endpointOptions = endpoint2.merge(route, parameters);
      if (!endpointOptions.request || !endpointOptions.request.hook)
        return fetchWrapper(endpoint2.parse(endpointOptions));
      let request2 = (route2, parameters2) => {
        return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
      };
      return Object.assign(request2, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
      }), endpointOptions.request.hook(request2, endpointOptions);
    }, {
      endpoint: endpoint2,
      defaults: withDefaults.bind(null, endpoint2)
    });
  }
  var request = withDefaults(import_endpoint.endpoint, {
    headers: {
      "user-agent": `octokit-request.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`
    }
  });
});

// node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node9 = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    GraphqlResponseError: () => GraphqlResponseError,
    graphql: () => graphql2,
    withCustomRequest: () => withCustomRequest
  });
  module.exports = __toCommonJS(dist_src_exports);
  var import_request3 = require_dist_node8(), import_universal_user_agent = require_dist_node(), VERSION = "7.1.0", import_request2 = require_dist_node8(), import_request = require_dist_node8();
  function _buildMessageForResponseErrors(data) {
    return `Request failed due to following response errors:
` + data.errors.map((e) => ` - ${e.message}`).join(`
`);
  }
  var GraphqlResponseError = class extends Error {
    constructor(request2, headers, response) {
      super(_buildMessageForResponseErrors(response));
      if (this.request = request2, this.headers = headers, this.response = response, this.name = "GraphqlResponseError", this.errors = response.errors, this.data = response.data, Error.captureStackTrace)
        Error.captureStackTrace(this, this.constructor);
    }
  }, NON_VARIABLE_OPTIONS = [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "query",
    "mediaType"
  ], FORBIDDEN_VARIABLE_OPTIONS = ["query", "method", "url"], GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
  function graphql(request2, query, options) {
    if (options) {
      if (typeof query === "string" && "query" in options)
        return Promise.reject(Error('[@octokit/graphql] "query" cannot be used as variable name'));
      for (let key in options) {
        if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key))
          continue;
        return Promise.reject(Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
      }
    }
    let parsedOptions = typeof query === "string" ? Object.assign({ query }, options) : query, requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
      if (NON_VARIABLE_OPTIONS.includes(key))
        return result[key] = parsedOptions[key], result;
      if (!result.variables)
        result.variables = {};
      return result.variables[key] = parsedOptions[key], result;
    }, {}), baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
    if (GHES_V3_SUFFIX_REGEX.test(baseUrl))
      requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
    return request2(requestOptions).then((response) => {
      if (response.data.errors) {
        let headers = {};
        for (let key of Object.keys(response.headers))
          headers[key] = response.headers[key];
        throw new GraphqlResponseError(requestOptions, headers, response.data);
      }
      return response.data.data;
    });
  }
  function withDefaults(request2, newDefaults) {
    let newRequest = request2.defaults(newDefaults);
    return Object.assign((query, options) => {
      return graphql(newRequest, query, options);
    }, {
      defaults: withDefaults.bind(null, newRequest),
      endpoint: newRequest.endpoint
    });
  }
  var graphql2 = withDefaults(import_request3.request, {
    headers: {
      "user-agent": `octokit-graphql.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`
    },
    method: "POST",
    url: "/graphql"
  });
  function withCustomRequest(customRequest) {
    return withDefaults(customRequest, {
      method: "POST",
      url: "/graphql"
    });
  }
});

// node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node10 = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    createTokenAuth: () => createTokenAuth
  });
  module.exports = __toCommonJS(dist_src_exports);
  var REGEX_IS_INSTALLATION_LEGACY = /^v1\./, REGEX_IS_INSTALLATION = /^ghs_/, REGEX_IS_USER_TO_SERVER = /^ghu_/;
  async function auth(token) {
    let isApp = token.split(/\./).length === 3, isInstallation = REGEX_IS_INSTALLATION_LEGACY.test(token) || REGEX_IS_INSTALLATION.test(token), isUserToServer = REGEX_IS_USER_TO_SERVER.test(token);
    return {
      type: "token",
      token,
      tokenType: isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth"
    };
  }
  function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3)
      return `bearer ${token}`;
    return `token ${token}`;
  }
  async function hook(token, request, route, parameters) {
    let endpoint = request.endpoint.merge(route, parameters);
    return endpoint.headers.authorization = withAuthorizationPrefix(token), request(endpoint);
  }
  var createTokenAuth = function(token) {
    if (!token)
      throw Error("[@octokit/auth-token] No token passed to createTokenAuth");
    if (typeof token !== "string")
      throw Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    return token = token.replace(/^(token|bearer) +/i, ""), Object.assign(auth.bind(null, token), {
      hook: hook.bind(null, token)
    });
  };
});

// node_modules/@octokit/core/dist-node/index.js
var require_dist_node11 = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), index_exports = {};
  __export(index_exports, {
    Octokit: () => Octokit
  });
  module.exports = __toCommonJS(index_exports);
  var import_universal_user_agent = require_dist_node(), import_before_after_hook = require_before_after_hook(), import_request = require_dist_node5(), import_graphql = require_dist_node9(), import_auth_token = require_dist_node10(), VERSION = "5.2.2", noop = () => {}, consoleWarn = console.warn.bind(console), consoleError = console.error.bind(console);
  function createLogger(logger = {}) {
    if (typeof logger.debug !== "function")
      logger.debug = noop;
    if (typeof logger.info !== "function")
      logger.info = noop;
    if (typeof logger.warn !== "function")
      logger.warn = consoleWarn;
    if (typeof logger.error !== "function")
      logger.error = consoleError;
    return logger;
  }
  var userAgentTrail = `octokit-core.js/${VERSION} ${(0, import_universal_user_agent.getUserAgent)()}`, Octokit = class {
    static {
      this.VERSION = VERSION;
    }
    static defaults(defaults) {
      return class extends this {
        constructor(...args) {
          let options = args[0] || {};
          if (typeof defaults === "function") {
            super(defaults(options));
            return;
          }
          super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
            userAgent: `${options.userAgent} ${defaults.userAgent}`
          } : null));
        }
      };
    }
    static {
      this.plugins = [];
    }
    static plugin(...newPlugins) {
      let currentPlugins = this.plugins;
      return class extends this {
        static {
          this.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
        }
      };
    }
    constructor(options = {}) {
      let hook = new import_before_after_hook.Collection, requestDefaults = {
        baseUrl: import_request.request.endpoint.DEFAULTS.baseUrl,
        headers: {},
        request: Object.assign({}, options.request, {
          hook: hook.bind(null, "request")
        }),
        mediaType: {
          previews: [],
          format: ""
        }
      };
      if (requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail, options.baseUrl)
        requestDefaults.baseUrl = options.baseUrl;
      if (options.previews)
        requestDefaults.mediaType.previews = options.previews;
      if (options.timeZone)
        requestDefaults.headers["time-zone"] = options.timeZone;
      if (this.request = import_request.request.defaults(requestDefaults), this.graphql = (0, import_graphql.withCustomRequest)(this.request).defaults(requestDefaults), this.log = createLogger(options.log), this.hook = hook, !options.authStrategy)
        if (!options.auth)
          this.auth = async () => ({
            type: "unauthenticated"
          });
        else {
          let auth = (0, import_auth_token.createTokenAuth)(options.auth);
          hook.wrap("request", auth.hook), this.auth = auth;
        }
      else {
        let { authStrategy, ...otherOptions } = options, auth = authStrategy(Object.assign({
          request: this.request,
          log: this.log,
          octokit: this,
          octokitOptions: otherOptions
        }, options.auth));
        hook.wrap("request", auth.hook), this.auth = auth;
      }
      let classConstructor = this.constructor;
      for (let i = 0;i < classConstructor.plugins.length; ++i)
        Object.assign(this, classConstructor.plugins[i](this, options));
    }
  };
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node12 = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    legacyRestEndpointMethods: () => legacyRestEndpointMethods,
    restEndpointMethods: () => restEndpointMethods
  });
  module.exports = __toCommonJS(dist_src_exports);
  var VERSION = "10.4.1", Endpoints = {
    actions: {
      addCustomLabelsToSelfHostedRunnerForOrg: [
        "POST /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      addCustomLabelsToSelfHostedRunnerForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
      ],
      addSelectedRepoToOrgVariable: [
        "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
      ],
      approveWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
      ],
      cancelWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
      ],
      createEnvironmentVariable: [
        "POST /repositories/{repository_id}/environments/{environment_name}/variables"
      ],
      createOrUpdateEnvironmentSecret: [
        "PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
      ],
      createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
      ],
      createOrgVariable: ["POST /orgs/{org}/actions/variables"],
      createRegistrationTokenForOrg: [
        "POST /orgs/{org}/actions/runners/registration-token"
      ],
      createRegistrationTokenForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/registration-token"
      ],
      createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
      createRemoveTokenForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/remove-token"
      ],
      createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
      createWorkflowDispatch: [
        "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
      ],
      deleteActionsCacheById: [
        "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
      ],
      deleteActionsCacheByKey: [
        "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
      ],
      deleteArtifact: [
        "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
      ],
      deleteEnvironmentSecret: [
        "DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
      ],
      deleteEnvironmentVariable: [
        "DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
      deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
      ],
      deleteRepoVariable: [
        "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
      ],
      deleteSelfHostedRunnerFromOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}"
      ],
      deleteSelfHostedRunnerFromRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
      ],
      deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
      deleteWorkflowRunLogs: [
        "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
      ],
      disableSelectedRepositoryGithubActionsOrganization: [
        "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
      ],
      disableWorkflow: [
        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
      ],
      downloadArtifact: [
        "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
      ],
      downloadJobLogsForWorkflowRun: [
        "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
      ],
      downloadWorkflowRunAttemptLogs: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
      ],
      downloadWorkflowRunLogs: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
      ],
      enableSelectedRepositoryGithubActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
      ],
      enableWorkflow: [
        "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
      ],
      forceCancelWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
      ],
      generateRunnerJitconfigForOrg: [
        "POST /orgs/{org}/actions/runners/generate-jitconfig"
      ],
      generateRunnerJitconfigForRepo: [
        "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
      ],
      getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
      getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
      getActionsCacheUsageByRepoForOrg: [
        "GET /orgs/{org}/actions/cache/usage-by-repository"
      ],
      getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
      getAllowedActionsOrganization: [
        "GET /orgs/{org}/actions/permissions/selected-actions"
      ],
      getAllowedActionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
      ],
      getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
      getCustomOidcSubClaimForRepo: [
        "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
      ],
      getEnvironmentPublicKey: [
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"
      ],
      getEnvironmentSecret: [
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"
      ],
      getEnvironmentVariable: [
        "GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
      ],
      getGithubActionsDefaultWorkflowPermissionsOrganization: [
        "GET /orgs/{org}/actions/permissions/workflow"
      ],
      getGithubActionsDefaultWorkflowPermissionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/workflow"
      ],
      getGithubActionsPermissionsOrganization: [
        "GET /orgs/{org}/actions/permissions"
      ],
      getGithubActionsPermissionsRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions"
      ],
      getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
      getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
      getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
      getPendingDeploymentsForRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
      ],
      getRepoPermissions: [
        "GET /repos/{owner}/{repo}/actions/permissions",
        {},
        { renamed: ["actions", "getGithubActionsPermissionsRepository"] }
      ],
      getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
      getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
      getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
      getReviewsForRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
      ],
      getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
      getSelfHostedRunnerForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
      ],
      getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
      getWorkflowAccessToRepository: [
        "GET /repos/{owner}/{repo}/actions/permissions/access"
      ],
      getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
      getWorkflowRunAttempt: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
      ],
      getWorkflowRunUsage: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
      ],
      getWorkflowUsage: [
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
      ],
      listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
      listEnvironmentSecrets: [
        "GET /repositories/{repository_id}/environments/{environment_name}/secrets"
      ],
      listEnvironmentVariables: [
        "GET /repositories/{repository_id}/environments/{environment_name}/variables"
      ],
      listJobsForWorkflowRun: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
      ],
      listJobsForWorkflowRunAttempt: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
      ],
      listLabelsForSelfHostedRunnerForOrg: [
        "GET /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      listLabelsForSelfHostedRunnerForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
      listOrgVariables: ["GET /orgs/{org}/actions/variables"],
      listRepoOrganizationSecrets: [
        "GET /repos/{owner}/{repo}/actions/organization-secrets"
      ],
      listRepoOrganizationVariables: [
        "GET /repos/{owner}/{repo}/actions/organization-variables"
      ],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
      listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
      listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
      listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
      listRunnerApplicationsForRepo: [
        "GET /repos/{owner}/{repo}/actions/runners/downloads"
      ],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
      ],
      listSelectedReposForOrgVariable: [
        "GET /orgs/{org}/actions/variables/{name}/repositories"
      ],
      listSelectedRepositoriesEnabledGithubActionsOrganization: [
        "GET /orgs/{org}/actions/permissions/repositories"
      ],
      listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
      listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
      listWorkflowRunArtifacts: [
        "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
      ],
      listWorkflowRuns: [
        "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
      ],
      listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
      reRunJobForWorkflowRun: [
        "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
      ],
      reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
      reRunWorkflowFailedJobs: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
      ],
      removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      removeCustomLabelFromSelfHostedRunnerForOrg: [
        "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
      ],
      removeCustomLabelFromSelfHostedRunnerForRepo: [
        "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
      ],
      removeSelectedRepoFromOrgVariable: [
        "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
      ],
      reviewCustomGatesForRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
      ],
      reviewPendingDeploymentsForRun: [
        "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
      ],
      setAllowedActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/selected-actions"
      ],
      setAllowedActionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
      ],
      setCustomLabelsForSelfHostedRunnerForOrg: [
        "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
      ],
      setCustomLabelsForSelfHostedRunnerForRepo: [
        "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
      ],
      setCustomOidcSubClaimForRepo: [
        "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
      ],
      setGithubActionsDefaultWorkflowPermissionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/workflow"
      ],
      setGithubActionsDefaultWorkflowPermissionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
      ],
      setGithubActionsPermissionsOrganization: [
        "PUT /orgs/{org}/actions/permissions"
      ],
      setGithubActionsPermissionsRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
      ],
      setSelectedReposForOrgVariable: [
        "PUT /orgs/{org}/actions/variables/{name}/repositories"
      ],
      setSelectedRepositoriesEnabledGithubActionsOrganization: [
        "PUT /orgs/{org}/actions/permissions/repositories"
      ],
      setWorkflowAccessToRepository: [
        "PUT /repos/{owner}/{repo}/actions/permissions/access"
      ],
      updateEnvironmentVariable: [
        "PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"
      ],
      updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
      updateRepoVariable: [
        "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
      ]
    },
    activity: {
      checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
      deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
      deleteThreadSubscription: [
        "DELETE /notifications/threads/{thread_id}/subscription"
      ],
      getFeeds: ["GET /feeds"],
      getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
      getThread: ["GET /notifications/threads/{thread_id}"],
      getThreadSubscriptionForAuthenticatedUser: [
        "GET /notifications/threads/{thread_id}/subscription"
      ],
      listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
      listNotificationsForAuthenticatedUser: ["GET /notifications"],
      listOrgEventsForAuthenticatedUser: [
        "GET /users/{username}/events/orgs/{org}"
      ],
      listPublicEvents: ["GET /events"],
      listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
      listPublicEventsForUser: ["GET /users/{username}/events/public"],
      listPublicOrgEvents: ["GET /orgs/{org}/events"],
      listReceivedEventsForUser: ["GET /users/{username}/received_events"],
      listReceivedPublicEventsForUser: [
        "GET /users/{username}/received_events/public"
      ],
      listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
      listRepoNotificationsForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/notifications"
      ],
      listReposStarredByAuthenticatedUser: ["GET /user/starred"],
      listReposStarredByUser: ["GET /users/{username}/starred"],
      listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
      listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
      listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
      listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
      markNotificationsAsRead: ["PUT /notifications"],
      markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
      markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
      markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
      setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
      setThreadSubscription: [
        "PUT /notifications/threads/{thread_id}/subscription"
      ],
      starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
      unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
    },
    apps: {
      addRepoToInstallation: [
        "PUT /user/installations/{installation_id}/repositories/{repository_id}",
        {},
        { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] }
      ],
      addRepoToInstallationForAuthenticatedUser: [
        "PUT /user/installations/{installation_id}/repositories/{repository_id}"
      ],
      checkToken: ["POST /applications/{client_id}/token"],
      createFromManifest: ["POST /app-manifests/{code}/conversions"],
      createInstallationAccessToken: [
        "POST /app/installations/{installation_id}/access_tokens"
      ],
      deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
      deleteInstallation: ["DELETE /app/installations/{installation_id}"],
      deleteToken: ["DELETE /applications/{client_id}/token"],
      getAuthenticated: ["GET /app"],
      getBySlug: ["GET /apps/{app_slug}"],
      getInstallation: ["GET /app/installations/{installation_id}"],
      getOrgInstallation: ["GET /orgs/{org}/installation"],
      getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
      getSubscriptionPlanForAccount: [
        "GET /marketplace_listing/accounts/{account_id}"
      ],
      getSubscriptionPlanForAccountStubbed: [
        "GET /marketplace_listing/stubbed/accounts/{account_id}"
      ],
      getUserInstallation: ["GET /users/{username}/installation"],
      getWebhookConfigForApp: ["GET /app/hook/config"],
      getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
      listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
      listAccountsForPlanStubbed: [
        "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
      ],
      listInstallationReposForAuthenticatedUser: [
        "GET /user/installations/{installation_id}/repositories"
      ],
      listInstallationRequestsForAuthenticatedApp: [
        "GET /app/installation-requests"
      ],
      listInstallations: ["GET /app/installations"],
      listInstallationsForAuthenticatedUser: ["GET /user/installations"],
      listPlans: ["GET /marketplace_listing/plans"],
      listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
      listReposAccessibleToInstallation: ["GET /installation/repositories"],
      listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
      listSubscriptionsForAuthenticatedUserStubbed: [
        "GET /user/marketplace_purchases/stubbed"
      ],
      listWebhookDeliveries: ["GET /app/hook/deliveries"],
      redeliverWebhookDelivery: [
        "POST /app/hook/deliveries/{delivery_id}/attempts"
      ],
      removeRepoFromInstallation: [
        "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
        {},
        { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] }
      ],
      removeRepoFromInstallationForAuthenticatedUser: [
        "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
      ],
      resetToken: ["PATCH /applications/{client_id}/token"],
      revokeInstallationAccessToken: ["DELETE /installation/token"],
      scopeToken: ["POST /applications/{client_id}/token/scoped"],
      suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
      unsuspendInstallation: [
        "DELETE /app/installations/{installation_id}/suspended"
      ],
      updateWebhookConfigForApp: ["PATCH /app/hook/config"]
    },
    billing: {
      getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
      getGithubActionsBillingUser: [
        "GET /users/{username}/settings/billing/actions"
      ],
      getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
      getGithubPackagesBillingUser: [
        "GET /users/{username}/settings/billing/packages"
      ],
      getSharedStorageBillingOrg: [
        "GET /orgs/{org}/settings/billing/shared-storage"
      ],
      getSharedStorageBillingUser: [
        "GET /users/{username}/settings/billing/shared-storage"
      ]
    },
    checks: {
      create: ["POST /repos/{owner}/{repo}/check-runs"],
      createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
      get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
      getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
      listAnnotations: [
        "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
      ],
      listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
      listForSuite: [
        "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
      ],
      listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
      rerequestRun: [
        "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
      ],
      rerequestSuite: [
        "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
      ],
      setSuitesPreferences: [
        "PATCH /repos/{owner}/{repo}/check-suites/preferences"
      ],
      update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
    },
    codeScanning: {
      deleteAnalysis: [
        "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
      ],
      getAlert: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
        {},
        { renamedParameters: { alert_id: "alert_number" } }
      ],
      getAnalysis: [
        "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
      ],
      getCodeqlDatabase: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
      ],
      getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
      getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
      listAlertInstances: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
      listAlertsInstances: [
        "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
        {},
        { renamed: ["codeScanning", "listAlertInstances"] }
      ],
      listCodeqlDatabases: [
        "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
      ],
      listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
      ],
      updateDefaultSetup: [
        "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
      ],
      uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
    },
    codesOfConduct: {
      getAllCodesOfConduct: ["GET /codes_of_conduct"],
      getConductCode: ["GET /codes_of_conduct/{key}"]
    },
    codespaces: {
      addRepositoryForSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      checkPermissionsForDevcontainer: [
        "GET /repos/{owner}/{repo}/codespaces/permissions_check"
      ],
      codespaceMachinesForAuthenticatedUser: [
        "GET /user/codespaces/{codespace_name}/machines"
      ],
      createForAuthenticatedUser: ["POST /user/codespaces"],
      createOrUpdateOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
      ],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      createOrUpdateSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}"
      ],
      createWithPrForAuthenticatedUser: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
      ],
      createWithRepoForAuthenticatedUser: [
        "POST /repos/{owner}/{repo}/codespaces"
      ],
      deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
      deleteFromOrganization: [
        "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      deleteSecretForAuthenticatedUser: [
        "DELETE /user/codespaces/secrets/{secret_name}"
      ],
      exportForAuthenticatedUser: [
        "POST /user/codespaces/{codespace_name}/exports"
      ],
      getCodespacesForUserInOrg: [
        "GET /orgs/{org}/members/{username}/codespaces"
      ],
      getExportDetailsForAuthenticatedUser: [
        "GET /user/codespaces/{codespace_name}/exports/{export_id}"
      ],
      getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
      getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
      getPublicKeyForAuthenticatedUser: [
        "GET /user/codespaces/secrets/public-key"
      ],
      getRepoPublicKey: [
        "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
      ],
      getRepoSecret: [
        "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
      ],
      getSecretForAuthenticatedUser: [
        "GET /user/codespaces/secrets/{secret_name}"
      ],
      listDevcontainersInRepositoryForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/devcontainers"
      ],
      listForAuthenticatedUser: ["GET /user/codespaces"],
      listInOrganization: [
        "GET /orgs/{org}/codespaces",
        {},
        { renamedParameters: { org_id: "org" } }
      ],
      listInRepositoryForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces"
      ],
      listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
      listRepositoriesForSecretForAuthenticatedUser: [
        "GET /user/codespaces/secrets/{secret_name}/repositories"
      ],
      listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
      ],
      preFlightWithRepoForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/new"
      ],
      publishForAuthenticatedUser: [
        "POST /user/codespaces/{codespace_name}/publish"
      ],
      removeRepositoryForSecretForAuthenticatedUser: [
        "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
      ],
      repoMachinesForAuthenticatedUser: [
        "GET /repos/{owner}/{repo}/codespaces/machines"
      ],
      setRepositoriesForSecretForAuthenticatedUser: [
        "PUT /user/codespaces/secrets/{secret_name}/repositories"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
      ],
      startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
      stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
      stopInOrganization: [
        "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
      ],
      updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"]
    },
    copilot: {
      addCopilotSeatsForTeams: [
        "POST /orgs/{org}/copilot/billing/selected_teams"
      ],
      addCopilotSeatsForUsers: [
        "POST /orgs/{org}/copilot/billing/selected_users"
      ],
      cancelCopilotSeatAssignmentForTeams: [
        "DELETE /orgs/{org}/copilot/billing/selected_teams"
      ],
      cancelCopilotSeatAssignmentForUsers: [
        "DELETE /orgs/{org}/copilot/billing/selected_users"
      ],
      getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
      getCopilotSeatDetailsForUser: [
        "GET /orgs/{org}/members/{username}/copilot"
      ],
      listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"]
    },
    dependabot: {
      addSelectedRepoToOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
      ],
      createOrUpdateOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
      ],
      createOrUpdateRepoSecret: [
        "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
      deleteRepoSecret: [
        "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
      getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
      getRepoPublicKey: [
        "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
      ],
      getRepoSecret: [
        "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
      ],
      listAlertsForEnterprise: [
        "GET /enterprises/{enterprise}/dependabot/alerts"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
      listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
      listSelectedReposForOrgSecret: [
        "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
      ],
      removeSelectedRepoFromOrgSecret: [
        "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
      ],
      setSelectedReposForOrgSecret: [
        "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
      ],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
      ]
    },
    dependencyGraph: {
      createRepositorySnapshot: [
        "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
      ],
      diffRange: [
        "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
      ],
      exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"]
    },
    emojis: { get: ["GET /emojis"] },
    gists: {
      checkIsStarred: ["GET /gists/{gist_id}/star"],
      create: ["POST /gists"],
      createComment: ["POST /gists/{gist_id}/comments"],
      delete: ["DELETE /gists/{gist_id}"],
      deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
      fork: ["POST /gists/{gist_id}/forks"],
      get: ["GET /gists/{gist_id}"],
      getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
      getRevision: ["GET /gists/{gist_id}/{sha}"],
      list: ["GET /gists"],
      listComments: ["GET /gists/{gist_id}/comments"],
      listCommits: ["GET /gists/{gist_id}/commits"],
      listForUser: ["GET /users/{username}/gists"],
      listForks: ["GET /gists/{gist_id}/forks"],
      listPublic: ["GET /gists/public"],
      listStarred: ["GET /gists/starred"],
      star: ["PUT /gists/{gist_id}/star"],
      unstar: ["DELETE /gists/{gist_id}/star"],
      update: ["PATCH /gists/{gist_id}"],
      updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
    },
    git: {
      createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
      createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
      createRef: ["POST /repos/{owner}/{repo}/git/refs"],
      createTag: ["POST /repos/{owner}/{repo}/git/tags"],
      createTree: ["POST /repos/{owner}/{repo}/git/trees"],
      deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
      getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
      getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
      getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
      getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
      getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
      listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
      updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
    },
    gitignore: {
      getAllTemplates: ["GET /gitignore/templates"],
      getTemplate: ["GET /gitignore/templates/{name}"]
    },
    interactions: {
      getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
      getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
      getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
      getRestrictionsForYourPublicRepos: [
        "GET /user/interaction-limits",
        {},
        { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }
      ],
      removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
      removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
      removeRestrictionsForRepo: [
        "DELETE /repos/{owner}/{repo}/interaction-limits"
      ],
      removeRestrictionsForYourPublicRepos: [
        "DELETE /user/interaction-limits",
        {},
        { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }
      ],
      setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
      setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
      setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
      setRestrictionsForYourPublicRepos: [
        "PUT /user/interaction-limits",
        {},
        { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }
      ]
    },
    issues: {
      addAssignees: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
      ],
      addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
      checkUserCanBeAssignedToIssue: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
      ],
      create: ["POST /repos/{owner}/{repo}/issues"],
      createComment: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
      ],
      createLabel: ["POST /repos/{owner}/{repo}/labels"],
      createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
      deleteComment: [
        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
      ],
      deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
      deleteMilestone: [
        "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
      ],
      get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
      getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
      getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
      getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
      list: ["GET /issues"],
      listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
      listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
      listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
      listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
      listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
      listEventsForTimeline: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
      ],
      listForAuthenticatedUser: ["GET /user/issues"],
      listForOrg: ["GET /orgs/{org}/issues"],
      listForRepo: ["GET /repos/{owner}/{repo}/issues"],
      listLabelsForMilestone: [
        "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
      ],
      listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
      listLabelsOnIssue: [
        "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
      ],
      listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
      lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      removeAllLabels: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
      ],
      removeAssignees: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
      ],
      removeLabel: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
      ],
      setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
      updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
      updateMilestone: [
        "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
      ]
    },
    licenses: {
      get: ["GET /licenses/{license}"],
      getAllCommonlyUsed: ["GET /licenses"],
      getForRepo: ["GET /repos/{owner}/{repo}/license"]
    },
    markdown: {
      render: ["POST /markdown"],
      renderRaw: [
        "POST /markdown/raw",
        { headers: { "content-type": "text/plain; charset=utf-8" } }
      ]
    },
    meta: {
      get: ["GET /meta"],
      getAllVersions: ["GET /versions"],
      getOctocat: ["GET /octocat"],
      getZen: ["GET /zen"],
      root: ["GET /"]
    },
    migrations: {
      cancelImport: [
        "DELETE /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"
        }
      ],
      deleteArchiveForAuthenticatedUser: [
        "DELETE /user/migrations/{migration_id}/archive"
      ],
      deleteArchiveForOrg: [
        "DELETE /orgs/{org}/migrations/{migration_id}/archive"
      ],
      downloadArchiveForOrg: [
        "GET /orgs/{org}/migrations/{migration_id}/archive"
      ],
      getArchiveForAuthenticatedUser: [
        "GET /user/migrations/{migration_id}/archive"
      ],
      getCommitAuthors: [
        "GET /repos/{owner}/{repo}/import/authors",
        {},
        {
          deprecated: "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"
        }
      ],
      getImportStatus: [
        "GET /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"
        }
      ],
      getLargeFiles: [
        "GET /repos/{owner}/{repo}/import/large_files",
        {},
        {
          deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"
        }
      ],
      getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
      getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
      listForAuthenticatedUser: ["GET /user/migrations"],
      listForOrg: ["GET /orgs/{org}/migrations"],
      listReposForAuthenticatedUser: [
        "GET /user/migrations/{migration_id}/repositories"
      ],
      listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
      listReposForUser: [
        "GET /user/migrations/{migration_id}/repositories",
        {},
        { renamed: ["migrations", "listReposForAuthenticatedUser"] }
      ],
      mapCommitAuthor: [
        "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
        {},
        {
          deprecated: "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"
        }
      ],
      setLfsPreference: [
        "PATCH /repos/{owner}/{repo}/import/lfs",
        {},
        {
          deprecated: "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"
        }
      ],
      startForAuthenticatedUser: ["POST /user/migrations"],
      startForOrg: ["POST /orgs/{org}/migrations"],
      startImport: [
        "PUT /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"
        }
      ],
      unlockRepoForAuthenticatedUser: [
        "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
      ],
      unlockRepoForOrg: [
        "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
      ],
      updateImport: [
        "PATCH /repos/{owner}/{repo}/import",
        {},
        {
          deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"
        }
      ]
    },
    oidc: {
      getOidcCustomSubTemplateForOrg: [
        "GET /orgs/{org}/actions/oidc/customization/sub"
      ],
      updateOidcCustomSubTemplateForOrg: [
        "PUT /orgs/{org}/actions/oidc/customization/sub"
      ]
    },
    orgs: {
      addSecurityManagerTeam: [
        "PUT /orgs/{org}/security-managers/teams/{team_slug}"
      ],
      assignTeamToOrgRole: [
        "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
      ],
      assignUserToOrgRole: [
        "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
      ],
      blockUser: ["PUT /orgs/{org}/blocks/{username}"],
      cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
      checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
      checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
      checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
      convertMemberToOutsideCollaborator: [
        "PUT /orgs/{org}/outside_collaborators/{username}"
      ],
      createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
      createInvitation: ["POST /orgs/{org}/invitations"],
      createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
      createOrUpdateCustomPropertiesValuesForRepos: [
        "PATCH /orgs/{org}/properties/values"
      ],
      createOrUpdateCustomProperty: [
        "PUT /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      createWebhook: ["POST /orgs/{org}/hooks"],
      delete: ["DELETE /orgs/{org}"],
      deleteCustomOrganizationRole: [
        "DELETE /orgs/{org}/organization-roles/{role_id}"
      ],
      deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
      enableOrDisableSecurityProductOnAllOrgRepos: [
        "POST /orgs/{org}/{security_product}/{enablement}"
      ],
      get: ["GET /orgs/{org}"],
      getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
      getCustomProperty: [
        "GET /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
      getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
      getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
      getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
      getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
      getWebhookDelivery: [
        "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
      ],
      list: ["GET /organizations"],
      listAppInstallations: ["GET /orgs/{org}/installations"],
      listBlockedUsers: ["GET /orgs/{org}/blocks"],
      listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
      listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
      listForAuthenticatedUser: ["GET /user/orgs"],
      listForUser: ["GET /users/{username}/orgs"],
      listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
      listMembers: ["GET /orgs/{org}/members"],
      listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
      listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
      listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
      listOrgRoles: ["GET /orgs/{org}/organization-roles"],
      listOrganizationFineGrainedPermissions: [
        "GET /orgs/{org}/organization-fine-grained-permissions"
      ],
      listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
      listPatGrantRepositories: [
        "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
      ],
      listPatGrantRequestRepositories: [
        "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
      ],
      listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
      listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
      listPendingInvitations: ["GET /orgs/{org}/invitations"],
      listPublicMembers: ["GET /orgs/{org}/public_members"],
      listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
      listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
      listWebhooks: ["GET /orgs/{org}/hooks"],
      patchCustomOrganizationRole: [
        "PATCH /orgs/{org}/organization-roles/{role_id}"
      ],
      pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
      redeliverWebhookDelivery: [
        "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
      ],
      removeCustomProperty: [
        "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
      ],
      removeMember: ["DELETE /orgs/{org}/members/{username}"],
      removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
      removeOutsideCollaborator: [
        "DELETE /orgs/{org}/outside_collaborators/{username}"
      ],
      removePublicMembershipForAuthenticatedUser: [
        "DELETE /orgs/{org}/public_members/{username}"
      ],
      removeSecurityManagerTeam: [
        "DELETE /orgs/{org}/security-managers/teams/{team_slug}"
      ],
      reviewPatGrantRequest: [
        "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
      ],
      reviewPatGrantRequestsInBulk: [
        "POST /orgs/{org}/personal-access-token-requests"
      ],
      revokeAllOrgRolesTeam: [
        "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
      ],
      revokeAllOrgRolesUser: [
        "DELETE /orgs/{org}/organization-roles/users/{username}"
      ],
      revokeOrgRoleTeam: [
        "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
      ],
      revokeOrgRoleUser: [
        "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
      ],
      setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
      setPublicMembershipForAuthenticatedUser: [
        "PUT /orgs/{org}/public_members/{username}"
      ],
      unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
      update: ["PATCH /orgs/{org}"],
      updateMembershipForAuthenticatedUser: [
        "PATCH /user/memberships/orgs/{org}"
      ],
      updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
      updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
      updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
      updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
    },
    packages: {
      deletePackageForAuthenticatedUser: [
        "DELETE /user/packages/{package_type}/{package_name}"
      ],
      deletePackageForOrg: [
        "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
      ],
      deletePackageForUser: [
        "DELETE /users/{username}/packages/{package_type}/{package_name}"
      ],
      deletePackageVersionForAuthenticatedUser: [
        "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      deletePackageVersionForOrg: [
        "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      deletePackageVersionForUser: [
        "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getAllPackageVersionsForAPackageOwnedByAnOrg: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
        {},
        { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] }
      ],
      getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions",
        {},
        {
          renamed: [
            "packages",
            "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
          ]
        }
      ],
      getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions"
      ],
      getAllPackageVersionsForPackageOwnedByOrg: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
      ],
      getAllPackageVersionsForPackageOwnedByUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}/versions"
      ],
      getPackageForAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}"
      ],
      getPackageForOrganization: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}"
      ],
      getPackageForUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}"
      ],
      getPackageVersionForAuthenticatedUser: [
        "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getPackageVersionForOrganization: [
        "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      getPackageVersionForUser: [
        "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
      ],
      listDockerMigrationConflictingPackagesForAuthenticatedUser: [
        "GET /user/docker/conflicts"
      ],
      listDockerMigrationConflictingPackagesForOrganization: [
        "GET /orgs/{org}/docker/conflicts"
      ],
      listDockerMigrationConflictingPackagesForUser: [
        "GET /users/{username}/docker/conflicts"
      ],
      listPackagesForAuthenticatedUser: ["GET /user/packages"],
      listPackagesForOrganization: ["GET /orgs/{org}/packages"],
      listPackagesForUser: ["GET /users/{username}/packages"],
      restorePackageForAuthenticatedUser: [
        "POST /user/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageForOrg: [
        "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageForUser: [
        "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
      ],
      restorePackageVersionForAuthenticatedUser: [
        "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ],
      restorePackageVersionForOrg: [
        "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ],
      restorePackageVersionForUser: [
        "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
      ]
    },
    projects: {
      addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
      createCard: ["POST /projects/columns/{column_id}/cards"],
      createColumn: ["POST /projects/{project_id}/columns"],
      createForAuthenticatedUser: ["POST /user/projects"],
      createForOrg: ["POST /orgs/{org}/projects"],
      createForRepo: ["POST /repos/{owner}/{repo}/projects"],
      delete: ["DELETE /projects/{project_id}"],
      deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
      deleteColumn: ["DELETE /projects/columns/{column_id}"],
      get: ["GET /projects/{project_id}"],
      getCard: ["GET /projects/columns/cards/{card_id}"],
      getColumn: ["GET /projects/columns/{column_id}"],
      getPermissionForUser: [
        "GET /projects/{project_id}/collaborators/{username}/permission"
      ],
      listCards: ["GET /projects/columns/{column_id}/cards"],
      listCollaborators: ["GET /projects/{project_id}/collaborators"],
      listColumns: ["GET /projects/{project_id}/columns"],
      listForOrg: ["GET /orgs/{org}/projects"],
      listForRepo: ["GET /repos/{owner}/{repo}/projects"],
      listForUser: ["GET /users/{username}/projects"],
      moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
      moveColumn: ["POST /projects/columns/{column_id}/moves"],
      removeCollaborator: [
        "DELETE /projects/{project_id}/collaborators/{username}"
      ],
      update: ["PATCH /projects/{project_id}"],
      updateCard: ["PATCH /projects/columns/cards/{card_id}"],
      updateColumn: ["PATCH /projects/columns/{column_id}"]
    },
    pulls: {
      checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      create: ["POST /repos/{owner}/{repo}/pulls"],
      createReplyForReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
      ],
      createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      createReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
      ],
      deletePendingReview: [
        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      deleteReviewComment: [
        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
      ],
      dismissReview: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
      ],
      get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
      getReview: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
      list: ["GET /repos/{owner}/{repo}/pulls"],
      listCommentsForReview: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
      ],
      listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
      listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
      listRequestedReviewers: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      listReviewComments: [
        "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
      ],
      listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
      listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      removeRequestedReviewers: [
        "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      requestReviewers: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
      ],
      submitReview: [
        "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
      ],
      update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
      updateBranch: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
      ],
      updateReview: [
        "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
      ],
      updateReviewComment: [
        "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
      ]
    },
    rateLimit: { get: ["GET /rate_limit"] },
    reactions: {
      createForCommitComment: [
        "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
      ],
      createForIssue: [
        "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
      ],
      createForIssueComment: [
        "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
      ],
      createForPullRequestReviewComment: [
        "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
      ],
      createForRelease: [
        "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
      ],
      createForTeamDiscussionCommentInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
      ],
      createForTeamDiscussionInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
      ],
      deleteForCommitComment: [
        "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForIssue: [
        "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
      ],
      deleteForIssueComment: [
        "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForPullRequestComment: [
        "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
      ],
      deleteForRelease: [
        "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
      ],
      deleteForTeamDiscussion: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
      ],
      deleteForTeamDiscussionComment: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
      ],
      listForCommitComment: [
        "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
      ],
      listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
      listForIssueComment: [
        "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
      ],
      listForPullRequestReviewComment: [
        "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
      ],
      listForRelease: [
        "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
      ],
      listForTeamDiscussionCommentInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
      ],
      listForTeamDiscussionInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
      ]
    },
    repos: {
      acceptInvitation: [
        "PATCH /user/repository_invitations/{invitation_id}",
        {},
        { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }
      ],
      acceptInvitationForAuthenticatedUser: [
        "PATCH /user/repository_invitations/{invitation_id}"
      ],
      addAppAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
      addStatusCheckContexts: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      addTeamAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      addUserAccessRestrictions: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      cancelPagesDeployment: [
        "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
      ],
      checkAutomatedSecurityFixes: [
        "GET /repos/{owner}/{repo}/automated-security-fixes"
      ],
      checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
      checkVulnerabilityAlerts: [
        "GET /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
      compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
      compareCommitsWithBasehead: [
        "GET /repos/{owner}/{repo}/compare/{basehead}"
      ],
      createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
      createCommitComment: [
        "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
      ],
      createCommitSignatureProtection: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
      createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
      createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
      createDeploymentBranchPolicy: [
        "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
      ],
      createDeploymentProtectionRule: [
        "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
      ],
      createDeploymentStatus: [
        "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
      ],
      createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
      createForAuthenticatedUser: ["POST /user/repos"],
      createFork: ["POST /repos/{owner}/{repo}/forks"],
      createInOrg: ["POST /orgs/{org}/repos"],
      createOrUpdateCustomPropertiesValues: [
        "PATCH /repos/{owner}/{repo}/properties/values"
      ],
      createOrUpdateEnvironment: [
        "PUT /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
      createOrgRuleset: ["POST /orgs/{org}/rulesets"],
      createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
      createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
      createRelease: ["POST /repos/{owner}/{repo}/releases"],
      createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
      createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
      createUsingTemplate: [
        "POST /repos/{template_owner}/{template_repo}/generate"
      ],
      createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
      declineInvitation: [
        "DELETE /user/repository_invitations/{invitation_id}",
        {},
        { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }
      ],
      declineInvitationForAuthenticatedUser: [
        "DELETE /user/repository_invitations/{invitation_id}"
      ],
      delete: ["DELETE /repos/{owner}/{repo}"],
      deleteAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
      ],
      deleteAdminBranchProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      deleteAnEnvironment: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
      deleteBranchProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
      deleteCommitSignatureProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
      deleteDeployment: [
        "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
      ],
      deleteDeploymentBranchPolicy: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
      deleteInvitation: [
        "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
      ],
      deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
      deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
      deletePullRequestReviewProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
      deleteReleaseAsset: [
        "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
      ],
      deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      deleteTagProtection: [
        "DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"
      ],
      deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
      disableAutomatedSecurityFixes: [
        "DELETE /repos/{owner}/{repo}/automated-security-fixes"
      ],
      disableDeploymentProtectionRule: [
        "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
      ],
      disablePrivateVulnerabilityReporting: [
        "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
      ],
      disableVulnerabilityAlerts: [
        "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      downloadArchive: [
        "GET /repos/{owner}/{repo}/zipball/{ref}",
        {},
        { renamed: ["repos", "downloadZipballArchive"] }
      ],
      downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
      downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
      enableAutomatedSecurityFixes: [
        "PUT /repos/{owner}/{repo}/automated-security-fixes"
      ],
      enablePrivateVulnerabilityReporting: [
        "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
      ],
      enableVulnerabilityAlerts: [
        "PUT /repos/{owner}/{repo}/vulnerability-alerts"
      ],
      generateReleaseNotes: [
        "POST /repos/{owner}/{repo}/releases/generate-notes"
      ],
      get: ["GET /repos/{owner}/{repo}"],
      getAccessRestrictions: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
      ],
      getAdminBranchProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      getAllDeploymentProtectionRules: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
      ],
      getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
      getAllStatusCheckContexts: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
      ],
      getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
      getAppsWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
      ],
      getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
      getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
      getBranchProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
      getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
      getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
      getCollaboratorPermissionLevel: [
        "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
      ],
      getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
      getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
      getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
      getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
      getCommitSignatureProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
      ],
      getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
      getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
      getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
      getCustomDeploymentProtectionRule: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
      ],
      getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
      getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
      getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
      getDeploymentBranchPolicy: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      getDeploymentStatus: [
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
      ],
      getEnvironment: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}"
      ],
      getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
      getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
      getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
      getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
      getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
      getOrgRulesets: ["GET /orgs/{org}/rulesets"],
      getPages: ["GET /repos/{owner}/{repo}/pages"],
      getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
      getPagesDeployment: [
        "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
      ],
      getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
      getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
      getPullRequestReviewProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
      getReadme: ["GET /repos/{owner}/{repo}/readme"],
      getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
      getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
      getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
      getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
      getRepoRuleSuite: [
        "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
      ],
      getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
      getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
      getStatusChecksProtection: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      getTeamsWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
      ],
      getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
      getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
      getUsersWithAccessToProtectedBranch: [
        "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
      ],
      getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
      getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
      getWebhookConfigForRepo: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
      ],
      getWebhookDelivery: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
      ],
      listActivities: ["GET /repos/{owner}/{repo}/activity"],
      listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
      listBranches: ["GET /repos/{owner}/{repo}/branches"],
      listBranchesForHeadCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
      ],
      listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
      listCommentsForCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
      ],
      listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
      listCommitStatusesForRef: [
        "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
      ],
      listCommits: ["GET /repos/{owner}/{repo}/commits"],
      listContributors: ["GET /repos/{owner}/{repo}/contributors"],
      listCustomDeploymentRuleIntegrations: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
      ],
      listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
      listDeploymentBranchPolicies: [
        "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
      ],
      listDeploymentStatuses: [
        "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
      ],
      listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
      listForAuthenticatedUser: ["GET /user/repos"],
      listForOrg: ["GET /orgs/{org}/repos"],
      listForUser: ["GET /users/{username}/repos"],
      listForks: ["GET /repos/{owner}/{repo}/forks"],
      listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
      listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
      listLanguages: ["GET /repos/{owner}/{repo}/languages"],
      listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
      listPublic: ["GET /repositories"],
      listPullRequestsAssociatedWithCommit: [
        "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
      ],
      listReleaseAssets: [
        "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
      ],
      listReleases: ["GET /repos/{owner}/{repo}/releases"],
      listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
      listTags: ["GET /repos/{owner}/{repo}/tags"],
      listTeams: ["GET /repos/{owner}/{repo}/teams"],
      listWebhookDeliveries: [
        "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
      ],
      listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
      merge: ["POST /repos/{owner}/{repo}/merges"],
      mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
      pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
      redeliverWebhookDelivery: [
        "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
      ],
      removeAppAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      removeCollaborator: [
        "DELETE /repos/{owner}/{repo}/collaborators/{username}"
      ],
      removeStatusCheckContexts: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      removeStatusCheckProtection: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      removeTeamAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      removeUserAccessRestrictions: [
        "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
      replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
      requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
      setAdminBranchProtection: [
        "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
      ],
      setAppAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
        {},
        { mapToData: "apps" }
      ],
      setStatusCheckContexts: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
        {},
        { mapToData: "contexts" }
      ],
      setTeamAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
        {},
        { mapToData: "teams" }
      ],
      setUserAccessRestrictions: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
        {},
        { mapToData: "users" }
      ],
      testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
      transfer: ["POST /repos/{owner}/{repo}/transfer"],
      update: ["PATCH /repos/{owner}/{repo}"],
      updateBranchProtection: [
        "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
      ],
      updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
      updateDeploymentBranchPolicy: [
        "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
      ],
      updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
      updateInvitation: [
        "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
      ],
      updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
      updatePullRequestReviewProtection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
      ],
      updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
      updateReleaseAsset: [
        "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
      ],
      updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
      updateStatusCheckPotection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
        {},
        { renamed: ["repos", "updateStatusCheckProtection"] }
      ],
      updateStatusCheckProtection: [
        "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
      ],
      updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
      updateWebhookConfigForRepo: [
        "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
      ],
      uploadReleaseAsset: [
        "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
        { baseUrl: "https://uploads.github.com" }
      ]
    },
    search: {
      code: ["GET /search/code"],
      commits: ["GET /search/commits"],
      issuesAndPullRequests: ["GET /search/issues"],
      labels: ["GET /search/labels"],
      repos: ["GET /search/repositories"],
      topics: ["GET /search/topics"],
      users: ["GET /search/users"]
    },
    secretScanning: {
      getAlert: [
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
      ],
      listAlertsForEnterprise: [
        "GET /enterprises/{enterprise}/secret-scanning/alerts"
      ],
      listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
      listLocationsForAlert: [
        "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
      ],
      updateAlert: [
        "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
      ]
    },
    securityAdvisories: {
      createFork: [
        "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
      ],
      createPrivateVulnerabilityReport: [
        "POST /repos/{owner}/{repo}/security-advisories/reports"
      ],
      createRepositoryAdvisory: [
        "POST /repos/{owner}/{repo}/security-advisories"
      ],
      createRepositoryAdvisoryCveRequest: [
        "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
      ],
      getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
      getRepositoryAdvisory: [
        "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
      ],
      listGlobalAdvisories: ["GET /advisories"],
      listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
      listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
      updateRepositoryAdvisory: [
        "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
      ]
    },
    teams: {
      addOrUpdateMembershipForUserInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      addOrUpdateProjectPermissionsInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"
      ],
      addOrUpdateRepoPermissionsInOrg: [
        "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      checkPermissionsForProjectInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"
      ],
      checkPermissionsForRepoInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      create: ["POST /orgs/{org}/teams"],
      createDiscussionCommentInOrg: [
        "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
      ],
      createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
      deleteDiscussionCommentInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      deleteDiscussionInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
      getByName: ["GET /orgs/{org}/teams/{team_slug}"],
      getDiscussionCommentInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      getDiscussionInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      getMembershipForUserInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      list: ["GET /orgs/{org}/teams"],
      listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
      listDiscussionCommentsInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
      ],
      listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
      listForAuthenticatedUser: ["GET /user/teams"],
      listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
      listPendingInvitationsInOrg: [
        "GET /orgs/{org}/teams/{team_slug}/invitations"
      ],
      listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
      listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
      removeMembershipForUserInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
      ],
      removeProjectInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"
      ],
      removeRepoInOrg: [
        "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
      ],
      updateDiscussionCommentInOrg: [
        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
      ],
      updateDiscussionInOrg: [
        "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
      ],
      updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
    },
    users: {
      addEmailForAuthenticated: [
        "POST /user/emails",
        {},
        { renamed: ["users", "addEmailForAuthenticatedUser"] }
      ],
      addEmailForAuthenticatedUser: ["POST /user/emails"],
      addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
      block: ["PUT /user/blocks/{username}"],
      checkBlocked: ["GET /user/blocks/{username}"],
      checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
      checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
      createGpgKeyForAuthenticated: [
        "POST /user/gpg_keys",
        {},
        { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }
      ],
      createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
      createPublicSshKeyForAuthenticated: [
        "POST /user/keys",
        {},
        { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }
      ],
      createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
      createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
      deleteEmailForAuthenticated: [
        "DELETE /user/emails",
        {},
        { renamed: ["users", "deleteEmailForAuthenticatedUser"] }
      ],
      deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
      deleteGpgKeyForAuthenticated: [
        "DELETE /user/gpg_keys/{gpg_key_id}",
        {},
        { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }
      ],
      deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
      deletePublicSshKeyForAuthenticated: [
        "DELETE /user/keys/{key_id}",
        {},
        { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }
      ],
      deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
      deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
      deleteSshSigningKeyForAuthenticatedUser: [
        "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
      ],
      follow: ["PUT /user/following/{username}"],
      getAuthenticated: ["GET /user"],
      getByUsername: ["GET /users/{username}"],
      getContextForUser: ["GET /users/{username}/hovercard"],
      getGpgKeyForAuthenticated: [
        "GET /user/gpg_keys/{gpg_key_id}",
        {},
        { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }
      ],
      getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
      getPublicSshKeyForAuthenticated: [
        "GET /user/keys/{key_id}",
        {},
        { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }
      ],
      getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
      getSshSigningKeyForAuthenticatedUser: [
        "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
      ],
      list: ["GET /users"],
      listBlockedByAuthenticated: [
        "GET /user/blocks",
        {},
        { renamed: ["users", "listBlockedByAuthenticatedUser"] }
      ],
      listBlockedByAuthenticatedUser: ["GET /user/blocks"],
      listEmailsForAuthenticated: [
        "GET /user/emails",
        {},
        { renamed: ["users", "listEmailsForAuthenticatedUser"] }
      ],
      listEmailsForAuthenticatedUser: ["GET /user/emails"],
      listFollowedByAuthenticated: [
        "GET /user/following",
        {},
        { renamed: ["users", "listFollowedByAuthenticatedUser"] }
      ],
      listFollowedByAuthenticatedUser: ["GET /user/following"],
      listFollowersForAuthenticatedUser: ["GET /user/followers"],
      listFollowersForUser: ["GET /users/{username}/followers"],
      listFollowingForUser: ["GET /users/{username}/following"],
      listGpgKeysForAuthenticated: [
        "GET /user/gpg_keys",
        {},
        { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }
      ],
      listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
      listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
      listPublicEmailsForAuthenticated: [
        "GET /user/public_emails",
        {},
        { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }
      ],
      listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
      listPublicKeysForUser: ["GET /users/{username}/keys"],
      listPublicSshKeysForAuthenticated: [
        "GET /user/keys",
        {},
        { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }
      ],
      listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
      listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
      listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
      listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
      listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
      setPrimaryEmailVisibilityForAuthenticated: [
        "PATCH /user/email/visibility",
        {},
        { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] }
      ],
      setPrimaryEmailVisibilityForAuthenticatedUser: [
        "PATCH /user/email/visibility"
      ],
      unblock: ["DELETE /user/blocks/{username}"],
      unfollow: ["DELETE /user/following/{username}"],
      updateAuthenticated: ["PATCH /user"]
    }
  }, endpoints_default = Endpoints, endpointMethodsMap = /* @__PURE__ */ new Map;
  for (let [scope, endpoints] of Object.entries(endpoints_default))
    for (let [methodName, endpoint] of Object.entries(endpoints)) {
      let [route, defaults, decorations] = endpoint, [method, url] = route.split(/ /), endpointDefaults = Object.assign({
        method,
        url
      }, defaults);
      if (!endpointMethodsMap.has(scope))
        endpointMethodsMap.set(scope, /* @__PURE__ */ new Map);
      endpointMethodsMap.get(scope).set(methodName, {
        scope,
        methodName,
        endpointDefaults,
        decorations
      });
    }
  var handler = {
    has({ scope }, methodName) {
      return endpointMethodsMap.get(scope).has(methodName);
    },
    getOwnPropertyDescriptor(target, methodName) {
      return {
        value: this.get(target, methodName),
        configurable: !0,
        writable: !0,
        enumerable: !0
      };
    },
    defineProperty(target, methodName, descriptor) {
      return Object.defineProperty(target.cache, methodName, descriptor), !0;
    },
    deleteProperty(target, methodName) {
      return delete target.cache[methodName], !0;
    },
    ownKeys({ scope }) {
      return [...endpointMethodsMap.get(scope).keys()];
    },
    set(target, methodName, value) {
      return target.cache[methodName] = value;
    },
    get({ octokit, scope, cache }, methodName) {
      if (cache[methodName])
        return cache[methodName];
      let method = endpointMethodsMap.get(scope).get(methodName);
      if (!method)
        return;
      let { endpointDefaults, decorations } = method;
      if (decorations)
        cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
      else
        cache[methodName] = octokit.request.defaults(endpointDefaults);
      return cache[methodName];
    }
  };
  function endpointsToMethods(octokit) {
    let newMethods = {};
    for (let scope of endpointMethodsMap.keys())
      newMethods[scope] = new Proxy({ octokit, scope, cache: {} }, handler);
    return newMethods;
  }
  function decorate(octokit, scope, methodName, defaults, decorations) {
    let requestWithDefaults = octokit.request.defaults(defaults);
    function withDecorations(...args) {
      let options = requestWithDefaults.endpoint.merge(...args);
      if (decorations.mapToData)
        return options = Object.assign({}, options, {
          data: options[decorations.mapToData],
          [decorations.mapToData]: void 0
        }), requestWithDefaults(options);
      if (decorations.renamed) {
        let [newScope, newMethodName] = decorations.renamed;
        octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
      }
      if (decorations.deprecated)
        octokit.log.warn(decorations.deprecated);
      if (decorations.renamedParameters) {
        let options2 = requestWithDefaults.endpoint.merge(...args);
        for (let [name, alias] of Object.entries(decorations.renamedParameters))
          if (name in options2) {
            if (octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`), !(alias in options2))
              options2[alias] = options2[name];
            delete options2[name];
          }
        return requestWithDefaults(options2);
      }
      return requestWithDefaults(...args);
    }
    return Object.assign(withDecorations, requestWithDefaults);
  }
  function restEndpointMethods(octokit) {
    return {
      rest: endpointsToMethods(octokit)
    };
  }
  restEndpointMethods.VERSION = VERSION;
  function legacyRestEndpointMethods(octokit) {
    let api = endpointsToMethods(octokit);
    return {
      ...api,
      rest: api
    };
  }
  legacyRestEndpointMethods.VERSION = VERSION;
});

// node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node13 = __commonJS((exports, module) => {
  var { defineProperty: __defProp2, getOwnPropertyDescriptor: __getOwnPropDesc, getOwnPropertyNames: __getOwnPropNames2 } = Object, __hasOwnProp2 = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: !0 });
  }, __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  }, __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: !0 }), mod), dist_src_exports = {};
  __export(dist_src_exports, {
    composePaginateRest: () => composePaginateRest,
    isPaginatingEndpoint: () => isPaginatingEndpoint,
    paginateRest: () => paginateRest,
    paginatingEndpoints: () => paginatingEndpoints
  });
  module.exports = __toCommonJS(dist_src_exports);
  var VERSION = "9.2.2";
  function normalizePaginatedListResponse(response) {
    if (!response.data)
      return {
        ...response,
        data: []
      };
    if (!(("total_count" in response.data) && !("url" in response.data)))
      return response;
    let incompleteResults = response.data.incomplete_results, repositorySelection = response.data.repository_selection, totalCount = response.data.total_count;
    delete response.data.incomplete_results, delete response.data.repository_selection, delete response.data.total_count;
    let namespaceKey = Object.keys(response.data)[0], data = response.data[namespaceKey];
    if (response.data = data, typeof incompleteResults < "u")
      response.data.incomplete_results = incompleteResults;
    if (typeof repositorySelection < "u")
      response.data.repository_selection = repositorySelection;
    return response.data.total_count = totalCount, response;
  }
  function iterator(octokit, route, parameters) {
    let options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters), requestMethod = typeof route === "function" ? route : octokit.request, method = options.method, headers = options.headers, url = options.url;
    return {
      [Symbol.asyncIterator]: () => ({
        async next() {
          if (!url)
            return { done: !0 };
          try {
            let response = await requestMethod({ method, url, headers }), normalizedResponse = normalizePaginatedListResponse(response);
            return url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1], { value: normalizedResponse };
          } catch (error) {
            if (error.status !== 409)
              throw error;
            return url = "", {
              value: {
                status: 200,
                headers: {},
                data: []
              }
            };
          }
        }
      })
    };
  }
  function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function")
      mapFn = parameters, parameters = void 0;
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
  }
  function gather(octokit, results, iterator2, mapFn) {
    return iterator2.next().then((result) => {
      if (result.done)
        return results;
      let earlyExit = !1;
      function done() {
        earlyExit = !0;
      }
      if (results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data), earlyExit)
        return results;
      return gather(octokit, results, iterator2, mapFn);
    });
  }
  var composePaginateRest = Object.assign(paginate, {
    iterator
  }), paginatingEndpoints = [
    "GET /advisories",
    "GET /app/hook/deliveries",
    "GET /app/installation-requests",
    "GET /app/installations",
    "GET /assignments/{assignment_id}/accepted_assignments",
    "GET /classrooms",
    "GET /classrooms/{classroom_id}/assignments",
    "GET /enterprises/{enterprise}/dependabot/alerts",
    "GET /enterprises/{enterprise}/secret-scanning/alerts",
    "GET /events",
    "GET /gists",
    "GET /gists/public",
    "GET /gists/starred",
    "GET /gists/{gist_id}/comments",
    "GET /gists/{gist_id}/commits",
    "GET /gists/{gist_id}/forks",
    "GET /installation/repositories",
    "GET /issues",
    "GET /licenses",
    "GET /marketplace_listing/plans",
    "GET /marketplace_listing/plans/{plan_id}/accounts",
    "GET /marketplace_listing/stubbed/plans",
    "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "GET /networks/{owner}/{repo}/events",
    "GET /notifications",
    "GET /organizations",
    "GET /orgs/{org}/actions/cache/usage-by-repository",
    "GET /orgs/{org}/actions/permissions/repositories",
    "GET /orgs/{org}/actions/runners",
    "GET /orgs/{org}/actions/secrets",
    "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/actions/variables",
    "GET /orgs/{org}/actions/variables/{name}/repositories",
    "GET /orgs/{org}/blocks",
    "GET /orgs/{org}/code-scanning/alerts",
    "GET /orgs/{org}/codespaces",
    "GET /orgs/{org}/codespaces/secrets",
    "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/copilot/billing/seats",
    "GET /orgs/{org}/dependabot/alerts",
    "GET /orgs/{org}/dependabot/secrets",
    "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/events",
    "GET /orgs/{org}/failed_invitations",
    "GET /orgs/{org}/hooks",
    "GET /orgs/{org}/hooks/{hook_id}/deliveries",
    "GET /orgs/{org}/installations",
    "GET /orgs/{org}/invitations",
    "GET /orgs/{org}/invitations/{invitation_id}/teams",
    "GET /orgs/{org}/issues",
    "GET /orgs/{org}/members",
    "GET /orgs/{org}/members/{username}/codespaces",
    "GET /orgs/{org}/migrations",
    "GET /orgs/{org}/migrations/{migration_id}/repositories",
    "GET /orgs/{org}/organization-roles/{role_id}/teams",
    "GET /orgs/{org}/organization-roles/{role_id}/users",
    "GET /orgs/{org}/outside_collaborators",
    "GET /orgs/{org}/packages",
    "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
    "GET /orgs/{org}/personal-access-token-requests",
    "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
    "GET /orgs/{org}/personal-access-tokens",
    "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
    "GET /orgs/{org}/projects",
    "GET /orgs/{org}/properties/values",
    "GET /orgs/{org}/public_members",
    "GET /orgs/{org}/repos",
    "GET /orgs/{org}/rulesets",
    "GET /orgs/{org}/rulesets/rule-suites",
    "GET /orgs/{org}/secret-scanning/alerts",
    "GET /orgs/{org}/security-advisories",
    "GET /orgs/{org}/teams",
    "GET /orgs/{org}/teams/{team_slug}/discussions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/invitations",
    "GET /orgs/{org}/teams/{team_slug}/members",
    "GET /orgs/{org}/teams/{team_slug}/projects",
    "GET /orgs/{org}/teams/{team_slug}/repos",
    "GET /orgs/{org}/teams/{team_slug}/teams",
    "GET /projects/columns/{column_id}/cards",
    "GET /projects/{project_id}/collaborators",
    "GET /projects/{project_id}/columns",
    "GET /repos/{owner}/{repo}/actions/artifacts",
    "GET /repos/{owner}/{repo}/actions/caches",
    "GET /repos/{owner}/{repo}/actions/organization-secrets",
    "GET /repos/{owner}/{repo}/actions/organization-variables",
    "GET /repos/{owner}/{repo}/actions/runners",
    "GET /repos/{owner}/{repo}/actions/runs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
    "GET /repos/{owner}/{repo}/actions/secrets",
    "GET /repos/{owner}/{repo}/actions/variables",
    "GET /repos/{owner}/{repo}/actions/workflows",
    "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
    "GET /repos/{owner}/{repo}/activity",
    "GET /repos/{owner}/{repo}/assignees",
    "GET /repos/{owner}/{repo}/branches",
    "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
    "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
    "GET /repos/{owner}/{repo}/code-scanning/alerts",
    "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
    "GET /repos/{owner}/{repo}/code-scanning/analyses",
    "GET /repos/{owner}/{repo}/codespaces",
    "GET /repos/{owner}/{repo}/codespaces/devcontainers",
    "GET /repos/{owner}/{repo}/codespaces/secrets",
    "GET /repos/{owner}/{repo}/collaborators",
    "GET /repos/{owner}/{repo}/comments",
    "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/commits",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
    "GET /repos/{owner}/{repo}/commits/{ref}/status",
    "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
    "GET /repos/{owner}/{repo}/contributors",
    "GET /repos/{owner}/{repo}/dependabot/alerts",
    "GET /repos/{owner}/{repo}/dependabot/secrets",
    "GET /repos/{owner}/{repo}/deployments",
    "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
    "GET /repos/{owner}/{repo}/environments",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
    "GET /repos/{owner}/{repo}/events",
    "GET /repos/{owner}/{repo}/forks",
    "GET /repos/{owner}/{repo}/hooks",
    "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
    "GET /repos/{owner}/{repo}/invitations",
    "GET /repos/{owner}/{repo}/issues",
    "GET /repos/{owner}/{repo}/issues/comments",
    "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/issues/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
    "GET /repos/{owner}/{repo}/keys",
    "GET /repos/{owner}/{repo}/labels",
    "GET /repos/{owner}/{repo}/milestones",
    "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
    "GET /repos/{owner}/{repo}/notifications",
    "GET /repos/{owner}/{repo}/pages/builds",
    "GET /repos/{owner}/{repo}/projects",
    "GET /repos/{owner}/{repo}/pulls",
    "GET /repos/{owner}/{repo}/pulls/comments",
    "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
    "GET /repos/{owner}/{repo}/releases",
    "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
    "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
    "GET /repos/{owner}/{repo}/rules/branches/{branch}",
    "GET /repos/{owner}/{repo}/rulesets",
    "GET /repos/{owner}/{repo}/rulesets/rule-suites",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
    "GET /repos/{owner}/{repo}/security-advisories",
    "GET /repos/{owner}/{repo}/stargazers",
    "GET /repos/{owner}/{repo}/subscribers",
    "GET /repos/{owner}/{repo}/tags",
    "GET /repos/{owner}/{repo}/teams",
    "GET /repos/{owner}/{repo}/topics",
    "GET /repositories",
    "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
    "GET /repositories/{repository_id}/environments/{environment_name}/variables",
    "GET /search/code",
    "GET /search/commits",
    "GET /search/issues",
    "GET /search/labels",
    "GET /search/repositories",
    "GET /search/topics",
    "GET /search/users",
    "GET /teams/{team_id}/discussions",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
    "GET /teams/{team_id}/invitations",
    "GET /teams/{team_id}/members",
    "GET /teams/{team_id}/projects",
    "GET /teams/{team_id}/repos",
    "GET /teams/{team_id}/teams",
    "GET /user/blocks",
    "GET /user/codespaces",
    "GET /user/codespaces/secrets",
    "GET /user/emails",
    "GET /user/followers",
    "GET /user/following",
    "GET /user/gpg_keys",
    "GET /user/installations",
    "GET /user/installations/{installation_id}/repositories",
    "GET /user/issues",
    "GET /user/keys",
    "GET /user/marketplace_purchases",
    "GET /user/marketplace_purchases/stubbed",
    "GET /user/memberships/orgs",
    "GET /user/migrations",
    "GET /user/migrations/{migration_id}/repositories",
    "GET /user/orgs",
    "GET /user/packages",
    "GET /user/packages/{package_type}/{package_name}/versions",
    "GET /user/public_emails",
    "GET /user/repos",
    "GET /user/repository_invitations",
    "GET /user/social_accounts",
    "GET /user/ssh_signing_keys",
    "GET /user/starred",
    "GET /user/subscriptions",
    "GET /user/teams",
    "GET /users",
    "GET /users/{username}/events",
    "GET /users/{username}/events/orgs/{org}",
    "GET /users/{username}/events/public",
    "GET /users/{username}/followers",
    "GET /users/{username}/following",
    "GET /users/{username}/gists",
    "GET /users/{username}/gpg_keys",
    "GET /users/{username}/keys",
    "GET /users/{username}/orgs",
    "GET /users/{username}/packages",
    "GET /users/{username}/projects",
    "GET /users/{username}/received_events",
    "GET /users/{username}/received_events/public",
    "GET /users/{username}/repos",
    "GET /users/{username}/social_accounts",
    "GET /users/{username}/ssh_signing_keys",
    "GET /users/{username}/starred",
    "GET /users/{username}/subscriptions"
  ];
  function isPaginatingEndpoint(arg) {
    if (typeof arg === "string")
      return paginatingEndpoints.includes(arg);
    else
      return !1;
  }
  function paginateRest(octokit) {
    return {
      paginate: Object.assign(paginate.bind(null, octokit), {
        iterator: iterator.bind(null, octokit)
      })
    };
  }
  paginateRest.VERSION = VERSION;
});

// node_modules/@actions/artifact/node_modules/@actions/github/lib/utils.js
var require_utils8 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    return __setModuleDefault(result, mod), result;
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getOctokitOptions = exports.GitHub = exports.defaults = exports.context = void 0;
  var Context = __importStar(require_context()), Utils = __importStar(require_utils7()), core_1 = require_dist_node11(), plugin_rest_endpoint_methods_1 = require_dist_node12(), plugin_paginate_rest_1 = require_dist_node13();
  exports.context = new Context.Context;
  var baseUrl = Utils.getApiBaseUrl();
  exports.defaults = {
    baseUrl,
    request: {
      agent: Utils.getProxyAgent(baseUrl),
      fetch: Utils.getProxyFetch(baseUrl)
    }
  };
  exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
  function getOctokitOptions(token, options) {
    let opts = Object.assign({}, options || {}), auth = Utils.getAuthString(token, opts);
    if (auth)
      opts.auth = auth;
    return opts;
  }
  exports.getOctokitOptions = getOctokitOptions;
});

// node_modules/@actions/artifact/node_modules/@actions/github/lib/github.js
var require_github = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    return __setModuleDefault(result, mod), result;
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getOctokit = exports.context = void 0;
  var Context = __importStar(require_context()), utils_1 = require_utils8();
  exports.context = new Context.Context;
  function getOctokit(token, options, ...additionalPlugins) {
    return new (utils_1.GitHub.plugin(...additionalPlugins))((0, utils_1.getOctokitOptions)(token, options));
  }
  exports.getOctokit = getOctokit;
});

// node_modules/traverse/index.js
var require_traverse = __commonJS((exports, module) => {
  module.exports = Traverse;
  function Traverse(obj) {
    if (!(this instanceof Traverse))
      return new Traverse(obj);
    this.value = obj;
  }
  Traverse.prototype.get = function(ps) {
    var node = this.value;
    for (var i = 0;i < ps.length; i++) {
      var key = ps[i];
      if (!Object.hasOwnProperty.call(node, key)) {
        node = void 0;
        break;
      }
      node = node[key];
    }
    return node;
  };
  Traverse.prototype.set = function(ps, value) {
    var node = this.value;
    for (var i = 0;i < ps.length - 1; i++) {
      var key = ps[i];
      if (!Object.hasOwnProperty.call(node, key))
        node[key] = {};
      node = node[key];
    }
    return node[ps[i]] = value, value;
  };
  Traverse.prototype.map = function(cb) {
    return walk(this.value, cb, !0);
  };
  Traverse.prototype.forEach = function(cb) {
    return this.value = walk(this.value, cb, !1), this.value;
  };
  Traverse.prototype.reduce = function(cb, init) {
    var skip = arguments.length === 1, acc = skip ? this.value : init;
    return this.forEach(function(x) {
      if (!this.isRoot || !skip)
        acc = cb.call(this, acc, x);
    }), acc;
  };
  Traverse.prototype.deepEqual = function(obj) {
    if (arguments.length !== 1)
      throw Error("deepEqual requires exactly one object to compare against");
    var equal = !0, node = obj;
    return this.forEach(function(y) {
      var notEqual = function() {
        equal = !1;
        return;
      }.bind(this);
      if (!this.isRoot) {
        if (typeof node !== "object")
          return notEqual();
        node = node[this.key];
      }
      var x = node;
      this.post(function() {
        node = x;
      });
      var toS = function(o) {
        return Object.prototype.toString.call(o);
      };
      if (this.circular) {
        if (Traverse(obj).get(this.circular.path) !== x)
          notEqual();
      } else if (typeof x !== typeof y)
        notEqual();
      else if (x === null || y === null || x === void 0 || y === void 0) {
        if (x !== y)
          notEqual();
      } else if (x.__proto__ !== y.__proto__)
        notEqual();
      else if (x === y)
        ;
      else if (typeof x === "function") {
        if (x instanceof RegExp) {
          if (x.toString() != y.toString())
            notEqual();
        } else if (x !== y)
          notEqual();
      } else if (typeof x === "object")
        if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
          if (toS(x) !== toS(y))
            notEqual();
        } else if (x instanceof Date || y instanceof Date) {
          if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime())
            notEqual();
        } else {
          var kx = Object.keys(x), ky = Object.keys(y);
          if (kx.length !== ky.length)
            return notEqual();
          for (var i = 0;i < kx.length; i++) {
            var k = kx[i];
            if (!Object.hasOwnProperty.call(y, k))
              notEqual();
          }
        }
    }), equal;
  };
  Traverse.prototype.paths = function() {
    var acc = [];
    return this.forEach(function(x) {
      acc.push(this.path);
    }), acc;
  };
  Traverse.prototype.nodes = function() {
    var acc = [];
    return this.forEach(function(x) {
      acc.push(this.node);
    }), acc;
  };
  Traverse.prototype.clone = function() {
    var parents = [], nodes = [];
    return function clone(src) {
      for (var i = 0;i < parents.length; i++)
        if (parents[i] === src)
          return nodes[i];
      if (typeof src === "object" && src !== null) {
        var dst = copy(src);
        return parents.push(src), nodes.push(dst), Object.keys(src).forEach(function(key) {
          dst[key] = clone(src[key]);
        }), parents.pop(), nodes.pop(), dst;
      } else
        return src;
    }(this.value);
  };
  function walk(root, cb, immutable) {
    var path = [], parents = [], alive = !0;
    return function walker(node_) {
      var node = immutable ? copy(node_) : node_, modifiers = {}, state = {
        node,
        node_,
        path: [].concat(path),
        parent: parents.slice(-1)[0],
        key: path.slice(-1)[0],
        isRoot: path.length === 0,
        level: path.length,
        circular: null,
        update: function(x) {
          if (!state.isRoot)
            state.parent.node[state.key] = x;
          state.node = x;
        },
        delete: function() {
          delete state.parent.node[state.key];
        },
        remove: function() {
          if (Array.isArray(state.parent.node))
            state.parent.node.splice(state.key, 1);
          else
            delete state.parent.node[state.key];
        },
        before: function(f) {
          modifiers.before = f;
        },
        after: function(f) {
          modifiers.after = f;
        },
        pre: function(f) {
          modifiers.pre = f;
        },
        post: function(f) {
          modifiers.post = f;
        },
        stop: function() {
          alive = !1;
        }
      };
      if (!alive)
        return state;
      if (typeof node === "object" && node !== null) {
        state.isLeaf = Object.keys(node).length == 0;
        for (var i = 0;i < parents.length; i++)
          if (parents[i].node_ === node_) {
            state.circular = parents[i];
            break;
          }
      } else
        state.isLeaf = !0;
      state.notLeaf = !state.isLeaf, state.notRoot = !state.isRoot;
      var ret = cb.call(state, state.node);
      if (ret !== void 0 && state.update)
        state.update(ret);
      if (modifiers.before)
        modifiers.before.call(state, state.node);
      if (typeof state.node == "object" && state.node !== null && !state.circular) {
        parents.push(state);
        var keys = Object.keys(state.node);
        keys.forEach(function(key, i2) {
          if (path.push(key), modifiers.pre)
            modifiers.pre.call(state, state.node[key], key);
          var child = walker(state.node[key]);
          if (immutable && Object.hasOwnProperty.call(state.node, key))
            state.node[key] = child.node;
          if (child.isLast = i2 == keys.length - 1, child.isFirst = i2 == 0, modifiers.post)
            modifiers.post.call(state, child);
          path.pop();
        }), parents.pop();
      }
      if (modifiers.after)
        modifiers.after.call(state, state.node);
      return state;
    }(root).node;
  }
  Object.keys(Traverse.prototype).forEach(function(key) {
    Traverse[key] = function(obj) {
      var args = [].slice.call(arguments, 1), t = Traverse(obj);
      return t[key].apply(t, args);
    };
  });
  function copy(src) {
    if (typeof src === "object" && src !== null) {
      var dst;
      if (Array.isArray(src))
        dst = [];
      else if (src instanceof Date)
        dst = new Date(src);
      else if (src instanceof Boolean)
        dst = new Boolean(src);
      else if (src instanceof Number)
        dst = new Number(src);
      else if (src instanceof String)
        dst = new String(src);
      else
        dst = Object.create(Object.getPrototypeOf(src));
      return Object.keys(src).forEach(function(key) {
        dst[key] = src[key];
      }), dst;
    } else
      return src;
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS((exports, module) => {
  var Traverse = require_traverse(), EventEmitter = __require("events").EventEmitter;
  module.exports = Chainsaw;
  function Chainsaw(builder) {
    var saw = Chainsaw.saw(builder, {}), r = builder.call(saw.handlers, saw);
    if (r !== void 0)
      saw.handlers = r;
    return saw.record(), saw.chain();
  }
  Chainsaw.light = function(builder) {
    var saw = Chainsaw.saw(builder, {}), r = builder.call(saw.handlers, saw);
    if (r !== void 0)
      saw.handlers = r;
    return saw.chain();
  };
  Chainsaw.saw = function(builder, handlers) {
    var saw = new EventEmitter;
    return saw.handlers = handlers, saw.actions = [], saw.chain = function() {
      var ch = Traverse(saw.handlers).map(function(node) {
        if (this.isRoot)
          return node;
        var ps = this.path;
        if (typeof node === "function")
          this.update(function() {
            return saw.actions.push({
              path: ps,
              args: [].slice.call(arguments)
            }), ch;
          });
      });
      return process.nextTick(function() {
        saw.emit("begin"), saw.next();
      }), ch;
    }, saw.pop = function() {
      return saw.actions.shift();
    }, saw.next = function() {
      var action = saw.pop();
      if (!action)
        saw.emit("end");
      else if (!action.trap) {
        var node = saw.handlers;
        action.path.forEach(function(key) {
          node = node[key];
        }), node.apply(saw.handlers, action.args);
      }
    }, saw.nest = function(cb) {
      var args = [].slice.call(arguments, 1), autonext = !0;
      if (typeof cb === "boolean") {
        var autonext = cb;
        cb = args.shift();
      }
      var s = Chainsaw.saw(builder, {}), r = builder.call(s.handlers, s);
      if (r !== void 0)
        s.handlers = r;
      if (typeof saw.step < "u")
        s.record();
      if (cb.apply(s.chain(), args), autonext !== !1)
        s.on("end", saw.next);
    }, saw.record = function() {
      upgradeChainsaw(saw);
    }, ["trap", "down", "jump"].forEach(function(method) {
      saw[method] = function() {
        throw Error("To use the trap, down and jump features, please call record() first to start recording actions.");
      };
    }), saw;
  };
  function upgradeChainsaw(saw) {
    saw.step = 0, saw.pop = function() {
      return saw.actions[saw.step++];
    }, saw.trap = function(name, cb) {
      var ps = Array.isArray(name) ? name : [name];
      saw.actions.push({
        path: ps,
        step: saw.step,
        cb,
        trap: !0
      });
    }, saw.down = function(name) {
      var ps = (Array.isArray(name) ? name : [name]).join("/"), i = saw.actions.slice(saw.step).map(function(x) {
        if (x.trap && x.step <= saw.step)
          return !1;
        return x.path.join("/") == ps;
      }).indexOf(!0);
      if (i >= 0)
        saw.step += i;
      else
        saw.step = saw.actions.length;
      var act = saw.actions[saw.step - 1];
      if (act && act.trap)
        saw.step = act.step, act.cb();
      else
        saw.next();
    }, saw.jump = function(step) {
      saw.step = step, saw.next();
    };
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS((exports, module) => {
  module.exports = Buffers;
  function Buffers(bufs) {
    if (!(this instanceof Buffers))
      return new Buffers(bufs);
    this.buffers = bufs || [], this.length = this.buffers.reduce(function(size, buf) {
      return size + buf.length;
    }, 0);
  }
  Buffers.prototype.push = function() {
    for (var i = 0;i < arguments.length; i++)
      if (!Buffer.isBuffer(arguments[i]))
        throw TypeError("Tried to push a non-buffer");
    for (var i = 0;i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.push(buf), this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.unshift = function() {
    for (var i = 0;i < arguments.length; i++)
      if (!Buffer.isBuffer(arguments[i]))
        throw TypeError("Tried to unshift a non-buffer");
    for (var i = 0;i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.unshift(buf), this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.copy = function(dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
  };
  Buffers.prototype.splice = function(i, howMany) {
    var buffers = this.buffers, index = i >= 0 ? i : this.length - i, reps = [].slice.call(arguments, 2);
    if (howMany === void 0)
      howMany = this.length - index;
    else if (howMany > this.length - index)
      howMany = this.length - index;
    for (var i = 0;i < reps.length; i++)
      this.length += reps[i].length;
    var removed = new Buffers, bytes = 0, startBytes = 0;
    for (var ii = 0;ii < buffers.length && startBytes + buffers[ii].length < index; ii++)
      startBytes += buffers[ii].length;
    if (index - startBytes > 0) {
      var start = index - startBytes;
      if (start + howMany < buffers[ii].length) {
        removed.push(buffers[ii].slice(start, start + howMany));
        var orig = buffers[ii], buf0 = new Buffer(start);
        for (var i = 0;i < start; i++)
          buf0[i] = orig[i];
        var buf1 = new Buffer(orig.length - start - howMany);
        for (var i = start + howMany;i < orig.length; i++)
          buf1[i - howMany - start] = orig[i];
        if (reps.length > 0) {
          var reps_ = reps.slice();
          reps_.unshift(buf0), reps_.push(buf1), buffers.splice.apply(buffers, [ii, 1].concat(reps_)), ii += reps_.length, reps = [];
        } else
          buffers.splice(ii, 1, buf0, buf1), ii += 2;
      } else
        removed.push(buffers[ii].slice(start)), buffers[ii] = buffers[ii].slice(0, start), ii++;
    }
    if (reps.length > 0)
      buffers.splice.apply(buffers, [ii, 0].concat(reps)), ii += reps.length;
    while (removed.length < howMany) {
      var buf = buffers[ii], len = buf.length, take = Math.min(len, howMany - removed.length);
      if (take === len)
        removed.push(buf), buffers.splice(ii, 1);
      else
        removed.push(buf.slice(0, take)), buffers[ii] = buffers[ii].slice(take);
    }
    return this.length -= removed.length, removed;
  };
  Buffers.prototype.slice = function(i, j) {
    var buffers = this.buffers;
    if (j === void 0)
      j = this.length;
    if (i === void 0)
      i = 0;
    if (j > this.length)
      j = this.length;
    var startBytes = 0;
    for (var si = 0;si < buffers.length && startBytes + buffers[si].length <= i; si++)
      startBytes += buffers[si].length;
    var target = new Buffer(j - i), ti = 0;
    for (var ii = si;ti < j - i && ii < buffers.length; ii++) {
      var len = buffers[ii].length, start = ti === 0 ? i - startBytes : 0, end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
      buffers[ii].copy(target, ti, start, end), ti += end - start;
    }
    return target;
  };
  Buffers.prototype.pos = function(i) {
    if (i < 0 || i >= this.length)
      throw Error("oob");
    var l = i, bi = 0, bu = null;
    for (;; ) {
      if (bu = this.buffers[bi], l < bu.length)
        return { buf: bi, offset: l };
      else
        l -= bu.length;
      bi++;
    }
  };
  Buffers.prototype.get = function(i) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].get(pos.offset);
  };
  Buffers.prototype.set = function(i, b) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].set(pos.offset, b);
  };
  Buffers.prototype.indexOf = function(needle, offset) {
    if (typeof needle === "string")
      needle = new Buffer(needle);
    else if (needle instanceof Buffer)
      ;
    else
      throw Error("Invalid type for a search string");
    if (!needle.length)
      return 0;
    if (!this.length)
      return -1;
    var i = 0, j = 0, match = 0, mstart, pos = 0;
    if (offset) {
      var p = this.pos(offset);
      i = p.buf, j = p.offset, pos = offset;
    }
    for (;; ) {
      while (j >= this.buffers[i].length)
        if (j = 0, i++, i >= this.buffers.length)
          return -1;
      var char = this.buffers[i][j];
      if (char == needle[match]) {
        if (match == 0)
          mstart = {
            i,
            j,
            pos
          };
        if (match++, match == needle.length)
          return mstart.pos;
      } else if (match != 0)
        i = mstart.i, j = mstart.j, pos = mstart.pos, match = 0;
      j++, pos++;
    }
  };
  Buffers.prototype.toBuffer = function() {
    return this.slice();
  };
  Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS((exports, module) => {
  module.exports = function(store) {
    function getset(name, value) {
      var node = vars.store, keys = name.split(".");
      keys.slice(0, -1).forEach(function(k) {
        if (node[k] === void 0)
          node[k] = {};
        node = node[k];
      });
      var key = keys[keys.length - 1];
      if (arguments.length == 1)
        return node[key];
      else
        return node[key] = value;
    }
    var vars = {
      get: function(name) {
        return getset(name);
      },
      set: function(name, value) {
        return getset(name, value);
      },
      store: store || {}
    };
    return vars;
  };
});

// node_modules/binary/index.js
var require_binary = __commonJS((exports, module) => {
  var Chainsaw = require_chainsaw(), EventEmitter = __require("events").EventEmitter, Buffers = require_buffers(), Vars = require_vars(), Stream = __require("stream").Stream;
  exports = module.exports = function(bufOrEm, eventName) {
    if (Buffer.isBuffer(bufOrEm))
      return exports.parse(bufOrEm);
    var s = exports.stream();
    if (bufOrEm && bufOrEm.pipe)
      bufOrEm.pipe(s);
    else if (bufOrEm)
      bufOrEm.on(eventName || "data", function(buf) {
        s.write(buf);
      }), bufOrEm.on("end", function() {
        s.end();
      });
    return s;
  };
  exports.stream = function(input) {
    if (input)
      return exports.apply(null, arguments);
    var pending = null;
    function getBytes(bytes, cb, skip) {
      pending = {
        bytes,
        skip,
        cb: function(buf) {
          pending = null, cb(buf);
        }
      }, dispatch();
    }
    var offset = null;
    function dispatch() {
      if (!pending) {
        if (caughtEnd)
          done = !0;
        return;
      }
      if (typeof pending === "function")
        pending();
      else {
        var bytes = offset + pending.bytes;
        if (buffers.length >= bytes) {
          var buf;
          if (offset == null) {
            if (buf = buffers.splice(0, bytes), !pending.skip)
              buf = buf.slice();
          } else {
            if (!pending.skip)
              buf = buffers.slice(offset, bytes);
            offset = bytes;
          }
          if (pending.skip)
            pending.cb();
          else
            pending.cb(buf);
        }
      }
    }
    function builder(saw) {
      function next() {
        if (!done)
          saw.next();
      }
      var self2 = words(function(bytes, cb) {
        return function(name) {
          getBytes(bytes, function(buf) {
            vars.set(name, cb(buf)), next();
          });
        };
      });
      return self2.tap = function(cb) {
        saw.nest(cb, vars.store);
      }, self2.into = function(key, cb) {
        if (!vars.get(key))
          vars.set(key, {});
        var parent = vars;
        vars = Vars(parent.get(key)), saw.nest(function() {
          cb.apply(this, arguments), this.tap(function() {
            vars = parent;
          });
        }, vars.store);
      }, self2.flush = function() {
        vars.store = {}, next();
      }, self2.loop = function(cb) {
        var end = !1;
        saw.nest(!1, function loop() {
          this.vars = vars.store, cb.call(this, function() {
            end = !0, next();
          }, vars.store), this.tap(function() {
            if (end)
              saw.next();
            else
              loop.call(this);
          }.bind(this));
        }, vars.store);
      }, self2.buffer = function(name, bytes) {
        if (typeof bytes === "string")
          bytes = vars.get(bytes);
        getBytes(bytes, function(buf) {
          vars.set(name, buf), next();
        });
      }, self2.skip = function(bytes) {
        if (typeof bytes === "string")
          bytes = vars.get(bytes);
        getBytes(bytes, function() {
          next();
        });
      }, self2.scan = function(name, search) {
        if (typeof search === "string")
          search = new Buffer(search);
        else if (!Buffer.isBuffer(search))
          throw Error("search must be a Buffer or a string");
        var taken = 0;
        pending = function() {
          var pos = buffers.indexOf(search, offset + taken), i = pos - offset - taken;
          if (pos !== -1) {
            if (pending = null, offset != null)
              vars.set(name, buffers.slice(offset, offset + taken + i)), offset += taken + i + search.length;
            else
              vars.set(name, buffers.slice(0, taken + i)), buffers.splice(0, taken + i + search.length);
            next(), dispatch();
          } else
            i = Math.max(buffers.length - search.length - offset - taken, 0);
          taken += i;
        }, dispatch();
      }, self2.peek = function(cb) {
        offset = 0, saw.nest(function() {
          cb.call(this, vars.store), this.tap(function() {
            offset = null;
          });
        });
      }, self2;
    }
    var stream = Chainsaw.light(builder);
    stream.writable = !0;
    var buffers = Buffers();
    stream.write = function(buf) {
      buffers.push(buf), dispatch();
    };
    var vars = Vars(), done = !1, caughtEnd = !1;
    return stream.end = function() {
      caughtEnd = !0;
    }, stream.pipe = Stream.prototype.pipe, Object.getOwnPropertyNames(EventEmitter.prototype).forEach(function(name) {
      stream[name] = EventEmitter.prototype[name];
    }), stream;
  };
  exports.parse = function(buffer) {
    var self2 = words(function(bytes, cb) {
      return function(name) {
        if (offset + bytes <= buffer.length) {
          var buf = buffer.slice(offset, offset + bytes);
          offset += bytes, vars.set(name, cb(buf));
        } else
          vars.set(name, null);
        return self2;
      };
    }), offset = 0, vars = Vars();
    return self2.vars = vars.store, self2.tap = function(cb) {
      return cb.call(self2, vars.store), self2;
    }, self2.into = function(key, cb) {
      if (!vars.get(key))
        vars.set(key, {});
      var parent = vars;
      return vars = Vars(parent.get(key)), cb.call(self2, vars.store), vars = parent, self2;
    }, self2.loop = function(cb) {
      var end = !1, ender = function() {
        end = !0;
      };
      while (end === !1)
        cb.call(self2, ender, vars.store);
      return self2;
    }, self2.buffer = function(name, size) {
      if (typeof size === "string")
        size = vars.get(size);
      var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
      return offset += size, vars.set(name, buf), self2;
    }, self2.skip = function(bytes) {
      if (typeof bytes === "string")
        bytes = vars.get(bytes);
      return offset += bytes, self2;
    }, self2.scan = function(name, search) {
      if (typeof search === "string")
        search = new Buffer(search);
      else if (!Buffer.isBuffer(search))
        throw Error("search must be a Buffer or a string");
      vars.set(name, null);
      for (var i = 0;i + offset <= buffer.length - search.length + 1; i++) {
        for (var j = 0;j < search.length && buffer[offset + i + j] === search[j]; j++)
          ;
        if (j === search.length)
          break;
      }
      return vars.set(name, buffer.slice(offset, offset + i)), offset += i + search.length, self2;
    }, self2.peek = function(cb) {
      var was = offset;
      return cb.call(self2, vars.store), offset = was, self2;
    }, self2.flush = function() {
      return vars.store = {}, self2;
    }, self2.eof = function() {
      return offset >= buffer.length;
    }, self2;
  };
  function decodeLEu(bytes) {
    var acc = 0;
    for (var i = 0;i < bytes.length; i++)
      acc += Math.pow(256, i) * bytes[i];
    return acc;
  }
  function decodeBEu(bytes) {
    var acc = 0;
    for (var i = 0;i < bytes.length; i++)
      acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
    return acc;
  }
  function decodeBEs(bytes) {
    var val = decodeBEu(bytes);
    if ((bytes[0] & 128) == 128)
      val -= Math.pow(256, bytes.length);
    return val;
  }
  function decodeLEs(bytes) {
    var val = decodeLEu(bytes);
    if ((bytes[bytes.length - 1] & 128) == 128)
      val -= Math.pow(256, bytes.length);
    return val;
  }
  function words(decode) {
    var self2 = {};
    return [1, 2, 4, 8].forEach(function(bytes) {
      var bits = bytes * 8;
      self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes, decodeLEu), self2["word" + bits + "ls"] = decode(bytes, decodeLEs), self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes, decodeBEu), self2["word" + bits + "bs"] = decode(bytes, decodeBEs);
    }), self2.word8 = self2.word8u = self2.word8be, self2.word8s = self2.word8bs, self2;
  }
});

// node_modules/unzip-stream/lib/matcher-stream.js
var require_matcher_stream = __commonJS((exports, module) => {
  var Transform = __require("stream").Transform, util = __require("util");
  function MatcherStream(patternDesc, matchFn) {
    if (!(this instanceof MatcherStream))
      return new MatcherStream;
    Transform.call(this);
    var p = typeof patternDesc === "object" ? patternDesc.pattern : patternDesc;
    if (this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p), this.requiredLength = this.pattern.length, patternDesc.requiredExtraSize)
      this.requiredLength += patternDesc.requiredExtraSize;
    this.data = new Buffer(""), this.bytesSoFar = 0, this.matchFn = matchFn;
  }
  util.inherits(MatcherStream, Transform);
  MatcherStream.prototype.checkDataChunk = function(ignoreMatchZero) {
    var enoughData = this.data.length >= this.requiredLength;
    if (!enoughData)
      return;
    var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
    if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
      if (matchIndex > 0) {
        var packet = this.data.slice(0, matchIndex);
        this.push(packet), this.bytesSoFar += matchIndex, this.data = this.data.slice(matchIndex);
      }
      return;
    }
    if (matchIndex === -1) {
      var packetLen = this.data.length - this.requiredLength + 1, packet = this.data.slice(0, packetLen);
      this.push(packet), this.bytesSoFar += packetLen, this.data = this.data.slice(packetLen);
      return;
    }
    if (matchIndex > 0) {
      var packet = this.data.slice(0, matchIndex);
      this.data = this.data.slice(matchIndex), this.push(packet), this.bytesSoFar += matchIndex;
    }
    var finished = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : !0;
    if (finished) {
      this.data = new Buffer("");
      return;
    }
    return !0;
  };
  MatcherStream.prototype._transform = function(chunk, encoding, cb) {
    this.data = Buffer.concat([this.data, chunk]);
    var firstIteration = !0;
    while (this.checkDataChunk(!firstIteration))
      firstIteration = !1;
    cb();
  };
  MatcherStream.prototype._flush = function(cb) {
    if (this.data.length > 0) {
      var firstIteration = !0;
      while (this.checkDataChunk(!firstIteration))
        firstIteration = !1;
    }
    if (this.data.length > 0)
      this.push(this.data), this.data = null;
    cb();
  };
  module.exports = MatcherStream;
});

// node_modules/unzip-stream/lib/entry.js
var require_entry = __commonJS((exports, module) => {
  var stream = __require("stream"), inherits = __require("util").inherits;
  function Entry() {
    if (!(this instanceof Entry))
      return new Entry;
    stream.PassThrough.call(this), this.path = null, this.type = null, this.isDirectory = !1;
  }
  inherits(Entry, stream.PassThrough);
  Entry.prototype.autodrain = function() {
    return this.pipe(new stream.Transform({ transform: function(d, e, cb) {
      cb();
    } }));
  };
  module.exports = Entry;
});

// node_modules/unzip-stream/lib/unzip-stream.js
var require_unzip_stream = __commonJS((exports, module) => {
  var binary = require_binary(), stream = __require("stream"), util = __require("util"), zlib = __require("zlib"), MatcherStream = require_matcher_stream(), Entry = require_entry(), states = {
    STREAM_START: 0,
    START: 1,
    LOCAL_FILE_HEADER: 2,
    LOCAL_FILE_HEADER_SUFFIX: 3,
    FILE_DATA: 4,
    FILE_DATA_END: 5,
    DATA_DESCRIPTOR: 6,
    CENTRAL_DIRECTORY_FILE_HEADER: 7,
    CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
    CDIR64_END: 9,
    CDIR64_END_DATA_SECTOR: 10,
    CDIR64_LOCATOR: 11,
    CENTRAL_DIRECTORY_END: 12,
    CENTRAL_DIRECTORY_END_COMMENT: 13,
    TRAILING_JUNK: 14,
    ERROR: 99
  }, FOUR_GIGS = 4294967296, SIG_LOCAL_FILE_HEADER = 67324752, SIG_DATA_DESCRIPTOR = 134695760, SIG_CDIR_RECORD = 33639248, SIG_CDIR64_RECORD_END = 101075792, SIG_CDIR64_LOCATOR_END = 117853008, SIG_CDIR_RECORD_END = 101010256;
  function UnzipStream(options) {
    if (!(this instanceof UnzipStream))
      return new UnzipStream(options);
    stream.Transform.call(this), this.options = options || {}, this.data = new Buffer(""), this.state = states.STREAM_START, this.skippedBytes = 0, this.parsedEntity = null, this.outStreamInfo = {};
  }
  util.inherits(UnzipStream, stream.Transform);
  UnzipStream.prototype.processDataChunk = function(chunk) {
    var requiredLength;
    switch (this.state) {
      case states.STREAM_START:
      case states.START:
        requiredLength = 4;
        break;
      case states.LOCAL_FILE_HEADER:
        requiredLength = 26;
        break;
      case states.LOCAL_FILE_HEADER_SUFFIX:
        requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
        break;
      case states.DATA_DESCRIPTOR:
        requiredLength = 12;
        break;
      case states.CENTRAL_DIRECTORY_FILE_HEADER:
        requiredLength = 42;
        break;
      case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
        requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
        break;
      case states.CDIR64_END:
        requiredLength = 52;
        break;
      case states.CDIR64_END_DATA_SECTOR:
        requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
        break;
      case states.CDIR64_LOCATOR:
        requiredLength = 16;
        break;
      case states.CENTRAL_DIRECTORY_END:
        requiredLength = 18;
        break;
      case states.CENTRAL_DIRECTORY_END_COMMENT:
        requiredLength = this.parsedEntity.commentLength;
        break;
      case states.FILE_DATA:
        return 0;
      case states.FILE_DATA_END:
        return 0;
      case states.TRAILING_JUNK:
        if (this.options.debug)
          console.log("found", chunk.length, "bytes of TRAILING_JUNK");
        return chunk.length;
      default:
        return chunk.length;
    }
    var chunkLength = chunk.length;
    if (chunkLength < requiredLength)
      return 0;
    switch (this.state) {
      case states.STREAM_START:
      case states.START:
        var signature = chunk.readUInt32LE(0);
        switch (signature) {
          case SIG_LOCAL_FILE_HEADER:
            this.state = states.LOCAL_FILE_HEADER;
            break;
          case SIG_CDIR_RECORD:
            this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
            break;
          case SIG_CDIR64_RECORD_END:
            this.state = states.CDIR64_END;
            break;
          case SIG_CDIR64_LOCATOR_END:
            this.state = states.CDIR64_LOCATOR;
            break;
          case SIG_CDIR_RECORD_END:
            this.state = states.CENTRAL_DIRECTORY_END;
            break;
          default:
            var isStreamStart = this.state === states.STREAM_START;
            if (!isStreamStart && (signature & 65535) !== 19280 && this.skippedBytes < 26) {
              var remaining = signature, toSkip = 4;
              for (var i = 1;i < 4 && remaining !== 0; i++)
                if (remaining = remaining >>> 8, (remaining & 255) === 80) {
                  toSkip = i;
                  break;
                }
              if (this.skippedBytes += toSkip, this.options.debug)
                console.log("Skipped", this.skippedBytes, "bytes");
              return toSkip;
            }
            this.state = states.ERROR;
            var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
            if (this.options.debug) {
              var sig = chunk.readUInt32LE(0), asString;
              try {
                asString = chunk.slice(0, 4).toString();
              } catch (e) {}
              console.log("Unexpected signature in zip file: 0x" + sig.toString(16), '"' + asString + '", skipped', this.skippedBytes, "bytes");
            }
            return this.emit("error", Error(errMsg)), chunk.length;
        }
        return this.skippedBytes = 0, requiredLength;
      case states.LOCAL_FILE_HEADER:
        return this.parsedEntity = this._readFile(chunk), this.state = states.LOCAL_FILE_HEADER_SUFFIX, requiredLength;
      case states.LOCAL_FILE_HEADER_SUFFIX:
        var entry = new Entry, isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
        entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
        var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength), extra = this._readExtraFields(extraDataBuffer);
        if (extra && extra.parsed) {
          if (extra.parsed.path && !isUtf8)
            entry.path = extra.parsed.path;
          if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS - 1)
            this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
          if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS - 1)
            this.parsedEntity.compressedSize = extra.parsed.compressedSize;
        }
        if (this.parsedEntity.extra = extra.parsed || {}, this.options.debug) {
          let debugObj = Object.assign({}, this.parsedEntity, {
            path: entry.path,
            flags: "0x" + this.parsedEntity.flags.toString(16),
            extraFields: extra && extra.debug
          });
          console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
        }
        return this._prepareOutStream(this.parsedEntity, entry), this.emit("entry", entry), this.state = states.FILE_DATA, requiredLength;
      case states.CENTRAL_DIRECTORY_FILE_HEADER:
        return this.parsedEntity = this._readCentralDirectoryEntry(chunk), this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX, requiredLength;
      case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
        var isUtf8 = (this.parsedEntity.flags & 2048) !== 0, path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8), extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength), extra = this._readExtraFields(extraDataBuffer);
        if (extra && extra.parsed && extra.parsed.path && !isUtf8)
          path = extra.parsed.path;
        this.parsedEntity.extra = extra.parsed;
        var isUnix = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3, unixAttrs, isSymlink;
        if (isUnix) {
          unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
          var fileType = unixAttrs >>> 12;
          isSymlink = (fileType & 10) === 10;
        }
        if (this.options.debug) {
          let debugObj = Object.assign({}, this.parsedEntity, {
            path,
            flags: "0x" + this.parsedEntity.flags.toString(16),
            unixAttrs: unixAttrs && "0" + unixAttrs.toString(8),
            isSymlink,
            extraFields: extra.debug
          });
          console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
        }
        return this.state = states.START, requiredLength;
      case states.CDIR64_END:
        if (this.parsedEntity = this._readEndOfCentralDirectory64(chunk), this.options.debug)
          console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
        return this.state = states.CDIR64_END_DATA_SECTOR, requiredLength;
      case states.CDIR64_END_DATA_SECTOR:
        return this.state = states.START, requiredLength;
      case states.CDIR64_LOCATOR:
        return this.state = states.START, requiredLength;
      case states.CENTRAL_DIRECTORY_END:
        if (this.parsedEntity = this._readEndOfCentralDirectory(chunk), this.options.debug)
          console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
        return this.state = states.CENTRAL_DIRECTORY_END_COMMENT, requiredLength;
      case states.CENTRAL_DIRECTORY_END_COMMENT:
        if (this.options.debug)
          console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
        return this.state = states.TRAILING_JUNK, requiredLength;
      case states.ERROR:
        return chunk.length;
      default:
        return console.log("didn't handle state #", this.state, "discarding"), chunk.length;
    }
  };
  UnzipStream.prototype._prepareOutStream = function(vars, entry) {
    var self2 = this, isDirectory = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
    entry.path = entry.path.replace(/(?<=^|[/\\]+)[.][.]+(?=[/\\]+|$)/g, "."), entry.type = isDirectory ? "Directory" : "File", entry.isDirectory = isDirectory;
    var fileSizeKnown = !(vars.flags & 8);
    if (fileSizeKnown)
      entry.size = vars.uncompressedSize;
    var isVersionSupported = vars.versionsNeededToExtract <= 45;
    if (this.outStreamInfo = {
      stream: null,
      limit: fileSizeKnown ? vars.compressedSize : -1,
      written: 0
    }, !fileSizeKnown) {
      var pattern = new Buffer(4);
      pattern.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
      var zip64Mode = vars.extra.zip64Mode, extraSize = zip64Mode ? 20 : 12, searchPattern = {
        pattern,
        requiredExtraSize: extraSize
      }, matcherStream = new MatcherStream(searchPattern, function(matchedChunk, sizeSoFar) {
        var vars2 = self2._readDataDescriptor(matchedChunk, zip64Mode), compressedSizeMatches = vars2.compressedSize === sizeSoFar;
        if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
          var overflown = sizeSoFar - FOUR_GIGS;
          while (overflown >= 0) {
            if (compressedSizeMatches = vars2.compressedSize === overflown, compressedSizeMatches)
              break;
            overflown -= FOUR_GIGS;
          }
        }
        if (!compressedSizeMatches)
          return;
        self2.state = states.FILE_DATA_END;
        var sliceOffset = zip64Mode ? 24 : 16;
        if (self2.data.length > 0)
          self2.data = Buffer.concat([matchedChunk.slice(sliceOffset), self2.data]);
        else
          self2.data = matchedChunk.slice(sliceOffset);
        return !0;
      });
      this.outStreamInfo.stream = matcherStream;
    } else
      this.outStreamInfo.stream = new stream.PassThrough;
    var isEncrypted = vars.flags & 1 || vars.flags & 64;
    if (isEncrypted || !isVersionSupported) {
      var message = isEncrypted ? "Encrypted files are not supported!" : "Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported";
      entry.skip = !0, setImmediate(() => {
        self2.emit("error", Error(message));
      }), this.outStreamInfo.stream.pipe(new Entry().autodrain());
      return;
    }
    var isCompressed = vars.compressionMethod > 0;
    if (isCompressed) {
      var inflater = zlib.createInflateRaw();
      inflater.on("error", function(err) {
        self2.state = states.ERROR, self2.emit("error", err);
      }), this.outStreamInfo.stream.pipe(inflater).pipe(entry);
    } else
      this.outStreamInfo.stream.pipe(entry);
    if (this._drainAllEntries)
      entry.autodrain();
  };
  UnzipStream.prototype._readFile = function(data) {
    var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
    return vars;
  };
  UnzipStream.prototype._readExtraFields = function(data) {
    var extra = {}, result = { parsed: extra };
    if (this.options.debug)
      result.debug = [];
    var index = 0;
    while (index < data.length) {
      var vars = binary.parse(data).skip(index).word16lu("extraId").word16lu("extraSize").vars;
      index += 4;
      var fieldType = void 0;
      switch (vars.extraId) {
        case 1:
          fieldType = "Zip64 extended information extra field";
          var z64vars = binary.parse(data.slice(index, index + vars.extraSize)).word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offsetToLocalHeader").word32lu("diskStartNumber").vars;
          if (z64vars.uncompressedSize !== null)
            extra.uncompressedSize = z64vars.uncompressedSize;
          if (z64vars.compressedSize !== null)
            extra.compressedSize = z64vars.compressedSize;
          extra.zip64Mode = !0;
          break;
        case 10:
          fieldType = "NTFS extra field";
          break;
        case 21589:
          fieldType = "extended timestamp";
          var timestampFields = data.readUInt8(index), offset = 1;
          if (vars.extraSize >= offset + 4 && timestampFields & 1)
            extra.mtime = new Date(data.readUInt32LE(index + offset) * 1000), offset += 4;
          if (vars.extraSize >= offset + 4 && timestampFields & 2)
            extra.atime = new Date(data.readUInt32LE(index + offset) * 1000), offset += 4;
          if (vars.extraSize >= offset + 4 && timestampFields & 4)
            extra.ctime = new Date(data.readUInt32LE(index + offset) * 1000);
          break;
        case 28789:
          fieldType = "Info-ZIP Unicode Path Extra Field";
          var fieldVer = data.readUInt8(index);
          if (fieldVer === 1) {
            var offset = 1, nameCrc32 = data.readUInt32LE(index + offset);
            offset += 4;
            var pathBuffer = data.slice(index + offset);
            extra.path = pathBuffer.toString();
          }
          break;
        case 13:
        case 22613:
          fieldType = vars.extraId === 13 ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
          var offset = 0;
          if (vars.extraSize >= 8) {
            var atime = new Date(data.readUInt32LE(index + offset) * 1000);
            offset += 4;
            var mtime = new Date(data.readUInt32LE(index + offset) * 1000);
            if (offset += 4, extra.atime = atime, extra.mtime = mtime, vars.extraSize >= 12) {
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2, extra.uid = uid, extra.gid = gid;
            }
          }
          break;
        case 30805:
          fieldType = "Info-ZIP UNIX (type 2)";
          var offset = 0;
          if (vars.extraSize >= 4) {
            var uid = data.readUInt16LE(index + offset);
            offset += 2;
            var gid = data.readUInt16LE(index + offset);
            offset += 2, extra.uid = uid, extra.gid = gid;
          }
          break;
        case 30837:
          fieldType = "Info-ZIP New Unix";
          var offset = 0, extraVer = data.readUInt8(index);
          if (offset += 1, extraVer === 1) {
            var uidSize = data.readUInt8(index + offset);
            if (offset += 1, uidSize <= 6)
              extra.uid = data.readUIntLE(index + offset, uidSize);
            offset += uidSize;
            var gidSize = data.readUInt8(index + offset);
            if (offset += 1, gidSize <= 6)
              extra.gid = data.readUIntLE(index + offset, gidSize);
          }
          break;
        case 30062:
          fieldType = "ASi Unix";
          var offset = 0;
          if (vars.extraSize >= 14) {
            var crc = data.readUInt32LE(index + offset);
            offset += 4;
            var mode = data.readUInt16LE(index + offset);
            offset += 2;
            var sizdev = data.readUInt32LE(index + offset);
            offset += 4;
            var uid = data.readUInt16LE(index + offset);
            offset += 2;
            var gid = data.readUInt16LE(index + offset);
            if (offset += 2, extra.mode = mode, extra.uid = uid, extra.gid = gid, vars.extraSize > 14) {
              var start = index + offset, end = index + vars.extraSize - 14, symlinkName = this._decodeString(data.slice(start, end));
              extra.symlink = symlinkName;
            }
          }
          break;
      }
      if (this.options.debug)
        result.debug.push({
          extraId: "0x" + vars.extraId.toString(16),
          description: fieldType,
          data: data.slice(index, index + vars.extraSize).inspect()
        });
      index += vars.extraSize;
    }
    return result;
  };
  UnzipStream.prototype._readDataDescriptor = function(data, zip64Mode) {
    if (zip64Mode) {
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word64lu("compressedSize").word64lu("uncompressedSize").vars;
      return vars;
    }
    var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
    return vars;
  };
  UnzipStream.prototype._readCentralDirectoryEntry = function(data) {
    var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
    return vars;
  };
  UnzipStream.prototype._readEndOfCentralDirectory64 = function(data) {
    var vars = binary.parse(data).word64lu("centralDirectoryRecordSize").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskNumberWithCentralDirectoryStart").word64lu("centralDirectoryEntries").word64lu("totalCentralDirectoryEntries").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
    return vars;
  };
  UnzipStream.prototype._readEndOfCentralDirectory = function(data) {
    var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("centralDirectoryEntries").word16lu("totalCentralDirectoryEntries").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
    return vars;
  };
  var cp437 = "\x00 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ";
  UnzipStream.prototype._decodeString = function(buffer, isUtf8) {
    if (isUtf8)
      return buffer.toString("utf8");
    if (this.options.decodeString)
      return this.options.decodeString(buffer);
    let result = "";
    for (var i = 0;i < buffer.length; i++)
      result += cp437[buffer[i]];
    return result;
  };
  UnzipStream.prototype._parseOrOutput = function(encoding, cb) {
    var consume;
    while ((consume = this.processDataChunk(this.data)) > 0)
      if (this.data = this.data.slice(consume), this.data.length === 0)
        break;
    if (this.state === states.FILE_DATA) {
      if (this.outStreamInfo.limit >= 0) {
        var remaining = this.outStreamInfo.limit - this.outStreamInfo.written, packet;
        if (remaining < this.data.length)
          packet = this.data.slice(0, remaining), this.data = this.data.slice(remaining);
        else
          packet = this.data, this.data = new Buffer("");
        if (this.outStreamInfo.written += packet.length, this.outStreamInfo.limit === this.outStreamInfo.written)
          this.state = states.START, this.outStreamInfo.stream.end(packet, encoding, cb);
        else
          this.outStreamInfo.stream.write(packet, encoding, cb);
      } else {
        var packet = this.data;
        this.data = new Buffer(""), this.outStreamInfo.written += packet.length;
        var outputStream = this.outStreamInfo.stream;
        outputStream.write(packet, encoding, () => {
          if (this.state === states.FILE_DATA_END)
            return this.state = states.START, outputStream.end(cb);
          cb();
        });
      }
      return;
    }
    cb();
  };
  UnzipStream.prototype.drainAll = function() {
    this._drainAllEntries = !0;
  };
  UnzipStream.prototype._transform = function(chunk, encoding, cb) {
    var self2 = this;
    if (self2.data.length > 0)
      self2.data = Buffer.concat([self2.data, chunk]);
    else
      self2.data = chunk;
    var startDataLength = self2.data.length, done = function() {
      if (self2.data.length > 0 && self2.data.length < startDataLength) {
        startDataLength = self2.data.length, self2._parseOrOutput(encoding, done);
        return;
      }
      cb();
    };
    self2._parseOrOutput(encoding, done);
  };
  UnzipStream.prototype._flush = function(cb) {
    var self2 = this;
    if (self2.data.length > 0) {
      self2._parseOrOutput("buffer", function() {
        if (self2.data.length > 0)
          return setImmediate(function() {
            self2._flush(cb);
          });
        cb();
      });
      return;
    }
    if (self2.state === states.FILE_DATA)
      return cb(Error("Stream finished in an invalid state, uncompression failed"));
    setImmediate(cb);
  };
  module.exports = UnzipStream;
});

// node_modules/unzip-stream/lib/parser-stream.js
var require_parser_stream = __commonJS((exports, module) => {
  var Transform = __require("stream").Transform, util = __require("util"), UnzipStream = require_unzip_stream();
  function ParserStream(opts) {
    if (!(this instanceof ParserStream))
      return new ParserStream(opts);
    var transformOpts = opts || {};
    Transform.call(this, { readableObjectMode: !0 }), this.opts = opts || {}, this.unzipStream = new UnzipStream(this.opts);
    var self2 = this;
    this.unzipStream.on("entry", function(entry) {
      self2.push(entry);
    }), this.unzipStream.on("error", function(error) {
      self2.emit("error", error);
    });
  }
  util.inherits(ParserStream, Transform);
  ParserStream.prototype._transform = function(chunk, encoding, cb) {
    this.unzipStream.write(chunk, encoding, cb);
  };
  ParserStream.prototype._flush = function(cb) {
    var self2 = this;
    this.unzipStream.end(function() {
      process.nextTick(function() {
        self2.emit("close");
      }), cb();
    });
  };
  ParserStream.prototype.on = function(eventName, fn) {
    if (eventName === "entry")
      return Transform.prototype.on.call(this, "data", fn);
    return Transform.prototype.on.call(this, eventName, fn);
  };
  ParserStream.prototype.drainAll = function() {
    return this.unzipStream.drainAll(), this.pipe(new Transform({ objectMode: !0, transform: function(d, e, cb) {
      cb();
    } }));
  };
  module.exports = ParserStream;
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS((exports, module) => {
  var path = __require("path"), fs = __require("fs"), _0777 = parseInt("0777", 8);
  module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  function mkdirP(p, opts, f, made) {
    if (typeof opts === "function")
      f = opts, opts = {};
    else if (!opts || typeof opts !== "object")
      opts = { mode: opts };
    var mode = opts.mode, xfs = opts.fs || fs;
    if (mode === void 0)
      mode = _0777;
    if (!made)
      made = null;
    var cb = f || function() {};
    p = path.resolve(p), xfs.mkdir(p, mode, function(er) {
      if (!er)
        return made = made || p, cb(null, made);
      switch (er.code) {
        case "ENOENT":
          if (path.dirname(p) === p)
            return cb(er);
          mkdirP(path.dirname(p), opts, function(er2, made2) {
            if (er2)
              cb(er2, made2);
            else
              mkdirP(p, opts, cb, made2);
          });
          break;
        default:
          xfs.stat(p, function(er2, stat) {
            if (er2 || !stat.isDirectory())
              cb(er, made);
            else
              cb(null, made);
          });
          break;
      }
    });
  }
  mkdirP.sync = function sync(p, opts, made) {
    if (!opts || typeof opts !== "object")
      opts = { mode: opts };
    var mode = opts.mode, xfs = opts.fs || fs;
    if (mode === void 0)
      mode = _0777;
    if (!made)
      made = null;
    p = path.resolve(p);
    try {
      xfs.mkdirSync(p, mode), made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case "ENOENT":
          made = sync(path.dirname(p), opts, made), sync(p, opts, made);
          break;
        default:
          var stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory())
            throw err0;
          break;
      }
    }
    return made;
  };
});

// node_modules/unzip-stream/lib/extract.js
var require_extract2 = __commonJS((exports, module) => {
  var fs = __require("fs"), path = __require("path"), util = __require("util"), mkdirp = require_mkdirp(), Transform = __require("stream").Transform, UnzipStream = require_unzip_stream();
  function Extract(opts) {
    if (!(this instanceof Extract))
      return new Extract(opts);
    Transform.call(this), this.opts = opts || {}, this.unzipStream = new UnzipStream(this.opts), this.unfinishedEntries = 0, this.afterFlushWait = !1, this.createdDirectories = {};
    var self2 = this;
    this.unzipStream.on("entry", this._processEntry.bind(this)), this.unzipStream.on("error", function(error) {
      self2.emit("error", error);
    });
  }
  util.inherits(Extract, Transform);
  Extract.prototype._transform = function(chunk, encoding, cb) {
    this.unzipStream.write(chunk, encoding, cb);
  };
  Extract.prototype._flush = function(cb) {
    var self2 = this, allDone = function() {
      process.nextTick(function() {
        self2.emit("close");
      }), cb();
    };
    this.unzipStream.end(function() {
      if (self2.unfinishedEntries > 0)
        return self2.afterFlushWait = !0, self2.on("await-finished", allDone);
      allDone();
    });
  };
  Extract.prototype._processEntry = function(entry) {
    var self2 = this, destPath = path.join(this.opts.path, entry.path), directory = entry.isDirectory ? destPath : path.dirname(destPath);
    this.unfinishedEntries++;
    var writeFileFn = function() {
      var pipedStream = fs.createWriteStream(destPath);
      pipedStream.on("close", function() {
        self2.unfinishedEntries--, self2._notifyAwaiter();
      }), pipedStream.on("error", function(error) {
        self2.emit("error", error);
      }), entry.pipe(pipedStream);
    };
    if (this.createdDirectories[directory] || directory === ".")
      return writeFileFn();
    mkdirp(directory, function(err) {
      if (err)
        return self2.emit("error", err);
      if (self2.createdDirectories[directory] = !0, entry.isDirectory) {
        self2.unfinishedEntries--, self2._notifyAwaiter();
        return;
      }
      writeFileFn();
    });
  };
  Extract.prototype._notifyAwaiter = function() {
    if (this.afterFlushWait && this.unfinishedEntries === 0)
      this.emit("await-finished"), this.afterFlushWait = !1;
  };
  module.exports = Extract;
});

// node_modules/unzip-stream/unzip.js
var require_unzip = __commonJS((exports) => {
  exports.Parse = require_parser_stream();
  exports.Extract = require_extract2();
});

// node_modules/@actions/artifact/lib/internal/download/download-artifact.js
var require_download_artifact = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.streamExtractExternal = streamExtractExternal;
  exports.downloadArtifactPublic = downloadArtifactPublic;
  exports.downloadArtifactInternal = downloadArtifactInternal;
  var promises_1 = __importDefault(__require("fs/promises")), crypto2 = __importStar(__require("crypto")), stream = __importStar(__require("stream")), github = __importStar(require_github()), core = __importStar(require_core()), httpClient = __importStar(require_lib()), unzip_stream_1 = __importDefault(require_unzip()), user_agent_1 = require_user_agent(), config_1 = require_config(), artifact_twirp_client_1 = require_artifact_twirp_client2(), generated_1 = require_generated(), util_1 = require_util8(), errors_1 = require_errors2(), scrubQueryParameters = (url) => {
    let parsed = new URL(url);
    return parsed.search = "", parsed.toString();
  };
  function exists(path) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return yield promises_1.default.access(path), !0;
      } catch (error) {
        if (error.code === "ENOENT")
          return !1;
        else
          throw error;
      }
    });
  }
  function streamExtract(url, directory) {
    return __awaiter(this, void 0, void 0, function* () {
      let retryCount = 0;
      while (retryCount < 5)
        try {
          return yield streamExtractExternal(url, directory);
        } catch (error) {
          retryCount++, core.debug(`Failed to download artifact after ${retryCount} retries due to ${error.message}. Retrying in 5 seconds...`), yield new Promise((resolve) => setTimeout(resolve, 5000));
        }
      throw Error(`Artifact download failed after ${retryCount} retries.`);
    });
  }
  function streamExtractExternal(url_1, directory_1) {
    return __awaiter(this, arguments, void 0, function* (url, directory, opts = { timeout: 30000 }) {
      let response = yield new httpClient.HttpClient((0, user_agent_1.getUserAgentString)()).get(url);
      if (response.message.statusCode !== 200)
        throw Error(`Unexpected HTTP response from blob storage: ${response.message.statusCode} ${response.message.statusMessage}`);
      let sha256Digest = void 0;
      return new Promise((resolve, reject) => {
        let timer = setTimeout(() => {
          let timeoutError = Error(`Blob storage chunk did not respond in ${opts.timeout}ms`);
          response.message.destroy(timeoutError), reject(timeoutError);
        }, opts.timeout), hashStream = crypto2.createHash("sha256").setEncoding("hex"), passThrough = new stream.PassThrough;
        response.message.pipe(passThrough), passThrough.pipe(hashStream), passThrough.on("data", () => {
          timer.refresh();
        }).on("error", (error) => {
          core.debug(`response.message: Artifact download failed: ${error.message}`), clearTimeout(timer), reject(error);
        }).pipe(unzip_stream_1.default.Extract({ path: directory })).on("close", () => {
          if (clearTimeout(timer), hashStream)
            hashStream.end(), sha256Digest = hashStream.read(), core.info(`SHA256 digest of downloaded artifact is ${sha256Digest}`);
          resolve({ sha256Digest: `sha256:${sha256Digest}` });
        }).on("error", (error) => {
          reject(error);
        });
      });
    });
  }
  function downloadArtifactPublic(artifactId, repositoryOwner, repositoryName, token, options) {
    return __awaiter(this, void 0, void 0, function* () {
      let downloadPath = yield resolveOrCreateDirectory(options === null || options === void 0 ? void 0 : options.path), api = github.getOctokit(token), digestMismatch = !1;
      core.info(`Downloading artifact '${artifactId}' from '${repositoryOwner}/${repositoryName}'`);
      let { headers, status } = yield api.rest.actions.downloadArtifact({
        owner: repositoryOwner,
        repo: repositoryName,
        artifact_id: artifactId,
        archive_format: "zip",
        request: {
          redirect: "manual"
        }
      });
      if (status !== 302)
        throw Error(`Unable to download artifact. Unexpected status: ${status}`);
      let { location } = headers;
      if (!location)
        throw Error("Unable to redirect to artifact download url");
      core.info(`Redirecting to blob download url: ${scrubQueryParameters(location)}`);
      try {
        core.info(`Starting download of artifact to: ${downloadPath}`);
        let extractResponse = yield streamExtract(location, downloadPath);
        if (core.info("Artifact download completed successfully."), options === null || options === void 0 ? void 0 : options.expectedHash) {
          if ((options === null || options === void 0 ? void 0 : options.expectedHash) !== extractResponse.sha256Digest)
            digestMismatch = !0, core.debug(`Computed digest: ${extractResponse.sha256Digest}`), core.debug(`Expected digest: ${options.expectedHash}`);
        }
      } catch (error) {
        throw Error(`Unable to download and extract artifact: ${error.message}`);
      }
      return { downloadPath, digestMismatch };
    });
  }
  function downloadArtifactInternal(artifactId, options) {
    return __awaiter(this, void 0, void 0, function* () {
      let downloadPath = yield resolveOrCreateDirectory(options === null || options === void 0 ? void 0 : options.path), artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)(), digestMismatch = !1, { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)(), listReq = {
        workflowRunBackendId,
        workflowJobRunBackendId,
        idFilter: generated_1.Int64Value.create({ value: artifactId.toString() })
      }, { artifacts } = yield artifactClient.ListArtifacts(listReq);
      if (artifacts.length === 0)
        throw new errors_1.ArtifactNotFoundError(`No artifacts found for ID: ${artifactId}
Are you trying to download from a different run? Try specifying a github-token with \`actions:read\` scope.`);
      if (artifacts.length > 1)
        core.warning("Multiple artifacts found, defaulting to first.");
      let signedReq = {
        workflowRunBackendId: artifacts[0].workflowRunBackendId,
        workflowJobRunBackendId: artifacts[0].workflowJobRunBackendId,
        name: artifacts[0].name
      }, { signedUrl } = yield artifactClient.GetSignedArtifactURL(signedReq);
      core.info(`Redirecting to blob download url: ${scrubQueryParameters(signedUrl)}`);
      try {
        core.info(`Starting download of artifact to: ${downloadPath}`);
        let extractResponse = yield streamExtract(signedUrl, downloadPath);
        if (core.info("Artifact download completed successfully."), options === null || options === void 0 ? void 0 : options.expectedHash) {
          if ((options === null || options === void 0 ? void 0 : options.expectedHash) !== extractResponse.sha256Digest)
            digestMismatch = !0, core.debug(`Computed digest: ${extractResponse.sha256Digest}`), core.debug(`Expected digest: ${options.expectedHash}`);
        }
      } catch (error) {
        throw Error(`Unable to download and extract artifact: ${error.message}`);
      }
      return { downloadPath, digestMismatch };
    });
  }
  function resolveOrCreateDirectory() {
    return __awaiter(this, arguments, void 0, function* (downloadPath = (0, config_1.getGitHubWorkspaceDir)()) {
      if (!(yield exists(downloadPath)))
        core.debug(`Artifact destination folder does not exist, creating: ${downloadPath}`), yield promises_1.default.mkdir(downloadPath, { recursive: !0 });
      else
        core.debug(`Artifact destination folder already exists: ${downloadPath}`);
      return downloadPath;
    });
  }
});

// node_modules/@actions/artifact/lib/internal/find/retry-options.js
var require_retry_options = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getRetryOptions = getRetryOptions;
  var core = __importStar(require_core()), defaultMaxRetryNumber = 5, defaultExemptStatusCodes = [400, 401, 403, 404, 422];
  function getRetryOptions(defaultOptions, retries = defaultMaxRetryNumber, exemptStatusCodes = defaultExemptStatusCodes) {
    var _a;
    if (retries <= 0)
      return [{ enabled: !1 }, defaultOptions.request];
    let retryOptions = {
      enabled: !0
    };
    if (exemptStatusCodes.length > 0)
      retryOptions.doNotRetry = exemptStatusCodes;
    let requestOptions = Object.assign(Object.assign({}, defaultOptions.request), { retries });
    return core.debug(`GitHub client configured with: (retries: ${requestOptions.retries}, retry-exempt-status-code: ${(_a = retryOptions.doNotRetry) !== null && _a !== void 0 ? _a : "octokit default: [400, 401, 403, 404, 422]"})`), [retryOptions, requestOptions];
  }
});

// node_modules/@octokit/plugin-request-log/dist-node/index.js
var require_dist_node14 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var VERSION = "1.0.4";
  function requestLog(octokit) {
    octokit.hook.wrap("request", (request, options) => {
      octokit.log.debug("request", options);
      let start = Date.now(), requestOptions = octokit.request.endpoint.parse(options), path = requestOptions.url.replace(options.baseUrl, "");
      return request(options).then((response) => {
        return octokit.log.info(`${requestOptions.method} ${path} - ${response.status} in ${Date.now() - start}ms`), response;
      }).catch((error) => {
        throw octokit.log.info(`${requestOptions.method} ${path} - ${error.status} in ${Date.now() - start}ms`), error;
      });
    });
  }
  requestLog.VERSION = VERSION;
  exports.requestLog = requestLog;
});

// node_modules/bottleneck/light.js
var require_light = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module < "u" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.Bottleneck = factory();
  })(exports, function() {
    var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function getCjsExportFromNamespace(n) {
      return n && n.default || n;
    }
    var load = function(received, defaults, onto = {}) {
      var k, ref, v;
      for (k in defaults)
        v = defaults[k], onto[k] = (ref = received[k]) != null ? ref : v;
      return onto;
    }, overwrite = function(received, defaults, onto = {}) {
      var k, v;
      for (k in received)
        if (v = received[k], defaults[k] !== void 0)
          onto[k] = v;
      return onto;
    }, parser = {
      load,
      overwrite
    }, DLList;
    DLList = class {
      constructor(incr, decr) {
        this.incr = incr, this.decr = decr, this._first = null, this._last = null, this.length = 0;
      }
      push(value) {
        var node;
        if (this.length++, typeof this.incr === "function")
          this.incr();
        if (node = {
          value,
          prev: this._last,
          next: null
        }, this._last != null)
          this._last.next = node, this._last = node;
        else
          this._first = this._last = node;
        return;
      }
      shift() {
        var value;
        if (this._first == null)
          return;
        else if (this.length--, typeof this.decr === "function")
          this.decr();
        if (value = this._first.value, (this._first = this._first.next) != null)
          this._first.prev = null;
        else
          this._last = null;
        return value;
      }
      first() {
        if (this._first != null)
          return this._first.value;
      }
      getArray() {
        var node, ref, results;
        node = this._first, results = [];
        while (node != null)
          results.push((ref = node, node = node.next, ref.value));
        return results;
      }
      forEachShift(cb) {
        var node = this.shift();
        while (node != null)
          cb(node), node = this.shift();
        return;
      }
      debug() {
        var node, ref, ref1, ref2, results;
        node = this._first, results = [];
        while (node != null)
          results.push((ref = node, node = node.next, {
            value: ref.value,
            prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
            next: (ref2 = ref.next) != null ? ref2.value : void 0
          }));
        return results;
      }
    };
    var DLList_1 = DLList, Events;
    Events = class {
      constructor(instance) {
        if (this.instance = instance, this._events = {}, this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null)
          throw Error("An Emitter already exists for this object");
        this.instance.on = (name, cb) => {
          return this._addListener(name, "many", cb);
        }, this.instance.once = (name, cb) => {
          return this._addListener(name, "once", cb);
        }, this.instance.removeAllListeners = (name = null) => {
          if (name != null)
            return delete this._events[name];
          else
            return this._events = {};
        };
      }
      _addListener(name, status, cb) {
        var base;
        if ((base = this._events)[name] == null)
          base[name] = [];
        return this._events[name].push({ cb, status }), this.instance;
      }
      listenerCount(name) {
        if (this._events[name] != null)
          return this._events[name].length;
        else
          return 0;
      }
      async trigger(name, ...args) {
        var e, promises;
        try {
          if (name !== "debug")
            this.trigger("debug", `Event triggered: ${name}`, args);
          if (this._events[name] == null)
            return;
          return this._events[name] = this._events[name].filter(function(listener) {
            return listener.status !== "none";
          }), promises = this._events[name].map(async (listener) => {
            var e2, returned;
            if (listener.status === "none")
              return;
            if (listener.status === "once")
              listener.status = "none";
            try {
              if (returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0, typeof (returned != null ? returned.then : void 0) === "function")
                return await returned;
              else
                return returned;
            } catch (error) {
              return e2 = error, this.trigger("error", e2), null;
            }
          }), (await Promise.all(promises)).find(function(x) {
            return x != null;
          });
        } catch (error) {
          return e = error, this.trigger("error", e), null;
        }
      }
    };
    var Events_1 = Events, DLList$1, Events$1, Queues;
    DLList$1 = DLList_1, Events$1 = Events_1, Queues = class {
      constructor(num_priorities) {
        var i;
        this.Events = new Events$1(this), this._length = 0, this._lists = function() {
          var j, ref, results;
          results = [];
          for (i = j = 1, ref = num_priorities;1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j)
            results.push(new DLList$1(() => {
              return this.incr();
            }, () => {
              return this.decr();
            }));
          return results;
        }.call(this);
      }
      incr() {
        if (this._length++ === 0)
          return this.Events.trigger("leftzero");
      }
      decr() {
        if (--this._length === 0)
          return this.Events.trigger("zero");
      }
      push(job) {
        return this._lists[job.options.priority].push(job);
      }
      queued(priority) {
        if (priority != null)
          return this._lists[priority].length;
        else
          return this._length;
      }
      shiftAll(fn) {
        return this._lists.forEach(function(list) {
          return list.forEachShift(fn);
        });
      }
      getFirst(arr = this._lists) {
        var j, len, list;
        for (j = 0, len = arr.length;j < len; j++)
          if (list = arr[j], list.length > 0)
            return list;
        return [];
      }
      shiftLastFrom(priority) {
        return this.getFirst(this._lists.slice(priority).reverse()).shift();
      }
    };
    var Queues_1 = Queues, BottleneckError;
    BottleneckError = class extends Error {
    };
    var BottleneckError_1 = BottleneckError, BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;
    NUM_PRIORITIES = 10, DEFAULT_PRIORITY = 5, parser$1 = parser, BottleneckError$1 = BottleneckError_1, Job = class {
      constructor(task, args, options, jobDefaults, rejectOnDrop, Events2, _states, Promise2) {
        if (this.task = task, this.args = args, this.rejectOnDrop = rejectOnDrop, this.Events = Events2, this._states = _states, this.Promise = Promise2, this.options = parser$1.load(options, jobDefaults), this.options.priority = this._sanitizePriority(this.options.priority), this.options.id === jobDefaults.id)
          this.options.id = `${this.options.id}-${this._randomIndex()}`;
        this.promise = new this.Promise((_resolve, _reject) => {
          this._resolve = _resolve, this._reject = _reject;
        }), this.retryCount = 0;
      }
      _sanitizePriority(priority) {
        var sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
        if (sProperty < 0)
          return 0;
        else if (sProperty > NUM_PRIORITIES - 1)
          return NUM_PRIORITIES - 1;
        else
          return sProperty;
      }
      _randomIndex() {
        return Math.random().toString(36).slice(2);
      }
      doDrop({ error, message = "This job has been dropped by Bottleneck" } = {}) {
        if (this._states.remove(this.options.id)) {
          if (this.rejectOnDrop)
            this._reject(error != null ? error : new BottleneckError$1(message));
          return this.Events.trigger("dropped", { args: this.args, options: this.options, task: this.task, promise: this.promise }), !0;
        } else
          return !1;
      }
      _assertStatus(expected) {
        var status = this._states.jobStatus(this.options.id);
        if (!(status === expected || expected === "DONE" && status === null))
          throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
      }
      doReceive() {
        return this._states.start(this.options.id), this.Events.trigger("received", { args: this.args, options: this.options });
      }
      doQueue(reachedHWM, blocked) {
        return this._assertStatus("RECEIVED"), this._states.next(this.options.id), this.Events.trigger("queued", { args: this.args, options: this.options, reachedHWM, blocked });
      }
      doRun() {
        if (this.retryCount === 0)
          this._assertStatus("QUEUED"), this._states.next(this.options.id);
        else
          this._assertStatus("EXECUTING");
        return this.Events.trigger("scheduled", { args: this.args, options: this.options });
      }
      async doExecute(chained, clearGlobalState, run, free) {
        var error, eventInfo, passed;
        if (this.retryCount === 0)
          this._assertStatus("RUNNING"), this._states.next(this.options.id);
        else
          this._assertStatus("EXECUTING");
        eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount }, this.Events.trigger("executing", eventInfo);
        try {
          if (passed = await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args)), clearGlobalState())
            return this.doDone(eventInfo), await free(this.options, eventInfo), this._assertStatus("DONE"), this._resolve(passed);
        } catch (error1) {
          return error = error1, this._onFailure(error, eventInfo, clearGlobalState, run, free);
        }
      }
      doExpire(clearGlobalState, run, free) {
        var error, eventInfo;
        if (this._states.jobStatus(this.options.id === "RUNNING"))
          this._states.next(this.options.id);
        return this._assertStatus("EXECUTING"), eventInfo = { args: this.args, options: this.options, retryCount: this.retryCount }, error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`), this._onFailure(error, eventInfo, clearGlobalState, run, free);
      }
      async _onFailure(error, eventInfo, clearGlobalState, run, free) {
        var retry, retryAfter;
        if (clearGlobalState())
          if (retry = await this.Events.trigger("failed", error, eventInfo), retry != null)
            return retryAfter = ~~retry, this.Events.trigger("retry", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo), this.retryCount++, run(retryAfter);
          else
            return this.doDone(eventInfo), await free(this.options, eventInfo), this._assertStatus("DONE"), this._reject(error);
      }
      doDone(eventInfo) {
        return this._assertStatus("EXECUTING"), this._states.next(this.options.id), this.Events.trigger("done", eventInfo);
      }
    };
    var Job_1 = Job, BottleneckError$2, LocalDatastore, parser$2;
    parser$2 = parser, BottleneckError$2 = BottleneckError_1, LocalDatastore = class {
      constructor(instance, storeOptions, storeInstanceOptions) {
        this.instance = instance, this.storeOptions = storeOptions, this.clientId = this.instance._randomIndex(), parser$2.load(storeInstanceOptions, storeInstanceOptions, this), this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now(), this._running = 0, this._done = 0, this._unblockTime = 0, this.ready = this.Promise.resolve(), this.clients = {}, this._startHeartbeat();
      }
      _startHeartbeat() {
        var base;
        if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null))
          return typeof (base = this.heartbeat = setInterval(() => {
            var amount, incr, maximum, now, reservoir;
            if (now = Date.now(), this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval)
              this._lastReservoirRefresh = now, this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount, this.instance._drainAll(this.computeCapacity());
            if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
              if ({
                reservoirIncreaseAmount: amount,
                reservoirIncreaseMaximum: maximum,
                reservoir
              } = this.storeOptions, this._lastReservoirIncrease = now, incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount, incr > 0)
                return this.storeOptions.reservoir += incr, this.instance._drainAll(this.computeCapacity());
            }
          }, this.heartbeatInterval)).unref === "function" ? base.unref() : void 0;
        else
          return clearInterval(this.heartbeat);
      }
      async __publish__(message) {
        return await this.yieldLoop(), this.instance.Events.trigger("message", message.toString());
      }
      async __disconnect__(flush) {
        return await this.yieldLoop(), clearInterval(this.heartbeat), this.Promise.resolve();
      }
      yieldLoop(t = 0) {
        return new this.Promise(function(resolve, reject) {
          return setTimeout(resolve, t);
        });
      }
      computePenalty() {
        var ref;
        return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;
      }
      async __updateSettings__(options) {
        return await this.yieldLoop(), parser$2.overwrite(options, options, this.storeOptions), this._startHeartbeat(), this.instance._drainAll(this.computeCapacity()), !0;
      }
      async __running__() {
        return await this.yieldLoop(), this._running;
      }
      async __queued__() {
        return await this.yieldLoop(), this.instance.queued();
      }
      async __done__() {
        return await this.yieldLoop(), this._done;
      }
      async __groupCheck__(time) {
        return await this.yieldLoop(), this._nextRequest + this.timeout < time;
      }
      computeCapacity() {
        var maxConcurrent, reservoir;
        if ({ maxConcurrent, reservoir } = this.storeOptions, maxConcurrent != null && reservoir != null)
          return Math.min(maxConcurrent - this._running, reservoir);
        else if (maxConcurrent != null)
          return maxConcurrent - this._running;
        else if (reservoir != null)
          return reservoir;
        else
          return null;
      }
      conditionsCheck(weight) {
        var capacity = this.computeCapacity();
        return capacity == null || weight <= capacity;
      }
      async __incrementReservoir__(incr) {
        var reservoir;
        return await this.yieldLoop(), reservoir = this.storeOptions.reservoir += incr, this.instance._drainAll(this.computeCapacity()), reservoir;
      }
      async __currentReservoir__() {
        return await this.yieldLoop(), this.storeOptions.reservoir;
      }
      isBlocked(now) {
        return this._unblockTime >= now;
      }
      check(weight, now) {
        return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
      }
      async __check__(weight) {
        var now;
        return await this.yieldLoop(), now = Date.now(), this.check(weight, now);
      }
      async __register__(index, weight, expiration) {
        var now, wait;
        if (await this.yieldLoop(), now = Date.now(), this.conditionsCheck(weight)) {
          if (this._running += weight, this.storeOptions.reservoir != null)
            this.storeOptions.reservoir -= weight;
          return wait = Math.max(this._nextRequest - now, 0), this._nextRequest = now + wait + this.storeOptions.minTime, {
            success: !0,
            wait,
            reservoir: this.storeOptions.reservoir
          };
        } else
          return {
            success: !1
          };
      }
      strategyIsBlock() {
        return this.storeOptions.strategy === 3;
      }
      async __submit__(queueLength, weight) {
        var blocked, now, reachedHWM;
        if (await this.yieldLoop(), this.storeOptions.maxConcurrent != null && weight > this.storeOptions.maxConcurrent)
          throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);
        if (now = Date.now(), reachedHWM = this.storeOptions.highWater != null && queueLength === this.storeOptions.highWater && !this.check(weight, now), blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now)), blocked)
          this._unblockTime = now + this.computePenalty(), this._nextRequest = this._unblockTime + this.storeOptions.minTime, this.instance._dropAllQueued();
        return {
          reachedHWM,
          blocked,
          strategy: this.storeOptions.strategy
        };
      }
      async __free__(index, weight) {
        return await this.yieldLoop(), this._running -= weight, this._done += weight, this.instance._drainAll(this.computeCapacity()), {
          running: this._running
        };
      }
    };
    var LocalDatastore_1 = LocalDatastore, BottleneckError$3, States;
    BottleneckError$3 = BottleneckError_1, States = class {
      constructor(status1) {
        this.status = status1, this._jobs = {}, this.counts = this.status.map(function() {
          return 0;
        });
      }
      next(id) {
        var current, next;
        if (current = this._jobs[id], next = current + 1, current != null && next < this.status.length)
          return this.counts[current]--, this.counts[next]++, this._jobs[id]++;
        else if (current != null)
          return this.counts[current]--, delete this._jobs[id];
      }
      start(id) {
        var initial = 0;
        return this._jobs[id] = initial, this.counts[initial]++;
      }
      remove(id) {
        var current = this._jobs[id];
        if (current != null)
          this.counts[current]--, delete this._jobs[id];
        return current != null;
      }
      jobStatus(id) {
        var ref;
        return (ref = this.status[this._jobs[id]]) != null ? ref : null;
      }
      statusJobs(status) {
        var k, pos, ref, results, v;
        if (status != null) {
          if (pos = this.status.indexOf(status), pos < 0)
            throw new BottleneckError$3(`status must be one of ${this.status.join(", ")}`);
          ref = this._jobs, results = [];
          for (k in ref)
            if (v = ref[k], v === pos)
              results.push(k);
          return results;
        } else
          return Object.keys(this._jobs);
      }
      statusCounts() {
        return this.counts.reduce((acc, v, i) => {
          return acc[this.status[i]] = v, acc;
        }, {});
      }
    };
    var States_1 = States, DLList$2, Sync;
    DLList$2 = DLList_1, Sync = class {
      constructor(name, Promise2) {
        this.schedule = this.schedule.bind(this), this.name = name, this.Promise = Promise2, this._running = 0, this._queue = new DLList$2;
      }
      isEmpty() {
        return this._queue.length === 0;
      }
      async _tryToRun() {
        var args, cb, error, reject, resolve, returned, task;
        if (this._running < 1 && this._queue.length > 0)
          return this._running++, { task, args, resolve, reject } = this._queue.shift(), cb = await async function() {
            try {
              return returned = await task(...args), function() {
                return resolve(returned);
              };
            } catch (error1) {
              return error = error1, function() {
                return reject(error);
              };
            }
          }(), this._running--, this._tryToRun(), cb();
      }
      schedule(task, ...args) {
        var promise, reject, resolve;
        return resolve = reject = null, promise = new this.Promise(function(_resolve, _reject) {
          return resolve = _resolve, reject = _reject;
        }), this._queue.push({ task, args, resolve, reject }), this._tryToRun(), promise;
      }
    };
    var Sync_1 = Sync, version = "2.19.5", version$1 = {
      version
    }, version$2 = /* @__PURE__ */ Object.freeze({
      version,
      default: version$1
    }), require$$2 = () => console.log("You must import the full version of Bottleneck in order to use this feature."), require$$3 = () => console.log("You must import the full version of Bottleneck in order to use this feature."), require$$4 = () => console.log("You must import the full version of Bottleneck in order to use this feature."), Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;
    parser$3 = parser, Events$2 = Events_1, RedisConnection$1 = require$$2, IORedisConnection$1 = require$$3, Scripts$1 = require$$4, Group = function() {

      class Group2 {
        constructor(limiterOptions = {}) {
          if (this.deleteKey = this.deleteKey.bind(this), this.limiterOptions = limiterOptions, parser$3.load(this.limiterOptions, this.defaults, this), this.Events = new Events$2(this), this.instances = {}, this.Bottleneck = Bottleneck_1, this._startAutoCleanup(), this.sharedConnection = this.connection != null, this.connection == null) {
            if (this.limiterOptions.datastore === "redis")
              this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
            else if (this.limiterOptions.datastore === "ioredis")
              this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, { Events: this.Events }));
          }
        }
        key(key = "") {
          var ref;
          return (ref = this.instances[key]) != null ? ref : (() => {
            var limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
              id: `${this.id}-${key}`,
              timeout: this.timeout,
              connection: this.connection
            }));
            return this.Events.trigger("created", limiter, key), limiter;
          })();
        }
        async deleteKey(key = "") {
          var deleted, instance;
          if (instance = this.instances[key], this.connection)
            deleted = await this.connection.__runCommand__(["del", ...Scripts$1.allKeys(`${this.id}-${key}`)]);
          if (instance != null)
            delete this.instances[key], await instance.disconnect();
          return instance != null || deleted > 0;
        }
        limiters() {
          var k, ref, results, v;
          ref = this.instances, results = [];
          for (k in ref)
            v = ref[k], results.push({
              key: k,
              limiter: v
            });
          return results;
        }
        keys() {
          return Object.keys(this.instances);
        }
        async clusterKeys() {
          var cursor, end, found, i, k, keys, len, next, start;
          if (this.connection == null)
            return this.Promise.resolve(this.keys());
          keys = [], cursor = null, start = `b_${this.id}-`.length, end = 9;
          while (cursor !== 0) {
            [next, found] = await this.connection.__runCommand__(["scan", cursor != null ? cursor : 0, "match", `b_${this.id}-*_settings`, "count", 1e4]), cursor = ~~next;
            for (i = 0, len = found.length;i < len; i++)
              k = found[i], keys.push(k.slice(start, -end));
          }
          return keys;
        }
        _startAutoCleanup() {
          var base;
          return clearInterval(this.interval), typeof (base = this.interval = setInterval(async () => {
            var e, k, ref, results, time, v;
            time = Date.now(), ref = this.instances, results = [];
            for (k in ref) {
              v = ref[k];
              try {
                if (await v._store.__groupCheck__(time))
                  results.push(this.deleteKey(k));
                else
                  results.push(void 0);
              } catch (error) {
                e = error, results.push(v.Events.trigger("error", e));
              }
            }
            return results;
          }, this.timeout / 2)).unref === "function" ? base.unref() : void 0;
        }
        updateSettings(options = {}) {
          if (parser$3.overwrite(options, this.defaults, this), parser$3.overwrite(options, options, this.limiterOptions), options.timeout != null)
            return this._startAutoCleanup();
        }
        disconnect(flush = !0) {
          var ref;
          if (!this.sharedConnection)
            return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
        }
      }
      return Group2.prototype.defaults = {
        timeout: 300000,
        connection: null,
        Promise,
        id: "group-key"
      }, Group2;
    }.call(commonjsGlobal);
    var Group_1 = Group, Batcher, Events$3, parser$4;
    parser$4 = parser, Events$3 = Events_1, Batcher = function() {

      class Batcher2 {
        constructor(options = {}) {
          this.options = options, parser$4.load(this.options, this.defaults, this), this.Events = new Events$3(this), this._arr = [], this._resetPromise(), this._lastFlush = Date.now();
        }
        _resetPromise() {
          return this._promise = new this.Promise((res, rej) => {
            return this._resolve = res;
          });
        }
        _flush() {
          return clearTimeout(this._timeout), this._lastFlush = Date.now(), this._resolve(), this.Events.trigger("batch", this._arr), this._arr = [], this._resetPromise();
        }
        add(data) {
          var ret;
          if (this._arr.push(data), ret = this._promise, this._arr.length === this.maxSize)
            this._flush();
          else if (this.maxTime != null && this._arr.length === 1)
            this._timeout = setTimeout(() => {
              return this._flush();
            }, this.maxTime);
          return ret;
        }
      }
      return Batcher2.prototype.defaults = {
        maxTime: null,
        maxSize: null,
        Promise
      }, Batcher2;
    }.call(commonjsGlobal);
    var Batcher_1 = Batcher, require$$4$1 = () => console.log("You must import the full version of Bottleneck in order to use this feature."), require$$8 = getCjsExportFromNamespace(version$2), Bottleneck, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5, splice = [].splice;
    NUM_PRIORITIES$1 = 10, DEFAULT_PRIORITY$1 = 5, parser$5 = parser, Queues$1 = Queues_1, Job$1 = Job_1, LocalDatastore$1 = LocalDatastore_1, RedisDatastore$1 = require$$4$1, Events$4 = Events_1, States$1 = States_1, Sync$1 = Sync_1, Bottleneck = function() {

      class Bottleneck2 {
        constructor(options = {}, ...invalid) {
          var storeInstanceOptions, storeOptions;
          this._addToQueue = this._addToQueue.bind(this), this._validateOptions(options, invalid), parser$5.load(options, this.instanceDefaults, this), this._queues = new Queues$1(NUM_PRIORITIES$1), this._scheduled = {}, this._states = new States$1(["RECEIVED", "QUEUED", "RUNNING", "EXECUTING"].concat(this.trackDoneStatus ? ["DONE"] : [])), this._limiter = null, this.Events = new Events$4(this), this._submitLock = new Sync$1("submit", this.Promise), this._registerLock = new Sync$1("register", this.Promise), storeOptions = parser$5.load(options, this.storeDefaults, {}), this._store = function() {
            if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null)
              return storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {}), new RedisDatastore$1(this, storeOptions, storeInstanceOptions);
            else if (this.datastore === "local")
              return storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {}), new LocalDatastore$1(this, storeOptions, storeInstanceOptions);
            else
              throw new Bottleneck2.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
          }.call(this), this._queues.on("leftzero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
          }), this._queues.on("zero", () => {
            var ref;
            return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
          });
        }
        _validateOptions(options, invalid) {
          if (!(options != null && typeof options === "object" && invalid.length === 0))
            throw new Bottleneck2.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
        }
        ready() {
          return this._store.ready;
        }
        clients() {
          return this._store.clients;
        }
        channel() {
          return `b_${this.id}`;
        }
        channel_client() {
          return `b_${this.id}_${this._store.clientId}`;
        }
        publish(message) {
          return this._store.__publish__(message);
        }
        disconnect(flush = !0) {
          return this._store.__disconnect__(flush);
        }
        chain(_limiter) {
          return this._limiter = _limiter, this;
        }
        queued(priority) {
          return this._queues.queued(priority);
        }
        clusterQueued() {
          return this._store.__queued__();
        }
        empty() {
          return this.queued() === 0 && this._submitLock.isEmpty();
        }
        running() {
          return this._store.__running__();
        }
        done() {
          return this._store.__done__();
        }
        jobStatus(id) {
          return this._states.jobStatus(id);
        }
        jobs(status) {
          return this._states.statusJobs(status);
        }
        counts() {
          return this._states.statusCounts();
        }
        _randomIndex() {
          return Math.random().toString(36).slice(2);
        }
        check(weight = 1) {
          return this._store.__check__(weight);
        }
        _clearGlobalState(index) {
          if (this._scheduled[index] != null)
            return clearTimeout(this._scheduled[index].expiration), delete this._scheduled[index], !0;
          else
            return !1;
        }
        async _free(index, job, options, eventInfo) {
          var e, running;
          try {
            if ({ running } = await this._store.__free__(index, options.weight), this.Events.trigger("debug", `Freed ${options.id}`, eventInfo), running === 0 && this.empty())
              return this.Events.trigger("idle");
          } catch (error1) {
            return e = error1, this.Events.trigger("error", e);
          }
        }
        _run(index, job, wait) {
          var clearGlobalState, free, run;
          return job.doRun(), clearGlobalState = this._clearGlobalState.bind(this, index), run = this._run.bind(this, index, job), free = this._free.bind(this, index, job), this._scheduled[index] = {
            timeout: setTimeout(() => {
              return job.doExecute(this._limiter, clearGlobalState, run, free);
            }, wait),
            expiration: job.options.expiration != null ? setTimeout(function() {
              return job.doExpire(clearGlobalState, run, free);
            }, wait + job.options.expiration) : void 0,
            job
          };
        }
        _drainOne(capacity) {
          return this._registerLock.schedule(() => {
            var args, index, next, options, queue;
            if (this.queued() === 0)
              return this.Promise.resolve(null);
            if (queue = this._queues.getFirst(), { options, args } = next = queue.first(), capacity != null && options.weight > capacity)
              return this.Promise.resolve(null);
            return this.Events.trigger("debug", `Draining ${options.id}`, { args, options }), index = this._randomIndex(), this._store.__register__(index, options.weight, options.expiration).then(({ success, wait, reservoir }) => {
              var empty;
              if (this.Events.trigger("debug", `Drained ${options.id}`, { success, args, options }), success) {
                if (queue.shift(), empty = this.empty(), empty)
                  this.Events.trigger("empty");
                if (reservoir === 0)
                  this.Events.trigger("depleted", empty);
                return this._run(index, next, wait), this.Promise.resolve(options.weight);
              } else
                return this.Promise.resolve(null);
            });
          });
        }
        _drainAll(capacity, total = 0) {
          return this._drainOne(capacity).then((drained) => {
            var newCapacity;
            if (drained != null)
              return newCapacity = capacity != null ? capacity - drained : capacity, this._drainAll(newCapacity, total + drained);
            else
              return this.Promise.resolve(total);
          }).catch((e) => {
            return this.Events.trigger("error", e);
          });
        }
        _dropAllQueued(message) {
          return this._queues.shiftAll(function(job) {
            return job.doDrop({ message });
          });
        }
        stop(options = {}) {
          var done, waitForExecuting;
          return options = parser$5.load(options, this.stopDefaults), waitForExecuting = (at) => {
            var finished = () => {
              var counts = this._states.counts;
              return counts[0] + counts[1] + counts[2] + counts[3] === at;
            };
            return new this.Promise((resolve, reject) => {
              if (finished())
                return resolve();
              else
                return this.on("done", () => {
                  if (finished())
                    return this.removeAllListeners("done"), resolve();
                });
            });
          }, done = options.dropWaitingJobs ? (this._run = function(index, next) {
            return next.doDrop({
              message: options.dropErrorMessage
            });
          }, this._drainOne = () => {
            return this.Promise.resolve(null);
          }, this._registerLock.schedule(() => {
            return this._submitLock.schedule(() => {
              var k, ref, v;
              ref = this._scheduled;
              for (k in ref)
                if (v = ref[k], this.jobStatus(v.job.options.id) === "RUNNING")
                  clearTimeout(v.timeout), clearTimeout(v.expiration), v.job.doDrop({
                    message: options.dropErrorMessage
                  });
              return this._dropAllQueued(options.dropErrorMessage), waitForExecuting(0);
            });
          })) : this.schedule({
            priority: NUM_PRIORITIES$1 - 1,
            weight: 0
          }, () => {
            return waitForExecuting(1);
          }), this._receive = function(job) {
            return job._reject(new Bottleneck2.prototype.BottleneckError(options.enqueueErrorMessage));
          }, this.stop = () => {
            return this.Promise.reject(new Bottleneck2.prototype.BottleneckError("stop() has already been called"));
          }, done;
        }
        async _addToQueue(job) {
          var args, blocked, error, options, reachedHWM, shifted, strategy;
          ({ args, options } = job);
          try {
            ({ reachedHWM, blocked, strategy } = await this._store.__submit__(this.queued(), options.weight));
          } catch (error1) {
            return error = error1, this.Events.trigger("debug", `Could not queue ${options.id}`, { args, options, error }), job.doDrop({ error }), !1;
          }
          if (blocked)
            return job.doDrop(), !0;
          else if (reachedHWM) {
            if (shifted = strategy === Bottleneck2.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck2.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck2.prototype.strategy.OVERFLOW ? job : void 0, shifted != null)
              shifted.doDrop();
            if (shifted == null || strategy === Bottleneck2.prototype.strategy.OVERFLOW) {
              if (shifted == null)
                job.doDrop();
              return reachedHWM;
            }
          }
          return job.doQueue(reachedHWM, blocked), this._queues.push(job), await this._drainAll(), reachedHWM;
        }
        _receive(job) {
          if (this._states.jobStatus(job.options.id) != null)
            return job._reject(new Bottleneck2.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`)), !1;
          else
            return job.doReceive(), this._submitLock.schedule(this._addToQueue, job);
        }
        submit(...args) {
          var cb, fn, job, options, ref, ref1, task;
          if (typeof args[0] === "function")
            ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1), options = parser$5.load({}, this.jobDefaults);
          else
            ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1), options = parser$5.load(options, this.jobDefaults);
          return task = (...args2) => {
            return new this.Promise(function(resolve, reject) {
              return fn(...args2, function(...args3) {
                return (args3[0] != null ? reject : resolve)(args3);
              });
            });
          }, job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise), job.promise.then(function(args2) {
            return typeof cb === "function" ? cb(...args2) : void 0;
          }).catch(function(args2) {
            if (Array.isArray(args2))
              return typeof cb === "function" ? cb(...args2) : void 0;
            else
              return typeof cb === "function" ? cb(args2) : void 0;
          }), this._receive(job);
        }
        schedule(...args) {
          var job, options, task;
          if (typeof args[0] === "function")
            [task, ...args] = args, options = {};
          else
            [options, task, ...args] = args;
          return job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise), this._receive(job), job.promise;
        }
        wrap(fn) {
          var schedule, wrapped;
          return schedule = this.schedule.bind(this), wrapped = function(...args) {
            return schedule(fn.bind(this), ...args);
          }, wrapped.withOptions = function(options, ...args) {
            return schedule(options, fn, ...args);
          }, wrapped;
        }
        async updateSettings(options = {}) {
          return await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults)), parser$5.overwrite(options, this.instanceDefaults, this), this;
        }
        currentReservoir() {
          return this._store.__currentReservoir__();
        }
        incrementReservoir(incr = 0) {
          return this._store.__incrementReservoir__(incr);
        }
      }
      return Bottleneck2.default = Bottleneck2, Bottleneck2.Events = Events$4, Bottleneck2.version = Bottleneck2.prototype.version = require$$8.version, Bottleneck2.strategy = Bottleneck2.prototype.strategy = {
        LEAK: 1,
        OVERFLOW: 2,
        OVERFLOW_PRIORITY: 4,
        BLOCK: 3
      }, Bottleneck2.BottleneckError = Bottleneck2.prototype.BottleneckError = BottleneckError_1, Bottleneck2.Group = Bottleneck2.prototype.Group = Group_1, Bottleneck2.RedisConnection = Bottleneck2.prototype.RedisConnection = require$$2, Bottleneck2.IORedisConnection = Bottleneck2.prototype.IORedisConnection = require$$3, Bottleneck2.Batcher = Bottleneck2.prototype.Batcher = Batcher_1, Bottleneck2.prototype.jobDefaults = {
        priority: DEFAULT_PRIORITY$1,
        weight: 1,
        expiration: null,
        id: "<no-id>"
      }, Bottleneck2.prototype.storeDefaults = {
        maxConcurrent: null,
        minTime: 0,
        highWater: null,
        strategy: Bottleneck2.prototype.strategy.LEAK,
        penalty: null,
        reservoir: null,
        reservoirRefreshInterval: null,
        reservoirRefreshAmount: null,
        reservoirIncreaseInterval: null,
        reservoirIncreaseAmount: null,
        reservoirIncreaseMaximum: null
      }, Bottleneck2.prototype.localStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 250
      }, Bottleneck2.prototype.redisStoreDefaults = {
        Promise,
        timeout: null,
        heartbeatInterval: 5000,
        clientTimeout: 1e4,
        Redis: null,
        clientOptions: {},
        clusterNodes: null,
        clearDatastore: !1,
        connection: null
      }, Bottleneck2.prototype.instanceDefaults = {
        datastore: "local",
        connection: null,
        id: "<no-id>",
        rejectOnDrop: !0,
        trackDoneStatus: !1,
        Promise
      }, Bottleneck2.prototype.stopDefaults = {
        enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
        dropWaitingJobs: !0,
        dropErrorMessage: "This limiter has been stopped."
      }, Bottleneck2;
    }.call(commonjsGlobal);
    var Bottleneck_1 = Bottleneck, lib = Bottleneck_1;
    return lib;
  });
});

// node_modules/@octokit/plugin-retry/dist-node/index.js
var require_dist_node15 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex.default : ex;
  }
  var Bottleneck = _interopDefault(require_light());
  async function errorRequest(octokit, state, error, options) {
    if (!error.request || !error.request.request)
      throw error;
    if (error.status >= 400 && !state.doNotRetry.includes(error.status)) {
      let retries = options.request.retries != null ? options.request.retries : state.retries, retryAfter = Math.pow((options.request.retryCount || 0) + 1, 2);
      throw octokit.retry.retryRequest(error, retries, retryAfter);
    }
    throw error;
  }
  async function wrapRequest(state, request, options) {
    let limiter = new Bottleneck;
    return limiter.on("failed", function(error, info) {
      let maxRetries = ~~error.request.request.retries, after = ~~error.request.request.retryAfter;
      if (options.request.retryCount = info.retryCount + 1, maxRetries > info.retryCount)
        return after * state.retryAfterBaseValue;
    }), limiter.schedule(request, options);
  }
  var VERSION = "3.0.9";
  function retry(octokit, octokitOptions) {
    let state = Object.assign({
      enabled: !0,
      retryAfterBaseValue: 1000,
      doNotRetry: [400, 401, 403, 404, 422],
      retries: 3
    }, octokitOptions.retry);
    if (state.enabled)
      octokit.hook.error("request", errorRequest.bind(null, octokit, state)), octokit.hook.wrap("request", wrapRequest.bind(null, state));
    return {
      retry: {
        retryRequest: (error, retries, retryAfter) => {
          return error.request.request = Object.assign({}, error.request.request, {
            retries,
            retryAfter
          }), error;
        }
      }
    };
  }
  retry.VERSION = VERSION;
  exports.VERSION = VERSION;
  exports.retry = retry;
});

// node_modules/@actions/artifact/lib/internal/find/get-artifact.js
var require_get_artifact = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getArtifactPublic = getArtifactPublic;
  exports.getArtifactInternal = getArtifactInternal;
  var github_1 = require_github(), plugin_retry_1 = require_dist_node15(), core = __importStar(require_core()), utils_1 = require_utils8(), retry_options_1 = require_retry_options(), plugin_request_log_1 = require_dist_node14(), util_1 = require_util8(), user_agent_1 = require_user_agent(), artifact_twirp_client_1 = require_artifact_twirp_client2(), generated_1 = require_generated(), errors_1 = require_errors2();
  function getArtifactPublic(artifactName, workflowRunId, repositoryOwner, repositoryName, token) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      let [retryOpts, requestOpts] = (0, retry_options_1.getRetryOptions)(utils_1.defaults), opts = {
        log: void 0,
        userAgent: (0, user_agent_1.getUserAgentString)(),
        previews: void 0,
        retry: retryOpts,
        request: requestOpts
      }, getArtifactResp = yield (0, github_1.getOctokit)(token, opts, plugin_retry_1.retry, plugin_request_log_1.requestLog).request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts{?name}", {
        owner: repositoryOwner,
        repo: repositoryName,
        run_id: workflowRunId,
        name: artifactName
      });
      if (getArtifactResp.status !== 200)
        throw new errors_1.InvalidResponseError(`Invalid response from GitHub API: ${getArtifactResp.status} (${(_a = getArtifactResp === null || getArtifactResp === void 0 ? void 0 : getArtifactResp.headers) === null || _a === void 0 ? void 0 : _a["x-github-request-id"]})`);
      if (getArtifactResp.data.artifacts.length === 0)
        throw new errors_1.ArtifactNotFoundError(`Artifact not found for name: ${artifactName}
        Please ensure that your artifact is not expired and the artifact was uploaded using a compatible version of toolkit/upload-artifact.
        For more information, visit the GitHub Artifacts FAQ: https://github.com/actions/toolkit/blob/main/packages/artifact/docs/faq.md`);
      let artifact = getArtifactResp.data.artifacts[0];
      if (getArtifactResp.data.artifacts.length > 1)
        artifact = getArtifactResp.data.artifacts.sort((a, b) => b.id - a.id)[0], core.debug(`More than one artifact found for a single name, returning newest (id: ${artifact.id})`);
      return {
        artifact: {
          name: artifact.name,
          id: artifact.id,
          size: artifact.size_in_bytes,
          createdAt: artifact.created_at ? new Date(artifact.created_at) : void 0,
          digest: artifact.digest
        }
      };
    });
  }
  function getArtifactInternal(artifactName) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      let artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)(), { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)(), req = {
        workflowRunBackendId,
        workflowJobRunBackendId,
        nameFilter: generated_1.StringValue.create({ value: artifactName })
      }, res = yield artifactClient.ListArtifacts(req);
      if (res.artifacts.length === 0)
        throw new errors_1.ArtifactNotFoundError(`Artifact not found for name: ${artifactName}
        Please ensure that your artifact is not expired and the artifact was uploaded using a compatible version of toolkit/upload-artifact.
        For more information, visit the GitHub Artifacts FAQ: https://github.com/actions/toolkit/blob/main/packages/artifact/docs/faq.md`);
      let artifact = res.artifacts[0];
      if (res.artifacts.length > 1)
        artifact = res.artifacts.sort((a, b) => Number(b.databaseId) - Number(a.databaseId))[0], core.debug(`More than one artifact found for a single name, returning newest (id: ${artifact.databaseId})`);
      return {
        artifact: {
          name: artifact.name,
          id: Number(artifact.databaseId),
          size: Number(artifact.size),
          createdAt: artifact.createdAt ? generated_1.Timestamp.toDate(artifact.createdAt) : void 0,
          digest: (_a = artifact.digest) === null || _a === void 0 ? void 0 : _a.value
        }
      };
    });
  }
});

// node_modules/@actions/artifact/lib/internal/delete/delete-artifact.js
var require_delete_artifact = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.deleteArtifactPublic = deleteArtifactPublic;
  exports.deleteArtifactInternal = deleteArtifactInternal;
  var core_1 = require_core(), github_1 = require_github(), user_agent_1 = require_user_agent(), retry_options_1 = require_retry_options(), utils_1 = require_utils8(), plugin_request_log_1 = require_dist_node14(), plugin_retry_1 = require_dist_node15(), artifact_twirp_client_1 = require_artifact_twirp_client2(), util_1 = require_util8(), generated_1 = require_generated(), get_artifact_1 = require_get_artifact(), errors_1 = require_errors2();
  function deleteArtifactPublic(artifactName, workflowRunId, repositoryOwner, repositoryName, token) {
    return __awaiter(this, void 0, void 0, function* () {
      var _a;
      let [retryOpts, requestOpts] = (0, retry_options_1.getRetryOptions)(utils_1.defaults), opts = {
        log: void 0,
        userAgent: (0, user_agent_1.getUserAgentString)(),
        previews: void 0,
        retry: retryOpts,
        request: requestOpts
      }, github = (0, github_1.getOctokit)(token, opts, plugin_retry_1.retry, plugin_request_log_1.requestLog), getArtifactResp = yield (0, get_artifact_1.getArtifactPublic)(artifactName, workflowRunId, repositoryOwner, repositoryName, token), deleteArtifactResp = yield github.rest.actions.deleteArtifact({
        owner: repositoryOwner,
        repo: repositoryName,
        artifact_id: getArtifactResp.artifact.id
      });
      if (deleteArtifactResp.status !== 204)
        throw new errors_1.InvalidResponseError(`Invalid response from GitHub API: ${deleteArtifactResp.status} (${(_a = deleteArtifactResp === null || deleteArtifactResp === void 0 ? void 0 : deleteArtifactResp.headers) === null || _a === void 0 ? void 0 : _a["x-github-request-id"]})`);
      return {
        id: getArtifactResp.artifact.id
      };
    });
  }
  function deleteArtifactInternal(artifactName) {
    return __awaiter(this, void 0, void 0, function* () {
      let artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)(), { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)(), listReq = {
        workflowRunBackendId,
        workflowJobRunBackendId,
        nameFilter: generated_1.StringValue.create({ value: artifactName })
      }, listRes = yield artifactClient.ListArtifacts(listReq);
      if (listRes.artifacts.length === 0)
        throw new errors_1.ArtifactNotFoundError(`Artifact not found for name: ${artifactName}`);
      let artifact = listRes.artifacts[0];
      if (listRes.artifacts.length > 1)
        artifact = listRes.artifacts.sort((a, b) => Number(b.databaseId) - Number(a.databaseId))[0], (0, core_1.debug)(`More than one artifact found for a single name, returning newest (id: ${artifact.databaseId})`);
      let req = {
        workflowRunBackendId: artifact.workflowRunBackendId,
        workflowJobRunBackendId: artifact.workflowJobRunBackendId,
        name: artifact.name
      }, res = yield artifactClient.DeleteArtifact(req);
      return (0, core_1.info)(`Artifact '${artifactName}' (ID: ${res.artifactId}) deleted`), {
        id: Number(res.artifactId)
      };
    });
  }
});

// node_modules/@actions/artifact/lib/internal/find/list-artifacts.js
var require_list_artifacts = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.listArtifactsPublic = listArtifactsPublic;
  exports.listArtifactsInternal = listArtifactsInternal;
  var core_1 = require_core(), github_1 = require_github(), user_agent_1 = require_user_agent(), retry_options_1 = require_retry_options(), utils_1 = require_utils8(), plugin_request_log_1 = require_dist_node14(), plugin_retry_1 = require_dist_node15(), artifact_twirp_client_1 = require_artifact_twirp_client2(), util_1 = require_util8(), config_1 = require_config(), generated_1 = require_generated(), maximumArtifactCount = (0, config_1.getMaxArtifactListCount)(), paginationCount = 100, maxNumberOfPages = Math.ceil(maximumArtifactCount / paginationCount);
  function listArtifactsPublic(workflowRunId_1, repositoryOwner_1, repositoryName_1, token_1) {
    return __awaiter(this, arguments, void 0, function* (workflowRunId, repositoryOwner, repositoryName, token, latest = !1) {
      (0, core_1.info)(`Fetching artifact list for workflow run ${workflowRunId} in repository ${repositoryOwner}/${repositoryName}`);
      let artifacts = [], [retryOpts, requestOpts] = (0, retry_options_1.getRetryOptions)(utils_1.defaults), opts = {
        log: void 0,
        userAgent: (0, user_agent_1.getUserAgentString)(),
        previews: void 0,
        retry: retryOpts,
        request: requestOpts
      }, github = (0, github_1.getOctokit)(token, opts, plugin_retry_1.retry, plugin_request_log_1.requestLog), currentPageNumber = 1, { data: listArtifactResponse } = yield github.request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", {
        owner: repositoryOwner,
        repo: repositoryName,
        run_id: workflowRunId,
        per_page: paginationCount,
        page: currentPageNumber
      }), numberOfPages = Math.ceil(listArtifactResponse.total_count / paginationCount), totalArtifactCount = listArtifactResponse.total_count;
      if (totalArtifactCount > maximumArtifactCount)
        (0, core_1.warning)(`Workflow run ${workflowRunId} has ${totalArtifactCount} artifacts, exceeding the limit of ${maximumArtifactCount}. Results will be incomplete as only the first ${maximumArtifactCount} artifacts will be returned`), numberOfPages = maxNumberOfPages;
      for (let artifact of listArtifactResponse.artifacts)
        artifacts.push({
          name: artifact.name,
          id: artifact.id,
          size: artifact.size_in_bytes,
          createdAt: artifact.created_at ? new Date(artifact.created_at) : void 0,
          digest: artifact.digest
        });
      currentPageNumber++;
      for (currentPageNumber;currentPageNumber <= numberOfPages; currentPageNumber++) {
        (0, core_1.debug)(`Fetching page ${currentPageNumber} of artifact list`);
        let { data: listArtifactResponse2 } = yield github.request("GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts", {
          owner: repositoryOwner,
          repo: repositoryName,
          run_id: workflowRunId,
          per_page: paginationCount,
          page: currentPageNumber
        });
        for (let artifact of listArtifactResponse2.artifacts)
          artifacts.push({
            name: artifact.name,
            id: artifact.id,
            size: artifact.size_in_bytes,
            createdAt: artifact.created_at ? new Date(artifact.created_at) : void 0,
            digest: artifact.digest
          });
      }
      if (latest)
        artifacts = filterLatest(artifacts);
      return (0, core_1.info)(`Found ${artifacts.length} artifact(s)`), {
        artifacts
      };
    });
  }
  function listArtifactsInternal() {
    return __awaiter(this, arguments, void 0, function* (latest = !1) {
      let artifactClient = (0, artifact_twirp_client_1.internalArtifactTwirpClient)(), { workflowRunBackendId, workflowJobRunBackendId } = (0, util_1.getBackendIdsFromToken)(), req = {
        workflowRunBackendId,
        workflowJobRunBackendId
      }, artifacts = (yield artifactClient.ListArtifacts(req)).artifacts.map((artifact) => {
        var _a;
        return {
          name: artifact.name,
          id: Number(artifact.databaseId),
          size: Number(artifact.size),
          createdAt: artifact.createdAt ? generated_1.Timestamp.toDate(artifact.createdAt) : void 0,
          digest: (_a = artifact.digest) === null || _a === void 0 ? void 0 : _a.value
        };
      });
      if (latest)
        artifacts = filterLatest(artifacts);
      return (0, core_1.info)(`Found ${artifacts.length} artifact(s)`), {
        artifacts
      };
    });
  }
  function filterLatest(artifacts) {
    artifacts.sort((a, b) => b.id - a.id);
    let latestArtifacts = [], seenArtifactNames = /* @__PURE__ */ new Set;
    for (let artifact of artifacts)
      if (!seenArtifactNames.has(artifact.name))
        latestArtifacts.push(artifact), seenArtifactNames.add(artifact.name);
    return latestArtifacts;
  }
});

// node_modules/@actions/artifact/lib/internal/client.js
var require_client3 = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }, __rest = exports && exports.__rest || function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++)
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
          t[p[i]] = s[p[i]];
    }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.DefaultArtifactClient = void 0;
  var core_1 = require_core(), config_1 = require_config(), upload_artifact_1 = require_upload_artifact(), download_artifact_1 = require_download_artifact(), delete_artifact_1 = require_delete_artifact(), get_artifact_1 = require_get_artifact(), list_artifacts_1 = require_list_artifacts(), errors_1 = require_errors2();

  class DefaultArtifactClient {
    uploadArtifact(name, files, rootDirectory, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if ((0, config_1.isGhes)())
            throw new errors_1.GHESNotSupportedError;
          return (0, upload_artifact_1.uploadArtifact)(name, files, rootDirectory, options);
        } catch (error) {
          throw (0, core_1.warning)(`Artifact upload failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions is operating normally at [https://githubstatus.com](https://www.githubstatus.com).`), error;
        }
      });
    }
    downloadArtifact(artifactId, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if ((0, config_1.isGhes)())
            throw new errors_1.GHESNotSupportedError;
          if (options === null || options === void 0 ? void 0 : options.findBy) {
            let { findBy: { repositoryOwner, repositoryName, token } } = options, downloadOptions = __rest(options, ["findBy"]);
            return (0, download_artifact_1.downloadArtifactPublic)(artifactId, repositoryOwner, repositoryName, token, downloadOptions);
          }
          return (0, download_artifact_1.downloadArtifactInternal)(artifactId, options);
        } catch (error) {
          throw (0, core_1.warning)(`Download Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`), error;
        }
      });
    }
    listArtifacts(options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if ((0, config_1.isGhes)())
            throw new errors_1.GHESNotSupportedError;
          if (options === null || options === void 0 ? void 0 : options.findBy) {
            let { findBy: { workflowRunId, repositoryOwner, repositoryName, token } } = options;
            return (0, list_artifacts_1.listArtifactsPublic)(workflowRunId, repositoryOwner, repositoryName, token, options === null || options === void 0 ? void 0 : options.latest);
          }
          return (0, list_artifacts_1.listArtifactsInternal)(options === null || options === void 0 ? void 0 : options.latest);
        } catch (error) {
          throw (0, core_1.warning)(`Listing Artifacts failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`), error;
        }
      });
    }
    getArtifact(artifactName, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if ((0, config_1.isGhes)())
            throw new errors_1.GHESNotSupportedError;
          if (options === null || options === void 0 ? void 0 : options.findBy) {
            let { findBy: { workflowRunId, repositoryOwner, repositoryName, token } } = options;
            return (0, get_artifact_1.getArtifactPublic)(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
          }
          return (0, get_artifact_1.getArtifactInternal)(artifactName);
        } catch (error) {
          throw (0, core_1.warning)(`Get Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`), error;
        }
      });
    }
    deleteArtifact(artifactName, options) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          if ((0, config_1.isGhes)())
            throw new errors_1.GHESNotSupportedError;
          if (options === null || options === void 0 ? void 0 : options.findBy) {
            let { findBy: { repositoryOwner, repositoryName, workflowRunId, token } } = options;
            return (0, delete_artifact_1.deleteArtifactPublic)(artifactName, workflowRunId, repositoryOwner, repositoryName, token);
          }
          return (0, delete_artifact_1.deleteArtifactInternal)(artifactName);
        } catch (error) {
          throw (0, core_1.warning)(`Delete Artifact failed with error: ${error}.

Errors can be temporary, so please try again and optionally run the action with debug mode enabled for more information.

If the error persists, please check whether Actions and API requests are operating normally at [https://githubstatus.com](https://www.githubstatus.com).`), error;
        }
      });
    }
  }
  exports.DefaultArtifactClient = DefaultArtifactClient;
});

// node_modules/@actions/artifact/lib/internal/shared/interfaces.js
var require_interfaces2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
});

// node_modules/@actions/artifact/lib/artifact.js
var require_artifact2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var client_1 = require_client3();
  __exportStar(require_interfaces2(), exports);
  __exportStar(require_errors2(), exports);
  __exportStar(require_client3(), exports);
  var client = new client_1.DefaultArtifactClient;
  exports.default = client;
});

// node_modules/@actions/github/lib/context.js
var require_context2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.Context = void 0;
  var fs_1 = __require("fs"), os_1 = __require("os");

  class Context {
    constructor() {
      var _a, _b, _c;
      if (this.payload = {}, process.env.GITHUB_EVENT_PATH)
        if ((0, fs_1.existsSync)(process.env.GITHUB_EVENT_PATH))
          this.payload = JSON.parse((0, fs_1.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
        else {
          let path = process.env.GITHUB_EVENT_PATH;
          process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
        }
      this.eventName = process.env.GITHUB_EVENT_NAME, this.sha = process.env.GITHUB_SHA, this.ref = process.env.GITHUB_REF, this.workflow = process.env.GITHUB_WORKFLOW, this.action = process.env.GITHUB_ACTION, this.actor = process.env.GITHUB_ACTOR, this.job = process.env.GITHUB_JOB, this.runAttempt = parseInt(process.env.GITHUB_RUN_ATTEMPT, 10), this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10), this.runId = parseInt(process.env.GITHUB_RUN_ID, 10), this.apiUrl = (_a = process.env.GITHUB_API_URL) !== null && _a !== void 0 ? _a : "https://api.github.com", this.serverUrl = (_b = process.env.GITHUB_SERVER_URL) !== null && _b !== void 0 ? _b : "https://github.com", this.graphqlUrl = (_c = process.env.GITHUB_GRAPHQL_URL) !== null && _c !== void 0 ? _c : "https://api.github.com/graphql";
    }
    get issue() {
      let payload = this.payload;
      return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
      if (process.env.GITHUB_REPOSITORY) {
        let [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
        return { owner, repo };
      }
      if (this.payload.repository)
        return {
          owner: this.payload.repository.owner.login,
          repo: this.payload.repository.name
        };
      throw Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
  }
  exports.Context = Context;
});

// node_modules/@actions/github/node_modules/@actions/http-client/lib/proxy.js
var require_proxy3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getProxyUrl = getProxyUrl;
  exports.checkBypass = checkBypass;
  function getProxyUrl(reqUrl) {
    let usingSsl = reqUrl.protocol === "https:";
    if (checkBypass(reqUrl))
      return;
    let proxyVar = (() => {
      if (usingSsl)
        return process.env.https_proxy || process.env.HTTPS_PROXY;
      else
        return process.env.http_proxy || process.env.HTTP_PROXY;
    })();
    if (proxyVar)
      try {
        return new DecodedURL(proxyVar);
      } catch (_a) {
        if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
          return new DecodedURL(`http://${proxyVar}`);
      }
    else
      return;
  }
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname)
      return !1;
    let reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost))
      return !0;
    let noProxy = process.env.no_proxy || process.env.NO_PROXY || "";
    if (!noProxy)
      return !1;
    let reqPort;
    if (reqUrl.port)
      reqPort = Number(reqUrl.port);
    else if (reqUrl.protocol === "http:")
      reqPort = 80;
    else if (reqUrl.protocol === "https:")
      reqPort = 443;
    let upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number")
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    for (let upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x))
      if (upperNoProxyItem === "*" || upperReqHosts.some((x) => x === upperNoProxyItem || x.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x.endsWith(`${upperNoProxyItem}`)))
        return !0;
    return !1;
  }
  function isLoopbackAddress(host) {
    let hostLower = host.toLowerCase();
    return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
  }

  class DecodedURL extends URL {
    constructor(url, base) {
      super(url, base);
      this._decodedUsername = decodeURIComponent(super.username), this._decodedPassword = decodeURIComponent(super.password);
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
});

// node_modules/@actions/github/node_modules/@actions/http-client/lib/index.js
var require_lib4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.HttpClient = exports.HttpClientResponse = exports.HttpClientError = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
  exports.getProxyUrl = getProxyUrl;
  exports.isHttps = isHttps;
  var http = __importStar(__require("http")), https = __importStar(__require("https")), pm = __importStar(require_proxy3()), tunnel = __importStar(require_tunnel()), undici_1 = require_undici(), HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2.OK = 200] = "OK", HttpCodes2[HttpCodes2.MultipleChoices = 300] = "MultipleChoices", HttpCodes2[HttpCodes2.MovedPermanently = 301] = "MovedPermanently", HttpCodes2[HttpCodes2.ResourceMoved = 302] = "ResourceMoved", HttpCodes2[HttpCodes2.SeeOther = 303] = "SeeOther", HttpCodes2[HttpCodes2.NotModified = 304] = "NotModified", HttpCodes2[HttpCodes2.UseProxy = 305] = "UseProxy", HttpCodes2[HttpCodes2.SwitchProxy = 306] = "SwitchProxy", HttpCodes2[HttpCodes2.TemporaryRedirect = 307] = "TemporaryRedirect", HttpCodes2[HttpCodes2.PermanentRedirect = 308] = "PermanentRedirect", HttpCodes2[HttpCodes2.BadRequest = 400] = "BadRequest", HttpCodes2[HttpCodes2.Unauthorized = 401] = "Unauthorized", HttpCodes2[HttpCodes2.PaymentRequired = 402] = "PaymentRequired", HttpCodes2[HttpCodes2.Forbidden = 403] = "Forbidden", HttpCodes2[HttpCodes2.NotFound = 404] = "NotFound", HttpCodes2[HttpCodes2.MethodNotAllowed = 405] = "MethodNotAllowed", HttpCodes2[HttpCodes2.NotAcceptable = 406] = "NotAcceptable", HttpCodes2[HttpCodes2.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", HttpCodes2[HttpCodes2.RequestTimeout = 408] = "RequestTimeout", HttpCodes2[HttpCodes2.Conflict = 409] = "Conflict", HttpCodes2[HttpCodes2.Gone = 410] = "Gone", HttpCodes2[HttpCodes2.TooManyRequests = 429] = "TooManyRequests", HttpCodes2[HttpCodes2.InternalServerError = 500] = "InternalServerError", HttpCodes2[HttpCodes2.NotImplemented = 501] = "NotImplemented", HttpCodes2[HttpCodes2.BadGateway = 502] = "BadGateway", HttpCodes2[HttpCodes2.ServiceUnavailable = 503] = "ServiceUnavailable", HttpCodes2[HttpCodes2.GatewayTimeout = 504] = "GatewayTimeout";
  })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2.Accept = "accept", Headers2.ContentType = "content-type";
  })(Headers || (exports.Headers = Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2.ApplicationJson = "application/json";
  })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ], HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ], RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"], ExponentialBackoffCeiling = 10, ExponentialBackoffTimeSlice = 5;

  class HttpClientError extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError", this.statusCode = statusCode, Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  }
  exports.HttpClientError = HttpClientError;

  class HttpClientResponse {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
          let output = Buffer.alloc(0);
          this.message.on("data", (chunk) => {
            output = Buffer.concat([output, chunk]);
          }), this.message.on("end", () => {
            resolve(output.toString());
          });
        }));
      });
    }
    readBodyBuffer() {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
          let chunks = [];
          this.message.on("data", (chunk) => {
            chunks.push(chunk);
          }), this.message.on("end", () => {
            resolve(Buffer.concat(chunks));
          });
        }));
      });
    }
  }
  exports.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    return new URL(requestUrl).protocol === "https:";
  }

  class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
      if (this._ignoreSslError = !1, this._allowRedirects = !0, this._allowRedirectDowngrade = !1, this._maxRedirects = 50, this._allowRetries = !1, this._maxRetries = 1, this._keepAlive = !1, this._disposed = !1, this.userAgent = this._getUserAgentWithOrchestrationId(userAgent), this.handlers = handlers || [], this.requestOptions = requestOptions, requestOptions) {
        if (requestOptions.ignoreSslError != null)
          this._ignoreSslError = requestOptions.ignoreSslError;
        if (this._socketTimeout = requestOptions.socketTimeout, requestOptions.allowRedirects != null)
          this._allowRedirects = requestOptions.allowRedirects;
        if (requestOptions.allowRedirectDowngrade != null)
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        if (requestOptions.maxRedirects != null)
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        if (requestOptions.keepAlive != null)
          this._keepAlive = requestOptions.keepAlive;
        if (requestOptions.allowRetries != null)
          this._allowRetries = requestOptions.allowRetries;
        if (requestOptions.maxRetries != null)
          this._maxRetries = requestOptions.maxRetries;
      }
    }
    options(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      });
    }
    get(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      });
    }
    del(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      });
    }
    post(requestUrl, data, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      });
    }
    patch(requestUrl, data, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      });
    }
    put(requestUrl, data, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      });
    }
    head(requestUrl, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return __awaiter(this, void 0, void 0, function* () {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      });
    }
    getJson(requestUrl_1) {
      return __awaiter(this, arguments, void 0, function* (requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        let res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        let res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        let res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(requestUrl_1, obj_1) {
      return __awaiter(this, arguments, void 0, function* (requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson), additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultContentTypeHeader(additionalHeaders, MediaTypes.ApplicationJson);
        let res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    request(verb, requestUrl, data, headers) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this._disposed)
          throw Error("Client has already been disposed.");
        let parsedUrl = new URL(requestUrl), info = this._prepareRequest(verb, parsedUrl, headers), maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1, numTries = 0, response;
        do {
          if (response = yield this.requestRaw(info, data), response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (let handler of this.handlers)
              if (handler.canHandleAuthentication(response)) {
                authenticationHandler = handler;
                break;
              }
            if (authenticationHandler)
              return authenticationHandler.handleAuthentication(this, info, data);
            else
              return response;
          }
          let redirectsRemaining = this._maxRedirects;
          while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
            let redirectUrl = response.message.headers.location;
            if (!redirectUrl)
              break;
            let parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade)
              throw Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            if (yield response.readBody(), parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (let header in headers)
                if (header.toLowerCase() === "authorization")
                  delete headers[header];
            }
            info = this._prepareRequest(verb, parsedRedirectUrl, headers), response = yield this.requestRaw(info, data), redirectsRemaining--;
          }
          if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode))
            return response;
          if (numTries += 1, numTries < maxTries)
            yield response.readBody(), yield this._performExponentialBackoff(numTries);
        } while (numTries < maxTries);
        return response;
      });
    }
    dispose() {
      if (this._agent)
        this._agent.destroy();
      this._disposed = !0;
    }
    requestRaw(info, data) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
          function callbackForResult(err, res) {
            if (err)
              reject(err);
            else if (!res)
              reject(Error("Unknown error"));
            else
              resolve(res);
          }
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      });
    }
    requestRawWithCallback(info, data, onResult) {
      if (typeof data === "string") {
        if (!info.options.headers)
          info.options.headers = {};
        info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = !1;
      function handleResult(err, res) {
        if (!callbackCalled)
          callbackCalled = !0, onResult(err, res);
      }
      let req = info.httpModule.request(info.options, (msg) => {
        let res = new HttpClientResponse(msg);
        handleResult(void 0, res);
      }), socket;
      if (req.on("socket", (sock) => {
        socket = sock;
      }), req.setTimeout(this._socketTimeout || 180000, () => {
        if (socket)
          socket.end();
        handleResult(Error(`Request timeout: ${info.options.path}`));
      }), req.on("error", function(err) {
        handleResult(err);
      }), data && typeof data === "string")
        req.write(data, "utf8");
      if (data && typeof data !== "string")
        data.on("close", function() {
          req.end();
        }), data.pipe(req);
      else
        req.end();
    }
    getAgent(serverUrl) {
      let parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    getAgentDispatcher(serverUrl) {
      let parsedUrl = new URL(serverUrl), proxyUrl = pm.getProxyUrl(parsedUrl);
      if (!(proxyUrl && proxyUrl.hostname))
        return;
      return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      let info = {};
      info.parsedUrl = requestUrl;
      let usingSsl = info.parsedUrl.protocol === "https:";
      info.httpModule = usingSsl ? https : http;
      let defaultPort = usingSsl ? 443 : 80;
      if (info.options = {}, info.options.host = info.parsedUrl.hostname, info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort, info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || ""), info.options.method = method, info.options.headers = this._mergeHeaders(headers), this.userAgent != null)
        info.options.headers["user-agent"] = this.userAgent;
      if (info.options.agent = this._getAgent(info.parsedUrl), this.handlers)
        for (let handler of this.handlers)
          handler.prepareRequest(info.options);
      return info;
    }
    _mergeHeaders(headers) {
      if (this.requestOptions && this.requestOptions.headers)
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
      return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        let headerValue = lowercaseKeys(this.requestOptions.headers)[header];
        if (headerValue)
          clientHeader = typeof headerValue === "number" ? headerValue.toString() : headerValue;
      }
      let additionalValue = additionalHeaders[header];
      if (additionalValue !== void 0)
        return typeof additionalValue === "number" ? additionalValue.toString() : additionalValue;
      if (clientHeader !== void 0)
        return clientHeader;
      return _default;
    }
    _getExistingOrDefaultContentTypeHeader(additionalHeaders, _default) {
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        let headerValue = lowercaseKeys(this.requestOptions.headers)[Headers.ContentType];
        if (headerValue)
          if (typeof headerValue === "number")
            clientHeader = String(headerValue);
          else if (Array.isArray(headerValue))
            clientHeader = headerValue.join(", ");
          else
            clientHeader = headerValue;
      }
      let additionalValue = additionalHeaders[Headers.ContentType];
      if (additionalValue !== void 0)
        if (typeof additionalValue === "number")
          return String(additionalValue);
        else if (Array.isArray(additionalValue))
          return additionalValue.join(", ");
        else
          return additionalValue;
      if (clientHeader !== void 0)
        return clientHeader;
      return _default;
    }
    _getAgent(parsedUrl) {
      let agent, proxyUrl = pm.getProxyUrl(parsedUrl), useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy)
        agent = this._proxyAgent;
      if (!useProxy)
        agent = this._agent;
      if (agent)
        return agent;
      let usingSsl = parsedUrl.protocol === "https:", maxSockets = 100;
      if (this.requestOptions)
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      if (proxyUrl && proxyUrl.hostname) {
        let agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
          }), { host: proxyUrl.hostname, port: proxyUrl.port })
        }, tunnelAgent, overHttps = proxyUrl.protocol === "https:";
        if (usingSsl)
          tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
        else
          tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
        agent = tunnelAgent(agentOptions), this._proxyAgent = agent;
      }
      if (!agent) {
        let options = { keepAlive: this._keepAlive, maxSockets };
        agent = usingSsl ? new https.Agent(options) : new http.Agent(options), this._agent = agent;
      }
      if (usingSsl && this._ignoreSslError)
        agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: !1
        });
      return agent;
    }
    _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
      let proxyAgent;
      if (this._keepAlive)
        proxyAgent = this._proxyAgentDispatcher;
      if (proxyAgent)
        return proxyAgent;
      let usingSsl = parsedUrl.protocol === "https:";
      if (proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
        token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
      })), this._proxyAgentDispatcher = proxyAgent, usingSsl && this._ignoreSslError)
        proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
          rejectUnauthorized: !1
        });
      return proxyAgent;
    }
    _getUserAgentWithOrchestrationId(userAgent) {
      let baseUserAgent = userAgent || "actions/http-client", orchId = process.env.ACTIONS_ORCHESTRATION_ID;
      if (orchId) {
        let sanitizedId = orchId.replace(/[^a-z0-9_.-]/gi, "_");
        return `${baseUserAgent} actions_orchestration_id/${sanitizedId}`;
      }
      return baseUserAgent;
    }
    _performExponentialBackoff(retryNumber) {
      return __awaiter(this, void 0, void 0, function* () {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        let ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      });
    }
    _processResponse(res, options) {
      return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          let statusCode = res.message.statusCode || 0, response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode === HttpCodes.NotFound)
            resolve(response);
          function dateTimeDeserializer(key, value) {
            if (typeof value === "string") {
              let a = new Date(value);
              if (!isNaN(a.valueOf()))
                return a;
            }
            return value;
          }
          let obj, contents;
          try {
            if (contents = yield res.readBody(), contents && contents.length > 0) {
              if (options && options.deserializeDates)
                obj = JSON.parse(contents, dateTimeDeserializer);
              else
                obj = JSON.parse(contents);
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {}
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message)
              msg = obj.message;
            else if (contents && contents.length > 0)
              msg = contents;
            else
              msg = `Failed request: (${statusCode})`;
            let err = new HttpClientError(msg, statusCode);
            err.result = response.result, reject(err);
          } else
            resolve(response);
        }));
      });
    }
  }
  exports.HttpClient = HttpClient;
  var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
});

// node_modules/@actions/github/lib/internal/utils.js
var require_utils9 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }(), __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.getAuthString = getAuthString;
  exports.getProxyAgent = getProxyAgent;
  exports.getProxyAgentDispatcher = getProxyAgentDispatcher;
  exports.getProxyFetch = getProxyFetch;
  exports.getApiBaseUrl = getApiBaseUrl;
  var httpClient = __importStar(require_lib4()), undici_1 = require_undici();
  function getAuthString(token, options) {
    if (!token && !options.auth)
      throw Error("Parameter token or opts.auth is required");
    else if (token && options.auth)
      throw Error("Parameters token and opts.auth may not both be specified");
    return typeof options.auth === "string" ? options.auth : `token ${token}`;
  }
  function getProxyAgent(destinationUrl) {
    return new httpClient.HttpClient().getAgent(destinationUrl);
  }
  function getProxyAgentDispatcher(destinationUrl) {
    return new httpClient.HttpClient().getAgentDispatcher(destinationUrl);
  }
  function getProxyFetch(destinationUrl) {
    let httpDispatcher = getProxyAgentDispatcher(destinationUrl);
    return (url, opts) => __awaiter(this, void 0, void 0, function* () {
      return (0, undici_1.fetch)(url, Object.assign(Object.assign({}, opts), { dispatcher: httpDispatcher }));
    });
  }
  function getApiBaseUrl() {
    return process.env.GITHUB_API_URL || "https://api.github.com";
  }
});

// node_modules/@actions/github/lib/utils.js
var require_utils10 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.GitHub = exports.defaults = exports.context = void 0;
  exports.getOctokitOptions = getOctokitOptions;
  var Context = __importStar(require_context2()), Utils = __importStar(require_utils9()), core_1 = require_dist_node11(), plugin_rest_endpoint_methods_1 = require_dist_node12(), plugin_paginate_rest_1 = require_dist_node13();
  exports.context = new Context.Context;
  var baseUrl = Utils.getApiBaseUrl();
  exports.defaults = {
    baseUrl,
    request: {
      agent: Utils.getProxyAgent(baseUrl),
      fetch: Utils.getProxyFetch(baseUrl)
    }
  };
  exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(exports.defaults);
  function getOctokitOptions(token, options) {
    let opts = Object.assign({}, options || {}), auth = Utils.getAuthString(token, opts);
    if (auth)
      opts.auth = auth;
    return opts;
  }
});

// node_modules/@actions/github/lib/github.js
var require_github2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable))
      desc = { enumerable: !0, get: function() {
        return m[k];
      } };
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: !0, value: v });
  } : function(o, v) {
    o.default = v;
  }), __importStar = exports && exports.__importStar || function() {
    var ownKeys = function(o) {
      return ownKeys = Object.getOwnPropertyNames || function(o2) {
        var ar = [];
        for (var k in o2)
          if (Object.prototype.hasOwnProperty.call(o2, k))
            ar[ar.length] = k;
        return ar;
      }, ownKeys(o);
    };
    return function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k = ownKeys(mod), i = 0;i < k.length; i++)
          if (k[i] !== "default")
            __createBinding(result, mod, k[i]);
      }
      return __setModuleDefault(result, mod), result;
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: !0 });
  exports.context = void 0;
  exports.getOctokit = getOctokit;
  var Context = __importStar(require_context2()), utils_1 = require_utils10();
  exports.context = new Context.Context;
  function getOctokit(token, options, ...additionalPlugins) {
    return new (utils_1.GitHub.plugin(...additionalPlugins))((0, utils_1.getOctokitOptions)(token, options));
  }
});

export { __toESM, require_exec, require_core, require_artifact2 as require_artifact, require_github2 as require_github };
